{
  "magic": "B8n2c@e8kvfx",
  "timestamp": "2020-04-15T00:51:12.102794+00:00",
  "repo": "WICG/webpackage",
  "labels": [
    {
      "name": "bug",
      "description": null,
      "color": "ee0701"
    },
    {
      "name": "duplicate",
      "description": null,
      "color": "cccccc"
    },
    {
      "name": "feature request",
      "description": "",
      "color": "84b6eb"
    },
    {
      "name": "help wanted",
      "description": "Community members should chime in with your opinions.",
      "color": "128A0C"
    },
    {
      "name": "go",
      "description": "",
      "color": "fbca04"
    },
    {
      "name": "bundled-exchanges",
      "description": "",
      "color": "bfdadc"
    },
    {
      "name": "Pending Security + Privacy Review",
      "description": "",
      "color": "ccf280"
    },
    {
      "name": "needs spec",
      "description": "The issue has agreement, but someone needs to add it to the specification.",
      "color": "ce9cf4"
    },
    {
      "name": "discuss",
      "description": "Needs a verbal or face-to-face discussion",
      "color": "bc6c2b"
    },
    {
      "name": "consider closing",
      "description": "",
      "color": "ffe9c9"
    },
    {
      "name": "architecture",
      "description": "Big design questions that need to be figured out.",
      "color": "73d4ef"
    },
    {
      "name": "documentation",
      "description": "Tech writers wanted!",
      "color": "6f35b7"
    },
    {
      "name": "i18n-tracker",
      "description": "Group bringing to attention of Internationalization, or tracked by i18n but not needing response.",
      "color": "F9C9FF"
    },
    {
      "name": "i18n-needs-resolution",
      "description": "Issue the Internationalization Group has raised and looks for a response on.",
      "color": "F9C9FF"
    },
    {
      "name": "privacy-tracker",
      "description": "Group bringing to attention of Privacy, or tracked by the Privacy Group but not needing response.",
      "color": "d4af37"
    },
    {
      "name": "privacy-needs-resolution",
      "description": "Issue the Privacy Group has raised and looks for a response on.",
      "color": "d4af37"
    },
    {
      "name": "security-tracker",
      "description": "Group bringing to attention of security, or tracked by the security Group but not needing response.",
      "color": "ffff00"
    },
    {
      "name": "security-needs-resolution",
      "description": "Issue the security Group has raised and looks for a response on.",
      "color": "ffff00"
    },
    {
      "name": "a11y-tracker",
      "description": "Group bringing to attention of a11y, or tracked by the a11y Group but not needing response.",
      "color": "ea7472"
    },
    {
      "name": "a11y-needs-resolution",
      "description": "Issue the Accessibility Group has raised and looks for a response on.",
      "color": "ea7472"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWUxODk4MjcwNTU=",
      "title": "Interfacing with Resource Hints and link rel=preload.",
      "url": "https://github.com/WICG/webpackage/issues/2",
      "state": "CLOSED",
      "author": "addyosmani",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Something unclear reading through the current proposal is how a developer would hint that some resources in a web package have a higher priority to fetch (e.g via resource hints) than others - the entire package would be fetched with a single priority. If I want to prefetch or preload certain assets, I'm unsure how those systems interface with packages.\r\n\r\nAre there any thoughts about this?",
      "createdAt": "2016-11-16T20:03:18Z",
      "updatedAt": "2017-01-09T16:38:05Z",
      "closedAt": "2017-01-09T16:38:05Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@addyosmani I'm not sure that is possible under current text since it is a single non-multiplexed body for the payload. You might want to put the prioritized resources at the start of the package body. I would be interested more in having multiple streams like http/2 does if you want to interleave resources and/or change priorities dynamically.",
          "createdAt": "2016-12-02T16:37:03Z",
          "updatedAt": "2017-01-09T16:29:29Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@addyosmani after a call, it should be possible to re-order signed content resources as long as a Package-Signature and Content-Index can be recomputed by the server. The server could re-order them into a more optimal order. Might be a good idea to move the discussion to https://github.com/dimich-g/webpackage/issues/11 since that is going to be covering reordering. Is this ok to close?",
          "createdAt": "2016-12-29T19:27:07Z",
          "updatedAt": "2016-12-29T19:27:07Z"
        },
        {
          "author": "addyosmani",
          "authorAssociation": "NONE",
          "body": "Let's close this one up. Thanks for the replies, @bmeck! ",
          "createdAt": "2017-01-09T16:38:04Z",
          "updatedAt": "2017-01-09T16:38:04Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWUxOTAwNzk5MzY=",
      "title": "relationship to DPUB",
      "url": "https://github.com/WICG/webpackage/issues/3",
      "state": "CLOSED",
      "author": "TzviyaSiegman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Very happy to see Packaging reconsidered. The Digital Publishing IG considered this as well. Please see http://w3c.github.io/dpub-pwp-ucr/index.html for our use cases and requirements. We are also looking at Web App Manifest (https://w3c.github.io/manifest/) as a potential mechanism. Our goals are very similar, so it would be helpful to discuss and find common ground. ",
      "createdAt": "2016-11-17T15:34:29Z",
      "updatedAt": "2017-01-13T19:54:47Z",
      "closedAt": "2017-01-13T19:54:47Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@TzviyaSiegman it seems possible to place a Web App Manifest within a WebPackage since it is just a JSON file referenced by a `<link>` in HTML. On a glance it seems possible that the \"Packaged Web Publication\" standard distribution format could be WebPackage for DPUB, however I don't have the breadth of knowledge to say with 100% certainty that the pagination requirement would be related to WebPackage itself (that may be left up to the contents of individual resources within the package).",
          "createdAt": "2016-12-29T15:51:04Z",
          "updatedAt": "2016-12-29T15:51:04Z"
        },
        {
          "author": "dauwhe",
          "authorAssociation": "NONE",
          "body": "I've been experimenting with using web packages for publications. I put up an example at https://github.com/dauwhe/acme-labs/blob/gh-pages/MobyDick/MobyDick.pod (there's a tradition in the ebook community to use Moby Dick as a sample book). It's just a bunch of HTML files, etc. with a web app manifest. I've attempted a content index but have no idea how to figure out byte offsets, etc.\r\n\r\nOur interest in this is largely due to security concerns. Signing a bundle of web content could help solve the origin problem for portable publications. \r\n\r\nI would expect no dependency on pagination. That's a matter for CSS :)",
          "createdAt": "2017-01-05T14:51:48Z",
          "updatedAt": "2017-01-05T14:51:48Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@dauwhe - cool, thanks!  You will need to write a \"packager\" in order to get all the correct offsets (either that or a hex editor and patience :)).\r\n\r\nSigning the bundle is actually a small part of the solution for two security concerns for portable publications.  It doesn't actually get you an origin - since I could potentially resign your package and therefore \"reorigin\" it, which isn't what a professional publisher would want (and may indeed break the content).  But more importantly, it's actually the verification process (or specifically the establishment of trust) that we need in the publication realm..",
          "createdAt": "2017-01-05T20:38:20Z",
          "updatedAt": "2017-01-05T20:38:20Z"
        },
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm working on a golang packager script (in the \"go/\" directory) that will eventually support content-index and signatures.  Stay tuned!  I think a verifier is also a great tool to keep in this repo as well.",
          "createdAt": "2017-01-05T23:06:13Z",
          "updatedAt": "2017-01-05T23:06:13Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@TzviyaSiegman is this clear / ok to close?",
          "createdAt": "2017-01-13T03:33:36Z",
          "updatedAt": "2017-01-13T03:33:36Z"
        },
        {
          "author": "iherman",
          "authorAssociation": "NONE",
          "body": "@bmeck , @TzviyaSiegman is currently on a maternity leave. I think this issue was raised more as a FYI, and more specific technical problems were discussed on more specific issues. I think it is o.k.  to close this issue.\r\n\r\n@lrosenthol @dauwhe : what do you think?",
          "createdAt": "2017-01-13T03:54:05Z",
          "updatedAt": "2017-01-13T03:54:05Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Yes, fine to close by me.  We will raise other issues as we get to that\npoint in our development of DPUB\n\nOn Thu, Jan 12, 2017 at 10:54 PM, Ivan Herman <notifications@github.com>\nwrote:\n\n> @bmeck <https://github.com/bmeck> , @TzviyaSiegman\n> <https://github.com/TzviyaSiegman> is currently on a maternity leave. I\n> think this issue was raised more as a FYI, and more specific technical\n> problems were discussed on more specific issues. I think it is o.k. to\n> close this issue.\n>\n> @lrosenthol <https://github.com/lrosenthol> @dauwhe\n> <https://github.com/dauwhe> : what do you think?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/3#issuecomment-272354894>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNcUT6vET_BMrgc9-VX4mI2W1CiFuks5rRvVegaJpZM4K1cp1>\n> .\n>\n",
          "createdAt": "2017-01-13T12:56:22Z",
          "updatedAt": "2017-01-13T12:56:22Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUxOTAxMzExNzc=",
      "title": "Streaming not supported",
      "url": "https://github.com/WICG/webpackage/issues/6",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "One of the reasons that the [packaging on the web](https://w3ctag.github.io/packaging-on-the-web/) spec chose to avoid ZIP in favor of something new & different was due to the (perceived) lack of streaming support.\r\n\r\nHowever, this proposal suffers from the same problem.  You cannot create it entirely in stream, due to (a) the way that offsets are used and (b) the index file needing to list all other files.\r\n\r\nIf streaming is not a requirement for this format - that's fine.  But then, that should also be called out in the spec.",
      "createdAt": "2016-11-17T18:50:47Z",
      "updatedAt": "2017-03-30T03:05:56Z",
      "closedAt": "2017-03-30T03:05:56Z",
      "comments": [
        {
          "author": "addyosmani",
          "authorAssociation": "NONE",
          "body": "I would also like to get some clarity around how packaging interfaces with streaming (even if it's a non-goal for the first version).\n",
          "createdAt": "2016-11-17T19:43:23Z",
          "updatedAt": "2016-11-17T19:43:23Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Streaming is important and very much the goal, just as for the [packaging on the web](https://w3ctag.github.io/packaging-on-the-web/) effort that  you mention. I should have clarified that more (I will add to the Explainer, with corresponding example).\n\nThe idea is that there are two major use cases - streaming and 'local file'. The former is a regular way resources are used on the web - for example, one can package an SVG image with an SVG markup and PNG image that is used in that markup and refer to that from a regular web page. Or package a JS library. This usage is normally over HTTP or HTTPS and support for incremental streaming is important. The latter type of use cases can happen as result of local sharing, or saving a package for offline use. In that case, the package is on a local device in its entirety, and it is potentially huge (\"wikipedia in a package\" etc). In that case, it is important to be able to quickly access resource in the [huge] package w/o need to unpack it in any form, including things like seeking into a movie that is a part of package, etc. \n\nSo the proposed format is trying to address both! Note the usage of MIME-like parts and boundaries and per-parts headers - that allows streaming use by making it possible to parse the package while it trickles in. The offsets are serving the local case - by allowing use of efficient IO operations on a locally-stored 'file'. Note there is no information in the Content Index which would not be available from a part header, and also Content Index is optional. \n\nThe signature, if the package is signed, would require the Content Index (with hashes for parts). In that case, it makes sense for Content Index  and certificate to be in the beginning of the package to facilitate streaming - so the incoming parts can be validated as they are becoming available. The tools that would build such a package could ensure that, this format doesn't depend on the requirement to keep a 'directory' at the end of the file as ZIP does (which does it mostly for ease of append of possibly duplicating files, which is not a goal for this format).\n",
          "createdAt": "2016-11-18T01:20:23Z",
          "updatedAt": "2016-11-18T01:20:23Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "> Note the usage of MIME-like parts and boundaries and per-parts headers - that allows streaming use by making it possible to parse the package while it trickles in. \r\n\r\nMIME like boundary strings need to ensure they do not exist in any of the content body. This means potential collisions or preprocessing to ensure the boundary string does not exist within the body. From https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html :\r\n\r\n>> The encapsulation boundary MUST NOT appear inside any of the encapsulated parts. Thus, it is crucial that the composing agent be able to choose and specify the unique boundary that will separate the parts.\r\n\r\nThings like chunked encoding do not suffer from the potential collision or preprocessing issue.\r\n\r\n> The signature, if the package is signed, would require the Content Index (with hashes for parts). In that case, it makes sense for Content Index and certificate to be in the beginning of the package to facilitate streaming - so the incoming parts can be validated as they are becoming available.\r\n\r\nThis can be done as a trailer per resource rather than a batch up front. Running the digest cannot finish until all the resource is available. I see no need to receive the signed digest prior to the content since the local digest to verify against cannot be created until the body is finished streaming.\r\n\r\n> this format doesn't depend on the requirement to keep a 'directory' at the end of the file as ZIP does (which does it mostly for ease of append of possibly duplicating files, which is not a goal for this format).\r\n\r\nThere are other reasons to use ZIP, I would just like to make a point of disagreement on this being the prevailing reason to use ZIP like trailing directories.",
          "createdAt": "2016-11-29T06:02:08Z",
          "updatedAt": "2016-11-29T06:02:08Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "> one can package an SVG image with an SVG markup and PNG image that is used in that markup and refer to that from a regular web page\r\n\r\nNow you are introducing a completely new issue which is lack of a standard media type and file extension, which would be required to be supported by any OWP client in order to allow this to handled as the result of a URL.  \r\n\r\n> streaming, MIME parts, and index offsets\r\n>Link: <cid:f47ac10b-58cc-4372-a567-0e02b2c3d479>; rel=index; offset=12014/2048\r\n\r\nAs @bmeck mentioned, MIME boundary strings have issues when used for packaging.  In addition, the use of an offset to the index in the header is impossible to have in a streamed format, since you don't know how large the data itself is, and thus where the index where be when you start.\r\n\r\n> So the proposed format is trying to address both!\r\n\r\nIt can't - at least not in a mixed model.  If you are streaming out and streaming in - where there won't be any index/offsets.  OR if you are creating an \"offline\" package upfront.  Then sure, it works.  *BUT* what won't work is streaming out a package that will work offline - or passing an existing offline package to a streaming recipient.\r\n",
          "createdAt": "2016-11-29T06:35:32Z",
          "updatedAt": "2016-11-29T06:35:32Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "note: my PR does not address not knowing the indexes during streaming, your server must place the Content Index at the end of stream and record offsets for each content resource as it goes. I find this an acceptable compromise since a client is still allowed to re-order content within the package.",
          "createdAt": "2016-12-29T15:43:47Z",
          "updatedAt": "2016-12-29T15:43:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think \"streaming\" means at least 2 things here, and we need to distinguish them. Here are 3 scenarios with signed packages that might help structure the discussion. I'm not treating unsigned packages here because a client can rewrite them arbitrarily to make the boundaries and offsets work.\r\n\r\n3 actors: a server that can sign content with a private key, a client who connects to the server and trusts the key but can't sign with it, and a peer who connects to the client and also trusts the key.\r\n\r\n1. The server needs to dynamically generate at least one of the resources in the package, so it doesn't know all contents and offsets ahead of time. However, the client can benefit from loading resources as they're sent.\r\n  If the package is being transferred without authentication+integrity (e.g. HTTP instead of HTTPS), the client is out of luck and has to wait until the signatures arrive to use any of the package. We get no streaming benefit.\r\n  If the package is being transferred under TLS, the client can use that to infer trust in the content, and the server can send a signed manifest/index after all content is transferred. If there's some way to mark what's going to be in the package so the client knows to save it literally, the server can even transfer the files in multiple separate streams, and the client can assemble the package when the index arrives. Dynamically-generated resources can be transferred with the chunked encoding, but we could have the client rewrite that to MIME boundaries before serializing the package if we want, since the offsets aren't generated and signed until the end of the transfer.\r\n\r\n2) One client wants to send the package to a peer, who will rely on the signature to trust the content, but who also might want to use the initial resources before the whole file has transferred. \r\n  This requires the signature block to be sent *first*, opposite case (1). As @bmeck [mentioned](https://github.com/dimich-g/webpackage/issues/6#issuecomment-263484273), it's also possible to sign each resource independently, at the cost of more public-key operations. Nothing's being dynamically generated here, since the client couldn't sign dynamically generated content anyway, so MIME boundaries and fixed offsets are fine, although other ways of marking file boundaries are fine too. The peer can't use a file until the whole file is transferred, hashed, and verified, but they can use file1 before file2 has transferred.\r\n\r\n3) The client or peer wants to re-use a package that's fully transferred, without needing to parse the whole thing from the beginning. This requires an index with offsets and sizes, and signed hashes. The index can be anywhere in the file as long as the peer can find it.\r\n\r\nWhat have I missed?",
          "createdAt": "2017-01-26T23:29:04Z",
          "updatedAt": "2017-01-26T23:29:04Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin I am not sure those are the only three, but let's work through those.\r\n\r\n1 - I would call this \"streamed generation\", and is a possible use case though I would consider it the least important. But regardless, let's work through it.\r\nYour suggestion to utilize the trust of TLS towards the model is interesting, but not viable - as the type of trust one achieves from TLS is not comparable (or replaceable) by the trust inherent in signed content.  Just because badactor.com has a good TLS cert, doesn't mean that I trust the Javascript code that comes from. So a client that is concerned with trusted content (which hopefully will be more and more as we solve this problem) wouldn't be able to use anything until all the content and the certs are down and can verify the trust of those certs.\r\n\r\n2 - Not sure why this has to be client->peer.  To me, this is server->client, where the content already exists (with or without signature).  I agree that the **certificate** (and any associated trust chain and/or revocation info) has to be sent first - so that trust can be established.  However, it doesn't require that the signed hash be sent until the end.  The client can be validating the trust of the cert while streaming in the rest of the data (and the hash) and then only if it ends up trusting the cert does it even bother checking the hash and then (potentially) using the data.\r\n",
          "createdAt": "2017-01-27T13:54:47Z",
          "updatedAt": "2017-01-27T13:54:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "1. If you're not concerned with \"streamed generation\", then I don't understand your [comment](https://github.com/dimich-g/webpackage/issues/6#issue-190131177) at the top of this thread that \"You cannot create it entirely in stream\". Sorry for being dense.\r\n  I'm also not clear on the difference between TLS's trust and the trust in signed content. The two differences I know of are: A) TLS is repudiable since the signature only covers the shared symmetric key, not the content, and B) the TLS private key must be accessible in real time from the server, while signed content can protect the key better. If those are the only differences, I don't know why you'd trust a package signed by foo.com but wouldn't trust a TLS connection to foo.com. Could you enlighten me?\r\n\r\n2. Agreed: I called it \"client\" because the key difference is that it doesn't have access to the private key. It could easily be a server that serves a pre-signed package. My point about sending signatures early is that you can't use a file before you've received its signature. If you send [certificates, file1, file2, ... fileN, signatures], you've unnecessarily delayed use of file1. You can definitely send [certificates, file1, sig1, file2, sig2, ...] instead of [certificates, signatures, file1, file2, ...], but if the package is pre-built I don't really see the benefit.",
          "createdAt": "2017-01-27T17:37:09Z",
          "updatedAt": "2017-01-27T17:37:09Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "I did make that comment up front, as at the time, I wasn't sure whether that was (or wasn't) a requirement.  I would state that right now - no one has proposed a use case where streaming creation is required.  \r\n\r\nAs you note, you can't use a TLS cert to sign content - so that any trust I have in that cert wouldn't apply to content.  I would have to trust a different cert - and that other cert isn't tied to a domain but instead an organization or individual.  See #16 for previous conversations in this area.\r\n\r\n",
          "createdAt": "2017-01-27T19:02:47Z",
          "updatedAt": "2017-01-27T19:02:47Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Dropping streaming requirement seems fine to me. Only use case that we have is speeding up sending packages to registries when publishing.",
          "createdAt": "2017-01-27T20:14:07Z",
          "updatedAt": "2017-01-27T20:14:07Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @lrosenthol @dimich-g are we fine to close this?",
          "createdAt": "2017-03-29T14:24:16Z",
          "updatedAt": "2017-03-29T14:24:16Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. File a new issue if needed.",
          "createdAt": "2017-03-30T03:05:56Z",
          "updatedAt": "2017-03-30T03:05:56Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUxOTAxMzIyMTk=",
      "title": "Loading in a secure or insecure context?",
      "url": "https://github.com/WICG/webpackage/issues/7",
      "state": "OPEN",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [
        "jyasskin"
      ],
      "labels": [
        "consider closing"
      ],
      "body": "While there is a good discussion about the need to handle separate (and unique) origins [here](https://github.com/dimich-g/webpackage#use-case-a-web-page-with-a-resources-from-the-other-origin), it's not clear whether such content should be loaded in a secure (https-like) or insecure (http) context - and whether it being signed influences that choice.",
      "createdAt": "2016-11-17T18:55:09Z",
      "updatedAt": "2019-05-13T16:44:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a symptom of including the transfer protocol in the package content-location.\r\n\r\nThoughts for browser behavior:\r\n\r\n* If a package comes over an insecure context no contents can be treated as secure\r\n   * Even if contents are signed they are not secure due to potential resigning\r\n* If a package comes over a secure context\r\n   * Same origin/`<cid>` locations treated as secure since the transfer cert is providing a secure context\r\n* Differing origin needs cert to create a secure context\r\n   * Required even if loading insecure resource off the differing domain to prevent impersonation\r\n\r\nThis assumes differing origins is only possible via nested packages, the spec text currently does not mandate such.",
          "createdAt": "2017-01-13T04:30:24Z",
          "updatedAt": "2017-01-13T04:30:24Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "The cert and the origin have nothing to do with each other.  Just because\nsomething is signed - and even if that certificate verifies just fine - you\ncan't use that as any type of trust that you should use a different origin.\n\nFor example, what prevents me from creating a package, signing it with my\ncert but setting the origin to \"badactor.com\"? Or worse, taking a known\npackage (say jquery), signing it and remapping the origin.\n\nMixing origins in a single package is even worse, especially when you try\nto combine it with inter-package linking...\n\nWe've been looking at this problem for a while now in the context of other\npackaging models and so far we've found no good solution...\n\nOn Thu, Jan 12, 2017 at 11:30 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> I think this is a symptom of including the transfer protocol in the\n> package content-location.\n>\n> Thoughts for browser behavior:\n>\n>    - If a package comes over an insecure context no contents can be\n>    treated as secure\n>       - Even if contents are signed they are not secure due to potential\n>       resigning\n>    - If a package comes over a secure context\n>       - Same origin/<cid> locations treated as secure since the transfer\n>       cert is providing a secure context\n>    - Differing origin needs cert to create a secure context\n>       - Required even if loading insecure resource off the differing\n>       domain to prevent impersonation\n>\n> This assumes differing origins is only possible via nested packages, the\n> spec text currently does not mandate such.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/7#issuecomment-272358603>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNfMRt79Gq_mtd5783wHP6VveezUZks5rRv3hgaJpZM4K1rFA>\n> .\n>\n",
          "createdAt": "2017-01-13T12:55:22Z",
          "updatedAt": "2017-01-13T12:55:22Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol I'm saying your cert used for signing must have valid a valid chain of trust for `badactor.com` if you state an origin for `badactor.com`. The process to validate that a cert belongs to `badactor.com` is something that exists in the web world. However, this becomes complicated once we talk about offline verification since the full chain of trust needs to be verified and things like OCSP are not possible.\r\n\r\nMixing origins I think should be fine if the mixing is only at package boundaries:\r\n\r\n```\r\nfoo.com.webpackage (signed by foo.com cert, sets origin for contents to foo.com)\r\n\\- index.html\r\n\\- foo.js\r\n\\- bar.com.webpackage (must include Package Signature, sets origin for contents to bar.com)\r\n    \\- bar.js\r\n    \\- Content Index <- ALL SIGNED BY bar.com\r\n       \\- bar.js\r\n       \\- Pub key\r\n    \\- Pub Key\r\n\\- Content Index <- ALL SIGNED BY foo.com\r\n    \\- index.html\r\n    \\- foo.js\r\n    \\- bar.com.webpackage\r\n    \\- Pub Key\r\n\\- Pub Key\r\n```\r\n\r\nI think in particular the passing of pubkeys around is influenced by things such as [Google's attemp for Pub Key transparency](https://security.googleblog.com/2017/01/security-through-transparency.html).\r\n\r\n@lrosenthol Do you have a quick list of the problems you have experienced in the past?\r\n\r\n",
          "createdAt": "2017-01-13T13:54:42Z",
          "updatedAt": "2017-01-13T13:54:42Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck - Yes, SSL certs do indeed work for origins because that's what they\nwere designed to do.  But other types of certs don't have that feature.\nAnd you can't use the email address of the person/organization as the\norigin, because my company could own many domains.  (let's keep offline,\noff the table, for now)\n\nAnd I think we agree that you can't specify an origin unless you have a\ncert that verifies to that origin (once we figure out how that would work).\n\nSo in your example, for the bar.com.webpackage, bar.js would have an\nabsolute URL of https://bar.com/bar.js - since it's origined off bar.com.\nCorrect?  And it refers to a relative URL \"image.jpg\", that would then need\nto resolve to https://bar.com/image.jpg, correct?  I'm conflicted on if\nthat is a good or bad thing.\n\nI wasn't aware of the Key Transparency effort - that's interesting - but\nuntil (or if) it gets any real traction, I dont think its prudent to build\na system around...\n\n\nOn Fri, Jan 13, 2017 at 8:54 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> I'm saying your cert used for\n> signing must have valid a valid chain of trust for badactor.com if you\n> state an origin for badactor.com. The process to validate that a cert\n> belongs to badactor.com is something that exists in the web world.\n> However, this becomes complicated once we talk about offline verification\n> since the full chain of trust needs to be verified and things like OCSP are\n> not possible.\n>\n> Mixing origins I think should be fine if the mixing is only at package\n> boundaries:\n>\n> foo.com.webpackage (signed by foo.com cert, sets origin for contents to foo.com)\n> \\- index.html\n> \\- foo.js\n> \\- bar.com.webpackage (must include Package Signature, sets origin for contents to bar.com)\n>     \\- bar.js\n>     \\- Content Index <- ALL SIGNED BY bar.com\n>        \\- bar.js\n>        \\- Pub key\n>     \\- Pub Key\n> \\- Content Index <- ALL SIGNED BY foo.com\n>     \\- index.html\n>     \\- foo.js\n>     \\- bar.com.webpackage\n>     \\- Pub Key\n> \\- Pub Key\n>\n> I think in particular the passing of pubkeys around is influenced by\n> things such as Google's attemp for Pub Key transparency\n> <https://security.googleblog.com/2017/01/security-through-transparency.html>\n> .\n>\n> @lrosenthol <https://github.com/lrosenthol> Do you have a quick list of\n> the problems you have experienced in the past?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/7#issuecomment-272447900>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNWiTxjneKGnbkKbNteAeLJQV9-Joks5rR4IigaJpZM4K1rFA>\n> .\n>\n",
          "createdAt": "2017-01-13T14:13:30Z",
          "updatedAt": "2017-01-13T14:13:30Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "> I wasn't aware of the Key Transparency effort - that's interesting - but\r\nuntil (or if) it gets any real traction, I dont think its prudent to build\r\na system around...\r\n\r\nAgree other existing efforts like PGP Key Servers have similar lookup mechanisms already. It is something to think about.\r\n\r\n> So in your example, for the bar.com.webpackage, bar.js would have an\r\nabsolute URL of https://bar.com/bar.js - since it's origined off bar.com.\r\nCorrect?  And it refers to a relative URL \"image.jpg\", that would then need\r\nto resolve to https://bar.com/image.jpg, correct?  I'm conflicted on if\r\nthat is a good or bad thing.\r\n\r\nThis I am a bit fuzzy on. Web has a concept of \"base URL\" to change the root of relative lookups fo a resource; I see no reason why it couldn't have something like `base-url = bar.com/wepackages/1/` and then `bar.js` is treated as `bar.com/wepackages/1/bar.js`. It has the same escape properties as a naive `chroot` or a cookie `path` attribute which needs to be taken into consideration.\r\n\r\n> Yes, SSL certs do indeed work for origins because that's what they\r\nwere designed to do.  But other types of certs don't have that feature.\r\nAnd you can't use the email address of the person/organization as the\r\norigin, because my company could own many domains.  (let's keep offline,\r\noff the table, for now)\r\n\r\nIt is exactly non-SSL certs that are my interest here. I don't have a good definition for example of what a `secure context` is for filesystem based things that Node/Electron want. It isn't a www domain. Verifying would require some local keychain at the very minimum.",
          "createdAt": "2017-01-13T14:42:21Z",
          "updatedAt": "2017-01-13T14:42:21Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "> Web has a concept of \"base URL\" to change the root of relative lookups fo a resource; I see no reason why it couldn't have something like base-url = bar.com/wepackages/1/ and then bar.js is treated as bar.com/wepackages/1/bar.js.\r\n\r\nI agree, that would also apply.  But in lieu of that, we have to assume it's right at the root, yes?\r\n\r\n>>Yes, SSL certs do indeed work for origins because that's what they\r\nwere designed to do. But other types of certs don't have that feature.\r\n\r\n>It is exactly non-SSL certs that are my interest here. I don't have a good definition for example of what a secure context is for filesystem based things that Node/Electron want. It isn't a www domain. Verifying would require some local keychain at the very minimum.\r\n\r\nBingo!   That is exactly the problem.  \r\nOr one part of the problem\r\n\r\nActually, establishing a secure context is easy - a caller such as Node/Electron can easily establish that the content they are displaying in their \"web view\" must be in a secure context - regardless of where it comes from.   In fact, I would say that just like the many browsers are moving to https only ([here](https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/) and many other places), web-packages should also only run in secure context.\r\n\r\nBut secure context has nothing to do with the origin.  The question here is whether you need the origin or not.  The only reason you would need one is if you expect the package to reference resources outside of itself, and therefore are concerned about CORS-like considerations.  Otherwise, you could simply consider the package as the origin (and each sub-package is either its own origin or a [sub-origin](https://w3c.github.io/webappsec-suborigins/).)\r\n\r\nIt's exactly this problem (origin vs. context) that has been plaguing us and others as well...",
          "createdAt": "2017-01-13T14:55:11Z",
          "updatedAt": "2017-01-13T14:55:11Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree, that would also apply. But in lieu of that, we have to assume it's right at the root, yes?\r\n\r\nUp to UA, base URL depends on location of the HTML in web views. Could implicitly do URL resolve on browser side to get `http://foo.com/1.webpackage` => `http://foo.com/1.webpackage/` so `bar.js` would be `http://foo.com/1.webpackage/bar.js`. This behavior is similar to what https://github.com/bmeck/noda-loader did on filesystem locations.\r\n\r\n> Actually, establishing a secure context is easy - a caller such as Node/Electron can easily establish that the content they are displaying in their \"web view\" must be in a secure context - regardless of where it comes from. In fact, I would say that just like the many browsers are moving to https only (here and many other places), web-packages should also only run in secure context.\r\n\r\nNode for example doesn't have any \"view\". It should remain possible to run non-signed applications.\r\n\r\nPolicies on if your secure context is allowed to load insecure contexts is complicated in this sense. If I download some 3rd party package, I need my non-signed application to be able to use it, and maybe vice-versa (for example `webpack` used `.js` files for configuration).\r\n\r\n> But secure context has nothing to do with the origin. The question here is whether you need the origin or not. The only reason you would need one is if you expect the package to reference resources outside of itself, and therefore are concerned about CORS-like considerations. Otherwise, you could simply consider the package as the origin (and each sub-package is either its own origin or a sub-origin.)\r\n\r\nAgree. While I worked on this a few years back we were thinking of a policy where origin is recorded at time of transfer of the package and is up to the host to maintain. The download would be stored in some DB with the origin setup that is not mutable by user code (for `node` this requires OS/FS permissions to be done properly).\r\n\r\nI need to think on this some after these points.",
          "createdAt": "2017-01-13T15:05:27Z",
          "updatedAt": "2017-01-13T15:05:27Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "> Node for example doesn't have any \"view\". It should remain possible to run non-signed applications.\r\n\r\nI don't see why signing of the applications has any impact on whether to force a secure context or not.  I would think that forcing secure context on all applications - regardless of whether they are signed or not - is a good thing.  It prevents non-signed applications from doing things they shouldn't be doing (IMO).  However, I could see needing to be more lenient with apps than with publications.\r\n\r\n > we were thinking of a policy where origin is recorded at time of transfer of the package and is up to the host to maintain\r\n\r\nFor signed packages, you could have the origin as part of the package.  As long as the signature is verified and *trusted(!)*, then there would be no problem using that origin.  It's when it's not signed (which we expect to the normal case for publications) or there is no trust that we are back to square one.",
          "createdAt": "2017-01-16T15:14:17Z",
          "updatedAt": "2017-01-16T15:14:17Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol node has permission to access a shell / the real file system / etc. removing this is not possible at this point. Determining if something is *not-approved* for secure access is possible though.\r\n\r\n> For signed packages, you could have the origin as part of the package. As long as the signature is verified and trusted(!), then there would be no problem using that origin. It's when it's not signed (which we expect to the normal case for publications) or there is no trust that we are back to square one.\r\n\r\nIn `node`'s case that would be the current behavior, which is to allow full access. It would need a keystore to limit this behavior.",
          "createdAt": "2017-01-16T15:54:31Z",
          "updatedAt": "2017-01-16T15:54:31Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck - yes, for Node, I fully understand the problem/situation.  That is\nindeed more complex than for publications, where we would never want to\nallow access to such things.\n\nI assume that any UA that will process webpackages is going to either need\ntheir own personal keystore and/or use the one provided by the OS.  I don't\nsee how you can get away from that, especially when trust needs to be\nestablished.\n\nOn Mon, Jan 16, 2017 at 10:54 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> node has permission to access\n> a shell / the real file system / etc. removing this is not possible at this\n> point. Determining if something is *not-approved* for secure access is\n> possible though.\n>\n> For signed packages, you could have the origin as part of the package. As\n> long as the signature is verified and trusted(!), then there would be no\n> problem using that origin. It's when it's not signed (which we expect to\n> the normal case for publications) or there is no trust that we are back to\n> square one.\n>\n> In node's case that would be the current behavior, which is to allow full\n> access. It would need a keystore to limit this behavior.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/7#issuecomment-272898521>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNTeuZxSGYx_-lcDtZuSxV53zCvtNks5rS5K3gaJpZM4K1rFA>\n> .\n>\n",
          "createdAt": "2017-01-16T17:06:53Z",
          "updatedAt": "2017-01-16T17:06:53Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUxOTAxMzMxMTQ=",
      "title": "Index should use a common structured format (eg. JSON)",
      "url": "https://github.com/WICG/webpackage/issues/8",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Having the index file be in a text-like format that (a) doesn't specify or mandate an encoding and  (b) no provisions for proper data typing, (c) requires writing a custom parser and (d) will need a newly defined MIME type (see issue #9 ) - doesn't seem like a good idea.\r\n\r\nI recommend instead that the index be a well defined JSON grammar.  That way standard parsers can be used and there is no question about encodings, data types, etc.\r\n",
      "createdAt": "2016-11-17T18:58:44Z",
      "updatedAt": "2017-06-27T22:42:25Z",
      "closedAt": "2017-06-27T22:42:25Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol are there any use cases you can think of that are not solved by HTTP style header mappings that JSON would be better at. I am hesitant to have custom JSON properties but [SourceMaps](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit) have precedent of allowing this by `x_*` as a prefix. I also am concerned about deeply nested objects but with any custom header it would be possible to make the value itself an object, so that seems fine.\r\n\r\nIf you want to write up a schema that would be great :).",
          "createdAt": "2016-12-29T19:21:23Z",
          "updatedAt": "2016-12-29T19:21:23Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "The main issues are (1) data typing and (2) containers/lists.  if the data\nisn't typed (eg. always treated as a string), you will introduce numerous\nparsing and potential security risks.  But if I know something is a number\n(or boolean or ...), then the issues go away.   Same with having a list of\nthings - each implementor need not write a parser (that might have security\nflaws).\n\nI'll look at doing a schema.\n\nOn Thu, Dec 29, 2016 at 2:21 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> are there any use cases you\n> can think of that are not solved by HTTP style header mappings that JSON\n> would be better at. I am hesitant to have custom JSON properties but\n> SourceMaps\n> <https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit>\n> have precedent of allowing this by x_* as a prefix. I also am concerned\n> about deeply nested objects but with any custom header it would be possible\n> to make the value itself an object, so that seems fine.\n>\n> If you want to write up a schema that would be great :).\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/8#issuecomment-269679450>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNW4eaB8xap8i40pKwIfMR0jiuZ7jks5rNAgzgaJpZM4K1rU5>\n> .\n>\n",
          "createdAt": "2017-01-03T19:38:08Z",
          "updatedAt": "2017-01-03T19:38:08Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#36 uses a CDDL grammar to define the index, so I think this is fixed.",
          "createdAt": "2017-03-30T17:55:31Z",
          "updatedAt": "2017-03-30T17:55:31Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWUxOTAxMzM2ODQ=",
      "title": "application/index not defined as a valid media type",
      "url": "https://github.com/WICG/webpackage/issues/9",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As defined [in its IANA registration](https://www.iana.org/assignments/media-types/application/index), this is not a valid media type.  Instead, either a new sub-type should be defined and/or the appropriate format extension (eg. +json) should be added.",
      "createdAt": "2016-11-17T19:01:09Z",
      "updatedAt": "2017-01-24T02:07:46Z",
      "closedAt": "2017-01-24T02:07:46Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I would vote for a different sub-type, `index` doesn't really make me think that the content is also included. This also doesn't appear to match up with any of https://tools.ietf.org/html/rfc2652 or the subtree:\r\n\r\n```\r\napplication/index.cmd\r\napplication/index.response\r\napplication/index.obj\r\napplication/index.vnd\r\n```",
          "createdAt": "2016-11-29T22:13:20Z",
          "updatedAt": "2016-11-29T22:13:20Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUxOTAxMzQ0MDU=",
      "title": "Inclusion of binary data into a text-based format",
      "url": "https://github.com/WICG/webpackage/issues/10",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[The section on the index ](https://github.com/dimich-g/webpackage#use-case-optional-content-index) says that compression may be permitted, but that may/will yield binary data.  However, because the header of the is document is text - most sniffers will consider this a text file and treat it accordingly (eg. screwing up line endings).\r\n\r\nEither require that all data be text-encoded (eg. BASE64) or use a binary format.",
      "createdAt": "2016-11-17T19:04:06Z",
      "updatedAt": "2017-08-10T13:48:24Z",
      "closedAt": "2017-08-10T13:48:24Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol I do not view this as a problem. Opening a text editor on the file format and editing is not something I see as a goal.",
          "createdAt": "2016-11-29T22:07:30Z",
          "updatedAt": "2016-11-29T22:07:30Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck The problem isn't manual editing.  The problem is systems that determine whether to automatically convert line endings of injected files based on sniffing the beginning of file's content (eg. git).  ",
          "createdAt": "2016-11-30T20:26:47Z",
          "updatedAt": "2016-11-30T20:26:47Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol would using hpack or something to turn the headers into something a sniffer would not see as ASCII be sufficient? I'm not terribly moved by automatic conversion by git etc. as other files suffer similar problems.",
          "createdAt": "2016-12-02T20:07:18Z",
          "updatedAt": "2016-12-02T20:07:18Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck  - Assuming you mean [this hpack](https://http2.github.io/http2-spec/compression.html), it isn't viable as that only works for headers not arbitrary data.   \r\nAnd just because the other kids are jumping off the bridge doesn't mean we should too :).  We know it's wrong - let's not do it...",
          "createdAt": "2016-12-04T20:51:11Z",
          "updatedAt": "2016-12-04T20:51:11Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol my understanding is that the headers were the cause for concern related to sniffers. I do not wish to use hpack on bodies. So, I was saying something like hpack (maybe not hpack) to compress the headers might be sufficient.",
          "createdAt": "2016-12-05T14:42:45Z",
          "updatedAt": "2016-12-05T14:42:45Z"
        },
        {
          "author": "groundwater",
          "authorAssociation": "NONE",
          "body": "I think binary data will be common place.\r\n\r\n1. webassembly\r\n2. images/audio/video\r\n3. encrypted data\r\n\r\nI don't know how good/bad BASE64 encoding is, but it's never been a great story for JSON. Would a few magic bytes fool the sniffers?",
          "createdAt": "2016-12-30T20:46:03Z",
          "updatedAt": "2016-12-30T20:46:03Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "there is nothing wrong with BASE64 - it's been in widespread use for\ndecades.  However, it has the downside of bloating file size (since it is\nobviously larger than the binary equivalent).\n\nOne way to address this problem is to force a web package to be a binary\nformat, in the same way that PDF did 20+ years ago (and continues to do).\nPut a string of high order ASCII early on in the file (eg. as part of the\nformat header).  That should hopefully fool the sniffer to consider it\nalways a binary file and thus allowing enclosed binaries.\n\nOn Fri, Dec 30, 2016 at 3:46 PM, Jacob Groundwater <notifications@github.com\n> wrote:\n\n> I think binary data will be common place.\n>\n>    1. webassembly\n>    2. images/audio/video\n>    3. encrypted data\n>\n> I don't know how good/bad BASE64 encoding is, but it's never been a great\n> story for JSON. Would a few magic bytes fool the sniffers?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/10#issuecomment-269819994>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNV8UYmHHneJjJbqFJHmT5WGOODjgks5rNW2LgaJpZM4K1rr4>\n> .\n>\n",
          "createdAt": "2017-01-03T19:35:08Z",
          "updatedAt": "2017-01-03T19:35:08Z"
        },
        {
          "author": "groundwater",
          "authorAssociation": "NONE",
          "body": "Thank you @lrosenthol!\r\n\r\n> it has the downside of bloating file size\r\n\r\nThat was honestly the only downsize I could think of. Given that one problem this project aims to solve is packaging for folks with low or limited access, I think file size is important.\r\n\r\n> the same way that PDF did 20+ years ago\r\n\r\nWhat I love about this solution is that we're copying something that already works!\r\n\r\n@bmeck regarding hpack, I don't know much about the format, but it sounds like it has the upside of both reducing file size, and passing the sniff test. It sounds like the downsize is increased complexity of creating and parsing the package. For a moment, assuming the binary sniffing problem was solved, are there still benefits to hpack?",
          "createdAt": "2017-01-03T20:25:51Z",
          "updatedAt": "2017-01-03T20:25:51Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@groundwater file size is a big win, allowing arbitrary extension headers is a possible win. Stateful compression like hpack can have a downside in that you have to preserve state if you want to extract  only one part of the archive and leave the rest intact.",
          "createdAt": "2017-01-03T20:38:30Z",
          "updatedAt": "2017-01-03T20:38:30Z"
        },
        {
          "author": "groundwater",
          "authorAssociation": "NONE",
          "body": "@bmeck \r\n\r\n> file size is a big win\r\n\r\nI agree! Just to ask, is this something that could be seen as a v2.0 optimization? Or would this need to be part of the spec out of the gate.\r\n\r\n> allowing arbitrary extension headers is a possible win\r\n\r\nI am not sure what this means, but it sounds interesting. Can you explain a little more?\r\n\r\n> Stateful compression like hpack can have a downside in that you have to preserve state if you want to extract only one part of the archive and leave the rest intact.\r\n\r\nCorrect me if I'm wrong, but it sounds like this is solvable _with good tooling_. But there is a cost in creating that tooling.",
          "createdAt": "2017-01-03T21:24:53Z",
          "updatedAt": "2017-01-03T21:24:53Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "There are (basically) three different approaches to archival compression\n\n- Compress the entire thing (ala .tar.z)\n- Compress each file/object individually (ala ZIP)\n- Block-based compression\n\nThe latter is the most complex and yields somewhat larger files, but with\nthe advantage of being able to do partial decompression and/or updates.\nIt's also (AFAIK) still under a variety of patents from the 90's when it\nwas first developed.\n\nYou have to make a decision about which up front as it's part of your\nformat design.\n\n\nOn Tue, Jan 3, 2017 at 4:24 PM, Jacob Groundwater <notifications@github.com>\nwrote:\n\n> @bmeck <https://github.com/bmeck>\n>\n> file size is a big win\n>\n> I agree! Just to ask, is this something that could be seen as a v2.0\n> optimization? Or would this need to be part of the spec out of the gate.\n>\n> allowing arbitrary extension headers is a possible win\n>\n> I am not sure what this means, but it sounds interesting. Can you explain\n> a little more?\n>\n> Stateful compression like hpack can have a downside in that you have to\n> preserve state if you want to extract only one part of the archive and\n> leave the rest intact.\n>\n> Correct me if I'm wrong, but it sounds like this is solvable *with good\n> tooling*. But there is a cost in creating that tooling.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/10#issuecomment-270228930>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNRIJHuhau7coJYjCy7W-byRYnq7yks5rOrymgaJpZM4K1rr4>\n> .\n>\n",
          "createdAt": "2017-01-03T21:31:13Z",
          "updatedAt": "2017-01-03T21:31:13Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "> > allowing arbitrary extension headers is a possible win\r\n\r\n> I am not sure what this means, but it sounds interesting. Can you explain a little more?\r\n\r\nThings that are not well known headers a like `X-Special-Header: ...` in HTTP. In the actual HTTP 1.1 RFC extensions are not required to start with `X-` and the use of that prefix is deprecated, I just used it to make a point. \r\n\r\n> Correct me if I'm wrong, but it sounds like this is solvable with good tooling. But there is a cost in creating that tooling.\r\n\r\nThe way hpack works it can index existing field/value pairs https://http2.github.io/http2-spec/compression.html#compression.based.attacks has some more details on various design considerations to take note of due to this.",
          "createdAt": "2017-01-03T21:34:25Z",
          "updatedAt": "2017-01-03T21:34:25Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "What are the technical constraints here? I assume UTF-8 isn't sufficiently non-text to convince sniffers that they've found a binary file. How close to the beginning of the file do non-UTF-8 sequences need to appear in order to convince sniffers that the file's binary?",
          "createdAt": "2017-02-03T19:23:00Z",
          "updatedAt": "2017-02-03T19:23:00Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've finally realized the benefits of @bmeck's suggestion to use [HPACK](http://httpwg.org/specs/rfc7541.html). Even if we forbid parts from adding entries to the [dynamic table](http://httpwg.org/specs/rfc7541.html#dynamic.table), we get the following benefits:\r\n1. The format is obviously binary and will appear right at the beginning of the package, solving #10.\r\n2. The [static table](http://httpwg.org/specs/rfc7541.html#static.table.definition) will reduce the size of many common headers.\r\n3. The [Huffman code](http://httpwg.org/specs/rfc7541.html#huffman.code) will reduce the size of many uncommon headers and values.\r\n\r\nWe could allow the package to explicitly define the dynamic table in a single central place, which would give many of the benefits of HPACK's default online compression, but that seems like an extra feature that we can consider independently.",
          "createdAt": "2017-02-03T22:28:44Z",
          "updatedAt": "2017-02-03T22:30:21Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Correct, UTF8 is still text.   Usually sniffers tend to search the first\n2048 bytes or less.\n\nAs for HPACK - I am not seeing how that will help.  The large sizes for web\npackages aren't going to be the headers but the actual data of each part.\n\nOn Fri, Feb 3, 2017 at 2:23 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> What are the technical constraints here? I assume UTF-8 isn't sufficiently\n> non-text to convince sniffers that they've found a binary file. How close\n> to the beginning of the file do non-UTF-8 sequences need to appear in order\n> to convince sniffers that the file's binary?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/10#issuecomment-277337993>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNQBFKAZEcjJCfouC8G4e0nVooszCks5rY36VgaJpZM4K1rr4>\n> .\n>\n",
          "createdAt": "2017-02-06T13:58:26Z",
          "updatedAt": "2017-02-06T13:58:26Z"
        },
        {
          "author": "inexorabletash",
          "authorAssociation": "NONE",
          "body": "Reading through CBOR, I noticed the bit on [Self-Describe CBOR](https://tools.ietf.org/html/rfc7049#section-2.4.5) which roughly says you can freely prepend 0xd9d9f7 as a CBOR magic number, which is also carefully chosen to not be a valid UTF-8 or UTF-16 sequence. I don't know if mandating a leading \"tag 55799\" for webpackage has been discussed elsewhere (I'm a noob here) but it might be useful for making the very start of the package less sniffable as text?",
          "createdAt": "2017-05-17T22:20:49Z",
          "updatedAt": "2017-05-17T22:20:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The beginning of the current format is \"83 48\", which isn't valid UTF-8, but it is valid UTF-16. Do we need to prevent the format from being valid UTF-16?",
          "createdAt": "2017-05-17T23:14:11Z",
          "updatedAt": "2017-05-17T23:14:11Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol can we move this to https://github.com/WICG/webpackage/issues/47 ?",
          "createdAt": "2017-08-09T14:51:57Z",
          "updatedAt": "2017-08-09T14:51:57Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Yes, that's fine with me.  Thanks!\n\nOn Wed, Aug 9, 2017 at 10:51 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> can we move this to #47\n> <https://github.com/WICG/webpackage/issues/47> ?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/10#issuecomment-321279490>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNUdkWLNUQaBGTNwX6dHmsKlXVl2Lks5sWceOgaJpZM4K1rr4>\n> .\n>\n",
          "createdAt": "2017-08-09T15:42:45Z",
          "updatedAt": "2017-08-09T15:42:45Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWUxOTAxMzQ3NTA=",
      "title": "Index offset may not survive some processes",
      "url": "https://github.com/WICG/webpackage/issues/11",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "However, because the header of the is document is text - most sniffers will consider this a text file and treat it accordingly (eg. screwing up line endings).  If this happens, then all byte offsets will be incorrect and the file will be unable to load.\r\n\r\nConsider finding a way to fool the sniffer or move to a binary format.\r\n\r\n",
      "createdAt": "2016-11-17T19:05:37Z",
      "updatedAt": "2018-01-22T19:29:08Z",
      "closedAt": "2018-01-22T19:29:08Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "These offsets can also suffer if the package:\r\n\r\n1. is re-ordered (perhaps due to priorities)\r\n\r\n    Signatures are Headers+Body of a content resource currently which means it can be re-ordered fairly simply and maintain the signatures still. This was talked about on a phone call as being possible, particularly since the boundaries allow the Content Index Entities to keep the same hash.\r\n\r\n2. streamed in such a way as chunked encoded where encoding boundaries/headers could change the exact offsets.\r\n\r\n   In order for a Content Index to have these offsets for a streaming resource it would need to be at the end of file and not allow removing the encoding boundaries/headers. This seems a bit wasteful since a stream would need to track these offsets if the size of streamed chunks is not known ahead of time.\r\n\r\nIn any case, both of these have a need to recalculate the Package-Signature if the offsets change. Doing so while streaming would mean that Package-Signature also would need to occur at the end of file, presumably as a trailer.",
          "createdAt": "2016-12-29T19:13:47Z",
          "updatedAt": "2016-12-29T19:13:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#36 takes the index structure out of the signed content, so it can be re-generated by any process that invalidates its offsets. I think this is fixed.",
          "createdAt": "2017-03-30T17:54:38Z",
          "updatedAt": "2017-03-30T17:54:38Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWUxOTAxMzcwNzk=",
      "title": "Details of exactly what is hashed (both for individual entries and the package itself) are missing",
      "url": "https://github.com/WICG/webpackage/issues/12",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There is nothing specified for exactly which bytes are hashed - either for an individual file/resource for the header or the index.  \r\n\r\nDo you include the boundary string?  Do you include any closing line endings?  ",
      "createdAt": "2016-11-17T19:15:02Z",
      "updatedAt": "2017-06-27T22:40:15Z",
      "closedAt": "2017-06-27T22:40:15Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "see note about each resource having its HEADER+BODY signed in : https://github.com/dimich-g/webpackage/blame/master/README.md#L308\r\n\r\nMy PR rephrased in a few places to make more explicit in https://github.com/dimich-g/webpackage/pull/23\r\n\r\nIt might be prudent however to change the phrasing of https://github.com/dimich-g/webpackage/blame/master/README.md#L312 to state that nested packages as signed as opaque entities as it sounds currently like nested packages are not something that the root package can verify as being correct currently.",
          "createdAt": "2016-12-29T15:41:13Z",
          "updatedAt": "2016-12-29T15:41:13Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Just noticed, the certificates are not signed in the Content-Index examples; unsure if this is intentional, but seems like just an accident.",
          "createdAt": "2016-12-29T17:13:19Z",
          "updatedAt": "2016-12-29T17:13:19Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol if certificates are signed is the rest covered?",
          "createdAt": "2017-01-13T03:32:39Z",
          "updatedAt": "2017-01-13T03:32:39Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "You can't sign a certificate with itself - but you could sign the\ncertificates from a nested package with the certs from the parent - that\nwould be perfectly fine.\n\nOn Thu, Jan 12, 2017 at 10:32 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> if certificates are signed is\n> the rest covered?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/12#issuecomment-272352581>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNZL62PntQ79dK3bnPVwpddgBWyLFks5rRvBYgaJpZM4K1say>\n> .\n>\n",
          "createdAt": "2017-01-13T12:51:25Z",
          "updatedAt": "2017-01-13T12:51:25Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Arguably, these details can go in the draft specification rather than the explainer, but it's probably time to start that specification and add these details, so we can iterate on them.",
          "createdAt": "2017-01-24T01:15:19Z",
          "updatedAt": "2017-01-24T01:15:19Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#36 now specifies exactly which bytes are hashed and signed, so I believe this is fixed.",
          "createdAt": "2017-03-30T17:53:42Z",
          "updatedAt": "2017-03-30T17:53:42Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWUxOTAxMzc3NzQ=",
      "title": "Signatures not in compliance with EU law",
      "url": "https://github.com/WICG/webpackage/issues/13",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As described in [Mandate M/460](http://www.e-signatures-standards.eu/activities), only certain signature format and standards can be legally used in the EU - and this proposal does not comply with any.  It would be better to align with at least one of them - most likely CAdES.\r\n",
      "createdAt": "2016-11-17T19:17:45Z",
      "updatedAt": "2019-05-13T16:44:42Z",
      "closedAt": "2019-05-13T16:44:42Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Note various parts of these return 404s like https://docbox.etsi.org/ESI/Open/Latest_Drafts/ts-119172-1_v009-SignaturePolicyFramework-STABLE-DRAFT.pdf currently",
          "createdAt": "2016-12-28T16:07:32Z",
          "updatedAt": "2016-12-28T16:07:32Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I gave it a read through (once is not enough for me to fully understand in depth though). It seems this is more around policy and I see nothing in WebPackage that prevents you from using the proper standards (it also allows you to create signatures outside the standard). What are the exact things that prevent compliance?",
          "createdAt": "2016-12-29T17:43:53Z",
          "updatedAt": "2016-12-29T17:43:53Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUxOTAxMzkyMDA=",
      "title": "No need to specify cert algo as that is defined by the cert itself",
      "url": "https://github.com/WICG/webpackage/issues/14",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As asked [here](https://github.com/dimich-g/webpackage#use-case-signed-package-one-origin):\r\n> Should there be '-with-ECDSA' since certificate specifies the key's algorithm?\r\n\r\nNo, not necessary since the certificate specifies the algorithm.",
      "createdAt": "2016-11-17T19:23:09Z",
      "updatedAt": "2017-01-05T02:08:54Z",
      "closedAt": "2017-01-05T02:08:54Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWUxOTAxNDAwOTE=",
      "title": "Validation cannot necessarily take place offline ",
      "url": "https://github.com/WICG/webpackage/issues/15",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the [discussion on signing](https://github.com/dimich-g/webpackage#use-case-signed-package-one-origin), it says\r\n> The inclusion of certificate makes it possible to validate the package offline (certificate revocation aside, this can be done out-of-band when device is actually online).\r\n\r\nThis is only true in very few cases as you need to build an entire trust chain from that cert up to the root.  Most processors will not have local access to every cert - in which case, it will need to fetch them.",
      "createdAt": "2016-11-17T19:26:33Z",
      "updatedAt": "2019-05-13T16:45:50Z",
      "closedAt": "2019-05-13T16:45:50Z",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "True, the full chain is necessary for validation. Intermediary certificates can be usually fetched automatically, based on info in the Authority Information Access (AIA) extension in a typical certificate. There is a paragraph on that at the end of FAQ in the Explainer.\r\nSince a tool of some sort is required to sign a package, the same tool could make sure to fetch intermediate certificates and package them into the same package. Whether it is a part of the same resource or it has to be multiple 'certificate' parts all representing parts of the certificate chain is still somewhat an open question.",
          "createdAt": "2016-12-07T01:13:25Z",
          "updatedAt": "2016-12-07T01:13:25Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "You could indeed package up (a set of) intermediate certificates - but,\nthat may not be the same set that is used at validation time, depending on\nthe validation policy in place.  Different policies can lead to different\nbranches of the chain.   Also, you'd still (most likely) need to do\nrevocation checks, which require online access for full validation.\nAnd then there is the whole \"where do you get the CA certs from\"\nproblem...(EUTL, OS, other?)\n\nAll solvable - as they are in other instances - but could lead to\ninteroperability issues...\n\nOn Tue, Dec 6, 2016 at 8:13 PM, Dmitry Titov <notifications@github.com>\nwrote:\n\n> True, the full chain is necessary for validation. Intermediary\n> certificates can be usually fetched automatically, based on info in the\n> Authority Information Access (AIA) extension in a typical certificate.\n> There is a paragraph on that at the end of FAQ in the Explainer.\n> Since a tool of some sort is required to sign a package, the same tool\n> could make sure to fetch intermediate certificates and package them into\n> the same package. Whether it is a part of the same resource or it has to be\n> multiple 'certificate' parts all representing parts of the certificate\n> chain is still somewhat an open question.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/15#issuecomment-265325632>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNZ3qSdJ6LC3v7aHhxXSKDCpHcNmmks5rFgg2gaJpZM4K1tPO>\n> .\n>\n",
          "createdAt": "2016-12-08T14:23:04Z",
          "updatedAt": "2016-12-08T14:23:04Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the point here was that your environment could supply the missing certs and/or your downloader could automatically check/fetch missing certs. \"possible\" does not mean always true in my mind. I am unclear on the specific interoperability issue you allude to except from collision and/or replacement of certs which are true in almost all systems (particularly if non-security based revocation/expiration is allowed to be ignored).",
          "createdAt": "2016-12-28T14:41:52Z",
          "updatedAt": "2016-12-28T14:41:52Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "If you read the relevant standards around signature validation (such as\nthose form the EU's eIDAS regulations, incl EN 319 102-1 v1.1.1 and TS 119\n172-1), you will see that the building of the trust chain for validation is\ncontrolled by a number of factors including signature policies. Those\npolicies have impact on the interoperability, as does the selection of CA\nrepository.\n\nAgain, these are all solved problems in DOCUMENT signature space - which is\nnot the same as web content/TLS signature validation.\n\nOn Wed, Dec 28, 2016 at 9:41 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> I think the point here was that your environment could supply the missing\n> certs and/or your downloader could automatically check/fetch missing certs.\n> \"possible\" does not mean always true in my mind. I am unclear on the\n> specific interoperability issue you allude to except from collision and/or\n> replacement of certs which are true in almost all systems (particularly if\n> non-security based revocation/expiration is allowed to be ignored).\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/15#issuecomment-269485803>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNSkxk_oJLFRFzXiLZWkBD9CZZ9h8ks5rMnUxgaJpZM4K1tPO>\n> .\n>\n",
          "createdAt": "2016-12-28T15:30:45Z",
          "updatedAt": "2016-12-28T15:30:45Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol I was not thinking of looking at those, so if you have other relevant documents it might be good to share those.",
          "createdAt": "2016-12-28T16:06:20Z",
          "updatedAt": "2016-12-28T16:06:20Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol thanks for the references! Need to digest a bit :)",
          "createdAt": "2017-01-05T02:00:10Z",
          "updatedAt": "2017-01-05T02:00:10Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWUxOTAxNDAzMTI=",
      "title": "What type of certificates can be used to sign? ",
      "url": "https://github.com/WICG/webpackage/issues/16",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "What is the expectation of what types of certificates can be used to sign these packages? \r\n\r\nSSL/TLS?\r\nCode signing?\r\nStandard document/message signing?\r\nOther?\r\n",
      "createdAt": "2016-11-17T19:27:26Z",
      "updatedAt": "2017-01-13T19:19:02Z",
      "closedAt": "2017-01-13T19:19:02Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol do we need to constrain the types of certs or just the certificate container format: x509 vs PGP vs ...?\r\n\r\nedit: should clarify that the proposal contains:\r\n> Certificate is included as one of standard the DER-encoded resource (with proper Content-type).\r\n",
          "createdAt": "2016-11-29T22:14:57Z",
          "updatedAt": "2016-11-29T22:16:34Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck Yes, we would need both.  First the certificate format (eg. X509 vs. PGP) and then second the type of cert - because you can't necessarily intermix SSL/TLS certs with code or document signing certs.  (which is, of course, by design)",
          "createdAt": "2016-11-30T20:24:16Z",
          "updatedAt": "2016-11-30T20:24:16Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "with the conversation in https://github.com/dimich-g/webpackage/pull/22 \r\n\r\nI vote for X509 with a minimum of [Key Usage](https://tools.ietf.org/html/rfc5280#section-4.2.1.3):\r\n\r\n* `digitalSignature` - we could be sending down assets that would not execute\r\n* `id-kp-codeSigning` - we could be sending down JS that would execute\r\n* `id-kp-timeStamping` - we have mentions of expiration/ages\r\n\r\nShould check with certificate vendors around and see if there are any that would have issues easily supplying all 3 to average person wanting to make a package.",
          "createdAt": "2017-01-04T19:42:06Z",
          "updatedAt": "2017-01-04T19:42:15Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck\n\nIt's pretty difficult to get a code signing cert, due to the normal usage\ncases for it.   And timestamping even more so - since that's really only\nfor use in a timestamp server.\n\nBut can't hurt to ask...\n\n\nOn Wed, Jan 4, 2017 at 2:42 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> with the conversation in #22\n> <https://github.com/dimich-g/webpackage/pull/22> \ud83d\udc4d\n>\n> I vote for X509 with a minimum of Key Usage\n> <https://tools.ietf.org/html/rfc5280#section-4.2.1.3>:\n>\n>    - digitalSignature - we could be sending down assets that would not\n>    execute\n>    - id-kp-codeSigning - we could be sending down JS that would execute\n>    - id-kp-timeStamping - we have mentions of expiration/ages\n>\n> Should check with certificate vendors around and see if there are any that\n> would have issues easily supplying all 3 to average person wanting to make\n> a package.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/16#issuecomment-270466521>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNbXm5m7xNw5P-CI6Swb6440cwJZGks5rO_YOgaJpZM4K1tS->\n> .\n>\n",
          "createdAt": "2017-01-05T01:05:15Z",
          "updatedAt": "2017-01-05T01:05:15Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Was id-kp-codeSigning extension introduced to be able to issue those separately from SSL (and even using separate roots?) to reduce associated risks? \r\n\r\nPerhaps the limits on key usage (especially key usage extensions) should be a detail of implementation? For example, a browser would use SSL/TLS keys since the content it will validate is web content and the purpose of validation is to afford it the same privileges that delivering it via SSL provides. It is also likely that the procedure to sign the web content will involve the same certs the web servers use already. \r\n\r\nThe code distribution tools for JS runtimes may have different limits and require different type of keys (if this is practical).",
          "createdAt": "2017-01-05T01:55:33Z",
          "updatedAt": "2017-01-05T01:55:33Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Given that we have identified at least three different use cases for this\nwork (browsers loading scripts/etc, application packagers and\npublications), each of which would logically want/require a different type\nof certificate - perhaps we shouldn't put any restrictions here and leave\nit up to the use case in question to create a \"profile\" for their own\nneeds??\n\nOn Wed, Jan 4, 2017 at 8:55 PM, Dmitry Titov <notifications@github.com>\nwrote:\n\n> Was id-kp-codeSigning extension introduced to be able to issue those\n> separately from SSL (and even using separate roots?) to reduce associated\n> risks?\n>\n> Perhaps the limits on key usage (especially key usage extensions) should\n> be a detail of implementation? For example, a browser would use SSL/TLS\n> keys since the content it will validate is web content and the purpose of\n> validation is to afford it the same privileges that delivering it via SSL\n> provides. It is also likely that the procedure to sign the web content will\n> involve the same certs the web servers use already.\n>\n> The code distribution tools for JS runtimes may have different limits and\n> require different type of keys (if this is practical).\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/16#issuecomment-270543271>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNTK3IUa1eix9SPWex-WgtP6GySgUks5rPE2WgaJpZM4K1tS->\n> .\n>\n",
          "createdAt": "2017-01-05T12:47:14Z",
          "updatedAt": "2017-01-05T12:47:14Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol @dimich-g if we want to leave it up to env that seems fine.",
          "createdAt": "2017-01-05T15:19:10Z",
          "updatedAt": "2017-01-05T15:19:10Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWUxOTAxNDExODU=",
      "title": "In nested packages, what are the offsets relative to?",
      "url": "https://github.com/WICG/webpackage/issues/17",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It's not clear from the document whether offsets specified in the header or index of a nested package are to be taken from the start of the containing/primary package data or from the start of the nested package header.  \r\n",
      "createdAt": "2016-11-17T19:30:56Z",
      "updatedAt": "2016-12-07T00:40:56Z",
      "closedAt": "2016-12-07T00:40:56Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "for streaming[/reuse] purposes I would hope it is relative to the nested package and not the outer package.",
          "createdAt": "2016-11-29T22:17:18Z",
          "updatedAt": "2016-11-29T22:17:34Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck I would hope so too - but the spec is silent on the topic...",
          "createdAt": "2016-11-30T20:22:18Z",
          "updatedAt": "2016-11-30T20:22:18Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Commit https://github.com/dimich-g/webpackage/commit/45bf2223ef53764c5b42ae614744267aa7fe90ed\r\nadded the note about relative offsets - the offsets inside the nested package are relative to the nested package. The idea is that the nested packages are full-formed on their own and can be created/signed separately, then included as-is into containing package.",
          "createdAt": "2016-12-07T00:40:55Z",
          "updatedAt": "2016-12-07T00:40:55Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWUxOTQ3Nzg5NTc=",
      "title": "Self Extracting Binaries",
      "url": "https://github.com/WICG/webpackage/issues/20",
      "state": "CLOSED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For self extracting executables, the common implementation is to produce a file which is a concatenated binary executable head, and an archive tail.\r\n\r\nNode and Electron are looking at reusing webpackage possibly as things progress and need a way:\r\n\r\n* Have a signature for the concatenated binary+archive\r\n* Have a length pointer to let the runtime jump to the start of the archive\r\n\r\nSelf extracting zip files, ASAR from electron, and NODA are examples of this from the past. These all work by having a directory at end of file, but for all use cases I know a pointer to start of archive on the tail would be sufficient. Doing so would most likely just be a series of magic bytes and kength that exists at the end of the file. It could be optional but must be easy to add to an existing webpackage.\r\n\r\nFor a signature of the entire binary + archive this is important so people don't perform a secondary concatenation and load a different archive than expected, it most likely can just be a well known header that optionally exists on the package headers.",
      "createdAt": "2016-12-10T16:55:07Z",
      "updatedAt": "2019-12-12T01:16:14Z",
      "closedAt": "2017-03-30T18:07:48Z",
      "comments": [
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems that the most important incompatibility here is that an archive with an executable at the head won't be readable by archive readers since we use header lines to define the content type, signature, etc.  \r\n\r\nSignature of the binary+archive seems like a less important feature, unless the OS is going to know how to validate the binary signature before it executes it. Is there a use case I'm not seeing?  Can we split the discussion of binary signatures from the more general self-extracting case?",
          "createdAt": "2017-01-03T18:41:38Z",
          "updatedAt": "2017-01-03T18:41:38Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I would not expect to keep the same file extension if it is self extracting. Unsure what workflow:\r\n\r\n> Seems that the most important incompatibility here is that an archive with an executable at the head won't be readable by archive readers since we use header lines to define the content type, signature, etc.\r\n\r\nWould conflict with.\r\n\r\nSigning of a binary+archive is important if the runtime wants to prevent certain types of concatenation attacks. Otherwise:\r\n\r\n```sh\r\n> cat runtime webpackage > extracting_bin\r\n```\r\n\r\ncould have the package replaced by doing\r\n\r\n```sh\r\n> cat extracting_bin other_webpackage\r\n```\r\n\r\nWhich would not be good if you are trying to distribute a binary.\r\n\r\nSigning tools like `codesign` or `toolsign` are currently outside my intents but I don't see any problem with using them ontop in conjunction with a signature method for the combined executable.",
          "createdAt": "2017-01-03T18:57:30Z",
          "updatedAt": "2017-01-03T18:57:30Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Shouldn't signign the binary+archive be something that the self-extracting\nexecutable has to worry about and not something we need to worry about?  If\nthey want to use our packaging format (by cat'ing it to the end of\nthemselves), then they are responsible for their own signing - be it\nstandard/OS code sign or something else.\n\nOn Tue, Jan 3, 2017 at 1:57 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> I would not expect to keep the same file extension if it is self\n> extracting. Unsure what workflow:\n>\n> Seems that the most important incompatibility here is that an archive with\n> an executable at the head won't be readable by archive readers since we use\n> header lines to define the content type, signature, etc.\n>\n> Would conflict with.\n>\n> Signing of a binary+archive is important if the runtime wants to prevent\n> certain types of concatenation attacks. Otherwise:\n>\n> > cat runtime webpackage > extracting_bin\n>\n> could have the package replaced by doing\n>\n> > cat extracting_bin other_webpackage\n>\n> Which would not be good if you are trying to distribute a binary.\n>\n> Signing tools like codesign or toolsign are currently outside my intents\n> but I don't see any problem with using them ontop in conjunction with a\n> signature method for the combined executable.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/20#issuecomment-270193261>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNZZi6Wez9tjVavYLcB3wcnoPCUFXks5rOpobgaJpZM4LJspJ>\n> .\n>\n",
          "createdAt": "2017-01-03T19:31:22Z",
          "updatedAt": "2017-01-03T19:31:22Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol mostly yes, but as was talked about a bit ago on a call, there needs to be a standard so that the differing runtimes can leverage the same process/tooling to generate these. Same reason to have a trailer that could be picked up to find the beginning of the archive.",
          "createdAt": "2017-01-03T19:51:17Z",
          "updatedAt": "2017-01-03T19:51:17Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck I don't actually believe that a standard is needed in this case. And if there is, wouldn't it be better to come from the folks doing the SEA's and tooling for same, rather than us?  Do we have any folks from those communities participating here? ",
          "createdAt": "2017-01-03T20:19:09Z",
          "updatedAt": "2017-01-03T20:19:09Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Runtime people interested in this: Me (Node), @jasnell (Node), and @groundwater (Electron)",
          "createdAt": "2017-01-03T20:36:26Z",
          "updatedAt": "2017-01-03T20:36:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#36 added a length to the end of the package: https://github.com/dimich-g/webpackage#overall-format. Is that sufficient?",
          "createdAt": "2017-03-30T17:52:31Z",
          "updatedAt": "2017-03-30T17:52:31Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin yes",
          "createdAt": "2017-03-30T17:58:24Z",
          "updatedAt": "2017-03-30T17:58:24Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "@bmeck adding the length at last **inside cbor format** also works fine for your use case ?\r\n\r\n```\r\n> cat extracting_bin other_webpackage\r\n```\r\n\r\nit seems necessary decoding/re-encoding cbor format when adding other package to current .wbn .",
          "createdAt": "2019-12-11T04:01:19Z",
          "updatedAt": "2019-12-11T04:07:36Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Only works if the position is known, which means it must not be an unordered named field, it would still need to be at the very end of the payload. Is that what you are suggesting? E.g.\r\n\r\n```\r\n{\r\n  size,\r\n  payload\r\n} | {\r\n  payload,\r\n  size\r\n}\r\n```\r\n\r\nwouldn't work\r\n\r\n```\r\n[\r\n  payload,\r\n  size // guaranteed location at tail of the whole bundle\r\n]\r\n```\r\n\r\nis probably ok",
          "createdAt": "2019-12-11T15:03:02Z",
          "updatedAt": "2019-12-11T15:03:02Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "CBOR integers are variable-sized and can't be parsed backwards, so the total size does need to be a byte-string like it's currently specified: https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#name-top-level-structure. They are inside the overall CBOR format, which is easy since an array's last item is also the last bytes of the encoding of the array.",
          "createdAt": "2019-12-11T18:37:08Z",
          "updatedAt": "2019-12-11T18:37:08Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "adding another package to current webbundle should update section and section-length too.\r\nyou can update only length without parsing whole cbor. but updating section/section-length need to parse whole cbor isn't it ?\r\nin that case, move only length to bottom of cbor array will help this case ?\r\n",
          "createdAt": "2019-12-12T01:16:14Z",
          "updatedAt": "2019-12-12T01:16:14Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWUyMDA0MTE2ODE=",
      "title": "Links to resource within a Package",
      "url": "https://github.com/WICG/webpackage/issues/26",
      "state": "OPEN",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "For some use cases like Source Maps packages may wish to not include the full asset within themselves but have another package containing debugging symbols. Currently fragment URLs are proposed for removal, however I don't see a clear way to have a situation like:\r\n\r\n```\r\nminified.webpackage\r\n\\- index.min.js\r\n```\r\n\r\n```\r\nsource-maps.webpackage\r\n\\- index.min.js.map\r\n```\r\n\r\nAnd have `index.min.js` able to point to `index.min.js.map`.",
      "createdAt": "2017-01-12T16:20:01Z",
      "updatedAt": "2019-05-13T16:48:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Unless we can convince \"the powers that be\" to support fragment URLs or\nsome other method by which paths into packages could be supported as part\nof a URL syntax - you are correct, there is no solution :(.\n\nOn Thu, Jan 12, 2017 at 11:20 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> For some use cases like Source Maps packages may wish to not include the\n> full asset within themselves but have another package containing debugging\n> symbols. Currently fragment URLs are proposed for removal, however I don't\n> see a clear way to have a situation like:\n>\n> minified.webpackage\n> \\- index.min.js\n>\n> source-maps.webpackage\n> \\- index.min.js.map\n>\n> And have index.min.js able to point to index.min.js.map.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNW595WhOgmpM4tsGCHzs31bpGfQlks5rRlKxgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-13T02:45:13Z",
          "updatedAt": "2017-01-13T02:45:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Initially, what if we write the source map's URL, and insist on being online in order to debug?",
          "createdAt": "2017-01-24T01:18:18Z",
          "updatedAt": "2017-01-24T01:18:18Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin I'm not sure I understand. The source maps are generally linked via a URL already ( https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/view#heading=h.lmz475t4mvbx ). Even with an online mandate we don't have a way to refer to contents within different packages so source maps cannot exist within a different package from the generated content.",
          "createdAt": "2017-01-24T05:02:18Z",
          "updatedAt": "2017-01-24T05:02:18Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@bmeck Say https://example.com/index.package contains https://example.com/index.min.js, which says its sourcemap is https://example.com/index.min.js.map. https://example.com/maps.package happens to contain https://example.com/index.min.js.map, but as you said, there's no way to have index.min.js say its sourcemap is https://example.com/index.min.js.map *inside of https://example.com/maps.package*. But that's ok as long as you're online: the browser will just fetch https://example.com/index.min.js.map directly. If you want to pre-cache a bunch of sourcemaps, maybe your devtools will have a way to load a package, and then it won't need to re-download the sourcemap, but that doesn't need to be based on fragments.",
          "createdAt": "2017-01-25T18:43:48Z",
          "updatedAt": "2017-01-25T18:43:48Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin ah, I see the disconnect. I am mostly concerned with Node's ability to use webpackage. So we were looking at something more like a `app.webpackage` and `app_debug_info.webpackage` they would never refer to a sourcemap outside of a `webpackage`. Your assertion is that the sourcemap is available is outside a webpackage always, I was under the assumption that there are debug webpackages that are the source of truth and the sourcemaps contained within are not available outside of those webpackages.",
          "createdAt": "2017-01-25T19:01:36Z",
          "updatedAt": "2017-01-25T19:01:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I see. What if `app.webpackage` included a header:\r\n```\r\nLink: <app_debug_info.webpackage>; rel=debug; type=application/package\r\n```\r\nheader, and Node interpreted that as a request to load the package when trying to debug. When loading `app_debug_info.webpackage`, Node would cache `index.min.js.map` and then use it for requests from `app.webpackage`. This would also work for offline use in a browser.",
          "createdAt": "2017-01-25T20:02:28Z",
          "updatedAt": "2017-01-25T20:02:28Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck but we aren't designing this package format only for Node (or similar). In the context of a web publication, those sourcemaps are a huge security hole since it would allow for reference content across domains - even in signed/trusted content.\r\n\r\nWhile there are some excellent use cases for being able to map relative->absolute URLs, its a major security hole in the general package case.",
          "createdAt": "2017-01-25T23:22:09Z",
          "updatedAt": "2017-01-25T23:22:09Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol if those urls cannot be accessed (does not exist / lack of perms) how is that a security hole?\r\n\r\nI agree that if this allowed cross domain access it would be problematic. I have no desire to allow such, but have a very strong interest in solving packaging debug info. I simply insist it is an important use case. Having a constrained solution is fine to me, but a solution should exist.",
          "createdAt": "2017-01-25T23:47:30Z",
          "updatedAt": "2017-01-25T23:47:30Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck How do you restrict the URLs that are allowed?  What determines that only \"non-existent/non-resolvable\" URLs could used?  ",
          "createdAt": "2017-01-27T19:09:09Z",
          "updatedAt": "2017-01-27T19:09:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol, given that sourcemaps already exist on the web, and can already refer to cross-origin maps, it doesn't seem that we can or need to restrict them further within packages. The UA can process the `//#` annotation the same as it would if the resource weren't in a package.",
          "createdAt": "2017-01-27T21:50:36Z",
          "updatedAt": "2017-01-27T21:50:36Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't it where the 'scope' attribute of the Link: header provides necessary mapping? Lets say:\r\n\r\nThe package contains 2 subpackages, `app.webpackage` and `app_debug_map.webpackage`.\r\n\r\nThe top-level package would contain 2 Link: headers to list the packages:\r\n\r\n`Link: <https://googleapis.com/packs/jquery.pack>; rel=package; scope=/libs`\r\n`Link: <https://googleapis.com/packs/jquery_debug_map.pack>; rel=package; scope=/libs/maps\r\n....\r\n`\r\nThen the URL `https://googleapis.com/libs/jquery.min.js` will be resolved (scope-matched) to the first webpack, and the map it refers to as h`ttps://googleapis.com/libs/maps/jquery.min.js.map` will be mapped to the second.",
          "createdAt": "2017-01-27T23:57:29Z",
          "updatedAt": "2017-01-27T23:57:29Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin, interesting though AFAICT that only applies to (a) JavaScript\nand (b) when it is used in some form of transpilation.  I don't see any\nusage on the web proper, nor usage outside of JS.   Am I missing something?\n\n\nOn Fri, Jan 27, 2017 at 4:50 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol>, given that sourcemaps\n> already exist on the web, and can already refer to cross-origin maps, it\n> doesn't seem that we can or need to restrict them further within packages.\n> The UA can process the //# annotation the same as it would if the\n> resource weren't in a package.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-275784581>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNd3x9yk5KjyIQIoqUBvz50kW-wTKks5rWmasgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-29T20:03:57Z",
          "updatedAt": "2017-01-29T20:03:57Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol CSS preprocessors and WASM are also affected. I don't know of any HTML/image conventions that use src maps though.",
          "createdAt": "2017-01-29T20:29:32Z",
          "updatedAt": "2017-01-29T20:29:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol Yes, sourcemaps are used for transpilation and little if anything else. When you [said](https://github.com/dimich-g/webpackage/issues/26#issuecomment-275264434) \"sourcemaps are a huge security hole\", what did you mean?",
          "createdAt": "2017-01-30T18:35:32Z",
          "updatedAt": "2017-01-30T18:35:32Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin - thinking about them being used at actual resource load time in\na UA.  The concern being that you could be loading stuff from one domain\nand then remapping it into another one.  That's basically enabling XSS as a\nfeature...\n\nOn Mon, Jan 30, 2017 at 1:35 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> Yes, sourcemaps are used for\n> transpilation and little if anything else. When you said\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-275264434>\n> \"sourcemaps are a huge security hole\", what did you mean?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276149434>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNZXu3geL5iVCoWKvdyw4DwHdKhk7ks5rXi11gaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T20:06:09Z",
          "updatedAt": "2017-01-30T20:06:09Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol can you clarify the `remapping` bit. We aren't loading source maps to alter execution, but they can redefine what source text looks like in dev tools.",
          "createdAt": "2017-01-30T20:10:09Z",
          "updatedAt": "2017-01-30T20:10:09Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Right - I think I understand how they work for dev tools today.  What I am\nstill somewhat unclear on is how that would work in a package that is\ndistributed and then opened on another machine??\n\nOn Mon, Jan 30, 2017 at 3:10 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> can you clarify the remapping\n> bit. We aren't loading source maps to alter execution, but they can\n> redefine what source text looks like in dev tools.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276175820>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNVTXysSv1LPHTAYBcnDP_vvPa8YZks5rXkOigaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T21:36:12Z",
          "updatedAt": "2017-01-30T21:36:12Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, my presumption is that they would contain paths/urls to something potentially off the machine. Though these urls are contained within the resource bodies generally, not in the headers that would be related to webpackage. This is more a question about what to do when such a url is encountered / how to denote that a resource is within a different file. I have no desire to try and lock down what is allowed content within a .js/.css/.wasm file.",
          "createdAt": "2017-01-30T22:03:55Z",
          "updatedAt": "2017-01-30T22:04:04Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": ">Ah, my presumption is that they would contain paths/urls to something potentially off the machine. Though these urls are contained within the resource bodies generally, not in the headers that would be related to webpackage. This is more a question about what to do when such a url is encountered / how to denote that a resource is within a different file. \r\n\r\nAgreed.   To be specific, there are multiple cases here and not sure which you want to support.\r\n\r\nThe normal case is where an absolute URL is mapped to a relative URL (in the package).   For example, you might have a CSS file that refers to an image via absolute URL (eg. background-image: url(\"http://some.domain.com/image.jpg\")).  You want to be able to setup a mapping from that URL to something like \"/images/image.jp\".  However, in that case, the resources must be in the unique origin of the package **not associated with any other domain**!\r\n\r\nThe second case is relative to relative mapping, where the reference is already to \"images/image.jpg\", but as part of packaging, it had to be moved to simply \"image.jpg\", so you need something to map that.  _Same comment about unique origin here as well._\r\n\r\nFinally, we have the really problematic cases, where you are mapping **TO** an absolute URL (either from a relative or another absolute). You don't want to start having a local reference pull something from a remote source, especially if you then try to map it back into the unique domain.\r\n\r\n> I have no desire to try and lock down what is allowed content within a .js/.css/.wasm file.\r\n\r\nMe either.  But we need to do it in a way that is secure.\r\n\r\n\r\n",
          "createdAt": "2017-01-30T22:34:16Z",
          "updatedAt": "2017-01-30T22:34:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Source maps don't alter execution, so even if a malicious sourcemap changes how a string appears while debugging, the original string is still used for all program logic. Sourcemaps can't introduce XSS.",
          "createdAt": "2017-01-30T22:43:02Z",
          "updatedAt": "2017-01-30T22:43:02Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Jeffrey - I understand that is how they work today in the contexts in which\nthey execute.  I am trying to understand how they would be used in the\ncontext of a webpackage, especially as it is loaded by a UA dynamically.\n\nOn Mon, Jan 30, 2017 at 5:43 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Source maps don't alter execution, so even if a malicious sourcemap\n> changes how a string appears while debugging, the original string is still\n> used for all program logic. Sourcemaps can't introduce XSS.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276215877>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNerZP9ZewlwvBH0PLlrF2jZTR108ks5rXmd2gaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T22:57:14Z",
          "updatedAt": "2017-01-30T22:57:14Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "They'd be used in exactly the same way when a webpackage is loaded by a UA dynamically.",
          "createdAt": "2017-01-30T23:02:35Z",
          "updatedAt": "2017-01-30T23:02:35Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "I don't understand how you can do that without using them to remap URLs as\nyou load resources...\n\nOn Mon, Jan 30, 2017 at 6:02 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> They'd be used in exactly the same way when a webpackage is loaded by a UA\n> dynamically.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276220274>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNYQpvZn7DsWNKpP4CM24A1_moiOUks5rXmwMgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T23:04:13Z",
          "updatedAt": "2017-01-30T23:04:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Given a sourcemap, you load and execute resources as if there were no sourcemap. Then, when debugging, you display urls in the devtools as the sourcemap says to remap them. This is the same whether or not there's a package involved.",
          "createdAt": "2017-01-30T23:06:05Z",
          "updatedAt": "2017-01-30T23:06:05Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "So you saying that sourcemaps would **never** be used during normal loading\ntime - but only during debugging?  What use is that for general package\nresource remapping, as I laid out in the previous message?\n\nRemember that a package isn't just scripts - but can/will also be HTML +\nCSS...\n\nOn Mon, Jan 30, 2017 at 6:06 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Given a sourcemap, you load and execute resources as if there were no\n> sourcemap. Then, when debugging, you display urls in the devtools as the\n> sourcemap says to remap them. This is the same whether or not there's a\n> package involved.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276221025>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNQ6JY7HQESHaq1MHh6FAyVmRb4L-ks5rXmzdgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T23:09:21Z",
          "updatedAt": "2017-01-30T23:09:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Sourcemaps aren't much use for resources you haven't transpiled, and folks building packages out of just HTML and non-compiled CSS don't need to use sourcemaps.",
          "createdAt": "2017-01-30T23:12:22Z",
          "updatedAt": "2017-01-30T23:12:22Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "I disagree with you on that point, @jyasskin.  They would be very useful in\nthose cases - as mentioned above...\n\nOn Mon, Jan 30, 2017 at 6:12 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Sourcemaps aren't much use for resources you haven't transpiled, and folks\n> building packages out of just HTML and non-compiled CSS don't need to use\n> sourcemaps.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276222294>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNa9USNH3x37nORJ4r40M5D02gjtpks5rXm5WgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T23:13:57Z",
          "updatedAt": "2017-01-30T23:13:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "That's a different feature than sourcemaps then, and as you pointed out, it comes with significant XSS risks. If possible, I'd like to avoid that sort of distraction in at least the initial version of the packaging format.",
          "createdAt": "2017-01-30T23:23:19Z",
          "updatedAt": "2017-01-30T23:23:19Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Glad that we're now on the same page...\n\nAnd keeping them separate makes perfect sense - however, I then envision\nthat in version > 1, that we now have **two** mapping syntaxes in the same\nformat...and that would seem to yield more confusion for the UA that has to\nimplement.  (or maybe not...)\n\n\nOn Mon, Jan 30, 2017 at 6:23 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> That's a different feature than sourcemaps then, and as you pointed out,\n> it comes with significant XSS risks. If possible, I'd like to avoid that\n> sort of distraction in at least the initial version of the packaging format.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276224531>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNf0ExawYwu4xn1bq1-WpdDJVzH2fks5rXnDogaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T23:30:03Z",
          "updatedAt": "2017-01-30T23:30:03Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Even if we spend the time to design a new mapping system for version 1, sourcemaps already exist and are in wide use, so we'd still have two mapping syntaxes. The only piece that might be redundant is the `Link:` header I suggested, which @dimich-g pointed out could maybe be subsumed by the `scope` attribute that we want anyway.",
          "createdAt": "2017-01-31T00:09:11Z",
          "updatedAt": "2017-01-31T00:09:11Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWUyMDMyNzc3MTE=",
      "title": "Subpackage should have index in main package",
      "url": "https://github.com/WICG/webpackage/issues/29",
      "state": "CLOSED",
      "author": "jianli-chromium",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Without index, we will have to scan the whole package to find it out.",
      "createdAt": "2017-01-26T02:18:30Z",
      "updatedAt": "2019-05-13T16:48:21Z",
      "closedAt": "2019-05-13T16:48:21Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think #36 fixes this: https://github.com/dimich-g/webpackage#index",
          "createdAt": "2017-03-30T17:51:54Z",
          "updatedAt": "2017-03-30T17:51:54Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jianli-chromium can this be closed?",
          "createdAt": "2017-08-09T14:52:48Z",
          "updatedAt": "2017-08-09T14:52:48Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWUyMDMyNzg1MjA=",
      "title": "Generated name should be used to denote a subresource if there is not a corresponding pack file in the server",
      "url": "https://github.com/WICG/webpackage/issues/30",
      "state": "CLOSED",
      "author": "jianli-chromium",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For subpackage that contains pages and resources downloaded from one domain, but not through pack file offered by that domain, we should not use http://foo.com/something.pack since it does not exist in the server. Probably we should use a generated name.",
      "createdAt": "2017-01-26T02:25:15Z",
      "updatedAt": "2019-05-13T16:49:02Z",
      "closedAt": "2019-05-13T16:49:02Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Subpackages aren't in the spec anymore.",
          "createdAt": "2019-05-13T16:49:02Z",
          "updatedAt": "2019-05-13T16:49:02Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUyMDM1MTE2MzE=",
      "title": "Document Adobe's use cases",
      "url": "https://github.com/WICG/webpackage/issues/32",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@lrosenthol, could you describe the use cases you're interested in for the packaging format, either in this issue or as a PR against the [`README.md`](https://github.com/dimich-g/webpackage/blob/master/README.md)?",
      "createdAt": "2017-01-26T22:45:10Z",
      "updatedAt": "2019-05-13T16:49:31Z",
      "closedAt": "2019-05-13T16:49:31Z",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin I became involved in this project due to Adobe's involvement in the [Web Publications](https://w3c.github.io/dpub-pwp/) work at the W3C and the filing of issue #3 .  However, we are also interested in the work with Node & Electron, as they are technologies that we use internally.\r\n\r\nPersonally, I have a very long (30+ year) history with archiving and packaging formats having been one of the founders of Aladdin Systems, which was responsible for [StuffIt](https://en.wikipedia.org/wiki/StuffIt).",
          "createdAt": "2017-01-27T14:02:50Z",
          "updatedAt": "2017-01-27T14:02:50Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks, so http://w3c.github.io/dpub-pwp-ucr/index.html covers the use cases? Also thanks for explaining your background.",
          "createdAt": "2017-01-27T16:11:23Z",
          "updatedAt": "2017-01-27T16:11:23Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Yes, that would be the right document to work from.\n\nOn Fri, Jan 27, 2017 at 11:11 AM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Thanks, so http://w3c.github.io/dpub-pwp-ucr/index.html covers the use\n> cases? Also thanks for explaining your background.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/32#issuecomment-275703397>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNaz1az1nrY1Q5NKEw7OHon1KjiBzks5rWhcsgaJpZM4LvPIw>\n> .\n>\n",
          "createdAt": "2017-01-27T18:57:54Z",
          "updatedAt": "2017-01-27T18:57:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Looking at dpub-pwp-ucr, it doesn't mention signing the publication. Given your other comments, I assume Adobe does have requirements around signatures, so could you write them down somewhere?\r\n\r\nI'll also admit that the Chrome folks are going to prioritize letting browsers give a package the [same origin](https://html.spec.whatwg.org/multipage/browsers.html#same-origin) as content loaded over HTTPS, over any Web Publications requirements, if there's a conflict. I don't see any impossible conflicts yet, especially if we allow multiple certificates to sign the same package, but FYI.",
          "createdAt": "2017-01-27T22:07:12Z",
          "updatedAt": "2017-01-27T22:07:12Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin Nothing Adobe-centric here - just me representing the PWP community as one of the editors of the works in progress.  \r\n\r\nSigning a publication is simply one well-established model to establish trust on a set of \"off the web\" resources - just as it is here with web packages.  That's what this entire discussion is about - how to establish that trust so that both the user and the UA feel safe in using some/all of the resources in a package/publication.\r\n\r\nThe entire work on sub-domains is also something interesting to the world of publications, where a single \"physical\" publication may actually be a collection of publications - in which case, sub-domains would serve to help with a variety of potential problems.",
          "createdAt": "2017-01-29T20:11:02Z",
          "updatedAt": "2017-01-29T20:11:02Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWUyMDM1MTE3NTU=",
      "title": "Document Node's use cases",
      "url": "https://github.com/WICG/webpackage/issues/33",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@bmeck, could you describe the use cases you're interested in for the packaging format, either in this issue or as a PR against the [`README.md`](https://github.com/dimich-g/webpackage/blob/master/README.md)?",
      "createdAt": "2017-01-26T22:45:48Z",
      "updatedAt": "2019-05-13T16:49:49Z",
      "closedAt": "2019-05-13T16:49:49Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "From an older call: https://docs.google.com/document/d/1iPHPLMUVimh8cZgB_vkO-XtmDrnanOMI9v5kfnwiv4U/view",
          "createdAt": "2017-02-01T19:16:12Z",
          "updatedAt": "2017-02-01T19:16:12Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Mandatory:\r\n\r\n- [x] Signing\r\n- [x] Random Access (via manifest)\r\n- [x] Self Extracting capable\r\n\r\nImportant but not absolute requirements (would need some path to mitigate):\r\n\r\n- [ ] Inter-package linking\r\n- [x] Nested packages\r\n- [ ] Deduplication\r\n\r\nNice to have:\r\n\r\n- [ ] Streaming\r\n- [x] Expiration",
          "createdAt": "2017-02-01T19:59:00Z",
          "updatedAt": "2017-03-30T19:22:49Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "mandatory requirements have been reached, feel free to mark closed",
          "createdAt": "2017-03-30T19:23:21Z",
          "updatedAt": "2017-03-30T19:23:21Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUyMDU3MzA1NDQ=",
      "title": "Electron user stories",
      "url": "https://github.com/WICG/webpackage/issues/35",
      "state": "CLOSED",
      "author": "groundwater",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi all, I saw some of you at Blink On, and I promised to come up with a few user stories. Rather than trying help shape the implementation, I thought I could just outline why electron is looking at this format. Here's my first pass at some user stories.\r\n\r\n## App Installer Story\r\n\r\nDeveloper Kim builds a new electron app, and wants to host it on her site. She wants to make the install as easy as possible, and a new hot installation tool some people have downloaded knows how to take a web package, and install it like a desktop app. Right now, every electron app comes with its own chromium. A web package format distribution could link out to the required chromium, which may already be installed on the users desktop.\r\n\r\nThe end-user downloads the `.electron` bundle, double-clicks it, and the installer installs a new app.\r\n\r\nBoth the installer, and the operating system should be validating the package and checking code signatures. (Open question if the dynamic installer messes up the signature story)\r\n\r\nA new icon is placed wherever there operating system installs applications, and double-clicking it opens the app.\r\n\r\n## Lifecycle with _shared_ resources\r\n\r\nKim is at it again, but this time her users have demanded an even slimmer after install experience. Kim builds the next web package bundle, but instead of including everything in `node_modules` the web package simply links out to indicate that a requires these and PM modules at specific versions. To complicate matters, some of these modules require compilation.\r\n\r\nKim knows that not all of her users have developer tools installed, but also doesn't want to set up CI on numerous different platforms. That's okay, we have your back. The top 100 electron modules that require compilation have been precompiled on common platforms packaged into a web package format.\r\n\r\nUser Angela downloads Kim's latest web package, which only includes the core app code. The installer understands the outbound links in the web package, and first attempts to satisfy them with a local cache on disk. One of the compiled dependencies is missing however, and the installer has to downloaded fresh. Instead of pulling from npm directly, the installer is able to resolve the location of a precompiled version and use that.\r\n\r\n## BigCorp\r\n\r\nBig Corp once control over every last bit of their installed application. They want to block every last piece down. They want a self-contained packaging format, where everything gets shipped altogether.\r\n\r\nThis is the situation we have now, which is why it's worth putting down.\r\n\r\n## BigCrop Internal\r\n\r\nInternally at big Corp, they have a lot of internal tools developers that wish to distribute quick one-off applications. Because everything is running behind their firewall, they only want vetted code. Developers love the hotlinking that the web package can do, but all links should resolve to an internal npm mirror and an internal blob store for precompiled modules.",
      "createdAt": "2017-02-06T22:43:56Z",
      "updatedAt": "2019-05-13T16:50:43Z",
      "closedAt": "2019-05-13T16:50:43Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think these have been incorporated into the [use cases document](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html).",
          "createdAt": "2019-05-13T16:50:43Z",
          "updatedAt": "2019-05-13T16:50:43Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWUyMDY5NDc1NDY=",
      "title": "Switch to binary format and more.",
      "url": "https://github.com/WICG/webpackage/issues/38",
      "state": "CLOSED",
      "author": "dimich-g",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nCapturing recent conversations with @jyasskin and @mrdewitt:\r\n\r\n1. We think it makes sense to switch to 100% binary format since the header compression and parts body compression makes it mostly binary anyways. It also lets us to replace MIME boundary strings with direct chunk-size kind of encoding.\r\n2. The Explainer and samples in it will be gradually updated to reflect switch to binary encoding. While in update, there can be some inconsistency in the doc.\r\n\r\nAlso discussed:\r\n- Binary alignment at 32 bit boundaries (decided not to)\r\n- Use Self-Delimiting Numeric Values (rfc 6256) (decided not to)\r\n- Split content index and offset table (so the resources may be rearranged)\r\n- Multiple hashes (to support deprecation of old ones)\r\n- Cross-signing\r\n",
      "createdAt": "2017-02-11T01:43:58Z",
      "updatedAt": "2017-06-27T22:41:25Z",
      "closedAt": "2017-06-27T22:41:25Z",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "If you are moving to a binary format - why not use an existing one instead\nof inventing yet another one?\n\nOn Fri, Feb 10, 2017 at 8:43 PM, Dmitry Titov <notifications@github.com>\nwrote:\n\n> Hi,\n>\n> Capturing recent conversations with @jyasskin\n> <https://github.com/jyasskin> and @mrdewitt <https://github.com/mrdewitt>:\n>\n>    1. We think it makes sense to switch to 100% binary format since the\n>    header compression and parts body compression makes it mostly binary\n>    anyways. It also lets us to replace MIME boundary strings with direct\n>    chunk-size kind of encoding.\n>    2. The Explainer and samples in it will be gradually updated to\n>    reflect switch to binary encoding. While in update, there can be some\n>    inconsistency in the doc.\n>\n> Also discussed:\n>\n>    - Binary alignment at 32 bit boundaries (decided not to)\n>    - Use Self-Delimiting Numeric Values (rfc 6256) (decided not to)\n>    - Split content index and offset table (so the resources may be\n>    rearranged)\n>    - Multiple hashes (to support deprecation of old ones)\n>    - Cross-signing\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/38>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNVOpv6nACGgd-JbgukU8oqFXpRHLks5rbRJegaJpZM4L-CAb>\n> .\n>\n",
          "createdAt": "2017-02-14T23:40:26Z",
          "updatedAt": "2017-02-14T23:40:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol Which existing one? Note the considerations at https://github.com/w3ctag/packaging-on-the-web#rejected-approaches",
          "createdAt": "2017-02-14T23:45:53Z",
          "updatedAt": "2017-02-14T23:46:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "[CBOR](http://cbor.io/) is an option for the package structure, and it even has a draft schema definition language, [CDDL](https://tools.ietf.org/html/draft-greevenbosch-appsawg-cbor-cddl-09). It won't be quite as compact as something we do custom, but it'll be easier to debug and to extend in the future.",
          "createdAt": "2017-02-15T19:50:05Z",
          "updatedAt": "2017-02-15T19:50:05Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "CBOR looks interesting. It seems to support streaming on receiving end as well.",
          "createdAt": "2017-02-15T21:01:46Z",
          "updatedAt": "2017-02-15T21:01:46Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "CBOR does look interesting, but seems to be more focused on handling a\nsingle file and not a package/collection of files & resources. I think we\nneed a more classic archiving format - something like a ZIP or StuffIt -\nbut with modern sensibilities.  I'll do some research\n\nOn Wed, Feb 15, 2017 at 4:01 PM, Dmitry Titov <notifications@github.com>\nwrote:\n\n> CBOR looks interesting. It seems to support streaming on receiving end as\n> well.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/38#issuecomment-280137551>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNRW1nXyJEUNjLiSLLVF6OohBQ-jEks5rc2e6gaJpZM4L-CAb>\n> .\n>\n",
          "createdAt": "2017-02-16T01:31:25Z",
          "updatedAt": "2017-02-16T01:31:25Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "There are 2 orthogonal things - binary encoding and then an index/manifest/hashing structure.  Formats like CBOR provide the former w/o attempting to provide the latter. So if we want specific structure and content of the package metadata (index, manifest, certificates and hashes), and don't care much about the way to assemble those pieces into a binary file with chunks of certain size is not important.\r\n\r\nThe main issue with Zip and other archiving formats is they mostly were developed without streaming on receiving and with fixed and/or limited set of metadata, and they will have to be 'augmented' in one way or another.\r\n\r\nCBOR seems to be a simple way to assemble length-prefixed and variable-length records, arrays and maps, and supports variable-length numbers, byte blobs and UTF-8 strings. No notion of a directory or hashing, which seems to be a good thing since those are exactly the subject of this proposal.",
          "createdAt": "2017-02-16T17:58:11Z",
          "updatedAt": "2017-02-16T17:58:11Z"
        },
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "It is small potatoes, but CBOR has already got debug tools and pretty\nprinters, so we'd have a head start on tooling as well.\n\nOn Thu, Feb 16, 2017 at 9:58 AM Dmitry Titov <notifications@github.com>\nwrote:\n\n> There are 2 orthogonal things - binary encoding and then an\n> index/manifest/hashing structure. Formats like CBOR provide the former w/o\n> attempting to provide the latter. So if we want specific structure and\n> content of the package metadata (index, manifest, certificates and hashes),\n> and don't care much about the way to assemble those pieces into a binary\n> file with chunks of certain size is not important.\n>\n> The main issue with Zip and other archiving formats is they mostly were\n> developed without streaming on receiving and with fixed and/or limited set\n> of metadata, and they will have to be 'augmented' in one way or another.\n>\n> CBOR seems to be a simple way to assemble length-prefixed and\n> variable-length records, arrays and maps, and supports variable-length\n> numbers, byte blobs and UTF-8 strings. No notion of a directory or hashing,\n> which seems to be a good thing since those are exactly the subject of this\n> proposal.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/38#issuecomment-280407885>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABQXzu8O_nbEWIOoQ7krTnKr6ERfmEWMks5rdI4zgaJpZM4L-CAb>\n> .\n>\n",
          "createdAt": "2017-02-16T18:06:19Z",
          "updatedAt": "2017-02-16T18:06:19Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #36.",
          "createdAt": "2017-03-30T17:50:53Z",
          "updatedAt": "2017-03-30T17:50:53Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUyMTg5NDI3ODM=",
      "title": "Figure out unsigned sub-packages",
      "url": "https://github.com/WICG/webpackage/issues/39",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From @dimich-g's https://github.com/dimich-g/webpackage/pull/36#issuecomment-290316360:\r\n\r\nWithout a signed manifest, there's no structure to identify sub-packages.\r\n\r\nHowever, it might just work to lump all the resources together at the top level. Do we need to identify the sub-package structure?",
      "createdAt": "2017-04-03T13:59:48Z",
      "updatedAt": "2019-05-13T16:51:39Z",
      "closedAt": "2019-05-13T16:51:39Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you clarify\r\n\r\n> lump all the resources together at the top level\r\n\r\nSub-packages are certainly distinct, even if unsigned.",
          "createdAt": "2017-04-03T15:00:10Z",
          "updatedAt": "2017-04-03T15:00:10Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Sorry for my delay in replying. If a package consists of a bunch of resources, and a sub-package consists of a bunch of resources with distinct URLs, do we need to have the packaging format distinguish the sub-package's resources from the main package's resources? How would a package consumer use that information?",
          "createdAt": "2017-04-12T03:56:48Z",
          "updatedAt": "2017-04-12T03:56:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We don't have subpackages anymore.",
          "createdAt": "2019-05-13T16:51:39Z",
          "updatedAt": "2019-05-13T16:51:39Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUyMTg5OTcwMzE=",
      "title": "Allow linking to sub-packages instead of just including them",
      "url": "https://github.com/WICG/webpackage/issues/40",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "architecture",
        "feature request"
      ],
      "body": "From @dimich-g's https://github.com/dimich-g/webpackage/pull/36#issuecomment-290316360:\r\n\r\nHaving external sub-packages could be useful to tell the UA that it's likely to need some files, without incurring an extra download cost when the UA happens to already have that package.",
      "createdAt": "2017-04-03T16:56:18Z",
      "updatedAt": "2019-05-13T16:55:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUyMTkwMDExNTI=",
      "title": "Optimize the storage of the resource URLs in the manifest, index, and main content",
      "url": "https://github.com/WICG/webpackage/issues/41",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From @dimich-g's https://github.com/dimich-g/webpackage/pull/36#issuecomment-290316360:\r\n\r\nThe `resource-key` structure (which holds a URL and possibly a set of request headers) is used as the key for the index, manifest, and main content. URLs can be fairly long, so we may want to optimize or compress that redundancy.\r\n\r\nOne idea for avoiding this duplication: Add a section of abbreviations that assigns each resource-key an index, and use those indices as the keys in the other three sections.\r\n\r\n1. We could re-use the index as that section of abbreviations.\r\n2. We probably don't want to re-use the manifest as that section, so that aggregating packages can build their own abbreviations.\r\n3. The abbreviations need to be expanded before hashing or checking signatures.\r\n4. We could shorten the abbreviation section even more by:\r\n   1. Resolving each URL/resource-key relative to the previous one.\r\n   1. Using the array index of the URL as its abbreviation instead of making the section name an abbreviation.\r\n\r\nAnother possibility would be to use a shared brotli dictionary to compress all three sections. The main downside here is that shared brotli dictionaries don't exist yet, and when they do, we may want to use a URL to identify which shared dictionary to use, which we'd again want to compress.",
      "createdAt": "2017-04-03T17:11:58Z",
      "updatedAt": "2017-05-11T00:02:03Z",
      "closedAt": "2017-05-11T00:02:03Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "In face-to-face discussion, we settled on the following arrangement:\r\n* The index holds the only copy of the `resource-key`s.\r\n* They point into an array of response-header/body pairs, where you can't interpret this response pair without knowing the resource-key that points to it.\r\n* The manifest holds only a list of valid hashes for its origin, where a hash is computed over `resource-key||response-header||body`. I believe this guarantees that changing the untrusted index can't cause a body to be accessible by a different resource-key.\r\n\r\nThis also removes an attack where one might check validity over a resource found via the index, but then use a resource with the same `resource-key` found by linearly-searching the content, since now it's impossible to find resources by linearly-searching the content.",
          "createdAt": "2017-04-09T17:11:31Z",
          "updatedAt": "2017-04-09T17:11:31Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUyMTkwMDE0MDc=",
      "title": "Update examples for CBOR format",
      "url": "https://github.com/WICG/webpackage/issues/42",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/dimich-g/webpackage#use-cases has lots of examples that use an old version of the design.",
      "createdAt": "2017-04-03T17:12:55Z",
      "updatedAt": "2019-05-13T16:52:21Z",
      "closedAt": "2019-05-13T16:52:21Z",
      "comments": [
        {
          "author": "BigBlueHat",
          "authorAssociation": "NONE",
          "body": "@jyasskin is there a place to get visibility into the move to CBOR? The MIME-like packaging format described in the original [web-packaging](https://www.w3.org/TR/web-packaging/) spec felt very familiar and comfortable. :smiley: Mostly curious as to the choices made.\r\n\r\nThanks!\r\n:tophat:",
          "createdAt": "2017-06-02T20:50:42Z",
          "updatedAt": "2017-06-02T20:50:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#10 and #38 discuss the decision to move to a binary format. We also got feedback that it was hard to reliably generate the MIME boundary strings that the TAG's format needed, and that length prefixing was easier.",
          "createdAt": "2017-06-02T20:56:50Z",
          "updatedAt": "2017-06-02T20:56:50Z"
        },
        {
          "author": "BigBlueHat",
          "authorAssociation": "NONE",
          "body": "@jyasskin much thanks for the description and the links! CBOR does look promising. Cheers!",
          "createdAt": "2017-06-07T19:23:27Z",
          "updatedAt": "2017-06-07T19:23:27Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWUyMTkzNDQ2MDg=",
      "title": "Remove references to urn:uuid URLs",
      "url": "https://github.com/WICG/webpackage/issues/43",
      "state": "CLOSED",
      "author": "mrdewitt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With the switch to CBOR, we no longer need urn:uuid URLs for special parts.  Some of the example sections still refer to that type of URL.",
      "createdAt": "2017-04-04T18:40:22Z",
      "updatedAt": "2018-05-08T22:55:37Z",
      "closedAt": "2018-05-08T22:55:37Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I believe these are all gone.",
          "createdAt": "2018-05-08T22:55:37Z",
          "updatedAt": "2018-05-08T22:55:37Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWUyMjExMTYzNzA=",
      "title": "Explain why we're not using ZIP",
      "url": "https://github.com/WICG/webpackage/issues/45",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "We have some hints in https://w3ctag.github.io/packaging-on-the-web/#intro, but it's not complete, and it needs to appear in the local explainer, not something remote.\r\n\r\nOther considerations against zip:\r\n* We've seen vulnerabilities caused by validating one copy of a resource but using a different one. #41 will avoid this for the CBOR-based format.\r\n* Zip resources are identified by filename, which isn't the primary key of web resources.\r\n* Zip resources don't include response headers.\r\n* Lots of details in the [format](https://www.iana.org/assignments/media-types/application/zip) are archaic and wouldn't be used.\r\n\r\nWe should probably also list reasons in favor of re-using zip so that proponents know we've considered their arguments:\r\n* A huge number of other formats are based on zip, so we're unlikely to run into something we can't express.\r\n* Existing tools would be able to extract packages.",
      "createdAt": "2017-04-12T00:16:56Z",
      "updatedAt": "2019-05-13T16:53:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "should make sure that the fact that .zip has duplication of headers that can cause mismatch of local vs central headers is mentioned",
          "createdAt": "2017-05-30T17:13:11Z",
          "updatedAt": "2017-05-30T17:13:11Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "how many of these arguments also stand against lzo or lz4 or (best) zstd?\r\n\r\ni'd also be interested in seeing how much of the raging popular https://github.com/opencontainers/image-spec would make sense to use, vs how much doesn't match up?",
          "createdAt": "2017-10-05T03:31:31Z",
          "updatedAt": "2017-10-05T03:31:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@rektide I believe lzo, lz4, and zstd are better compression algorithms, and none of the arguments are about any quality issues in zip's compression, so ... all of them?\r\n\r\nI haven't looked through the opencontainers spec and will do so. Thanks for the pointer.",
          "createdAt": "2017-10-17T04:26:13Z",
          "updatedAt": "2017-10-17T04:26:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Now that I've skimmed https://github.com/opencontainers/image-spec, it seems mostly-inapplicable. https://github.com/opencontainers/image-spec/blob/master/layer.md doesn't appear to support [random access](https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-00#section-3.1.5) because it's a tar file. I'm having trouble finding the primary key of items in the image, but it seems like it's a path, contrary to https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-00#section-3.1.1.",
          "createdAt": "2017-12-12T21:54:08Z",
          "updatedAt": "2017-12-12T21:54:08Z"
        },
        {
          "author": "skhameneh",
          "authorAssociation": "NONE",
          "body": "lz4 preferred for speed, zstd preferred for ratio.\r\n\r\nI am working on a similar packaging format and have a working tool, see\r\nhttps://github.com/lbryio/lbry-format\r\n\r\nI am very interested in cross adoption, @jyasskin  \ud83d\ude03 ",
          "createdAt": "2019-01-15T20:22:46Z",
          "updatedAt": "2019-01-15T20:22:46Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUyMjE0NTk3NzY=",
      "title": "Consider switching to DER-encoded ASN.1",
      "url": "https://github.com/WICG/webpackage/issues/47",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I received feedback from some of our security people that [DER](https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf) is easier to parse securely than [CBOR](https://tools.ietf.org/html/rfc7049). I'm not 100% sure that's the right choice yet, so here are some pros and cons.\r\n\r\nDER Pro's:\r\n1. Much older, with security-hardened implementations in many languages. e.g. BoringSSL includes a library for memory-safe DER parsing. CBOR has [many implementations](http://cbor.io/impls.html), but they aren't hardened.\r\n1. Prefixing with the length in bytes makes it easier to skip unneeded items. CBOR can work around this by embedding things into bytestrings.\r\n1. Generic parsing has only 2 cases: Primitive, where the interpretation of the bytes depends on the tag, and Constructed, where the content bytes encode a sequence of items. CBOR has 8 cases: integer, string, array, map, tag, simple value, simple value in next byte, and float. This is primarily used to skip unknown fields in structures.\r\n\r\nCBOR Pro's:\r\n1. ~8 primitive types instead of 30+. We can subset ASN.1 to only use INTEGER, OCTET STRING, UTF8String, and SEQUENCE, but we can also subset CBOR to use integers, byte strings, text strings, arrays, and maps.\r\n1. Extensibility based on maps from strings to values is easier to understand and possibly to manage than ASN.1's extensibility based on appending to sequences. However, it's possible I've missed a better way to extend structures in ASN.1.\r\n1. It's easy to find the latest specification.\r\n1. Combining the length into the type saves a byte for smaller items.\r\n1. Serializing canonical CBOR, which is needed for signature checking, is significantly easier to implement.\r\n1. All DER integers and floats have to deal with the complexity of encoding bignums. For our purposes, where bignums aren't needed, CBOR's 8,16,32, and 64-bit integers are simpler. Even if bignums were needed, it's likely that a fixed length would be simpler to specify and implement than DER's variable-length encoding.\r\n\r\n\r\nIf we stick with CBOR, we'll mandate [Canonical CBOR](https://tools.ietf.org/html/rfc7049#section-3.9), which includes minimal integer encodings. That means offsets will need to measure a range that doesn't include the offset itself, but that's doable for both the section list and the resource index.\r\n\r\nI'll update this list as more considerations come up.",
      "createdAt": "2017-04-13T05:09:55Z",
      "updatedAt": "2019-05-13T16:54:03Z",
      "closedAt": "2019-05-13T16:54:03Z",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "You also have the fact that DER has been around a lot longer and there are\nmany implementations in many different languages.  As noted, it's undergone\na lot more scrutiny for security, etc.\n\nOn Thu, Apr 13, 2017 at 1:09 AM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> I received feedback from some of our security people that DER\n> <https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf> is\n> easier to parse securely than CBOR <https://tools.ietf.org/html/rfc7049>.\n> I'm not 100% sure that's the right choice yet, so here are some pros and\n> cons.\n>\n> DER Pro's:\n>\n>    1. BoringSSL includes a library for memory-safe DER parsing. We'd have\n>    to write our own for CBOR.\n>    2. Prefixing with the length in bytes makes it easier to skip unneeded\n>    items. CBOR can work around this by embedding everything into bytestrings.\n>    3. Generic parsing has only 2 cases: Primitive, where the\n>    interpretation of the bytes depends on the tag, and Constructed, where the\n>    content bytes encode a sequence of items. CBOR has 8 cases: integer,\n>    string, array, map, tag, simple value, simple value in next byte, and float.\n>\n> CBOR Pro's:\n>\n>    1. ~8 primitive types instead of 30+. However, I think we can subset\n>    ASN.1 to only use BOOLEAN, INTEGER, OCTET STRING, UTF8String, and SEQUENCE.\n>    2. Extensibility based on maps from strings to values is easier to\n>    understand and possibly to manage than ASN.1's extensibility based on\n>    appending to sequences. However, it's possible I've missed a better way to\n>    extend structures in ASN.1.\n>    3. It's easy to find the latest specification.\n>    4. Combining the length into the type saves a byte for smaller items.\n>\n> Even if we stick with CBOR, I'm inclined to mandate Canonical CBOR\n> <https://tools.ietf.org/html/rfc7049#section-3.9>, which includes minimal\n> integer encodings. That means offsets will need to measure a range that\n> doesn't include the offset itself, but I think that's doable for both the\n> section list and the resource index.\n>\n> I'll update this list as more considerations come up.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/47>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNayKVCul9V4IR7UQx3TT-M0eGBqRks5rva4jgaJpZM4M8Q7U>\n> .\n>\n",
          "createdAt": "2017-04-13T13:15:21Z",
          "updatedAt": "2017-04-13T13:15:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol Incorporated.",
          "createdAt": "2017-04-13T18:50:48Z",
          "updatedAt": "2017-04-13T18:50:48Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@hsivonen mentioned that CBOR doesn't define error handling: https://tools.ietf.org/html/rfc7049#section-3.3. Does DER? I think we absolutely do not want to introduce a new format in browsers without well-defined error handling. (And forking CBOR to add error handling reduces the utility of reusing it.)",
          "createdAt": "2018-01-26T07:34:19Z",
          "updatedAt": "2018-01-26T07:34:19Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@annevk https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf appears to be the spec for DER, and it only specifies how encoders must encode things, not how parsers decode or handle errors.\r\n\r\nI think the right place to specify error handling is the same places I'm currently requiring parsers to fail when an item wasn't encoded canonically. I should also be explicit that they must fail and return no data for invalid items.",
          "createdAt": "2018-01-26T23:26:53Z",
          "updatedAt": "2018-01-26T23:26:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(DER parsers are supposed to reject non-canonical inputs, yes. That's the whole point of DER.)",
          "createdAt": "2018-01-26T23:56:55Z",
          "updatedAt": "2018-01-26T23:56:55Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm inclined to stick with CBOR. It seems noticeably simpler than DER for both the encoder and decoder, even if I try to subset DER, and I'm not confident I understand ASN.1 well enough to subset it.",
          "createdAt": "2018-01-29T04:53:30Z",
          "updatedAt": "2018-01-29T04:53:30Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "As an implementer, I'd also like to vote on using CBOR. The CBOR format was so simple and obvious to implement.\r\nre: error handling, I found the simple \"reject any non-canonical input\" to be enough to clarify the implementation.\r\nIn addition, Chromium already has a fuzz-tested CBOR encoder/decoder (for prior use-case in [Web Authentication](https://www.w3.org/TR/webauthn/)).",
          "createdAt": "2018-01-29T05:30:37Z",
          "updatedAt": "2018-01-29T05:30:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Chromium had a fuzz-tested DER encoder/decoder for much much longer by way of X.509. :-P In an ideal world, both Web Authentication and Web Packaging would use DER, as browsers already must parse that securely and pay for in binary size, but alas, since Web Authentication already messed up, we're stuck paying for both and either is probably fine.\r\n\r\n(I haven't looked closely at CBOR. DER has a critical nice property that it can be parsed without any allocations with a purely StringPiece-like API. If CBOR does not have this property, do not use it.)",
          "createdAt": "2018-01-29T06:11:58Z",
          "updatedAt": "2018-01-29T06:15:56Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@nyaxt it's unclear to me whether that is enough to lead to fully interoperable implementations. It also means that you cannot use any generic CBOR parser if you want interoperability.",
          "createdAt": "2018-01-29T06:47:18Z",
          "updatedAt": "2018-01-29T06:47:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "To be fair, a lot of existing DER parsers are buggy and accept all or bits of BER as well. The good ones only accept DER, but there are a lot of bad ones.",
          "createdAt": "2018-01-29T07:14:06Z",
          "updatedAt": "2018-01-29T07:14:06Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@annevk The IETF is working on a CBORbis at https://github.com/cbor-wg/CBORbis. I'll send them a patch to try to tighten up the error handling. It's still likely to have more than one option, like UTF-8 does.",
          "createdAt": "2018-01-29T18:59:36Z",
          "updatedAt": "2018-01-29T18:59:36Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@jyasskin UTF-8 on the web doesn't (and note that too has been very problematic, a costly endavor, and not without security consequences).",
          "createdAt": "2018-01-30T07:40:50Z",
          "updatedAt": "2018-01-30T07:40:50Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWUyMjIyNDY2NDE=",
      "title": "In links to packages, consider srcset-type mechanism",
      "url": "https://github.com/WICG/webpackage/issues/48",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "In whatever mechanism we use to offer a package to a browser, we should think about allowing browsers to choose optimized packages for their situations. There could be a fully-general package that includes many sizes of images that'll appear optimally on any device, but also a small-screen version of the same package that omits the high-resolution images entirely. There could also be other axes than screen size, along the lines of https://github.com/spanicker/device-ram.\r\n\r\nThis introduces some complications around having multiple different resources signed for the same URL. Normally, we could resolve such conflicts by just using the latest such resource, but it's possible that's one optimized for smaller screens than the current device.\r\n\r\nThis is not a v1 consideration.",
      "createdAt": "2017-04-17T22:14:56Z",
      "updatedAt": "2019-05-13T17:01:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Depends on #40.",
          "createdAt": "2019-05-13T17:01:55Z",
          "updatedAt": "2019-05-13T17:01:55Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWUyMjc4MDc4Mjg=",
      "title": "Look into Macaroons for cross-signing",
      "url": "https://github.com/WICG/webpackage/issues/52",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "https://research.google.com/pubs/pub41892.html describes a way to grant capabilities in a way the receiver can attenuate and pass on. We're thinking of having authorities counter-sign packages in order to say, for example, that FooCorp trusts this package to `fetch()` from internal systems. Maybe macaroons are a better way to express this.",
      "createdAt": "2017-05-10T20:55:44Z",
      "updatedAt": "2019-05-13T16:55:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Also https://arxiv.org/pdf/1607.02192.pdf.",
          "createdAt": "2017-05-26T15:37:57Z",
          "updatedAt": "2017-05-26T15:37:57Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWUyMzEwNDA4NDE=",
      "title": "Documenting webpackage tools",
      "url": "https://github.com/WICG/webpackage/issues/57",
      "state": "OPEN",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [
        "nyaxt"
      ],
      "labels": [
        "documentation"
      ],
      "body": "Having some minimal documentation for webpack would be helpful for those of us not fluent in Golang. ",
      "createdAt": "2017-05-24T13:31:41Z",
      "updatedAt": "2019-05-13T16:58:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "You're looking for documentation on the tool in https://github.com/dimich-g/webpackage/tree/master/go/webpack/cmd/wpktext2cbor, right? Yep, I should write some, but it'll probably come behind some more elaboration of the loading model.",
          "createdAt": "2017-05-26T15:37:30Z",
          "updatedAt": "2017-05-26T15:37:30Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "make sure to call it Webpackage, https://github.com/webpack is already a very large ecosystem for the web",
          "createdAt": "2017-05-30T17:11:19Z",
          "updatedAt": "2017-05-30T17:11:19Z"
        },
        {
          "author": "TheLarkInn",
          "authorAssociation": "NONE",
          "body": "Yes please!! \u2665\ufe0f",
          "createdAt": "2017-06-02T20:26:29Z",
          "updatedAt": "2017-06-02T20:26:29Z"
        },
        {
          "author": "dauwhe",
          "authorAssociation": "NONE",
          "body": "A few notes on my initial experiences with the tool:\r\n\r\n1. In the [Readme](https://github.com/WICG/webpackage/blob/master/README.md), the command `go install github.com/WICG/webpackage/tree/internet-draft/go/webpack/cmd/wpktext2cbor` didn't work for me. At least when downloading the master branch here, I had a path closer to `github.com/WICG/webpackage/go/webpack/cmd/wpktext2cbor`, and for some reason I had to go into the webpack directory and do `go install ./...`. \r\n\r\n2. The `wpktext2cbor` takes two parameters. `-i` points to a \"manifest*\" file (not the web app manifest!), with format like\r\n\r\n```\r\n[Content]\r\nhttps://dauwhe.github.io/html-first/MobyDickNav/index.html\r\n\r\n200\r\nContent-Type: text/html\r\nDate: Wed, 15 Nov 2016 06:25:24 GMT\r\nExpires: Mon, 01 Jan 2018 16:00:00 GMT\r\n\r\nMobyDickNav/index.html\r\n\r\nhttps://dauwhe.github.io/html-first/MobyDickNav/html/cover.html\r\n\r\n200\r\nContent-Type: text/html\r\nDate: Wed, 15 Nov 2016 06:25:24 GMT\r\nExpires: Mon, 01 Jan 2018 16:00:00 GMT\r\n\r\nMobyDickNav/html/cover.html\r\n```\r\nAnd for us HTML/XML folks, the line breaks are important :) Then the `-o` option points to the package file you want to create. \r\n\r\n3. So far I can't get the package signing to work\u2014I get the same resulting package whether or not I have a `[manifest]` section in the \u201cmanifest,\u201d even when using the samples in this repo. I'll keep trying.\r\n\r\n4. I found [these tools](https://github.com/cabo/cbor-diag) to be helpful when playing around with this stuff, especially `cbor2diag.rb`. \r\n\r\n5. As a tip for the exceedingly ignorant, like myself, the `hpackdec` tool takes the hpack-encoded headers (in hex, which you can get from the .wpk file by using the aforementioned `cbor2diag.rb`) and converts them back to \"English\":\r\n\r\n```\r\ncramerd$ bin/hpackdec 885F87497CA589D34D1F6196E4593E940B6A693F750400B8A01CB826EE09A53168DF6496DF3DBF4A002A651D4A08017540B97000B800298B46FF\r\n:status: 200\r\ncontent-type: text/html\r\ndate: Wed, 15 Nov 2016 06:25:24 GMT\r\nexpires: Thu, 01 Jan 2017 16:00:00 GMT\r\ncramerd$\r\n```\r\n\r\nNow I just have to teach a service worker to do all this stuff :)",
          "createdAt": "2017-09-12T02:15:02Z",
          "updatedAt": "2017-09-12T02:15:02Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@nyaxt, could you find someone to own documentation for the tools, or decide they're already documented enough?",
          "createdAt": "2019-05-13T16:57:26Z",
          "updatedAt": "2019-05-13T16:57:26Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWUyMzE2NzAwNDg=",
      "title": "Figure out how to identify signing algorithms",
      "url": "https://github.com/WICG/webpackage/issues/58",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Options:\r\n1. [TLS 1.3 SignatureScheme](https://tlswg.github.io/tls13-spec/#rfc.section.4.2.3) codes.\r\n2. <strike>[JWS algorithm names](https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms).</strike> (I have advice to avoid these.)\r\n3. RFC5280's [AlgorithmIdentifier](https://tools.ietf.org/html/rfc5280#section-4.1.1.2) used in certificates.\r\n4. Define a mapping from the certificate's public key to a signature algorithm. This is easy for ECDSA and EdDSA keys, but would need work for RSA keys. Straw man: <=3072 bits gets rsa_pss_sha256, and >=3073 gets rsa_pss_sha384.\r\n\r\nIn some cases, like TLS' [ecdsa_secp256r1_sha256](https://tlswg.github.io/tls13-spec/#rfc.section.4.2.3) vs JWS' [ES256](https://tools.ietf.org/html/rfc7518#section-3.4), even though the algorithm is the same, the signature appears in different formats.\r\n\r\nAny of these options is sufficient to let us sign with any TLS certificate, but TLS doesn't yet have identifiers for post-quantum signature schemes that counter-signatures might want to use.\r\n\r\n",
      "createdAt": "2017-05-26T16:08:27Z",
      "updatedAt": "2017-06-17T04:31:32Z",
      "closedAt": "2017-06-17T04:31:32Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Crypto folks seem to strongly prefer Option 4.",
          "createdAt": "2017-05-26T16:42:28Z",
          "updatedAt": "2017-05-26T16:42:28Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "How would you use a TLS cert to sign \"code\" or content, which is what you\ndoing here?  It's not really what a TLS cert is supposed to be used for.\nIt would also bind things to the domain and not necessary to the\nauthor/producer/publisher of the content.\n\nOn Fri, May 26, 2017 at 12:08 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Options:\n>\n>    1. TLS 1.3 SignatureScheme\n>    <https://tlswg.github.io/tls13-spec/#rfc.section.4.2.3> codes.\n>    2. JWS algorithm names\n>    <https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms>\n>    .\n>    3. RFC5280's AlgorithmIdentifier\n>    <https://tools.ietf.org/html/rfc5280#section-4.1.1.2> used in\n>    certificates.\n>    4. Define a mapping from the certificate's public key to a signature\n>    algorithm. This is easy for ECDSA and EdDSA keys, but would need work for\n>    RSA keys.\n>\n> In some cases, like TLS' ecdsa_secp256r1_sha256\n> <https://tlswg.github.io/tls13-spec/#rfc.section.4.2.3> vs JWS' ES256\n> <https://tools.ietf.org/html/rfc7518#section-3.4>, even though the\n> algorithm is the same, the signature appears in different formats.\n>\n> Any of these options is sufficient to let us sign with any TLS\n> certificate, but TLS and JWS don't yet have identifiers for post-quantum\n> signature schemes that counter-signatures might want to use.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/58>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNTPMmDx56DMBrcVcpUc4KSWV-W0Vks5r9vj7gaJpZM4NnyJ_>\n> .\n>\n",
          "createdAt": "2017-05-26T16:44:28Z",
          "updatedAt": "2017-05-26T16:44:28Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "For \"how\", see https://github.com/dimich-g/webpackage#manifest-signatures, which needs to be updated with the result of this issue.\r\n\r\nFrom talking to some security folks, it looks like it'll be safe enough to sign with a TLS cert if we also check for revocation and urgent package updates periodically. e.g. every 7 days would definitely be sufficient. I need to flesh that out in the explainer.\r\n\r\nYes, getting package content to be same-origin with a domain needs the signature to bind the content to the domain. It'll be possible to also counter-sign with extra certificates that might be attached to a real-world identity instead of a domain, and that's one reason I'm worried about certificate types that aren't supported by TLS.",
          "createdAt": "2017-05-26T16:51:49Z",
          "updatedAt": "2017-05-26T16:51:49Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "And for the specific use cases for web packages that you have today, I can\nsee that being sufficient.\n\nBut as we move things like PWP forward, it's not helpful there - as that\ncontent isn't bound to a domain, at least not by the author.  It could\npotentially be by a publisher, but then that limits the usefulness.\n\nOn Fri, May 26, 2017 at 12:51 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> For \"how\", see https://github.com/dimich-g/webpackage#manifest-signatures,\n> which needs to be updated with the result of this issue.\n>\n> From talking to some security folks, it looks like it'll be safe enough to\n> sign with a TLS cert if we also check for revocation and urgent package\n> updates periodically. e.g. every 7 days would definitely be sufficient. I\n> need to flesh that out in the explainer.\n>\n> Yes, getting package content to be same-origin with a domain needs the\n> signature to bind the content to the domain. It'll be possible to also\n> counter-sign with extra certificates that might be attached to a real-world\n> identity instead of a domain, and that's one reason I'm worried about\n> certificate types that aren't supported by TLS.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/58#issuecomment-304333036>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNSw764DyadWBG-pCHnGbWGtJSKGwks5r9wMlgaJpZM4NnyJ_>\n> .\n>\n",
          "createdAt": "2017-05-26T17:29:15Z",
          "updatedAt": "2017-05-26T17:29:15Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWUyMzE3MDE0MDg=",
      "title": "Describe how to check for revocation and downgrades when loading a package",
      "url": "https://github.com/WICG/webpackage/issues/59",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The sketch, which I've run by @sleevi, is:\r\n1. Check the manifest's signature and that the signing certificate is for the package's claimed origin and that it chains to a trusted root, using intermediate certificates included in the package.\r\n2. Each package also has an accompanying set of OCSP responses and anti-downgrade information.\r\n3. The UA checks that the OCSP responses are signed by the certificate's signer and were generated less than 7 days ago.\r\n4. The UA checks that the anti-downgrade information is signed by a certificate trusted for package's origin (potentially taking advantage of the package's intermediate certs), hasn't expired yet and was signed less than 7 days ago, and says that the package's date is sufficiently recent.\r\n5. If any of this isn't recent enough, the package identifies a URL from which to fetch newer validity information. This validity information is small (<1kb?), so it should be cheap enough to fetch even when full packages are too expensive.\r\n\r\nThere's some evidence that we'll still have a significant number of UAs that are fully offline and won't be able to fetch new validity information every week. Depending on the existing HTTP cache's behavior, maybe we don't need to revalidate once we've opened a package once. Maybe it's ok to trust older validations as long as the package doesn't make any network requests, and have revalidation block the package's first network request when the UA gets back online. We'll need to decide what to do about local storage if that validation fails.\r\n\r\nI need to add this to the main explainer.",
      "createdAt": "2017-05-26T18:25:20Z",
      "updatedAt": "2018-01-26T23:53:37Z",
      "closedAt": "2018-01-26T23:53:37Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "As long as it is an explainer (SHOULD not MUST) +1",
          "createdAt": "2017-07-31T15:53:43Z",
          "updatedAt": "2017-07-31T15:53:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is now in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity. It *is* a bunch of MUSTs. I'm tracking one need to loosen those up in #117. @bmeck, could you file any others you know about?",
          "createdAt": "2018-01-26T23:53:37Z",
          "updatedAt": "2018-01-26T23:53:37Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWUyMzQ5ODE1NTk=",
      "title": "Look into Merkle trees for quick access to parts of large resources",
      "url": "https://github.com/WICG/webpackage/issues/69",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "For example, we might want to be able to start playing a large video file without hashing the whole thing.\r\n\r\nSee https://tools.ietf.org/html/draft-thomson-http-mice for one approach.",
      "createdAt": "2017-06-10T05:26:16Z",
      "updatedAt": "2018-01-24T18:39:54Z",
      "closedAt": "2018-01-24T18:39:34Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "can you clarify? we aren't encoding the resource so random access should work. Or are you talking about allowing integrity checks on ranges within a resource?",
          "createdAt": "2017-06-21T19:17:23Z",
          "updatedAt": "2017-06-21T19:17:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Allowing integrity checks on ranges within a resource.",
          "createdAt": "2017-07-06T17:38:48Z",
          "updatedAt": "2017-07-06T17:38:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#108 defined a generic way to identify a header that guards the content. The `MI` header from [draft-thomson-http-mice](https://tools.ietf.org/html/draft-thomson-http-mice) then provides incremental integrity for the beginning of a resource, and when there's a demonstrated need we can define another header or content encoding within the `MI` header that uses a balanced Merkle tree for random access integrity checks.",
          "createdAt": "2018-01-24T18:39:34Z",
          "updatedAt": "2018-01-24T18:39:54Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWUyMzQ5ODE2MzI=",
      "title": "Do we need the :method header?",
      "url": "https://github.com/WICG/webpackage/issues/70",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "https://github.com/WICG/webpackage/pull/60#discussion_r121227994 points out that we might not want to store the [`:method` header](http://httpwg.org/specs/rfc7540.html#HttpRequest) in requests. We only know of uses of `GET` requests, and having the ability to code other methods might cause bugs.",
      "createdAt": "2017-06-10T05:27:22Z",
      "updatedAt": "2019-11-13T16:28:57Z",
      "closedAt": "2019-01-18T21:20:32Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I vote it is uneeded.",
          "createdAt": "2017-06-21T16:35:12Z",
          "updatedAt": "2017-06-21T16:35:12Z"
        },
        {
          "author": "ibnesayeed",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From an archival perspective it might be important to keep it. Also, apart from `GET` there are other methods that might be useful, such as, `HEAD` and `OPTIONS` or any other methods that do not change the state of the resource.",
          "createdAt": "2018-01-10T02:24:35Z",
          "updatedAt": "2018-01-10T02:24:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We'd already restricted the method to be [safe](https://tools.ietf.org/html/rfc7231#section-4.2.1) and [cacheable] (https://tools.ietf.org/html/rfc7231#section-4.2.3). Since the creation of HTTP, only GET and HEAD have met those requirements, and HEAD responses can be synthesized from a stored GET response. So #360 is dropping the `:method` field (since it would be the only remaining field in the request map).",
          "createdAt": "2019-01-03T21:26:23Z",
          "updatedAt": "2019-01-03T21:26:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#360 is merged. If a particular archival use case comes up, we can reopen the question.",
          "createdAt": "2019-01-18T21:20:32Z",
          "updatedAt": "2019-01-18T21:20:32Z"
        },
        {
          "author": "ibnesayeed",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin do we have a way to support `OPTIONS` request without this header? If not, then how will the CORS requests work that need pre-flight requests?",
          "createdAt": "2019-11-13T16:28:57Z",
          "updatedAt": "2019-11-13T16:28:57Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWUyMzU3MDkxMTE=",
      "title": "Start an internet-draft",
      "url": "https://github.com/WICG/webpackage/issues/71",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "This supports the [IETF submission](https://mailarchive.ietf.org/arch/msg/dispatch/NQ0deHSsRvt4BL4alk_WYVnhhvo). It has to happen before they close the RFC database from July 3 until the [Prague meeting](http://ietf.org/meeting/99/index.html).\r\n\r\nWe can use https://github.com/cabo/kramdown-rfc2629 to author in markdown, and https://github.com/martinthomson/i-d-template to build with Travis CI.",
      "createdAt": "2017-06-13T22:16:28Z",
      "updatedAt": "2017-08-14T23:58:02Z",
      "closedAt": "2017-08-14T23:58:02Z",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin can you explain why you want to have this work happen through IETF instead of W3C? ",
          "createdAt": "2017-06-23T13:00:36Z",
          "updatedAt": "2017-06-23T13:00:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol The IETF has way more expertise developing file formats than the W3C. One can even think of the packaging format as a transport protocol with particular constraints on the connection, which is squarely in the IETF's domain.\r\n\r\nThat said, the W3C is definitely the right place to specify how browsers load the format, and, for publications, how publication-readers load it, which could be different from browsers. I expect to have 2+ specifications as a result: one in the IETF, and one or more in the W3C and maybe elsewhere.",
          "createdAt": "2017-06-26T04:26:26Z",
          "updatedAt": "2017-06-26T04:26:26Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin Historically, I would agree with you about that. However, with the IETF (which has over a decade) of packaging and format experience joining the W3C this year, you now have a group of people who not only have the knowledge *but* are also engaged to this work.  I am not sure that the IETF folks will be as engaged.  In a related bit, I would think that having the browser vendors at the W3C aligning on the format as a \"web archive\" would be a win.\r\n\r\nI would strongly prefer that we keep the entire thing, but broken into separate work items as you suggest, would be best.",
          "createdAt": "2017-06-26T14:15:27Z",
          "updatedAt": "2017-06-26T14:15:27Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWUyMzU3NTU4OTA=",
      "title": "Test each kind of private key",
      "url": "https://github.com/WICG/webpackage/issues/72",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "[example.com.key](https://github.com/WICG/webpackage/tree/master/go/webpack/testdata/pki/example.com.key) is currently a secp256r1 key, but we should also test creating packages for each of:\r\n* RSA <= 3072 bits\r\n* RSA with 3073-7680 bits (probably 4096)\r\n* secp384r1\r\n* secp521r1\r\n\r\nI'll probably create the keys for `rsa2048.example.com`, `secp521r1.example.com`, etc.",
      "createdAt": "2017-06-14T03:56:27Z",
      "updatedAt": "2019-05-13T16:59:18Z",
      "closedAt": "2019-05-13T16:59:18Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The other key types are no longer allowed.",
          "createdAt": "2019-05-13T16:59:18Z",
          "updatedAt": "2019-05-13T16:59:18Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWUyMzc2NTg5MTY=",
      "title": "HTML integration",
      "url": "https://github.com/WICG/webpackage/issues/73",
      "state": "CLOSED",
      "author": "matthewp",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello, is it within the scope to define (or speculate) on how a person might load a webpackage in an HTML document, and what the browser should do when it unpacks a package?\r\n\r\nOr is the idea that a document might request `GET /app.js` (from a script tag) and the server would reply with a webpackage, making any other resources that are later requested come from that package?\r\n\r\nThanks!",
      "createdAt": "2017-06-21T20:44:32Z",
      "updatedAt": "2017-08-10T22:52:10Z",
      "closedAt": "2017-08-09T14:45:56Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yes, that's in scope. That's probably the main subject of the specification that'll go through the W3C.",
          "createdAt": "2017-06-26T04:27:54Z",
          "updatedAt": "2017-06-26T04:27:54Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "In the history of this, the idea was WebPackage is a cache filling mechanism. So I would presume (don't count it as truth) that all environments using WebPackage including HTML would accept any request responding with WebPackage appropriately to fill things out.\r\n\r\nFor Node, that is with a file extension.\r\nFor Web, that is with a MIME Type.\r\n\r\nSo, if `./app.js` in Web returns a Webpackage we have a slight problem. `type=module` does not do aliasing for paths so Webpackage would need to declare a `main` field somewhere I would presume. For Node it follows the standard resolution, but that resolution is problematic for Web since it requires resolution with IO involved.\r\n\r\nI would go through WHATWG/W3C for figuring that out.",
          "createdAt": "2017-06-29T14:02:03Z",
          "updatedAt": "2017-06-29T14:02:03Z"
        },
        {
          "author": "matthewp",
          "authorAssociation": "NONE",
          "body": "Going to close as whatwg will likely define this.",
          "createdAt": "2017-08-09T14:45:56Z",
          "updatedAt": "2017-08-09T14:45:56Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Well, the WHATWG will only define this if our work in this repository results in a proposal to them. I'm working on writing one, so it's fine to have closed this issue, but I'll want reviewers when I send the PR.",
          "createdAt": "2017-08-10T22:15:40Z",
          "updatedAt": "2017-08-10T22:15:40Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Ill be at the ready\n\nOn Aug 10, 2017 5:15 PM, \"Jeffrey Yasskin\" <notifications@github.com> wrote:\n\n> Well, the WHATWG will only define this if our work in this repository\n> results in a proposal to them. I'm working on writing one, so it's fine to\n> have closed this issue, but I'll want reviewers when I send the PR.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/73#issuecomment-321688195>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AAOUo6bBFED7TJxK4l8wNXI06LaJIV6Wks5sW4ENgaJpZM4OBfql>\n> .\n>\n",
          "createdAt": "2017-08-10T22:52:10Z",
          "updatedAt": "2017-08-10T22:52:10Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWUyMzg0NDAzODA=",
      "title": "Be clearer that the TAG's proposal is very out of date.",
      "url": "https://github.com/WICG/webpackage/issues/74",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The link to https://w3ctag.github.io/packaging-on-the-web/ at the beginning of the explainer needs to say clearly that it's been superseded.",
      "createdAt": "2017-06-26T04:43:18Z",
      "updatedAt": "2018-01-24T18:36:30Z",
      "closedAt": "2018-01-24T18:36:30Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #77.",
          "createdAt": "2018-01-24T18:36:30Z",
          "updatedAt": "2018-01-24T18:36:30Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWUyMzk2OTc1OTE=",
      "title": "Please do not use abbreviation PWA for Portable Web Applications",
      "url": "https://github.com/WICG/webpackage/issues/75",
      "state": "CLOSED",
      "author": "kenchris",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I saw this in your slides and that abbreviation is already quite commonly used for Progressive Web Apps.",
      "createdAt": "2017-06-30T07:22:50Z",
      "updatedAt": "2018-01-24T18:35:26Z",
      "closedAt": "2018-01-24T18:35:26Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "What slides? I believe we're always using PWA to mean \"Progressive Web App\".",
          "createdAt": "2017-06-30T14:09:57Z",
          "updatedAt": "2017-06-30T14:09:57Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "MDU6SXNzdWUyNDA3MTc0ODM=",
      "title": "Look at using CMS or S/MIME for signatures",
      "url": "https://github.com/WICG/webpackage/issues/78",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In response to https://tools.ietf.org/html/draft-yasskin-dispatch-web-packaging-00, [Paul Hoffman](https://icannwiki.org/Paul_Hoffman) suggested, if I'm understanding his email correctly, that we replace the [signed-manifest item](https://tools.ietf.org/html/draft-yasskin-dispatch-web-packaging-00#section-2.4) that wraps the manifest, with a CMS or possibly S/MIME document that wraps the manifest.\r\n\r\nBecause CMS is an ASN.1 format, I think we'd want to accept #47, switching the overall format to DER-encoded ASN.1, first.\r\n\r\n[CMS](https://tools.ietf.org/html/rfc5652#section-5) is fairly complicated, so Adam Langley suggests that we pick a precise subset and mandate that in the packaging format, rather than allowing all the flexibility in the original standard. For example, instead of allowing arbitrary `RevocationInfoChoice`s, we might specify that the `SignedData.crls` field be filled with exactly one OCSP response. The result could still be parsed with CMS tools, but it could also be parsed with much simpler package-specific tools.\r\n\r\nI suspect we'll run into some trouble around the `SignerInfo.*algorithm` fields: the current format specifies exactly one digest+signature algorithm for each possible certificate type, and doesn't encode that algorithm into the serialized bytes. CMS appears to allow the attacker to select the algorithms, just like [JOSE](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/). A package-specific parser would enforce the restriction, but a generic CMS tool wouldn't, and so would be vulnerable to the same attacks as JOSE. That's a reason to use a non-CMS format, to disallow generic tools from parsing package signatures.",
      "createdAt": "2017-07-05T17:11:00Z",
      "updatedAt": "2019-05-13T16:59:42Z",
      "closedAt": "2019-05-13T16:59:41Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We'll stick with our current signatures.",
          "createdAt": "2019-05-13T16:59:41Z",
          "updatedAt": "2019-05-13T16:59:41Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWUyNDM4NTMxNTg=",
      "title": "Study the openZIM format",
      "url": "https://github.com/WICG/webpackage/issues/79",
      "state": "CLOSED",
      "author": "kelson42",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I kind of wonder why the ZIM format seems not to have been studied properly? Even if the format is not so rigorously documented and still lacks a few tools around it, this is probably the most used web content offline distribution file format.\r\n\r\nGeneral purpose web sites:\r\n* http://www.openzim.org/\r\n* http://www.kiwix.org/\r\n\r\nFor developers:\r\n* https://github.com/openzim/\r\n* https://github.com/kiwix/",
      "createdAt": "2017-07-18T21:12:46Z",
      "updatedAt": "2019-05-13T17:09:21Z",
      "closedAt": "2019-05-13T17:00:01Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@kelson42 can you define \"seems not to have been studied properly\"\r\n\r\nIt seems much more limited in capabilities / lacking signing / lacking requirements of things like Node.",
          "createdAt": "2017-07-31T15:57:04Z",
          "updatedAt": "2017-07-31T15:57:04Z"
        },
        {
          "author": "kelson42",
          "authorAssociation": "NONE",
          "body": "@bmeck \r\n\r\nIt's true about signing. That looks something relatively easy to specify and implement. Would make sense to make it on openzim side.\r\n\r\nWhat do you mean exactly about \"requirements of things like Node\". The README talks about self-exactracting things? Is that what you mean? If \"yes\", have you an extended explanation about the requirement?",
          "createdAt": "2017-07-31T16:10:09Z",
          "updatedAt": "2017-07-31T16:10:09Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Node constraints: https://github.com/WICG/webpackage/issues/33\r\n\r\nOther things like supporting `link:`/`transfer-encoding:`/`cache-control:`/`expires:` style metadata and subpackages were the main things when commenting on limited capabilities.",
          "createdAt": "2017-07-31T16:17:40Z",
          "updatedAt": "2017-07-31T16:17:40Z"
        },
        {
          "author": "kelson42",
          "authorAssociation": "NONE",
          "body": "@bmeck Thx for the confirmation about self-extracting, but I do not really understand how data package with self-extracting could be used a  standard. This will be de-facto designed for one system/arch. Do you have somewhere the use case? Why having the decompressor in the package is so important?",
          "createdAt": "2017-07-31T18:52:29Z",
          "updatedAt": "2017-07-31T18:52:29Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@kelson42 use case is to create single file executables (of which both Node and Electron are interested), moving it to the host env means variations on how such is performed and loss of interoperability. Node certainly can use other formats than WebPackage such as `.zip` and `.asar` already but those are not standardized and agreed upon.",
          "createdAt": "2017-07-31T19:43:18Z",
          "updatedAt": "2017-07-31T19:43:18Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks to the pointer to an existing format. You're right that I didn't study it when designing the packaging format. Looking at it now, I think the lack of signing prevents us from just adopting it. The rest of the format looks tailored to Wikipedia articles: is it being used for other kinds of websites as well?",
          "createdAt": "2017-07-31T22:38:15Z",
          "updatedAt": "2017-07-31T22:38:15Z"
        },
        {
          "author": "kelson42",
          "authorAssociation": "NONE",
          "body": "It is a bit late, but this is only for documentation:\r\n* The format does still not provide content signing. The ticket is here https://github.com/openzim/libzim/issues/40\r\n* The format is suited for any kind of static content, not only Wikipedia & co. We provide already a lot of different content see https://download.kiwix.org/zim/",
          "createdAt": "2019-05-13T17:09:21Z",
          "updatedAt": "2019-05-13T17:09:21Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWUyNjEzMDI1Mzk=",
      "title": "Noting open W3C TAG legacy issues",
      "url": "https://github.com/WICG/webpackage/issues/86",
      "state": "OPEN",
      "author": "torgo",
      "authorAssociation": "NONE",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "Hello web packaging fans - \r\n\r\nWe're just cleaning up issues in possibly obsolete repos under [our organization](github.com/w3ctag/) (W3CTAG). One of these documents was the original packaging on the web which has since been obsoleted by your work. However there are many open issues on our document and before we summarily closed them we wanted to alert you to these issues in case you wanted to bring any of them over into your issues list. Can you please have a look through [these issues](https://github.com/w3ctag/packaging-on-the-web/issues) and leave a note on each issue to let us know that it's OK to close it? If you do take one of them on as an issue, please leave a note including a link to your new issue.\r\n\r\nThanks,\r\nDan Appelquist\r\nCo-Chair, W3CTAG",
      "createdAt": "2017-09-28T12:36:00Z",
      "updatedAt": "2019-05-13T17:00:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWUyODQzNjcxNzk=",
      "title": "Hh",
      "url": "https://github.com/WICG/webpackage/issues/100",
      "state": "CLOSED",
      "author": "Sadlowski",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hnm",
      "createdAt": "2017-12-24T14:55:47Z",
      "updatedAt": "2017-12-24T15:30:17Z",
      "closedAt": "2017-12-24T15:30:17Z",
      "comments": []
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWUyODY5NjMyMDk=",
      "title": "will support packaging only subresource ?",
      "url": "https://github.com/WICG/webpackage/issues/101",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in ES modules, we need to fetch a lot of module files.\r\nincreasing requests cause a performance issue. ([10k 1kB load is 10 times slower than single 10MB load](https://docs.google.com/document/d/1ds9EEkcDGnt-iR8SAN-_7nsOfw7gsMfhZjzZ_QAIyjM/edit))\r\n\r\nh2 will reduce connection handshake/establish, but doesn't reduce request/response itself which browser handles inside.\r\n\r\nbut reducing files via bundling like webpack is less merit of es modules(ex caching etc). \r\n\r\nsame things happens for image. so we sometimes concatting them aka Sprite.\r\n\r\ncurrent spec seems packaging main-resource + sub-resource in 1 file.\r\nso if webpackage support or have candidate to package lot of resources into 1 package(not include main-resoruce) seems solve fetching performance problem.\r\nexpected behavior is fetching single response but unpackaging in browser and handling/caching like separated ESModules/ImageIcons/StyleSheets etc.",
      "createdAt": "2018-01-09T03:55:58Z",
      "updatedAt": "2018-02-13T06:06:33Z",
      "closedAt": "2018-02-13T06:06:33Z",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a use case I discussed with @jyasskin, @addyosmani and @patrickkettner.\r\n\r\nI think using webpackage as a bundling format is an interesting use case, and will provide the same compression benefits bundling currently provides without all its downsides. I think it can and should be addressed by these specifications, but will require some extra mechanisms to enable it.\r\n\r\nI guess the first step is to send out a PR outlining this use-case.",
          "createdAt": "2018-02-12T13:11:10Z",
          "updatedAt": "2018-02-12T13:11:10Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed a use case PR. Beyond that, we also need to define a mechanism that will let the browser:\r\n* Know that a package download is required\r\n* Know which resources are covered by a certain package, so that their requests won't race with the package's response. Such a mechanism can use some form of digest that will include all the URLs in the package and will be delivered with the \"package is required\" markup.\r\n\r\nStraw-man for such markup may look like:\r\n`<link rel=package href=\"js_bundle\" digest=\"bcfd23234989734abdcef\">`",
          "createdAt": "2018-02-12T13:57:17Z",
          "updatedAt": "2018-02-12T13:57:17Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "It's not only for esmodules but also image, style, font, favicon etc.\r\n\r\nI have 2 plan for this in my mind.\r\n\r\ndump them in rough.\r\n\r\n## `<package>` like `<picture>` way for selective `<img>`\r\n\r\nfor example\r\n\r\n```\r\n<package src=bundle.wpac>\r\n  <!-- backword compat for no-package -->\r\n  <script type=module src=react.js>\r\n  <script type=module src=moment.js>\r\n  <script type=module src=main.js>\r\n\r\n  <!-- backword compat for no-module -->\r\n  <script type=nomodule src=bundle.js>\r\n\r\n  <!-- css -->\r\n  <link rel=stylesheet href=bootstrap.css>\r\n  <link rel=stylesheet href=style.css>\r\n\r\n  <!-- favicon -->\r\n  <link rel=\"shortcut icon\" href=\"favicon.ico\">\r\n</package>\r\n```\r\n\r\nbrowser which support webpackaging fetches `<package>` resource.\r\n\r\n```\r\nGET /bundle.wpac HTTP/1.1\r\nAccept-Encoding: wpac\r\n```\r\n\r\nserver responses bundled.wpac\r\n\r\n```\r\nHTTP/1.1 200 OK\r\nContent-Encoding: wpac\r\n\r\npackaged all resouces\r\n```\r\n\r\nunpack them and treat each file as fetched via reach request\r\n\r\n\r\nin this time we have 2 consideration\r\n\r\n\r\n- what is cache time for wpac ?\r\n  - longest cache in package\r\n- what is the cache information for each modules ?\r\n  - wpac format should contain meta information about how long each modules could cache\r\n- browser should not always fetch bundle.wpac, how to decide ?\r\n  - while bundle.wpac cache is valid, fetch each files. if bundle.wpac cache is invalid, fetch bundle.wpac\r\n- what happen if bundle.wpac doesn't include `moment.js` ?\r\n  - fetch moment.js again according to `<script>`\r\n\r\n\r\nthis requires adding new tag `<package>` and adding meta information for packaging format.\r\n\r\n\r\n## Content-Encoding and 209 Already Respond\r\n\r\n\r\nbrowser requests\r\n\r\n```\r\nGET index.js HTTP/1.1\r\nAccept-Encoding: wpac\r\n\r\nGET moment.js HTTP/1.1\r\nAccept-Encoding: wpac\r\n\r\nGET bootstrap.css HTTP/1.1\r\nAccept-Encoding: wpac\r\n```\r\n\r\n\r\nbrowser sends accept encoding wpac so server can response in single pack.\r\n\r\nand server responses\r\n\r\n\r\n```\r\nHTTP/1.1 200 OK // for index.js session\r\nContent-Encoding: wpac\r\nPacked-Content: index.js\r\nPacked-Content: moment.js\r\nCache-Control: max-age=3600\r\n// wpac body\r\n\r\n\r\nHTTP/1.1 209 Already Respond // for moment.js session\r\nCache-Control: max-age=1024\r\n// empty body\r\n\r\nHTTP/1.1 209 Already Respond // for bootstrap.css\r\nCache-Control: max-age=3600\r\n// empty body\r\n```\r\n\r\n1st response include packaged resouces. browser unpack them in files which treat as they are respond in Status Code 200 each.\r\n\r\nif client already cached wpac, but only index.js is expired, request index.js only.\r\n\r\n\r\nin this case, client/server can handle via content-negotiation\r\nno adding semantics for html but need new response status code `209 Already Respond`\r\n\r\n- why Already Reponed\r\n  - need to close http session. but browser don't need to care much about response which already respond in Pack.\r\n- what is HTML look like ?\r\n  - as-is, content-negotiation is opt in.\r\n- what is in package ?\r\n  - server knows which is depended in index.js, so server can bundle them, and show them in Packed-Content header\r\n- what will happen in unsupported browser\r\n  - work as is",
          "createdAt": "2018-02-13T03:26:12Z",
          "updatedAt": "2018-02-13T03:26:12Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWUyODcwNjgyNDM=",
      "title": "Optionally check hashes of externally included packages",
      "url": "https://github.com/WICG/webpackage/issues/102",
      "state": "OPEN",
      "author": "HuangYuSan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "Scenario: Developer A includes a package from Developer B (e.g. a specific version of jQuery, or a hypothetical wasm implementation of python3) to serve the purpose of a shared library. This is loaded from a version-specific URL, say packages.jquery.com/v3-2-1, to ensure that A's app is running with the right version of jQuery or python that it was developed for. However, A has to trust the integrity of B and B's server to actually keep the resource static. B or any attacker on B's server has the power to inject malicious code into A's web app. This makes shared libraries impractical for security-critical applications. \r\n\r\nTo solve this problem, A links B's package with both a URL and a hash, which is checked by the client as soon as B's package is loaded (libraries are unlikely to need streaming). So A can have absolute confidence that their app uses the exact same version of the resource that it has been developed for, while keeping the benefits of shared library use.\r\n  ",
      "createdAt": "2018-01-09T12:13:24Z",
      "updatedAt": "2019-05-13T17:01:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Depends on #40.",
          "createdAt": "2019-05-13T17:01:45Z",
          "updatedAt": "2019-05-13T17:01:45Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUyODcxNzQ3MjU=",
      "title": "Clarify relationship with Publishing WG\u2019s Packaged Web Publications",
      "url": "https://github.com/WICG/webpackage/issues/103",
      "state": "CLOSED",
      "author": "js-choi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Several days ago, the [W3C Publishing WG published three working drafts][Publishing WG announcement], including [Packaged Web Publications][] (WPub/PWP), which defines a packaging format for combining collections of resources into a single portable WPUB file.\r\n\r\nThis WPub standard seem to be quite similar to this WICG\u2013IETF Web Packages (WPK) standard. But the relationship between the two is unclear.\r\n\r\nI could find some references to the Publishing WG here. [Web Packaging Format\u2019s use-cases note has a \u201cPackaged Web Publications\u201d][] in its \u201cNice-to-have\u201d section; it refers to the Publishing WG and discusses several abstract use cases provided by the WG, without actual reference to WPub as a specification. Several issues here (#3 \u201cRelationship to DPUB\u201d, #32 \u201cDocument Adobe\u2019s use cases\u201d, #37 \u201cAdd a list of goals and non-goals\u201d, #71 \u201cStart an internet-draft\u201d) also refer to the Publishing WG. Some Publishing WG members (@lrosenthol, @iherman, @dauwhe)  have participated in these issues.\r\n\r\nNone of these references talk about WPub as a separate specification, and none of them elaborate on its relationship with Web Packaging Format. Neither the [Web Packaging specification itself][] nor the [obsolete TAG Packaging on the Web draft](https://w3ctag.github.io/packaging-on-the-web/) make any mention of WPub either.\r\n\r\nThis is triply confusing. There is clear overlap between the two specifications\u2019 use cases. For instance, both initiatives appear to desire addressing Google AMP\u2019s use cases. Even their names are confusingly similar (WPK vs. PWP). Both are being actively developed\u2014there were even announcements regarding both on this same week (the [WPub public-draft announcement][Publishing WG announcement] and the [Google AMP Project\u2019s announcement on its transition to WPK][WPK for Google AMP]). And some of the same people have participated in both discussions on one standard and discussions on the other.\r\n\r\nFor readers of both specifications, it would be useful if their authors clarified this uncertainty. \u201cWhat is the relationship between the two standards?\u201d \u201cWhy are there two separate standards?\u201d \u201cHow are their use cases and file formats similar and different?\u201d Further active collaboration between the two specs\u2019 authors might also be worth pursuing. Though it might be too late for unification, it would be a shame if there was fragmentation of the same goal into two formats. Browser vendors are probably less likely to implement two formats than just one. On the other hand, if their use cases are irreconcilable, then that should be made explicit in the specifications.\r\n\r\n(Also cf. https://github.com/w3c/wpub/issues/5#issuecomment-314265230, https://github.com/w3c/wpub/issues/5#issuecomment-315076651 by @HadrienGardeur; as well as w3c/wpub#10, w3c/wpub#90, and w3c/wpub#111.)\r\n\r\n[Publishing WG announcement]: https://www.w3.org/blog/news/archives/6756\r\n\r\n[Packaged Web Publications]: https://www.w3.org/TR/2018/WD-pwpub-20180104\r\n\r\n[Web Packaging Format\u2019s use-cases note has a \u201cPackaged Web Publications\u201d]: https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#rfc.section.2.2.1\r\n\r\n[Web Packaging specification itself]: https://wicg.github.io/webpackage/draft-yasskin-dispatch-web-packaging.html\r\n\r\n[obsolete TAG Packaging on the Web draft]: https://w3ctag.github.io/packaging-on-the-web/\r\n\r\n[WPK for Google AMP]: https://amphtml.wordpress.com/2018/01/09/improving-urls-for-amp-pages/amp/\r\n  ",
      "createdAt": "2018-01-09T17:48:47Z",
      "updatedAt": "2018-01-09T21:57:43Z",
      "closedAt": "2018-01-09T21:57:43Z",
      "comments": [
        {
          "author": "js-choi",
          "authorAssociation": "NONE",
          "body": "I realized that it may be more appropriate to raise this issue in w3c/wpub, since WPub/PWP addresses more specific use cases than WPK does. I raised w3c/wpub#120 and will close this issue for now.",
          "createdAt": "2018-01-09T21:57:43Z",
          "updatedAt": "2018-01-09T21:57:43Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWUyODcxODg2MjY=",
      "title": "Capture sources of non-determinism",
      "url": "https://github.com/WICG/webpackage/issues/104",
      "state": "OPEN",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "Some of the suggested uses cases seem to require that sources of non-determinism (such as RNG seeds and the current time) are captured to ensure that, for example, saving and sharing a web page can occur with greater fidelity.",
      "createdAt": "2018-01-09T18:38:39Z",
      "updatedAt": "2019-05-13T17:02:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I suspect this will be a v2 feature if we decide to do it at all: overriding the behavior of JS APIs is orthogonal to a bunch of the other things involved in packaging, and pinning RNG seeds has some definite security implications.\r\n\r\n@dimich-g, you know more about the \"save and share\" use cases. Do you think this will turn out to be important?",
          "createdAt": "2018-01-09T22:41:21Z",
          "updatedAt": "2018-01-09T22:41:21Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWUyODcyNTM1MTM=",
      "title": "Archived / immutable content",
      "url": "https://github.com/WICG/webpackage/issues/105",
      "state": "CLOSED",
      "author": "craigfrancis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While some packages need to be kept up to date, and expired when they become too old; there are also things that should never expire/change.\r\n\r\nFor example the content of a webpage a user wants to keep, a report or invoice created by a website, etc (this is instead of using a PDF or MS Word document).\r\n\r\nSo would it be possible to skip the Expires header, and have some way of marking the package as immutable?\r\n\r\nThat immutable flag could also instruct the browser to never download any resources, and for the JS `Date` object to return a date/time based on the Date header from the package (not the current date/time)... may be related to issue #104?",
      "createdAt": "2018-01-09T22:31:52Z",
      "updatedAt": "2019-05-13T17:06:20Z",
      "closedAt": "2019-05-13T17:06:19Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "\"Archival\" makes me think of formats like [WARC](http://iipc.github.io/warc-specifications/specifications/warc-format/warc-1.1/), which we're not trying to compete with: they focus on recording the state of the web, while we're trying to distribute content to browsers.\r\n\r\nHowever, the rest of your comment looks like your use case is actually around saving a webpage for later personal use. Most of the need for expiration centers around preventing attackers from forging signatures or exploiting bugs, which isn't a risk for sites you've saved personally and don't distribute. We will support un-signed packages for this sort of thing, and there won't be anything forcing them to expire. Does that work for you?",
          "createdAt": "2018-01-09T22:46:36Z",
          "updatedAt": "2018-01-09T22:46:36Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "The [`cache-control: immutable` header](https://tools.ietf.org/html/rfc8246) also seems to follow that line of thought where it does have an expiration associated with it, even if it is immutable. I think saving from signed->unsigned seems a reasonable utility to have for most tools.",
          "createdAt": "2018-01-09T22:50:01Z",
          "updatedAt": "2018-01-09T22:50:01Z"
        },
        {
          "author": "TzviyaSiegman",
          "authorAssociation": "NONE",
          "body": "@prototypo Please see overlap with Archiving section (to come) in https://www.w3.org/TR/pwpub/",
          "createdAt": "2018-01-09T22:58:15Z",
          "updatedAt": "2018-01-09T22:58:15Z"
        },
        {
          "author": "ibnesayeed",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The web archiving community is [taking notice of it](https://twitter.com/anjacks0n/status/950861384266416134). While WARC works well for its purpose, it would be good to give some more thoughts on the archiving aspect, be it in the form of some possibility of transformation between webpackage and WARC or some other way to interoperate. WARC might want to store the whole package as an object or unpack it to store individual resources.",
          "createdAt": "2018-01-10T01:58:44Z",
          "updatedAt": "2018-01-10T01:58:44Z"
        },
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "@jyasskin, @TzviyaSiegman, I think there are similarities to Web Archive (WARC) and Packaged Web Publications (PWPUB); but I think the WebPackage format is slightly more appropriate for these document types:\r\n\r\n- Invoices.\r\n- Terms and conditions.\r\n- Contracts.\r\n- Reports, assessments, statistics.\r\n- Bank statements.\r\n- CVs.\r\n\r\nWhere these document (as packages) could then be easily downloaded, emailed, viewed any time, and kept/stored/archived - where [PDF files cause problems](https://github.com/craigfrancis/wdoc/blob/master/readme.md#justification).\r\n\r\nAnd I agree, these documents do not *need* to be signed by an origin, so un-signed packages would be a simple solution.\r\n\r\n----\r\n\r\nBut, just to think about it further... if it was possible for the WebPackage format to work with \"cache-control: immutable\", as per the suggestion by @bmeck, that could be a flag to show that a package can be kept indefinitely.\r\n\r\nAnd later (version 2?), that flag could be used to sign the content in a slightly different way - e.g. the Code Signing approach, where the Date recorded within the package is used instead of the current date, both when checking the certificate, but also when executing JavaScript (you don't want some JS hiding content based on the date/time).",
          "createdAt": "2018-01-10T14:43:49Z",
          "updatedAt": "2018-01-10T14:43:49Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "@craigfrancis according to https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#rfc.section.4.1 ,\r\n\r\n> Packages are designed to hold public information and to be shared to people with whom the original author never has an interactive connection. In that situation, there\u2019s no way to keep the contents confidential: even if they were encrypted, to make the data public, anyone would have to be able to get the decryption key.\r\n\r\nThat said, if the only data inside the bundle is encrypted data, your use cases of holding secure personal information in a webpackage could be possible. Just keep in mind that you're somewhat in the explicit \"non-goals\" area of webpackage.\r\n\r\nThat all said, as a developer I would definitely expect some means available to me to keep resources available from the page for a long long time. \"Immutable\" content sounds like something I'd want. I'd hope that existing HTTP headers would be sufficient to make this happen. Is there any behavior of `cache-control: immutable` that needs improvement?",
          "createdAt": "2018-01-25T04:03:00Z",
          "updatedAt": "2018-01-25T04:03:00Z"
        },
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "@rektide, thanks for the comment, but (fortunately) I\u2019ve no interest in the package being encrypted from a sensitive data / privacy point of view. I don\u2019t think that will be possible for this spec, as secret key management is tricky, and isn\u2019t covered at all in this case... you might be able to argue for password protected packages, but that would need to be considered another day, when the basic principle of archivable/immutable packages exist.\r\n\r\nFor now I think it should be up to the user to protect their sensitive documents, and if they decide to share their personal data (or whatever is in these archive-able packages), that will be their choice :-)\r\n\r\nAs to the immutable header, I hope it\u2019s possible in some way... where the browser *might* then be able to show that the package is unchanging (which is slightly different to how other non-immutable packages will work).",
          "createdAt": "2018-01-25T06:52:06Z",
          "updatedAt": "2018-01-25T06:52:06Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Closed by #137. ",
          "createdAt": "2019-05-13T17:06:19Z",
          "updatedAt": "2019-05-13T17:06:19Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWUyODcyOTQ1NDI=",
      "title": "Use-case: Service Worker cache population and synchronization",
      "url": "https://github.com/WICG/webpackage/issues/107",
      "state": "OPEN",
      "author": "ibnesayeed",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "feature request",
        "help wanted"
      ],
      "body": "If and when browser support for webpackage arrives, batch cache synchronization [1] or cache initialization [2] might be good use-cases, especially in the context of Service Worker. Using some sort of content negotiation mechanism, Service Worker might be able to ask the server for a webpackage that at least contains desired request URL(s). By unpacking the response and populating the cache, it can serve subsequent requests pretty quickly. What will be packed in the response is something that can be negotiated using some means or the server can decide as it does in case of HTTP/2 Server Hints (`prefetch`).\r\n\r\n[1] https://github.com/WICG/BackgroundSync\r\n[2] https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll",
      "createdAt": "2018-01-10T02:20:20Z",
      "updatedAt": "2019-05-13T17:07:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "Given the current spec, I would expect a developer to be able to create a page that:\r\n\r\n1. Receives a WebPackage\r\n2. Activates a ServiceWorker\r\n3. Has user code in the ServiceWorker that:\r\n3.a. Requests well known resources that it expects to be sourced from the WebPackage\r\n3.b. Puts those resources into the Cache\r\n\r\nWhat's tricky about this is that there needs to be some out-of-band transfer about which resources have been sent, as the ServiceWorker has to know which resources it can explicitly ask for, request the item, & put the item into the Cache.",
          "createdAt": "2018-01-25T03:31:40Z",
          "updatedAt": "2018-01-25T03:31:40Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm expecting that, when the browser loads a web package that either has a manifest identifying a service worker, or that is within scope of an existing service worker, the SW will get an event with the full contents of the package, so the SW can add it to its cache. I haven't started specifying this yet. PRs to add a [Bikeshed](https://tabatkins.github.io/bikeshed/) spec for the SW APIs are welcome if anyone wants to get to it first.",
          "createdAt": "2018-01-25T04:53:27Z",
          "updatedAt": "2018-01-25T04:53:27Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWUyOTE0MjY2NjA=",
      "title": "Officially rename webpackage to another name.",
      "url": "https://github.com/WICG/webpackage/issues/113",
      "state": "CLOSED",
      "author": "TheLarkInn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'd like to propose that we explore an alternative name for webpackage. Although [webpack](https://webpack.js.org/) is a separate tool in concerns of responsibilities from webpackage, I've already had a variety of confusion expressed from our userbase about what webpackage is and how it relates to webpack. \r\n\r\n\r\nMaybe some options: \r\n* WebParcel\r\n* WebZip\r\n* WebDistro\r\n\r\nMind you these are off the cuff, but I'd like to formally spin up the work involved to start exploring a replacement if there are no objections. ",
      "createdAt": "2018-01-25T02:10:19Z",
      "updatedAt": "2018-05-08T22:54:07Z",
      "closedAt": "2018-05-08T22:54:07Z",
      "comments": [
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "I can't think of a better alternative.\r\n\r\nKeep in mind that the spec needs magic-bytes. Any replacement candidate names OUGHT also have a fair and sensible set of magic bytes that emphasize the name. Anything not having good magic-bytes is, imho, a major downgrade in DX.",
          "createdAt": "2018-01-25T03:19:20Z",
          "updatedAt": "2018-01-25T03:19:20Z"
        },
        {
          "author": "TheLarkInn",
          "authorAssociation": "NONE",
          "body": "> spec needs magic-bytes\r\n\r\nWould you mind expanding on this? ",
          "createdAt": "2018-01-25T03:38:38Z",
          "updatedAt": "2018-01-25T03:38:38Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "> Would you mind expanding on this?\r\n\r\nThese magic-bytes are defined in https://tools.ietf.org/html/draft-yasskin-dispatch-web-packaging-00#section-2.2 .",
          "createdAt": "2018-01-25T03:50:33Z",
          "updatedAt": "2018-01-25T03:50:33Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is related to https://github.com/WICG/webpackage/issues/57#issuecomment-304945769, but thanks for filing an explicit issue about it.\r\n\r\nI've started calling the [bundling spec](https://github.com/WICG/webpackage/pull/98), well, \"bundling\" for lack of a better name, but WebParcel, WebZip, WebBundle, or some other name is fine with me. WebDistro reminds me a bit too much of Linux.\r\n\r\nI don't think there will be any trouble finding decent magic bytes for whatever we choose. Even if we keep the cute use of emoji, there are enough emoji to match almost anything.",
          "createdAt": "2018-01-25T04:36:55Z",
          "updatedAt": "2018-01-25T04:36:55Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "I don't super look forward to explaining to everyone that the name changed. That personally feels like a fright & complication I'd rather not deal with, & I personally would rather roll with it as is.\r\n\r\nWebBundle would be accurate though.",
          "createdAt": "2018-01-25T04:44:12Z",
          "updatedAt": "2018-01-25T04:44:12Z"
        },
        {
          "author": "TheLarkInn",
          "authorAssociation": "NONE",
          "body": "I guess my goal here is: \r\n\r\n**A name that doesn't include the following**: webpack, bundle, bundler, module bundler, etc.\r\n\r\n**Avoiding also**: Anything that could be confused with webpack, module bundler, rollup bundler, etc.\r\n\r\nUnless I've missed some recent changes to this spec, this is to describe a compression and peer to peer transfer/transmission protocol no? And not static bundling/compiling of web assets?\r\n",
          "createdAt": "2018-01-25T05:39:17Z",
          "updatedAt": "2018-01-25T05:39:47Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "If we're going no clash with anything at all, [Parcel](https://github.com/parcel-bundler/parcel) is out too.\r\n\r\nOf the original list, that leaves WebDistro (too linuxy) and WebZip (it's not a zip and that's confusing).\r\n\r\nAre we going to have to leave the visible spectrum to find a color we can paint this bikeshed?",
          "createdAt": "2018-01-25T06:29:42Z",
          "updatedAt": "2018-01-25T06:29:42Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Sean, it's a way to bundle web resources: a format containing an index, a\nmanifest and resources.\n\nWebwrap, Webcontainer, Webpacket?\n\nOn Thu, Jan 25, 2018, 3:29 PM rektide <notifications@github.com> wrote:\n\n> If we're going no clash with anything at all, Parcel\n> <https://github.com/parcel-bundler/parcel> is out too.\n>\n> Of the original list, that leaves WebDistro (too linuxy) and WebZip (it's\n> not a zip and that's confusing).\n>\n> Are we going to have to leave the visible spectrum to find a color we can\n> paint this bikeshed?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/113#issuecomment-360374038>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AGD3CtFA58rVoRnPsNwUCnNbuTZL5-qFks5tOB9XgaJpZM4RsOW8>\n> .\n>\n",
          "createdAt": "2018-01-25T12:00:26Z",
          "updatedAt": "2018-01-25T12:00:26Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there is a systematic way to go about the naming conflicts itself. Using a generic naming like \"Package\" or \"Bundle\" will always lead to conflicts. Certainly Web \"Animations\" and CSS \"Grid\" conflicted with another project here and there. The conflicts on the generic term cannot be avoided. This is where the \"Web\" prefix comes in. Being customary for modern web specs it disambiguates the generic term.\r\n\r\nNow, there is a special case, since webpack also uses the web prefix and hence there is genuine chance of confusion, especially given the similar domain that webpack and Web Packaging operate in (webpack would likely eventually become one of the most popular ways to make Web Packages).\r\n\r\nWith that I agree that \"Web Packaging\" should be reconsidered to avoid the confusion with \"webpack\" outlined above, but I'd not further constrain the namespace.\r\n\r\nGiven the current use of terminology in this project it seems to me like \"Web Bundle\" or \"Web Bundling\" seems like the most straightforward choice. ",
          "createdAt": "2018-01-25T14:49:57Z",
          "updatedAt": "2018-01-25T14:49:57Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "Wrap doesn't make intuitive sense to me. Container is hella over loaded. Packet is a weird clash with network layer, where packet is typically the smallest unit not a bundle of other things.",
          "createdAt": "2018-01-26T23:23:51Z",
          "updatedAt": "2018-01-26T23:23:51Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@TheLarkInn Do you still dislike names involving \"bundle\" given @cramforce's argument and the fact that the format in #98 is actually about static bundling of web assets?\r\n\r\nIt's likely that we'll be referring to this as \"the specifications formerly known as web packaging\" for a while, but since the specification has split anyway, and packaging was too associated with other complications in people's minds, I'm definitely in favor of calling the two halves something other than packaging.\r\n\r\nWe have roughly 2 categories of options:\r\n\r\n1. A purely descriptive name\r\n   1. WebBundle\r\n   1. WebZip: follows the precedent of things like 7zip and correctly implies that resources can be directly accessed without decompressing a prefix of the file.\r\n1. A made-up codename, which can avoid colliding with anything else. I don't have any good ideas here yet, but clever suggestions with good rationales could win out.\r\n\r\nI also want to be clear that I don't know who @rektide is, and while their suggestions are welcome, they're not going to determine the name.",
          "createdAt": "2018-01-26T23:43:58Z",
          "updatedAt": "2018-01-26T23:43:58Z"
        },
        {
          "author": "TheLarkInn",
          "authorAssociation": "NONE",
          "body": "I do like WebZip. It makes it very clear what is happening.\n\nOn Fri, Jan 26, 2018, 3:44 PM Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> @TheLarkInn <https://github.com/thelarkinn> Do you still dislike names\n> involving \"bundle\" given @cramforce <https://github.com/cramforce>'s\n> argument and the fact that the format in #98\n> <https://github.com/WICG/webpackage/pull/98> is actually about static\n> bundling of web assets?\n>\n> It's likely that we'll be referring to this as \"the specifications\n> formerly known as web packaging\" for a while, but since the specification\n> has split anyway, and packaging was too associated with other complications\n> in people's minds, I'm definitely in favor of calling the two halves\n> something other than packaging.\n>\n> We have roughly 2 categories of options:\n>\n>    1. A purely descriptive name\n>       1. WebBundle\n>       2. WebZip: follows the precedent of things like 7zip and correctly\n>       implies that resources can be directly accessed without decompressing a\n>       prefix of the file.\n>    2. A made-up codename, which can avoid colliding with anything else. I\n>    don't have any good ideas here yet, but clever suggestions with good\n>    rationales could win out.\n>\n> I also want to be clear that I don't know who @rektide\n> <https://github.com/rektide> is, and while their suggestions are welcome,\n> they're not going to determine the name.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/113#issuecomment-360935848>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ADQBMN-x7E0iTI0jdv_H2xuVIo7u0hFEks5tOmNAgaJpZM4RsOW8>\n> .\n>\n",
          "createdAt": "2018-01-27T12:38:04Z",
          "updatedAt": "2018-01-27T12:38:04Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "HTTP has a HPACK now.\r\nso I like WPACK for this.",
          "createdAt": "2018-01-29T06:31:59Z",
          "updatedAt": "2018-01-29T06:31:59Z"
        },
        {
          "author": "BigBlueHat",
          "authorAssociation": "NONE",
          "body": "> I do like WebZip. It makes it very clear what is happening.\r\n\r\nNot sure PKWARE would agree there... http://www.pkware.com/documents/casestudies/APPNOTE.TXT ...nor the ISO http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=60101\r\n\r\nAlso, WebBundle seems to be the most promising name (of the current list) so far, though HTTPack is maybe closest. \ud83d\ude04 ",
          "createdAt": "2018-02-02T21:39:57Z",
          "updatedAt": "2018-02-02T21:39:57Z"
        },
        {
          "author": "edwardkenfox",
          "authorAssociation": "NONE",
          "body": "I think webpackage is most straightforward, but also think WebBundle makes sense, too. I came up with \"Site Packaging\" as well as \"HTTP Container\" as alternatives, yet, thinking to myself \"HTTP Container\" sounds more of a low-level thing and might not suit the need for this. ",
          "createdAt": "2018-02-23T16:05:15Z",
          "updatedAt": "2018-02-24T00:18:06Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've been referring and getting others to refer to the components as \"Signed Exchanges\" and \"Bundles\", but the \"Web Packaging\" name for the overall project has enough mindshare, dating back to https://www.w3.org/TR/2015/WD-web-packaging-20150115/, that I don't think we can change it. The IETF is using the [\"wpack\"](https://www.ietf.org/mailman/listinfo/wpack) shorthand. All of this is close to \"webpack\", but it's not directly ambiguous, so I think it's the best we can do.",
          "createdAt": "2018-05-08T22:54:07Z",
          "updatedAt": "2018-05-08T22:54:07Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWUyOTE0NDE0ODc=",
      "title": "Use case: listing available content",
      "url": "https://github.com/WICG/webpackage/issues/114",
      "state": "CLOSED",
      "author": "rektide",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As a developer, it would be useful to be able to read what resources are in my own bundle.\r\n\r\nUse case example: I am writing a offline capable Zine webapp. I typically have a directory for each issue, and a number of html files in each directory corresponding to pages in my Zine. There is also a \"zine browser\" main interface that let's me pick which zine I want to read, or skip to pages, and the main interface knows what I was last reading. To let people share my zine, I create a webpackage of the client software, and a number of zine issues.\r\n\r\nDilemma: how does my main interface know what zines are available in the bundle?\r\n\r\nIdeally, as a developer, I could have the main-client reader able to ask- what resources do I already know about? Any zines in a webpackage ought to be able to present themselves to my main client, let it know: hey, there's content here.\r\n\r\nThis issue gets more pointed if users start collecting multiple webpackages, like if I release a new webpackage with new zines. Before- considering the case of only a single webpackage of main-client+zines- it would perhaps not be pleasant but it could be possible to build an index file into my webpackage that enumerates all the content. However when there are multiple webpackages available, it becomes outright impossible to work with this situation. The main-client will not have a way to figure out what is in other bundles.\r\n\r\nAn implementation of #107 would resolve this use case. If webpackage content were available via the page's Cache APIs then we could use `Cache.keys()` to discover the content.\r\n\r\nThere is a related problem in HTTP/2 PUSH, with not being able to detect content: whatwg/fetch#65. As a page, there's no way to detect resources that HTTP/2 PUSH has sent: once again the developer needs to create an out-of-band mechanism to ever be able to access the resource.\r\n\r\nI would like to see listing of at least same-origin content added to the use-cases. I hope this example of a Zine illustrates the need and how this capability would help. Thanks.",
      "createdAt": "2018-01-25T03:46:55Z",
      "updatedAt": "2019-05-13T17:07:40Z",
      "closedAt": "2019-05-13T17:07:40Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Probably a duplicate of #107.",
          "createdAt": "2019-05-13T17:07:40Z",
          "updatedAt": "2019-05-13T17:07:40Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWUyOTE1Mjk3NzA=",
      "title": "Loading",
      "url": "https://github.com/WICG/webpackage/issues/115",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The README suggests loading will be done at the W3C, which made me wonder. Shouldn't loading be integrated into Fetch somehow?",
      "createdAt": "2018-01-25T11:00:07Z",
      "updatedAt": "2018-01-30T00:46:19Z",
      "closedAt": "2018-01-30T00:46:19Z",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(This concern also applies to some extent to response header processing, which also takes place in Fetch and has been a source of confusion for IETF efforts as they don't carefully consider service workers, synthetic responses, etc.)",
          "createdAt": "2018-01-25T11:01:31Z",
          "updatedAt": "2018-01-25T11:01:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yes, and sorry for conflating the W3C and the WHATWG. I expect to do the initial web-side spec in the WICG, and then merge into Fetch, Service Workers, and whichever other web specs make sense, in those specs' organizations.",
          "createdAt": "2018-01-25T15:21:50Z",
          "updatedAt": "2018-01-25T15:21:50Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWUyOTIwNjYyNDg=",
      "title": "Address clients that are offline for long periods of time",
      "url": "https://github.com/WICG/webpackage/issues/117",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "architecture",
        "feature request",
        "help wanted"
      ],
      "body": "People with expensive data plans may run out of data early in a month, and not come back online until the next month. The 7-day validity limit in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity is good or even too long while online, but not enough while offline. We need to figure out if we can give clients permission to use expired signatures under certain circumstances, and if so, how to specify that.",
      "createdAt": "2018-01-26T23:53:10Z",
      "updatedAt": "2019-05-13T17:08:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Is the framing correct? It presumes it\u2019s desirable or even good for clients to use expired signatures, and it\u2019s just a matter of figuring out \u201chow.\u201d It seems the bigger question is whether that is a valid use case, given the security risks - with a perfectly acceptable answer being \u201cNo, this is not a valid use case.\u201d",
          "createdAt": "2018-01-26T23:58:28Z",
          "updatedAt": "2018-01-26T23:58:28Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi Yeah, good point. How's the new wording?",
          "createdAt": "2018-01-27T00:06:54Z",
          "updatedAt": "2018-01-27T00:06:54Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "\ud83d\udc4c\u2764\ufe0f",
          "createdAt": "2018-01-27T00:07:59Z",
          "updatedAt": "2018-01-27T00:07:59Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWUyOTg0OTU2Mzk=",
      "title": "gen-signedexchange should be able to capture arbitrary request/response HTTP headers.",
      "url": "https://github.com/WICG/webpackage/issues/124",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "Originally requested by @kinu.\r\n\r\nWe should be able to set arbitrary request/response HTTP headers to be captured in the generated signed exchange.\r\n```\r\n$ ./gen-signedexchange \\\r\n    -requestHeader \"Accept-Language: en\" \\\r\n    -responseHeader \"Server: Nginx\" \\\r\n    -responseHeader \"X-Frame-Options: Deny\"\r\n```\r\n\r\n@hajimehoshi Would you work on this?",
      "createdAt": "2018-02-20T07:30:56Z",
      "updatedAt": "2018-03-01T17:29:55Z",
      "closedAt": "2018-03-01T17:29:55Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking",
          "createdAt": "2018-02-21T07:20:49Z",
          "updatedAt": "2018-02-21T07:20:49Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWUzMDAxNjI5MDA=",
      "title": "http and P2p",
      "url": "https://github.com/WICG/webpackage/issues/128",
      "state": "CLOSED",
      "author": null,
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "With PWA's rise, there is allot of action going on with P2P. \r\nYour browser is almost a web server now.\r\nI am seeing so many different ways to do the security aspects for P2P. \r\nHTTPS is not designed to do P2P, so i wanted to raise this and se if there is any thoughts on this going forward.\r\n\r\nI am expected to be told that this aspect is not part of the \"WebPackage\" spec and probably rightly so.\r\nBut i am trying to find where people are trying things out using golang to try to use HTTPS and P2p.\r\n",
      "createdAt": "2018-02-26T09:27:12Z",
      "updatedAt": "2018-03-05T21:35:53Z",
      "closedAt": "2018-03-05T21:35:53Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Web packages would be good content to transfer peer-to-peer, but this repository won't define the Javascript API to actually make P2P connections. At one point Mozilla was working on https://flyweb.github.io/ to provide this kind of API, but I suspect they've abandoned it.",
          "createdAt": "2018-03-05T21:35:53Z",
          "updatedAt": "2018-03-05T21:35:53Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWUzMDAxOTA4OTU=",
      "title": "spelling nit",
      "url": "https://github.com/WICG/webpackage/issues/129",
      "state": "CLOSED",
      "author": "thiemonagel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It's \"Chrome OS\", not \"ChromeOS\".",
      "createdAt": "2018-02-26T10:51:09Z",
      "updatedAt": "2018-03-05T22:07:41Z",
      "closedAt": "2018-03-05T21:29:35Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2018-03-05T22:07:41Z",
          "updatedAt": "2018-03-05T22:07:41Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWUzMDI0NzU5MDg=",
      "title": "Update http-exchange format to improve security+reliability",
      "url": "https://github.com/WICG/webpackage/issues/135",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "@davidben points out that it's hard to write streaming parsers, and that the most reliable protocols send a number of bytes to read, read that number of bytes, and then use a non-streaming parser to pull information out of that contiguous data. The format in https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-03#section-5.3 doesn't accomplish this because CBOR items are prefixed by their length in items, not bytes.\r\n\r\nIn multi-process clients, we also want to allow the main/verification process to bound the amount of memory it uses. This implies (1) a length limit on the exchange header set, and (2) mandating use of the MI header instead of the Digest header to verify the payload authenticity, since MI has fixed-size records.\r\n\r\nFinally, it would be nice to be able to check signatures against the literal bytes in the http-exchange format instead of needing to reserialize. Reserialization still needs to be *possible* so that intermediates can receive a signature in a normal same-origin HTTP response and then produce the http-exchange format, but final clients shouldn't need to do it.\r\n\r\nThis probably means the format will move away from being a general http-exchange serialization format and toward being specific to signed exchanges. This has the extra benefit of not needing to say that request payloads and response trailers cause the signature not to verify.",
      "createdAt": "2018-03-05T21:46:20Z",
      "updatedAt": "2018-04-04T22:51:53Z",
      "closedAt": "2018-04-04T22:51:53Z",
      "comments": []
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWUzMDI2MDQ5MzM=",
      "title": "Remove Digest in favor of MI",
      "url": "https://github.com/WICG/webpackage/issues/138",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For DoS reasons, the low-level portions of the networking stack must never buffer memory unboundedly. That means the Digest option is not usable, unless we move the hash check to the higher-level portions, but integrity is handled in the low-level portions. This means the low-level portions must return data with a \"this is unchecked, please check it later\". This is a classic mistake in designing a crypto system. All in all, this means that it is unlikely that any implementation of Digest could pass muster in Chrome.\r\n\r\nAdditionally, adding random redundant options is generally a bad idea. There's no reason to offer Digest when MI suffices. Please remove Digest from the specification completely.",
      "createdAt": "2018-03-06T08:24:33Z",
      "updatedAt": "2018-05-01T23:45:19Z",
      "closedAt": "2018-05-01T23:45:19Z",
      "comments": []
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWUzMDMyMjQ4MzM=",
      "title": "Deal with clock skew",
      "url": "https://github.com/WICG/webpackage/issues/141",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "Our strictness in enforcing being within the 7-day signature validity period interacts badly with skewed clocks. Do we want to encourage signers to pre-date the signature's timestamp by X hours, or require clients to trust signatures that start being valid in X hours, or something else?",
      "createdAt": "2018-03-07T19:15:23Z",
      "updatedAt": "2019-05-13T17:09:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The spec currently says to [deal with clock skew in a particular way](https://wicg.github.io/webpackage/loading.html#validating-signature), but it's not obvious that's correct.",
          "createdAt": "2019-05-13T17:09:21Z",
          "updatedAt": "2019-05-13T17:09:21Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWUzMDM1ODAxMzA=",
      "title": "gen-certurl: turn this into a library so that other tool can depend on this",
      "url": "https://github.com/WICG/webpackage/issues/142",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [
        "go"
      ],
      "body": "",
      "createdAt": "2018-03-08T18:17:04Z",
      "updatedAt": "2018-12-20T04:05:27Z",
      "closedAt": "2018-12-20T04:05:26Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure the concrete plan.",
          "createdAt": "2018-03-13T06:12:10Z",
          "updatedAt": "2018-03-13T06:12:10Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Now we have the [certurl package](https://github.com/WICG/webpackage/tree/master/go/signedexchange/certurl) which can be used as a library. ([example usage](https://github.com/irori/htxg-b1/blob/sxg-test/gae/cert_handler.go))",
          "createdAt": "2018-12-20T04:05:26Z",
          "updatedAt": "2018-12-20T04:05:26Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWUzMDUzMjg2NDQ=",
      "title": "Define or forbid relative certUrls",
      "url": "https://github.com/WICG/webpackage/issues/147",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "H/T @twifkak for noticing that these are underspecified and underthought.",
      "createdAt": "2018-03-14T21:06:18Z",
      "updatedAt": "2018-04-06T17:34:09Z",
      "closedAt": "2018-04-06T17:34:09Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "The same thought should go into validityUrl, which is also a \"valid URL string\". Also note that \"valid URL string\"s can contain fragments, per that link.\r\n\r\nAlso, should the client verify that responses from these URLs don't contain any stateful headers, or are evaluated in a cross-origin context?",
          "createdAt": "2018-03-14T21:48:29Z",
          "updatedAt": "2018-03-14T21:48:29Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWUzMDU3MzQxNDE=",
      "title": "Signed exchange use case: selectively downgrading content?",
      "url": "https://github.com/WICG/webpackage/issues/149",
      "state": "CLOSED",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The use case document has a section on [how webpackages may help users avoid censorship](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#rfc.section.2.2.2) but I'm wondering if they may also help achieve the opposite outcome: to allow authorities to censor content. (In particular, to withhold new content, and present old content as if it were fresh.)\r\n\r\nWith current browsers, when a user clicks on a link, if a page subsequently loads and `https://news.example.com/` is shown in the URL bar, they can be confident that the browser is displaying content retrieved from `news.example.com` and that was retrieved *after* they clicked on the link.  (That is, the content is fresh.) However, this is not necessarily true if the resource in question is a signed webpackage delivered by a CDN: whilst the content was signed by `news.example.com`, it could be up to 7 days old.\r\n\r\nThis may result in unexpected behavior for users in regions where the use of such CDNs/caches is pervasive (for e.g. performance and/or regulatory reasons) and where the cache operator has the ability and desire to selectively censor information (perhaps in reaction to a particular event or crisis). \r\n\r\nIf the cache rewrites links, it may even be possible to arrange for an entire website to appear up to date and completely functional when in fact fresh content is mixed with old at the discretion of the intermediary.\r\n\r\nSome mechanisms that may help reduce these risks:\r\n\r\n- Clients could indicate to users that content was not retrieved from an intermediary, and not the origin, and recommend that the \"reload\" feature be used if users are unsure of its freshness. (This also requires that the reload feature applies to the user-visible URL, and not the network URL; is this a recommendation of the format?)\r\n- Clients could verify the `validityUrl` more frequently than required, or allow users to manually trigger a validity check. (Related to [6.3 Downgrades](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.6.3).)\r\n- Recommend that origins who believe they might be subject to such attacks expire signatures within seconds or minutes. (Perhaps this could vary per cache, depending on the degree of confidence the origin has in the cache.)\r\n- Recommend that origins embed absolute timestamps within their content (e.g. \"Last modified: 2018-03-15 18:45\"), so that users are aware when content is not fresh.",
      "createdAt": "2018-03-15T21:59:31Z",
      "updatedAt": "2018-05-15T16:10:30Z",
      "closedAt": "2018-05-15T16:10:30Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The first two paragraphs are definitely a risk. If someone's browsing an untrustworthy site, with signed exchanges it has the ability to link to an old version of a story instead of the newest version, and there's currently no plan to show the user that in the URL bar.\r\n\r\nThe third paragraph seems unlikely to me: each link source has to separately opt into serving a signed exchange for a resource, so the attack would have to come from a widely-used CDN that all of these sources opt into.\r\n\r\nCaches can't rewrite links within a signed exchange without breaking the exchange's signature, so I don't think that's a risk at all. With bundles, we'll even be able to ensure that the intermediate can't selectively upgrade resources: if the publisher signs their site as a group (TBD exactly how this'll be expressed), the intermediate will be able to selectively break the signature of a subset of the resources, but the client can remove those from the cache and re-request them instead of mixing an old cached version with a newer signed version.\r\n\r\nI haven't written the recommendation that \"reload\" always ask the logical origin for freshness information, but that's the plan.\r\n\r\nWe can't have publishers expire signatures within minutes because that doesn't give the intermediate enough time to serve it on, but hours are probably plausible in many cases. Sites can set the `Cache-control` header to expire in minutes, like they currently do, and we could maybe use that as the indication that the browser should fetch the `validityUrl` eagerly. Maybe we could also expose the fact that a loaded page failed its validity check to javascript so the page can force-reload itself or otherwise notify the user? Pages could also ping their origin server themselves.",
          "createdAt": "2018-03-18T16:08:58Z",
          "updatedAt": "2018-03-18T16:08:58Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> so the attack would have to come from a widely-used CDN that all of these sources opt into\r\n\r\nMy understanding is that internet connectivity in some regions already has an equivalent property: in some parts of the world, it is an actual or de facto requirement that all network traffic go through a central point.\r\n\r\nRight now, this gives the central point the ability to block entire origins. However, this proposal seems to introduce new capabilities: (1) the ability to downgrade (not block) resources (so content appears to be fresh, but isn't); and (2) the ability to selectively downgrade or block individual resources (paths), rather than entire origins (so some content really is fresh).\r\n\r\nPerhaps neither of these capabilities is especially powerful/dangerous, but they do seem to add complexity to the user's security model.\r\n\r\n> Caches can't rewrite links within a signed exchange without breaking the exchange's signature\r\n\r\nI was thinking of rewriting the links prior to signing, not after signing. (For example, caches might choose to rewrite links to always point back to the cache for improved performance/reliability.)",
          "createdAt": "2018-03-18T18:34:29Z",
          "updatedAt": "2018-03-18T18:34:29Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing, I think this concern is about a \"resolved\" as it ever will be.",
          "createdAt": "2018-05-15T16:10:30Z",
          "updatedAt": "2018-05-15T16:10:30Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "MDU6SXNzdWUzMDU4MDk2NTk=",
      "title": "signedexchange: Only first request/response header is adopted when multiple values are specified",
      "url": "https://github.com/WICG/webpackage/issues/151",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [
        "bug",
        "go"
      ],
      "body": "https://github.com/WICG/webpackage/blob/master/go/signedexchange/signedexchange.go#L87\r\n\r\nIn multiple values are specified, it looks like ok to join all the values with comma:\r\n\r\nhttps://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\r\n\r\n> Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.\r\n\r\n",
      "createdAt": "2018-03-16T05:48:40Z",
      "updatedAt": "2018-03-19T12:16:01Z",
      "closedAt": "2018-03-19T12:16:01Z",
      "comments": []
    },
    {
      "number": 152,
      "id": "MDU6SXNzdWUzMDU4MjU4MDE=",
      "title": "gen-signedexchange: Add a flag to override signature's date",
      "url": "https://github.com/WICG/webpackage/issues/152",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [],
      "body": "That would be useful for generating test htxg.\r\n\r\ncc: @hajimehoshi ",
      "createdAt": "2018-03-16T07:21:26Z",
      "updatedAt": "2018-03-20T07:00:37Z",
      "closedAt": "2018-03-20T07:00:37Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Done",
          "createdAt": "2018-03-20T07:00:36Z",
          "updatedAt": "2018-03-20T07:00:36Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWUzMDYyMTIyNjQ=",
      "title": "Specify the cache lifetime of a signed exchange",
      "url": "https://github.com/WICG/webpackage/issues/154",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The signature's expiry limits when you can receive the exchange. The HTTP cache control headers limit when you can use the exchange after it's successfully received.\r\n\r\nIt's not obvious what the policy should be, but a simple policy is to say that the resource expires from the cache at the earlier time of the signature expiration and the cache expiration.\r\n\r\nWe also need to specify how the resource is revalidated after it expires.\r\n1. The first use needs to be similar to [`<link rel=preload>`](https://w3c.github.io/preload/#link-type-preload) so that it's not revalidated during that first use.\r\n1. Subsequent uses can either [update signature validity](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#updating-validity) if the signature's expired, or use a conditional request if the cache information's expired. Once the signature's expired, remember that the etag isn't trustworthy.",
      "createdAt": "2018-03-18T04:24:21Z",
      "updatedAt": "2018-05-08T22:41:28Z",
      "closedAt": "2018-05-08T22:41:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "Hm. If we're talking about signed exchanges that are transferred over \"normal\" HTTP (i.e., not inside a bundle), the HTTP caches receiving it will treat it like any other response with freshness controls. You can't really override that, since not all caches receiving it will understand the signature.\r\n\r\nIf we're talking about signed exchanges inside a bundle -- which is effectively a different protocol -- it makes sense to figure out what the basis of the freshness lifetime is. I'm thinking it might make sense to make the `date` of the signature input to [calculating age](http://httpwg.org/specs/rfc7234.html#expiration.model).\r\n",
          "createdAt": "2018-03-26T04:51:16Z",
          "updatedAt": "2018-03-26T04:51:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is now sketched at https://github.com/WICG/webpackage/blob/master/explainer.md#signed-exchange-loading-sketch via #173.\r\n\r\nFor now, we're omitting third-party signed exchanges from the HTTP cache entirely. If we [add them later](https://github.com/WICG/webpackage/blob/master/explainer.md#to-consider-cache-the-inner-exchange), I think we'll have them live the shorter of the signature validity and the HTTP cache freshness expiration.\r\n\r\nAs Mark says, first-party signed exchanges are cached purely according to their HTTP headers.",
          "createdAt": "2018-05-08T22:41:28Z",
          "updatedAt": "2018-05-08T22:41:28Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWUzMDYzOTgzODc=",
      "title": "Resource Timing behavior for HTTP Exchange loading",
      "url": "https://github.com/WICG/webpackage/issues/156",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "igrigorik",
        "irori"
      ],
      "labels": [
        "feature request"
      ],
      "body": "This came up in https://chromium-review.googlesource.com/c/chromium/src/+/967632.\r\n\r\nWhen a HTTP Exchange is loaded from an application/http-exchange+cbor envelope, what the resource timing fields for that load should represent?\r\n\r\ncc: @jyasskin @kinu\r\n",
      "createdAt": "2018-03-19T10:05:07Z",
      "updatedAt": "2019-05-13T17:14:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Resource timing is https://w3c.github.io/resource-timing/.\r\n\r\nWe'll need to specify all of the fields in https://w3c.github.io/resource-timing/#dom-performanceresourcetiming.\r\n\r\nIf we treat a signed exchange as a redirect, the normal resource timing algorithms will skip most of the data transfer, so I suspect we want to special-case them to cover the envelope instead of its content.",
          "createdAt": "2018-04-10T23:56:29Z",
          "updatedAt": "2018-04-10T23:56:29Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWUzMDY3NTE2NTU=",
      "title": "gen-singedexchange: Cause an error when a stateful header field is found",
      "url": "https://github.com/WICG/webpackage/issues/160",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [],
      "body": "https://jyasskin.github.io/webpackage/implementation-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#stateful-headers\r\n\r\nCC @twifkak @nyaxt ",
      "createdAt": "2018-03-20T07:12:25Z",
      "updatedAt": "2018-04-02T01:35:44Z",
      "closedAt": "2018-04-02T01:35:44Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Instead of causing an error, just eliminating sounds fine. ",
          "createdAt": "2018-03-20T07:26:26Z",
          "updatedAt": "2018-03-20T07:26:26Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm I'd actually want it to cause an error instead of silently eliminating.\r\nSignedExchange is not built to capture private responses, and the attempt to do so should be an error.",
          "createdAt": "2018-03-20T08:10:18Z",
          "updatedAt": "2018-03-20T08:10:18Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWUzMDY3NTQ3MDE=",
      "title": "Case-different keys in CBOR exchange headers",
      "url": "https://github.com/WICG/webpackage/issues/161",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "CBOR representation of exchange headers must be canonically-serialized, which means maps must not have multiple entries with the same key.\r\n\r\nHowever, they still can have duplicated HTTP header fields with case differences. For example:\r\n```\r\n[\r\n  {\r\n    ':url': 'https://example.com/'\r\n    ':method': 'GET',\r\n  },\r\n  {\r\n    ':status': '200',\r\n    'Content-Type': ...\r\n    'content-type': ...\r\n  }\r\n]\r\n\r\n```\r\nShould the spec explicitly forbid such duplicated headers? Or specify that header names must be stored in lower-case?",
      "createdAt": "2018-03-20T07:26:45Z",
      "updatedAt": "2018-03-27T20:27:15Z",
      "closedAt": "2018-03-27T20:27:15Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "HTTP/2 requires that everything be lowercase. This isn't exactly HTTP/2 since `:url` is different, but it borrows `:method` and `:status` from HTTP/2, so aligning there seems reasonable. No reason to allow multiple spellings of the same thing.",
          "createdAt": "2018-03-20T20:53:44Z",
          "updatedAt": "2018-03-20T20:53:44Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yep, PTAL at #163.",
          "createdAt": "2018-03-21T14:27:33Z",
          "updatedAt": "2018-03-21T14:27:33Z"
        }
      ]
    },
    {
      "number": 164,
      "id": "MDU6SXNzdWUzMDc0ODI3NDI=",
      "title": "Remove validityUrl mechanism from implementation snapshot",
      "url": "https://github.com/WICG/webpackage/issues/164",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the #updating-validity section, the 3rd and subsequent paragraphs should be removed.\r\n\r\nAt present, Chromium requires the Signature to have a valid validityUrl, but doesn't use it except for including it in the signed message. (@nyaxt please correct me if I'm wrong.)",
      "createdAt": "2018-03-22T02:22:06Z",
      "updatedAt": "2018-04-06T03:00:13Z",
      "closedAt": "2018-04-06T03:00:13Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> At present, Chromium requires the Signature to have a valid validityUrl, but doesn't use it except for including it in the signed message. (@nyaxt please correct me if I'm wrong.)\r\n\r\nYes. This is correct.",
          "createdAt": "2018-03-22T02:27:09Z",
          "updatedAt": "2018-03-22T02:27:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "My thought in leaving this in was that the validityUrl isn't just intended for the browser to check: any intermediate can use it to update their signed exchange without fetching the whole body. Even though the AMP intermediate doesn't intend to use it, some other intermediate that syncs on this draft might want to. That said, taking out the mechanism reduces the amount of work other intermediates and package generators need to think about.\r\n\r\nIf I take out the mechanism, I'll keep the validityUrl itself to match Chrome's enforcement that it's present, even though we don't check that it's fetchable.\r\n\r\n\ud83d\udc4d/\ud83d\udc4ethis comment if you want to keep the validityUrl mechanism(\ud83d\udc4d) or take it out(\ud83d\udc4e)?",
          "createdAt": "2018-03-22T09:46:54Z",
          "updatedAt": "2018-03-22T09:46:54Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I see, the option is there for intermediaries to rewrite the signed-exchange payload to include the new Signature header? In that case, I'm pretty ambivalent. Maybe leave it in, as a lever we might explore later.",
          "createdAt": "2018-03-22T18:58:37Z",
          "updatedAt": "2018-03-22T18:58:37Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWUzMDc4OTc2Mzc=",
      "title": "gen-certurl should be updated to follow latest spec draft",
      "url": "https://github.com/WICG/webpackage/issues/165",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [
        "go"
      ],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cert-chain-format",
      "createdAt": "2018-03-23T04:18:00Z",
      "updatedAt": "2018-04-11T05:38:27Z",
      "closedAt": "2018-04-11T05:38:27Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "ack",
          "createdAt": "2018-03-23T04:18:19Z",
          "updatedAt": "2018-03-23T04:18:19Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@twifkak You may want to update your software to use nyaxt branch for gen-certurl before the change goes in.",
          "createdAt": "2018-03-23T04:18:39Z",
          "updatedAt": "2018-03-23T04:18:39Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks; will do. Please cc me on the PR for this.",
          "createdAt": "2018-03-23T05:02:25Z",
          "updatedAt": "2018-03-23T05:02:25Z"
        }
      ]
    },
    {
      "number": 169,
      "id": "MDU6SXNzdWUzMTE0ODE0OTA=",
      "title": "Cross-origin trust: Source of SCTs",
      "url": "https://github.com/WICG/webpackage/issues/169",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust\r\n\r\n> 6.4 Validate that main-certificate has an sct property (Section 3.3) containing valid SCTs from trusted logs. ([RFC6962])\r\n\r\nDoes this mean that SCTs have to be included as a map item of the cert-chain CBOR? Or SCTs can be provided as an X.509v3 extension of `main-certificate` or as an OCSP extension of the `ocsp` property?\r\n",
      "createdAt": "2018-04-05T05:55:51Z",
      "updatedAt": "2018-04-09T18:19:20Z",
      "closedAt": "2018-04-09T18:19:20Z",
      "comments": []
    },
    {
      "number": 172,
      "id": "MDU6SXNzdWUzMTI0MDA3NDE=",
      "title": "Is URL fragment (#foobar) allowed for URLs?",
      "url": "https://github.com/WICG/webpackage/issues/172",
      "state": "CLOSED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After the change https://github.com/WICG/webpackage/pull/170, URLs (request URL, certUrl, and validityUrl) must be **[absolute-URL string](https://url.spec.whatwg.org/#absolute-url-string)**.\r\n\r\nIf my understanding is correct, **[absolute-URL string](https://url.spec.whatwg.org/#absolute-url-string)** can't contain the fragment.\r\nThe fragments is meaningless for certURL and validityUrl.\r\nBut I think it is useful for request URL.\r\n\r\ncc: @jyasskin @twifkak @nyaxt ",
      "createdAt": "2018-04-09T05:43:44Z",
      "updatedAt": "2018-04-10T22:18:52Z",
      "closedAt": "2018-04-10T22:18:52Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it makes sense to allow requestURL be an absolute-URL string with fragments",
          "createdAt": "2018-04-09T06:38:58Z",
          "updatedAt": "2018-04-09T06:38:58Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Hm, my model was that if a signed exchange has a request URL of `https://pub.com/page.html` then it's authoritative for all fragments inside that page.\r\n\r\nI'm assuming that if `https://intermediate.com/nytimes.com/foo.sxg` has a request URL of `https://nytimes.com/foo.html` then a fetch of `https://intermediate.com/nytimes.com/foo.sxg#fragment` will internally redirect to `https://nytimes.com/foo.html#fragment`. Do we need to fix something for that to work?\r\n\r\nIf it already works, what's the use case for saying that a signed exchange holds `https://nytimes.com/foo.html#fragment` but not `https://nytimes.com/foo.html` or `https://nytimes.com/foo.html#other-fragment`?",
          "createdAt": "2018-04-09T16:20:16Z",
          "updatedAt": "2018-04-09T16:20:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Note fragments aren't sent to the server in a fetch over the network either. Nor do they figure into HTTP cache keys or anything. Agreed with @jyasskin that including fragments in the signed exchanges doesn't make sense. Having the fragments preserved on sxg \"redirects\" seems reasonable. It is how redirects normally work.",
          "createdAt": "2018-04-09T16:24:31Z",
          "updatedAt": "2018-04-09T16:25:00Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "According to RFC 7231, the Location header of redirection response can have the fragment.\r\nhttps://tools.ietf.org/html/rfc7231#section-7.1.2\r\nSo I think the request URL in signed exchange should be able to have the fragment.",
          "createdAt": "2018-04-10T00:43:56Z",
          "updatedAt": "2018-04-10T00:43:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the location header can have a fragment and, indeed, a signed location header can have one too. But that field is not analogous to this one. It's the request that's relevant, and remember that the fragment is *not* sent in the request line.\r\n\r\nAlso remember the signed exchange is *signed*, presumably offline. Including the fragment in the request wouldn't be useful because then every possible fragment on the page must be signed separately. That's a whole lot of effort for no gain, since the body does not normally vary by fragment.\r\n\r\nIf you wish to direct someone to a fragment within a signed exchange, the mechanism Jeff proposed makes a lot more sense. Because resources do not vary by fragments and one can freely direct a user to a fragment by including it in the URL, there's no reason for signed exchange matching to incorporate the fragment. Therefore, don't put the fragment in there.",
          "createdAt": "2018-04-10T00:49:46Z",
          "updatedAt": "2018-04-10T00:49:46Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me retract my reply earlier. I'm convinced with [@jyasskin's model](https://github.com/WICG/webpackage/issues/172#issuecomment-379809601).",
          "createdAt": "2018-04-10T01:16:47Z",
          "updatedAt": "2018-04-10T01:16:47Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I agree that `https://intermediate.com/nytimes.com/foo.sxg#fragment` should internally redirect to `https://nytimes.com/foo.html#fragment`.\r\n\r\nBut [offline browsing](https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-01#section-2.1.2) is one of use cases. It is very useful if \"Alex can download a file containing a large website (e.g.  Wikipedia) **with a fragment URL** from its origin, save it to transferrable storage (e.g. an SD card).\"\r\n\r\nI agree that the fragment doesn't need to be signed.\r\nOne option would be to have a metadata section in the signed exchange file which is not used to generate the signature.\r\nBut I don't think there is a problem that the signed exchange **can** have request URL with fragment.",
          "createdAt": "2018-04-10T02:31:58Z",
          "updatedAt": "2018-04-10T02:31:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think saving the fragment in the signed exchange format makes a whole lot of sense. The fragment is roughly the scroll position. (Consider your example, Wikipedia. The fragment doesn't tell you what article you are reading. It tells you to jump to a heading in the article.) If a user saves an HTML page today, it doesn't save the fragment.\r\n\r\nWhile I can see uses where one would want to stash it in, say, a bookmark, or in whatever mechanism offline websites get transmitted as, this does not make sense part of the signed exchange format. Rather it should be some *external* pointer, which would be needed anyway to pick out which page to look at out of a large package. If it were part of the request URI, verifying the signature would become complex, which is a security risk. If it were part of the format, it would carry over into the other use cases, which is a security risk.\r\n\r\nThis issue should just be closed WontFix.",
          "createdAt": "2018-04-10T15:34:30Z",
          "updatedAt": "2018-04-10T15:34:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The offline browsing use case needs bundling in order to be useful. While that use case doesn't mention fragments, bundles will have metadata with a [`start_url`](https://w3c.github.io/manifest/#start_url-member), and that can include a fragment.\r\n\r\n@horo-t Does putting the fragment at the bundle level work for the uses you're thinking of, or do they really need it in the signed exchange? If they really need it, could you describe them in more detail?\r\n\r\nAlso, thanks for bringing up details like this. Even if we decide not to make the change, it's helpful to consider it explicitly.",
          "createdAt": "2018-04-10T17:03:42Z",
          "updatedAt": "2018-04-10T17:03:42Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I didn't know about `start_url`. Then, we don't need to allow fragments in request URL of the signed exchange.\r\n\r\nI submitted a Chromium CL which checks the validity and the fragment of the URLs.\r\nhttps://chromium.googlesource.com/chromium/src/+/da1e9ae5f918c66f3f35f56b00190f5ed9773405",
          "createdAt": "2018-04-10T22:18:52Z",
          "updatedAt": "2018-04-10T22:18:52Z"
        }
      ]
    },
    {
      "number": 175,
      "id": "MDU6SXNzdWUzMTMxNDcwMjE=",
      "title": "OCSP / SCT requirements of the cert-chain",
      "url": "https://github.com/WICG/webpackage/issues/175",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cert-chain-format\r\n\r\n> 2. The first certificate\u2019s ocsp value *if any* MUST be a complete, DER-encoded OCSP response for that certificate\r\n\r\nThis reads main certificate's ocsp property is optional, but actually it's required in the step 6.3 of [Cross-origin trust](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust)?\r\n\r\n> 3. Each certificate\u2019s sct value MUST be a SignedCertificateTimestampList for that certificate\r\n\r\n- Add \"if any\" since SCTs may be embedded in the `cert` or `ocsp`? (#171)\r\n- The step 6.4 of [Cross-origin trust](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust) uses only SCTs for main certificate. If `sct` is to provide a channel to supply SCTs instead of the TLS extension, should the spec say that subsequent certificates MUST NOT have a `sct` value?\r\n\r\n@jyasskin @hajimehoshi @nyaxt ",
      "createdAt": "2018-04-11T01:57:45Z",
      "updatedAt": "2018-07-10T06:34:41Z",
      "closedAt": "2018-07-10T06:34:41Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, my understanding is the spec allows the same-origin response to omit ocsp and sct, in which case the intermediary must collect and attach them. Question: If an intermediary made a stricter requirement that it would only ingest SXGs that include these, would it be a bad citizen?",
          "createdAt": "2018-04-11T04:49:07Z",
          "updatedAt": "2018-04-11T04:49:07Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "These are covered by #246.",
          "createdAt": "2018-07-10T06:34:41Z",
          "updatedAt": "2018-07-10T06:34:41Z"
        }
      ]
    },
    {
      "number": 176,
      "id": "MDU6SXNzdWUzMTMzMjc0MTQ=",
      "title": "Node ecosystem might need to preserve using `file:` protocol",
      "url": "https://github.com/WICG/webpackage/issues/176",
      "state": "OPEN",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "Various things in the ecosystem use symlinks, the behavior of symlinks in node and how HTTP redirects is not compatible per https://github.com/nodejs/modules/issues/62 . Could repurpose the `Location` header over `file:` but https://fetch.spec.whatwg.org/#scheme-fetch could be changed in a forwards incompatible way if we do that.",
      "createdAt": "2018-04-11T13:36:43Z",
      "updatedAt": "2019-05-13T17:15:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWUzMTM0MjkwMTU=",
      "title": "Internal referencing and internal only resources",
      "url": "https://github.com/WICG/webpackage/issues/177",
      "state": "OPEN",
      "author": "BigBlueHat",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "architecture",
        "feature request"
      ],
      "body": "Question related to the \"bundling\" spec draft: https://github.com/WICG/webpackage/pull/98\r\n\r\nAre there plans to include an internal referencing mechanism similar to [MHTML](https://tools.ietf.org/html/rfc2557)'s use of [`Content-ID`](https://tools.ietf.org/html/rfc2557#section-9.5) or the TAG's previous [Packaging on the Web](https://www.w3.org/TR/web-packaging/)'s use of [fragment identifiers](https://www.w3.org/TR/2015/WD-web-packaging-20150115/#fragment-identifiers)?\r\n\r\nFor instance, book (et al) publishers are coming from EPUB where \"everything\" is built using internal references and internal-only resources. Additionally, there may be other use cases where \"internal only\" package contents might be needed and beneficial.\r\n\r\nIf that seems out of scope for this sort of bundling, though, no worries. Just wanted to check. \ud83d\ude03 \r\n\r\nWe'll be exploring that need in the Publishing WG via https://github.com/w3c/pwpub/issues/24\r\n\r\nThanks!\r\n\ud83c\udfa9 ",
      "createdAt": "2018-04-11T18:01:54Z",
      "updatedAt": "2019-05-13T17:15:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 183,
      "id": "MDU6SXNzdWUzMTU2Mzk3MTc=",
      "title": "How are duplicate response headers handled in the same-origin response?",
      "url": "https://github.com/WICG/webpackage/issues/183",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "Google App Engine apparently has a small (undocumented) per-header-line size limit [1]. I imagine other such containers might have similar limits. This will be a problem with Signature (esp. if multiple sigs) and Link, unless a signer is allowed split them by newline.\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cbor-representation doesn't specify a canonical way to join duplicate response headers; could/should it?\r\n\r\n[1] Was 497, per [stackoverflow](https://stackoverflow.com/questions/15280027/is-there-a-size-limit-for-http-response-headers-on-google-app-engine), but may have increased to 1k or so.",
      "createdAt": "2018-04-18T20:57:31Z",
      "updatedAt": "2019-05-13T17:16:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This is sort of issue is part of why we advocated changing the style of signature in issue #148. You don't need to worry as much about being able to round-trip what you got to and from the signed representation. Not that it's impossible to solve, but why solve a problem when you can just walk around it? :-)\r\n\r\nWhen what you get is the signed representation, it's more obvious how to verify it and that what you will process is exactly what you verified.",
          "createdAt": "2018-04-18T22:40:10Z",
          "updatedAt": "2018-04-18T22:40:10Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC, #148 changes the packaged `application/signed-exchange` format but not the https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#same-origin-response. I think there is value in publishers being able to deliver a same-origin response containing a Signature/Signed-Headers that is ignored by browsers and consumed by crawlers:\r\n\r\nThe `application/signed-exchange` is one that not all browsers understand (and likely suboptimal same-origin even for those that do). Therefore, there would need to be a discovery mechanism, by which the crawler knows a signed variant of a resource exists and how to get it. There are approximately two ways to do this:\r\n  1. By URL - the original page specifies via link tag where the htxg lives.\r\n  2. By header - the server Varies its response based on an as-yet-undefined request header\r\n\r\nThe first is bad for crawlers because it requires they maintain mappings between non-htxg and htxg, and handle all sorts of edge cases there. It's bad for publishers and search users because crawlers respect hostload maximums, and this would effect the rate at which updates could be crawled (and, in turn, search quality).\r\n\r\nThe second is bad for publishers because varying by request header is something that many frontends don't do well, or need special configuration for. (For instance, I don't know of any that let you specify a custom cache-key for request coalescing, so it would need to be disabled.) In the same-origin model, if a publisher is unable to configure Varying, that means they'll just be signing more responses than they need to. In the application/signed-exchange model, it means they'll be unable to serve signed exchanges.\r\n\r\n(In the end, there may be a need for a \"by URL\" mechanism, but I'd like to minimize the reasons publishers would want to take it, because of its downsides.)",
          "createdAt": "2018-04-18T23:10:09Z",
          "updatedAt": "2018-04-18T23:10:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "On the original question, I'm relying on https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-3 to allow senders to split each signature into its own header line. A single RSA signature might still go over the limit.\r\n\r\nIt's possible we'll eventually decide against implementing the header field, but I currently think it's useful for same-origin responses. It's necessary for signature-based SRI, although if we find that @twifkak's use cases for signed-exchanges don't actually need it, we could simplify the SRI header.",
          "createdAt": "2018-05-01T18:34:11Z",
          "updatedAt": "2018-05-01T18:34:11Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin That covers Signature, but not the headers that would be signed over, which are not httpbis structured headers. e.g. What is the signed message given this response?\r\n\r\n```\r\nSigned-Headers: \"link\"\r\nLink: <foo.js>;rel=preload\r\nLink: <foo.css>;rel=preload\r\n```\r\n\r\nThe section I linked to above says \"the header field\u2019s value as a byte string\". Is this enough to imply that the \"MAY\" in https://tools.ietf.org/html/rfc7230#section-3.2.2 becomes a \"MUST\"? I'd suggest this be explicit (if the header field remains).",
          "createdAt": "2018-05-01T19:18:27Z",
          "updatedAt": "2018-05-01T19:18:27Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "'k, I'll make that more explicit. Yes, in all of the signing situations, I'm expecting any duplicated headers to be joined with commas.",
          "createdAt": "2018-05-01T19:25:13Z",
          "updatedAt": "2018-05-01T19:25:13Z"
        }
      ]
    },
    {
      "number": 185,
      "id": "MDU6SXNzdWUzMjE3ODkyODA=",
      "title": "explainer: Should prefetch recursion have a limit?",
      "url": "https://github.com/WICG/webpackage/issues/185",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If A prefetches sxg_0, which includes a preload for sxg_1, which includes a preload for sxg_2, ... This could lead to unbounded prefetches. Perhaps include a limit like https://fetch.spec.whatwg.org/#ref-for-concept-request-redirect-count%E2%91%A0.",
      "createdAt": "2018-05-10T02:36:43Z",
      "updatedAt": "2018-05-10T21:25:59Z",
      "closedAt": "2018-05-10T21:25:59Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @kinu",
          "createdAt": "2018-05-10T17:47:48Z",
          "updatedAt": "2018-05-10T17:47:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this issue belongs in the https://github.com/w3c/resource-hints/ repository where prefetch is defined. I don't see anything specific to signed exchanges here.",
          "createdAt": "2018-05-10T21:25:59Z",
          "updatedAt": "2018-05-10T21:25:59Z"
        }
      ]
    },
    {
      "number": 186,
      "id": "MDU6SXNzdWUzMjIwMDE0NzE=",
      "title": "Increment ver num on \"implementation checkpoint\"",
      "url": "https://github.com/WICG/webpackage/issues/186",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt"
      ],
      "labels": [],
      "body": "Chromium would like to start adding support for next \"implementation checkpoint\".\r\nCan we increment ver num on https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.5.3 ?",
      "createdAt": "2018-05-10T16:47:24Z",
      "updatedAt": "2018-07-09T18:41:36Z",
      "closedAt": "2018-07-09T18:41:36Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yes ... do you have a feeling for the subset of https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html that you'll be able to implement for the next checkpoint?",
          "createdAt": "2018-05-10T20:42:22Z",
          "updatedAt": "2018-05-10T20:42:22Z"
        }
      ]
    },
    {
      "number": 187,
      "id": "MDU6SXNzdWUzMjIxMDQ0OTQ=",
      "title": "Versioning support in Accept-Signature?",
      "url": "https://github.com/WICG/webpackage/issues/187",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [
        "feature request"
      ],
      "body": "It seems worth adding a \"desired version(s)\" to the Accept-Signature, so intermediaries can signal which version of the Signature header they are capable of consuming. Otherwise, I guess they would have to sniff, based on the names of the parameters, or add a non-standard request header for this purpose.",
      "createdAt": "2018-05-10T22:15:26Z",
      "updatedAt": "2019-05-13T17:17:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I need to redesign the Accept-Signature header, and the new version should at least start with a version number.",
          "createdAt": "2019-05-13T17:17:07Z",
          "updatedAt": "2019-05-13T17:17:07Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "MDU6SXNzdWUzMjQ3NjY4MDQ=",
      "title": "Define a WebDriver extension for Signed Exchange testing",
      "url": "https://github.com/WICG/webpackage/issues/188",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Both Signed Exchange and CBOR cert chain have short lifetime (max 7 days). This makes it difficult to use pre-generated signed exchange / cert files in end-to-end testing. To workaround this, Chromium has an [internal testing API](https://chromium-review.googlesource.com/c/chromium/src/+/991833) (available only in test runner) that overrides signature verification time.\r\n\r\nIn order to test Signed Exchange Loading in web-platform-tests, we need an interoperable way to override signature verification time. The preferred way is defining a [WebDriver extension](https://w3c.github.io/webdriver/#dfn-extension-command) in the respective spec (in this case, Signed Exchange) so that the same surface API is used across UAs.\r\n\r\nSee [this doc](https://docs.google.com/document/d/1zlFRcKuTM3RpoYjcOtiVOioRErEkJyCyv8hDs9_mlXo/edit#heading=h.n0pzm6uk5f69) for more details and discussions.",
      "createdAt": "2018-05-21T02:14:14Z",
      "updatedAt": "2019-04-25T01:37:00Z",
      "closedAt": "2019-04-25T01:37:00Z",
      "comments": [
        {
          "author": "RByers",
          "authorAssociation": "MEMBER",
          "body": "@kereliuk, can you point to an example spec where this has been done now? This seems like it should be pretty straight forward to implement, and I'm a little concerned that the longer we continue with chromium-only testing, the more debt we might accidentally accrue. \r\n\r\nFWIW it looks like the existing chromium tests are here:\r\n[third_party/WebKit/LayoutTests/http/tests/loading/htxg](https://cs.chromium.org/chromium/src/third_party/WebKit/LayoutTests/http/tests/loading/htxg/)\r\n[third_party/WebKit/LayoutTests/http/tests/devtools/htxg/](https://cs.chromium.org/chromium/src/third_party/WebKit/LayoutTests/http/tests/devtools/htxg/)\r\n[content/test/data/htxg/](https://cs.chromium.org/chromium/src/content/test/data/htxg/)\r\n\r\nAnd there's already a devtools protocol API for mocking out the verification time: [setSignedExchangeVerificationTime](https://cs.chromium.org/chromium/src/third_party/WebKit/LayoutTests/http/tests/loading/htxg/resources/htxg-util.js?type=cs&q=setSignedExchangeVerificationTime&sq=package:chromium&g=0&l=38)\r\n\r\nAnything I missed @irori?",
          "createdAt": "2018-07-04T13:58:58Z",
          "updatedAt": "2018-07-04T13:58:58Z"
        },
        {
          "author": "kereliuk",
          "authorAssociation": "NONE",
          "body": "> @kereliuk, can you point to an example spec where this has been done now?\r\n\r\nHere is an example in [Reporting](https://w3c.github.io/reporting/#automation)\r\n\r\n@irori Let me know if you have any questions with defining the specification or the implementation steps that follow. I'm working on getting some end to end documentation/tutorials on the entire process.",
          "createdAt": "2018-07-05T15:40:09Z",
          "updatedAt": "2018-07-05T15:40:09Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "I initially thought we can override the verification time, but it seems not an option because OS/underlying library doesn't allow this.\r\n\r\nPasting @sleevi's comment (from an internal chat) about Signed Exchange testing (markup mine):\r\n\r\n> Here's things we can and can't do:\r\n> \r\n> 1. We can modify the HXTG interaction to support treating cert errors as interstitials, so that DevTools can bypass the interstitial (as it does today) - but that's going to be really weird with the whole flow and expected behaviours.\r\n> \r\n> 2. We can modify HXTG's cert verifier to lie (similar to `--ignore-cert-errors-spki-list`), but then like ICESL, we'd need to make sure it doesn't cache (which is why that flag requires `--user-data-dir`), but that means you can only DevTools with a custom profile (and ICESL already 'just works' for the cert part today)\r\n> \r\n> 3. We can generate an on-the-fly CA and on-the-fly responses. It needs to be an on-the-fly CA, not shared among WPT, because our TLS policies are such that we block vendors who generate shared-root-CA keys (meaning we'd blacklist the WPT CA key if it's generating a shared-key). That's the path WebPageReplay has gone, AIUI.\r\n> \r\n> What we can't do:\r\n> \r\n> - We can't verify a certificate and response \"in the past\" while still actually validating it. No one's APIs support that use case. PKI assumes time is linear and monotonic, and so to do the APIs\r\n\r\nFrom Chromium's point of view, 2. seems to be the easiest. Our test runner already uses `--ignore-cert-errors-spki-list` for WPT tests, so we just have to let SXG signature verifier lie (about signature expiration) too. Question is if other UAs have similar switches, and if we can/should make this switchable via a WebDriver extension. As Ryan noted, we have to make sure it doesn't cache, etc.\r\n\r\nOption 1 (let DevTools bypass interstitial SXG errors) is another way to bypass cert verification in tests. This might be more suitable for an underlying implementation of a WebDriver extension (I'm not completely sure). It's still question if other browsers are willing to implement the same WebDriver API.\r\n\r\nOption 3 actually exercises cert verification in tests. In addition to WPT infra work, this needs some Chromium-side testing infra change too (not to just ignore cert errors).\r\n\r\n\r\n## Strawman proposal\r\n- Add `.tentative` tests using the option 2. It wouldn't work unless UA is configured to ignore certificate errors, and wouldn't test the certificate verification behavior. But it would be still useful to test the \"loading\" aspect of SXGs. Also, we can add manual tests with instructions to generate SXGs using a test CA.\r\n\r\n- In the long term, explore an on-the-fly CA + SXG generation approach. Probably we can implement it in Go and submit binaries to the WPT repository.\r\n",
          "createdAt": "2018-08-14T02:06:36Z",
          "updatedAt": "2018-08-14T06:11:10Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI, I've started adding tentative tests in [wpt/signed-exchange](https://github.com/web-platform-tests/wpt/tree/master/signed-exchange). ([Tracking bug](https://bugs.chromium.org/p/chromium/issues/detail?id=895723))",
          "createdAt": "2018-10-16T09:03:05Z",
          "updatedAt": "2018-10-16T09:03:05Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "We've implemented the option 2 of https://github.com/WICG/webpackage/issues/188#issuecomment-412729051.\r\nProbably we won't need a WebDriver extension. Closing.",
          "createdAt": "2019-04-25T01:37:00Z",
          "updatedAt": "2019-04-25T01:37:00Z"
        }
      ]
    },
    {
      "number": 191,
      "id": "MDU6SXNzdWUzMjQ3OTkxMDc=",
      "title": "Request for fixed length magic string: \"sxg1-\"",
      "url": "https://github.com/WICG/webpackage/issues/191",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current spec draft, the magic string is allowed to be arbitrary length for implementation drafts.\r\n\r\n> Note: RFC EDITOR PLEASE DELETE THIS NOTE; The implementation of the final RFC MUST use this file signature, but implementations of drafts MUST NOT use it and MUST use another implementation-specific string beginning with \u201csxg1-\u201c and ending with a 0 byte instead.\r\n\r\nThis makes its streaming parsing non-trivial, since we need to scan for `\"\\0\"` to appear, rather than reading fixed length record.\r\n\r\nTwo proposals:\r\n- Allocate fixed length (8bytes?) for the magic string field, and pad the rest of the bytes `\"\\0\"` \r\n  - Will file a PR for this\r\n- Separate version field?",
      "createdAt": "2018-05-21T06:12:31Z",
      "updatedAt": "2018-05-24T23:19:19Z",
      "closedAt": "2018-05-24T23:19:19Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think an implementation can parse the current format by reading as many bytes as the longest magic string it supports, and then memcmp'ing against each of the magic strings including their trailing `'\\0'`.\r\n\r\nI think I prefer a version field over a `\\0`-padded magic string.",
          "createdAt": "2018-05-21T22:24:59Z",
          "updatedAt": "2018-05-21T22:24:59Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "We would like to simplify the decoder which would live in the browser process as much as possible. I will draft a change that basically does:\r\n```\r\n\"sxg1\" magic + 3byte ver + 3byte siglen + 3byte hdrlen + ...\r\n```\r\n\r\n> I think an implementation can parse the current format by reading as many bytes as the longest magic string it supports, and then memcmp'ing against each of the magic strings including their trailing '\\0'.\r\n\r\nYes, but it would require concatenating the overread portion to the start of {signature,headers} buffer.",
          "createdAt": "2018-05-21T23:12:51Z",
          "updatedAt": "2018-05-21T23:12:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yes, but it would require concatenating the overread portion to the start of {signature,headers} buffer\r\n\r\nIt is also possible that the signature/headers buffer may be smaller than the overread and you go into the body itself.\r\n\r\nThat said, you likely should be doing this anyway because issuing small reads at a time is not very efficient. (I don't remember being asked to review any CLs to implement the new format... I assume  they're just still in progress?) If you look at Chromium's HTTP/1.1 implementation, we read data in large chunks at a time and, if we got more or less than the full HTTP headers, we just handle that case.",
          "createdAt": "2018-05-21T23:20:05Z",
          "updatedAt": "2018-05-21T23:20:05Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't written any code yet. (Mainly landing golang lib impl right now)\r\n\r\nThe current impl for the old format basically issues 3 reads at the minimum:\r\n- SignedExchangeHandler: Read fixed header's header === {magic, headerLen}\r\n- SignedExchangeHandler: Read CBOR header of headerLen\r\n- MercleIntegritySourceStream: Read payload\r\n  - SignedExchangeHandler moves ownership of the `source_` stream to MercleIntegritySourceStream\r\n\r\nWe can basically keep this 3+ read scheme if the new \"header's header\" is const, but needs to do buffering (as @davidben mentioned) to handle variable len magic.\r\n\r\n> That said, you likely should be doing this anyway because issuing small reads at a time is not very efficient. (I don't remember being asked to review any CLs to implement the new format... I assume they're just still in progress?) If you look at Chromium's HTTP/1.1 implementation, we read data in large chunks at a time and, if we got more or less than the full HTTP headers, we just handle that case.\r\n\r\nI discussed this a bit with @irori.\r\n\r\nWe are a bit hesitant to do our own buffering in SignedExchangeHandler until we are sure that this is a major performance bottleneck.\r\n- We expect the format to evolve in the short term so we want to keep the implementation as simple as possible at this point.\r\n- Getting rid of the `source_` move to MercleIntegritySourceStream is non-trivial. We need to either:\r\n  - Modify MerkleIntegirtySourceStream to take additional ctor param for the overread portion, while this makes it divert from other FilterSourceStreams impl.\r\n  - Make SignedExchangeHandler a SourceStream so it could proxy Read() calls.",
          "createdAt": "2018-05-22T01:11:21Z",
          "updatedAt": "2018-05-22T01:11:21Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Doing small reads at parsing layer and making buffered read in the underlying layer for efficiency can be decoupled in the implementation, I think impl concerns can be probably addressed (we chatted potential feasible impl options with @nyaxt, @irori and @horo-t too).\r\n\r\n@davidben -- one thing that's a bit unclear to us is your stance on non-deterministic/streaming parsing. Once you pushed back the format that requires streaming parsing in favor of fixed length format, while this time we say that the variable length is preferable or okay in the newer format. What is driving the difference, is that the level of required complexity?\r\n",
          "createdAt": "2018-05-22T02:06:56Z",
          "updatedAt": "2018-05-22T02:06:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not pushing back against a fixed-width string. Fixed-width strings are great. I was just agreeing with Jeffrey's comment that this isn't a big deal given you already round up your reads, as is standard. Though it sounds like you're not planning on doing it, in which case I agree this is a nuisance.\r\n\r\nI pushed back on trying to use a streaming CBOR parser because that one does not admit much of simplifications. You end up threading the streaming logic through an already complex format. That is a classic error dating all the back to ASN.1 (except that CBOR made some mistakes that even ASN.1 avoided, so it's even worse in CBOR).\r\n\r\nActually, come to think of it, I'm pretty sure this already came up and I'd already asked for a change that avoids this problem. The format shouldn't require dispatching on the magic string, only MIME type. That avoids this problem completely because you already know how big of a magic string to expect by the time you instantiate your handler.\r\nhttps://github.com/WICG/webpackage/pull/148#discussion_r178949840",
          "createdAt": "2018-05-22T15:53:21Z",
          "updatedAt": "2018-05-22T15:53:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Indeed, if we say that `application/signed-exchange;v=b1` has a magic string of \"sxg1-b1\\0\", then the handler should be able to read exactly 8 bytes, and if it gets \"sxg1\\0abc\" instead, that's just a failure to parse. It wouldn't try to push \"abc\" back onto the stream to continue as a different version of the spec.",
          "createdAt": "2018-05-22T17:01:03Z",
          "updatedAt": "2018-05-22T17:01:03Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, that makes a lot sense to me now, thanks @davidben and @jyasskin for better clarification!",
          "createdAt": "2018-05-23T01:42:33Z",
          "updatedAt": "2018-05-23T01:42:33Z"
        }
      ]
    },
    {
      "number": 197,
      "id": "MDU6SXNzdWUzMjY5NjAyNDM=",
      "title": "Clarify how we handle permanent diffs between impl checkpoint and the main draft (e.g. `MI` vs `MI-draft2`)",
      "url": "https://github.com/WICG/webpackage/issues/197",
      "state": "CLOSED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I suppose the latest draft of the -impl checkpoint basically follows the latest responses draft ('the main draft) with some gaps, so a typical workflow could be like to keep cherry-picking changes from the latest responses into the latest impl draft.  However there are some diffs that are only tracked by the impl checkpoint but not in the main draft, e.g. like https://github.com/WICG/webpackage/pull/155 (`MI` vs `MI-draft2`).  I can see the reason not to track this in the main draft, but I'm afraid tracking such changes that only exist in some branch but not in the master responses draft may become a bit cumbersome, especially if we start to have multiple of such diffs.\r\n\r\nWould it be possible to avoid doing this but instead put some instructions for the implementors in the main draft? (This is something @jyasskin mentioned as a potential alternative in some of our offline chat)  Or could we have some special section in the ChangeLog in the main draft so that all we need to cherry-pick can be still found in the main draft?",
      "createdAt": "2018-05-28T09:27:39Z",
      "updatedAt": "2018-08-14T18:25:27Z",
      "closedAt": "2018-08-14T18:25:27Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The current long-lived impl-only diffs are:\r\n\r\n* MI->MI-draft2: Will be handled by https://github.com/martinthomson/http-mice/pull/8, probably with a reference in the main draft.\r\n* A specific version number for the https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#internet-media-type-applicationsigned-exchange, for which I could have the existing editor's note call out draft-yasskin-httpbis-origin-signed-exchanges-impl.\r\n* A couple TBDs have actual numbers. I could move these into the main draft.\r\n   * mi-sha256 records must be <= 16kB.\r\n   * application/signed-exchange's header length must be <= 512kB.\r\n\r\n\r\nDid I miss any?",
          "createdAt": "2018-06-18T23:13:24Z",
          "updatedAt": "2018-06-18T23:13:24Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good, thanks!  We'll also watch https://github.com/martinthomson/http-mice/pull/8.  Moving some of the (tentative) actual numbers into the main draft sounds good too, or at least could be helpful for tracking changes from impl side (if you think having the change there is not harmful for future revisions).\r\nExplicitly cc-ing @nyaxt in case he has other or additional thoughts.",
          "createdAt": "2018-06-25T04:32:04Z",
          "updatedAt": "2018-06-25T04:32:04Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As:\r\n\r\n  - https://tools.ietf.org/html/draft-thomson-http-mice-02 is still in draft\r\n  - there's a `Digest` header defined in https://tools.ietf.org/html/rfc3230 and https://tools.ietf.org/html/rfc5843\r\n\r\nWhat do you think of proposing:\r\n\r\n  - `mi-sha256` as an additional digest algo to rfc5843\r\n  - introduce `*base64url*` in rfc3230\r\n\r\nThe outcome would be:\r\n\r\n```\r\nDigest: mi-sha256=*...*\r\n```\r\n\r\n",
          "createdAt": "2018-07-04T13:00:30Z",
          "updatedAt": "2018-07-04T13:00:30Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Feedback from @martinthomson https://github.com/martinthomson/http-mice/issues/11",
          "createdAt": "2018-07-05T12:43:29Z",
          "updatedAt": "2018-07-05T12:43:29Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@ioggstream Let's keep discussing the Digest change over in the MICE repo.",
          "createdAt": "2018-07-06T21:29:20Z",
          "updatedAt": "2018-07-06T21:29:20Z"
        }
      ]
    },
    {
      "number": 201,
      "id": "MDU6SXNzdWUzMjg2ODczNjY=",
      "title": "Define how client-generated requests match serialized requests in signed exchanges and bundles",
      "url": "https://github.com/WICG/webpackage/issues/201",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-dispatch-bundled-exchanges.html currently doesn't specify how a client decides which bundled request to use in any particular context. We need to define that.\r\n\r\nhttps://docs.google.com/document/d/1JdJkdY7cK2rD9JXbK75sSn069c0rhF9UnLQACBZ1OtY/edit# starts exploring the space but doesn't come to a conclusion yet.",
      "createdAt": "2018-06-01T23:19:53Z",
      "updatedAt": "2019-03-22T18:56:29Z",
      "closedAt": "2019-03-22T18:56:28Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#285 and #360 defined this matching algorithm for signed exchanges, and https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html gives the algorithm we'll use for bundles when their loading spec is written.",
          "createdAt": "2019-03-22T18:56:28Z",
          "updatedAt": "2019-03-22T18:56:28Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWUzMjkzMzM0MTA=",
      "title": "Clarify #load-metadata Step 12.2 Metadata field",
      "url": "https://github.com/WICG/webpackage/issues/202",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "cc: @jyasskin \r\n\r\nIn the step 12.2 of \"[Load a bundle's metadata](https://wicg.github.io/webpackage/draft-yasskin-dispatch-bundled-exchanges.html#load-metadata)\", the text says:\r\n> If \"name\"\u2019s Metadata field is \u201cNo\u201d, continue to the next triple.\r\n\r\nI couldn't find where a Metadata field for a \"name\" is. Can we clarify the text here?",
      "createdAt": "2018-06-05T07:30:26Z",
      "updatedAt": "2018-06-19T05:50:47Z",
      "closedAt": "2018-06-19T05:50:47Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Step 8\r\n\r\n> Let knownSections be the subset of the Section 6.2 that this client has implemented.\r\n\r\nlinks to https://wicg.github.io/webpackage/draft-yasskin-dispatch-bundled-exchanges.html#section-name-registry, which has a Metadata field. It's probably worth including the link in 12.2 also.",
          "createdAt": "2018-06-06T07:59:25Z",
          "updatedAt": "2018-06-06T07:59:25Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWUzMzA4NzA5ODI=",
      "title": "Q: referrer from signed http exchanged page",
      "url": "https://github.com/WICG/webpackage/issues/206",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "1, navigate to https://example.com/a.sxg\r\n2, a.sxg is signed by https://example.net so browser display it as https://example.net\r\n3, clicking the link on https://example.net\r\n\r\nin request of 3, which origin should on referrer header example.com (actual) or example.net (display) ?\r\n(spec seems not mention this: https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html)",
      "createdAt": "2018-06-09T09:38:26Z",
      "updatedAt": "2019-05-13T17:18:38Z",
      "closedAt": "2019-05-13T17:18:38Z",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "That should be example.net I believe.  Also example.net *is* the actual origin once UA is navigated to the exchange.  The [loading sketch in the explainer](https://github.com/WICG/webpackage/blob/master/explainer.md#signed-exchange-loading-sketch)  discusses some of these (while not clearly specifying details like referrers)",
          "createdAt": "2018-06-12T03:43:52Z",
          "updatedAt": "2018-06-12T03:43:52Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "is there any plan to add actual url(example.com) on request header like referrer ?",
          "createdAt": "2018-06-12T08:47:42Z",
          "updatedAt": "2018-06-12T08:47:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "There's no plan to add a new `Referer`-like header that identifies the physical URL of the referrer. It's always possible, of course, given a strong enough use case.",
          "createdAt": "2018-06-12T20:23:15Z",
          "updatedAt": "2018-06-12T20:23:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#433 discusses the architectural question here.",
          "createdAt": "2019-05-13T17:18:38Z",
          "updatedAt": "2019-05-13T17:18:38Z"
        }
      ]
    },
    {
      "number": 212,
      "id": "MDU6SXNzdWUzMzE4MDY1MzA=",
      "title": "Structured responses section for streaming loading",
      "url": "https://github.com/WICG/webpackage/issues/212",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "# Goal\r\n- Easier streaming consumption of large bundles.\r\n- Easier non-streaming consumption of the small bundles.\r\n\r\n# Background\r\nIn the current bundle spec, the structure of the responses section is allowed to be very flexible and not required to be a CBOR construct.\r\n\r\n## Streaming loading algorithm for current format\r\nWhen loading a bundle in a streamed fashion, currently the parser will:\r\n1. Consume the index section\r\n1. Sort the exchanges by their response range offset\r\n1. Consume the other sections up till the responses section\r\n1. Discard the bytes until it reaches the first exchange in the sorted list\r\n1. Buffer the bytes until it reaches the end of the the first exchange\r\n1. The first exchange becomes ready for its use:\r\n  1. Parse its responses header CBOR map\r\n  1. Read its payload\r\n1. Append bytes to the buffer until it reaches the end of the next item.\r\n1. The second exchange becomes ready for its use.\r\n1. ...\r\n\r\nSince there may be overlap in the response exchange, we need to keep around the original responses section in the buffer (which probably will reside on memory), since they may theoretically be used more than 1 time in a different CBOR interpretation. It is non-trivial to compute the \"done\" part of the responses section which are not referenced in later exchanges to partially free the original responses bytes buffer.\r\n\r\n## Non-streaming consumption of the small bundles\r\nIf the entire bundle is guaranteed to be a valid CBOR, it will become very easy to consume small packages which will easily fit in memory. If efficiency is not an issue, you can feed the entire package to CBOR parser, and consume the exchanges without implementing the full parsing algorithm.\r\n\r\nFor example, @irori created [a live web demo of unbundler](\r\nhttps://bundle-load-test.surge.sh/) which assumes that the bundler output a CBOR array as response section.\r\n\r\n# Proposals\r\n- Specify the structure of the responses section\r\n  - A valid CBOR array? \r\n- An index section entry references the response via array index, not offset\r\n  - Enforces the start of the response is aligned to the start of the item in the responses CBOR array\r\n  - Can save an alignment assert in the parser\r\n- Require the responses section to be always after the index section",
      "createdAt": "2018-06-13T01:12:40Z",
      "updatedAt": "2018-06-22T18:51:37Z",
      "closedAt": "2018-06-22T18:51:37Z",
      "comments": []
    },
    {
      "number": 214,
      "id": "MDU6SXNzdWUzMzIwODgzODE=",
      "title": "Report failure to validate a signed exchange",
      "url": "https://github.com/WICG/webpackage/issues/214",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This should use http://wicg.github.io/reporting/.",
      "createdAt": "2018-06-13T17:18:55Z",
      "updatedAt": "2019-03-19T00:02:55Z",
      "closedAt": "2019-03-19T00:02:55Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This also needs to deal with the client being offline, and with clients who are fetching a signed exchange to avoid censorship/surveillance.",
          "createdAt": "2018-06-13T17:22:49Z",
          "updatedAt": "2018-06-13T17:22:49Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "It might be worth addressing two different use cases:\r\n\r\n1. For distributors, to collect metrics on the efficacy of their validation algorithms and maybe trigger a removal of their cached copy. This would be on the outer exchange. If the SXG was prefetched first, it would only need to occur on the prefetch, not the navigation.\r\n\r\n2. For publishers, to collect metrics on the validity of their publishing mechanism and maybe trigger a blacklist of that URL until the bug can be fixed. This would be on the inner exchange, and only occur on navigation, not prefetch.\r\n\r\nThere's a third case where the embedder is different from the distributor, but it's probably OK to make a simplifying assumption for now.",
          "createdAt": "2018-08-16T19:26:21Z",
          "updatedAt": "2018-08-16T19:26:21Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Chromium implementation issue: https://crbug.com/910516",
          "createdAt": "2018-11-30T10:46:07Z",
          "updatedAt": "2018-11-30T10:46:07Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@igrigorik suggested me to integrate with network-error-logging.\r\nSo I submitted an issue on NEL's repo.\r\nhttps://github.com/w3c/network-error-logging/issues/99\r\n",
          "createdAt": "2018-12-06T07:13:49Z",
          "updatedAt": "2018-12-06T07:13:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this was solved by https://github.com/WICG/webpackage/pull/374.",
          "createdAt": "2019-03-19T00:02:55Z",
          "updatedAt": "2019-03-19T00:02:55Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "MDU6SXNzdWUzMzMxMTUwOTE=",
      "title": "Certificate chain in exchanges",
      "url": "https://github.com/WICG/webpackage/issues/221",
      "state": "OPEN",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "architecture",
        "bundled-exchanges"
      ],
      "body": "By using [data-url](https://fetch.spec.whatwg.org/#data-urls) in cert-url of [Signature Header](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-header), the [certificate chain](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cert-chain-format) can be contained in a Signed HTTP Exchange. It is useful for offline loading.\r\n\r\nBut having the same certificate chain in multiple Signed HTTP Exchanges in a Bundled HTTP Exchange is not efficient. We should have a way to contain one certificate chain per one host name for multiple Signed HTTP Exchanges in a Bundled HTTP Exchange.\r\n\r\nI filed this issue from the discussion in https://crrev.com/c/1102281.",
      "createdAt": "2018-06-18T02:16:54Z",
      "updatedAt": "2019-05-13T17:19:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWUzMzMxMjA3OTY=",
      "title": "Clarify what schemes should be allowed for URL fields in the signature",
      "url": "https://github.com/WICG/webpackage/issues/222",
      "state": "CLOSED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current Signed Exchange spec draft [says](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1) `cert-url` and `validity-url` should be [an absolute-URL string](https://url.spec.whatwg.org/#absolute-url-string), but that could potentially allow multiple schemes than http/https (e.g. file and ws), while it doesn't seem to include data: URL.  It looks we'd better clarify what schemes should be allowed there.",
      "createdAt": "2018-06-18T03:05:23Z",
      "updatedAt": "2018-06-21T02:30:43Z",
      "closedAt": "2018-06-21T02:30:43Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I *think* `data:` is allowed as an absolute-URL string by following the \"not an ASCII case-insensitive match for a special scheme\" branch, followed by the \"path-relative-scheme-less-URL string\" branch. That said, the real parsing for this should use the [URL parser](https://url.spec.whatwg.org/#url-parsing) with no base URL and then exclude fragments and filter for the schemes we want.\r\n\r\nI feel like the right set of schemes is https://fetch.spec.whatwg.org/#fetch-scheme, maybe subset by https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy, and maybe removing `file:` for the small risk of finding a way to read local files from the signed exchange.",
          "createdAt": "2018-06-18T21:26:21Z",
          "updatedAt": "2018-06-18T21:26:21Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/whatwg/url/issues/68 made me think it's not covered there but rather in fetch spec, but yeah the URL spec covers broader concepts so it might actually cover it.\r\n\r\nReg: https://fetch.spec.whatwg.org/#fetch-scheme I doubt we want to include `about`, `blob` and `filesystem` schemes either, unless we're considering dynamic package generation done by a JS code.  Loading data from these URL would basically need upper layer context than HTTP layer (e.g. we need a concept of Web origin there), and implementing it will become harder.",
          "createdAt": "2018-06-19T00:55:31Z",
          "updatedAt": "2018-06-19T00:55:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think `blob:` and `filesystem:` make sense for the newsreader app Jake demoed at I/O, where one SW stores signed exchanges for a bunch of other websites. That said, maybe we should assume bundles there, where the certificate can be stored inline.",
          "createdAt": "2018-06-19T05:49:51Z",
          "updatedAt": "2018-06-19T05:49:51Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWUzMzQ3MTA5NDM=",
      "title": "Rename id-ce-testCanSignHttpExchanges",
      "url": "https://github.com/WICG/webpackage/issues/229",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Came up in https://crrev.com/c/1103430/5/net/cert/asn1_util.cc#241:\r\n\r\n@sleevi:\r\n> Gotcha. $.02 (but not critical) is we should rename this to id-ce-canSignHttpExchangesDraft (or id-ce-draftCanSignHttpExchanges), it was the 'test' bit that caught me by surprise.\r\n\r\n@jyasskin What do you think?",
      "createdAt": "2018-06-22T01:12:55Z",
      "updatedAt": "2018-06-25T01:47:11Z",
      "closedAt": "2018-06-25T01:47:11Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "SGTM.",
          "createdAt": "2018-06-22T16:13:45Z",
          "updatedAt": "2018-06-22T16:13:45Z"
        }
      ]
    },
    {
      "number": 234,
      "id": "MDU6SXNzdWUzMzYzMDQ4MjU=",
      "title": "Bad mi-sha256 signature in example",
      "url": "https://github.com/WICG/webpackage/issues/234",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I expect\r\n\r\n- mi-sha256 signatures to be base64 encoded\r\n\r\n## instead\r\n\r\n- in examples, they are hexdigest",
      "createdAt": "2018-06-27T16:38:08Z",
      "updatedAt": "2018-07-02T22:41:03Z",
      "closedAt": "2018-07-02T22:41:03Z",
      "comments": []
    },
    {
      "number": 236,
      "id": "MDU6SXNzdWUzMzY3ODAxOTE=",
      "title": "Include a list of used permissions in signed part of bundles",
      "url": "https://github.com/WICG/webpackage/issues/236",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "@slightlyoff mentioned that we might want to have [third-party security reviewers](https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-01#section-2.2.3) check more or less stringently depending on which permissions an app uses. To do that, they'll need to be able to sign over the permissions they've checked for.",
      "createdAt": "2018-06-28T21:06:38Z",
      "updatedAt": "2019-05-13T17:20:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWUzMzY3ODg5MDE=",
      "title": "Idea: use of jws in Signature header",
      "url": "https://github.com/WICG/webpackage/issues/237",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "What do you think about using a JWS inside a signature headers instead of redefining a Subset of jws claims?\r\n\r\nWhich is the Right Place for Such a discussion?\r\n",
      "createdAt": "2018-06-28T21:36:45Z",
      "updatedAt": "2018-07-11T17:16:04Z",
      "closedAt": "2018-07-04T12:46:48Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "No, this should not use JWS. That would bring in a boatload of complexity and security risk (the JWT family of standards are rather famously problematic), as well as lose some of the important considerations such as domain separation between TLS, for no real gain.",
          "createdAt": "2018-06-28T22:26:35Z",
          "updatedAt": "2018-06-28T22:26:35Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Understood. \r\n\r\nI was just trying to generalize this mechanism (eg. to other keys, ...) to use it as a non-repudiation standard (eg. respect to https://tools.ietf.org/id/draft-cavage-http-signatures-10.html) \r\n\r\nSending `Signature` in every request/response would have done the job.\r\n\r\n\r\n",
          "createdAt": "2018-07-04T12:46:48Z",
          "updatedAt": "2018-07-04T12:46:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is the right place for the discussion though. :) I'd like to make sure we appropriately address your use cases without getting side-tracked on the question of what format to use to encode signatures.\r\n\r\nI'll point out that there are two kinds of generalization in here already:\r\n\r\n1. The [ed25519key](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-header) parameter allows basically the same header to work for https://github.com/mikewest/signature-based-sri.\r\n1. When the public key is vouched by an X.509 chain, it could be something other than a domain-trusted key. For example, I expect [third-party security reviewers](https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-01#section-2.2.3) to sign with X.509 keys signed by something other than a Web CA.\r\n\r\nNeither one addresses use in an HTTP *request*, and I do suspect that requests are different enough from responses that we shouldn't try to use the same header for both, but if you think we should, please suggest it in a new issue. (New to avoid the confusion with JWS.)",
          "createdAt": "2018-07-06T23:08:34Z",
          "updatedAt": "2018-07-06T23:08:34Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @jyasskin and thank you very much for your reply!\r\n\r\n> please suggest it in a new issue. (New to avoid the confusion with JWS.)\r\n\r\nI moved the discussion to  #248 ",
          "createdAt": "2018-07-10T09:07:16Z",
          "updatedAt": "2018-07-11T17:16:04Z"
        }
      ]
    },
    {
      "number": 238,
      "id": "MDU6SXNzdWUzMzY4MzkxMjk=",
      "title": "Critical-ness of CanSignHttpExchanges extension",
      "url": "https://github.com/WICG/webpackage/issues/238",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This came up in https://crrev.com/c/1111485.\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req\r\n\r\n> Conforming CAs MUST mark this extension as critical, and clients MUST NOT accept certificates with this extension in TLS connections (Section 4.4.2.2 of [I-D.ietf-tls-tls13]). \r\n\r\nIn Chrome, certificate path building and verification is performed using underlying operating systems' API. So, if the CanSignHttpExchanges extension is marked as critical, the OS API will reject the cert, until the OS supports CanSignHttpExchanges extension.\r\n\r\nCan we revisit the critical-ness of this extension? What's the security implication of not marking it as critical?\r\n\r\ncc: @sleevi @jyasskin ",
      "createdAt": "2018-06-29T02:13:37Z",
      "updatedAt": "2018-07-18T15:49:04Z",
      "closedAt": "2018-07-18T15:49:04Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Thanks for filing, @irori! My understanding is that this could still be a potential issue for Edge/Safari, unless browser updates are strictly locked to OS updates (since the crypto APIs are controlled by the OS)\r\n\r\nBy making it critical, it ensures no existing application can use Signed Exchange certs in TLS - that is, it forces key separation by technological means. This minimizes risk for cross-protocol issues, and for ecosystem issues, by ensuring that 100% of (well-behaving) clients will reject Signed Exchange certs being used for TLS.\r\n\r\nHowever, it presents its own set of compatibility issues - every certificate verifying application has to be updated to recognize this extension - and, in general, OS and cryptographic libraries don't let applications extensibly say \"I know and recognize this extension\", which means they also have to be updated to recognize this extension.\r\n\r\nIf we make it non-critical, then there's the risk that users can end up deploying their Signed Exchanges key on their TLS endpoint. This doesn't undermine the signature scheme of Signed Exchanges, but it does present certain operational risks - particularly, if your TLS edge is compromised and that key is compromised, folks can MITM users without requiring an active-network presence.\r\n\r\nWe can mitigate that risk by having Signed Exchange supporting TLS clients refuse to connect to TLS servers that present this extension. That is, if the certificate for an on-the-wire exchange contains this extension, fail the connection, in the same way that if a certificate in a signed exchange lacks this extension, the exchange fails validation. This creates the ecosystem disincentive to deploy your signed exchange key at your TLS server - but runs a chicken and egg problem of if a bunch of users do this before browsers start shipping signed exchanges, the ecosystem could end up more broken once they do ship exchanges.\r\n\r\nDespite this, I think making it non-critical is fine. For example, there's nothing (at present) preventing a CA from issuing a TLS server cert and a \"signed exchange server cert\" using the same underlying key and CSR - providing two certificates, one with the extension and one without. This has all of the same security problems I just described above, and is not mitigated by the critical extension.\r\n\r\nMore broadly, I think the best way we can capture this is by making sure we have a \"Security Considerations\" section that details the risks from improper key hygiene, which can cover these scenarios in depth. This is somewhat captured in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.6.4 and https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.6.2 but may be worth fleshing out more comprehensively as its own bit.",
          "createdAt": "2018-06-29T15:32:11Z",
          "updatedAt": "2018-06-29T15:32:11Z"
        }
      ]
    },
    {
      "number": 242,
      "id": "MDU6SXNzdWUzMzc5NjYwNjU=",
      "title": "Fallback URLs for forward compatibility",
      "url": "https://github.com/WICG/webpackage/issues/242",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Chromium would like to be able to ship these formats and then continue evolving them as they make their way through the standards process. QUIC attempts something like this by defining [\"invariants\"](https://tools.ietf.org/html/draft-ietf-quic-invariants-01), \"properties of the QUIC transport protocol that are expected to remain unchanged over time as new versions of the protocol are developed.\" To try the same thing in these specifications, it might make sense to put a fallback URL in a fixed place in both the signed exchange and bundles formats.\r\n\r\nFor signed exchanges, this would be the request URL that's currently encoded as the `:url` field in the [request headers](https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-04#section-3.2). For bundles, it would be the [`start_url`](https://www.w3.org/TR/appmanifest/#start_url-member) that's expected to be in the bundle's [manifest](https://tools.ietf.org/html/draft-yasskin-wpack-bundled-exchanges-00#section-3.2.2). In both cases, the value would be moved instead of copied to the new location, to avoid the possibility of inconsistencies.\r\n\r\nWhen the client receives an unknown version of the format (either too old or too new), it would redirect to the fallback URL. Offline users would be out of luck, but online ones would still be able to get the content.\r\n\r\nThis could also be accomplished using content negotiation on the `Accept` header, but that's a [joint that might rust shut](https://www.imperialviolet.org/2016/05/16/agility.html), so we should try to make things work even if it's rusty, if possible.\r\n\r\nThoughts?",
      "createdAt": "2018-07-03T16:12:13Z",
      "updatedAt": "2018-08-20T07:21:21Z",
      "closedAt": "2018-08-20T07:21:21Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me.\r\nBy \"redirect to the fallback URL\", do we expect the fallback URL to be a plain content (not signed exchange nor bundle)?",
          "createdAt": "2018-07-04T01:20:53Z",
          "updatedAt": "2018-07-04T01:21:05Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me. Are there any strategies to keep the joint oiled for the time being (e.g. through origin trial)? Are there any cross-cutting concerns (e.g. referrer, SW) that need hammering out?",
          "createdAt": "2018-07-04T02:16:27Z",
          "updatedAt": "2018-07-04T02:16:27Z"
        },
        {
          "author": "RByers",
          "authorAssociation": "MEMBER",
          "body": "Yes, this sounds brilliant, thank you! I hope that we can plan for doing breaking format changes over a release or two of Chrome. Ensuring that version mismatch results only in loss of performance (no ability to pre-fetch due to privacy constraints) and offline functionality instead of hard breakage is critical to enabling that.\r\n\r\nShould we perhaps also add the higher level principle here to the \"Requirements\" section? I.e. signed exchanges need to be designed to plan for breaking format changes without the need for user agents to know how to decode more than one version.",
          "createdAt": "2018-07-04T13:42:41Z",
          "updatedAt": "2018-07-04T13:42:41Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool idea.\r\n\r\nhttps://github.com/WICG/webpackage/issues/242#issuecomment-402335315 : given the context, I think it makes sense to require a plain response from the fallback URL. \r\n\r\nAssumption: IUC, said fallback URL would be the URL of the signed exchange's content / ..., right?\r\n\r\nMy original comment mentioned using a regular Accept header given the above assumption. But, I noticed Jeffrey's rusty joint comment. Confusion ensued :)",
          "createdAt": "2018-07-06T04:04:08Z",
          "updatedAt": "2018-07-06T04:07:25Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "+1, this sounds really neat to me.  Also +1 to mention something like this in the higher level principle section.  Reg: how this could work in play in clients/UAs I assume this'd still look like a (fancy) redirect, maybe less fancier than when the version was supported in the client.\r\n\r\nReg: version changes should the spec also note some recommendation about how long an old version of format should be supported by implementors?",
          "createdAt": "2018-07-06T05:19:54Z",
          "updatedAt": "2018-07-06T05:19:54Z"
        }
      ]
    },
    {
      "number": 243,
      "id": "MDU6SXNzdWUzMzgxMDE5OTY=",
      "title": "gen-certurl: make sct optional",
      "url": "https://github.com/WICG/webpackage/issues/243",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt",
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "> -sct should be optional (if not, we should fix gen-certurl), so we can omit it.\r\nThe `-sct` command-line flag of the `gen-certurl` tool is not currently optional",
      "createdAt": "2018-07-04T01:30:32Z",
      "updatedAt": "2018-07-09T05:14:39Z",
      "closedAt": "2018-07-09T05:14:39Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like this is already done in #196 :)",
          "createdAt": "2018-07-09T05:14:39Z",
          "updatedAt": "2018-07-09T05:14:39Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWUzMzgxMzEzNDM=",
      "title": "openssl review needed: go/signedexchange/README.md",
      "url": "https://github.com/WICG/webpackage/issues/245",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "irori",
        "davidben"
      ],
      "labels": [],
      "body": "@davidben @irori, would you take a look at self-signed cert generation instructions at https://github.com/WICG/webpackage/tree/master/go/signedexchange#creating-our-first-signed-exchange ?",
      "createdAt": "2018-07-04T05:05:10Z",
      "updatedAt": "2018-07-23T16:21:01Z",
      "closedAt": "2018-07-23T16:21:01Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "You probably should mention that `example.org` should (I assume) be replaced with your origin.\r\n\r\nDoes `<(echo \"1.3.6.1.4.1.11129.2.1.22 = ASN1:NULL\\nsubjectAltName=DNS:example.org\")` work? That prints a literal `\\n` for me, not a newline, and indeed the instructions cause my `openssl` to break. (Had you run this before? Maybe we use different shells? I'm just using bash.) Perhaps `<(echo \"1.3.6.1.4.1.11129.2.1.22 = ASN1:NULL\"; echo \"subjectAltName=DNS:example.org\")` \r\n\r\nOtherwise LGTM.",
          "createdAt": "2018-07-06T19:40:03Z",
          "updatedAt": "2018-07-06T19:40:03Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!\r\n\r\n> Maybe we use different shells?\r\n\r\nI was using zsh and the shell expandeds it. Added `-e` param so that echo will expand it if the shell doesn't.",
          "createdAt": "2018-07-09T04:04:43Z",
          "updatedAt": "2018-07-09T04:05:51Z"
        }
      ]
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWUzMzkyMzgzNTk=",
      "title": "Use case: non repudiation",
      "url": "https://github.com/WICG/webpackage/issues/248",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I wish signed exchanges to cover the non-repudiation use-case\r\n\r\nI wish to use the `Signature` header for non repudiation.\r\n\r\nExample:\r\n\r\n  - client sends a request with a Signature of given headers and payload\r\n  - server replies with a Signature that may contain e.g. the request hash\r\n\r\n### Non repudiation\r\nSee [nist 800-32](https://csrc.nist.gov/publications/detail/sp/800-32/final)\r\n\r\nAssurance that:\r\n\r\n  - the sender is provided with proof of delivery \r\n  - and that the recipient is provided with proof of the sender's identity \r\n\r\nso that neither can later deny having processed the data.\r\n\r\nTechnical non repudiation refers to the assurance a Relying Party has that if a public key is used to validate a digital signature, that signature had to have been made by the corresponding private signature key. \r\n\r\nLegal non-repudiation refers to how well possession or control of the private signature key can be established. \r\n\r\n### Elements for non repudiation\r\n\r\nNon repudiation via PKI is usually achieved adding\r\n\r\n1- in a request\r\n\r\n  - an hash of the request representation\r\n  - a signature of the above hash and further elements, eg: `issuer, audience, subject, issued_at, not_before, expires`, similar to JWS claims\r\n  - sender informations\r\n\r\n2- in a response\r\n\r\n  - an hash of the response representation\r\n  - a signature of the above hash and further elements, including an hash of the original request\r\n  - original request informations (eg. the hash) may be added in the response representation\r\n\r\n\r\nFurther informations may include:\r\n\r\n  - URL or content of the certificate to be used for validating the signature\r\n\r\n### Signature and Non Repudiation\r\n\r\nThere are various similarities b/w the informations contained in this spec and Non Repudiation.\r\n\r\n  - `Digest` can be used to guarantee the integrity of the representation (eg. with other values of Content-Encoding)\r\n  - `Signature` covers a list of `Signed-Headers` which may cover all necessary headers\r\n\r\n\r\n## References\r\n\r\nAn example of non-repudiation via HTTP Headers is defined in:\r\n\r\n-  [Berlin Group Financial API \u00a711](https://docs.wixstatic.com/ugd/c2914b_5351b289bf844c6881e46ee3561d95bb.pdf) based on [https://tools.ietf.org/html/draft-cavage-http-signatures-10](draft-cavage-http-signatures-10)\r\n\r\n\r\n## Questions from #88 \r\n\r\nAbout https://github.com/WICG/webpackage/pull/88#discussion_r152628889\r\n\r\n  - agree JWS security issues though not everybody agrees on deprecating JOSE [see those tweets on jose vs paseto]( https://twitter.com/ioggstream/status/972126134136647687)\r\n\r\n  -  support for different curves and rsa is useful: is `CSP-style` eg `key=ed25519-base64` that dangerous, considering that we should somewhat converge in some way? Clearly RSA would be insanely longer\r\n\r\n  - about algos, in your opinion will ed25519 replace all the other algos in the near future so that we should \"hardcode\" its name? Should we \"deprecate\" RSA signatures?\r\n\r\n  \r\n\r\n\r\n",
      "createdAt": "2018-07-08T16:22:38Z",
      "updatedAt": "2018-08-29T12:25:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The `Signature` header here is already somewhat useful for non-repudiation for the response, although I believe that non-repudiation has more to it than just a signature with a possibly-stolen private key.\r\n\r\nIs there a reason to use the same header definition for both requests and responses? The semantics are noticeably different, especially in that a response has a matching request that (I think) needs to be included in the signature, but a request stands alone.\r\n\r\nDo non-repudiable requests need to be done with an HTTP header, or should there be a signed blob in the request payload that conveys the real request?\r\n\r\n`key=ed25519-base64` would generally be fine. I currently have `ed25519key` in the parameters just to reduce the number of parsers we have to use. I'd expect to add new `otheralgorithmkey` parameters just as freely as we'd define new `key=` prefixes. RSA is forbidden in order to reduce the complexity of implementations and because there have been various attacks on multi-purpose RSA keys, which we side-step by banning RSA here. See the links from #181 for more discussion around this.\r\n\r\nThe difference between the existing `Digest` header and mice-02's `MI` header is just that `MI` allows the headers and payload to be checked and processed incrementally and with a fixed-size buffer, while `Digest` requires the recipient to receive and buffer the whole payload before checking or processing any of it. If MICE changes to specify the top-level hash in the Digest header, that'll still allow the fixed-size buffer.",
          "createdAt": "2018-07-09T22:51:13Z",
          "updatedAt": "2018-07-09T22:51:13Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> ... non-repudiation has more to it than just a signature with a possibly-stolen private key.\r\n\r\nCan you share your non-repudiation requirements? iiuc if you lose your private key there's nothing\r\nyou can do (other that demonstrate the `iat|exp` > revocation time).  See \"Legal non-repudiation\" NIST definition above.\r\n\r\n> Is there a reason to use the same header definition for both requests and responses?\r\n\r\nIt is fair to use two different headers. My goal is a shared RFC for non-repudiable request/responses.\r\n\r\nMy basic idea was just to use signed claims containing:\r\n\r\n  - basic claims (iss, sub, ... )\r\n  - further claims that could be legislation-dependant (nbf, body_hash, request_id, correlation_id, ...)\r\n\r\n> The semantics are noticeably different, .. a response has a matching request\r\n> that (I think) needs to be included in the signature, but a request stands alone.\r\n\r\nSee above claims body_hash, request_id, ... feedback welcome!\r\n\r\n> Do non-repudiable requests need to be done with an HTTP header, \r\n> or should there be a signed blob in the request payload that conveys the real request?\r\n\r\nI'd avoid encapsulation or json extension as this modifies the service interface.\r\nEg. \r\n\r\n  - I want to implement a non-repudiation wrapper around [google storage api](https://cloud.google.com/storage/docs/json_api/v1/objects/insert)\r\n  - using headers I just have to add/validate the signature header with limited changes to the google api interface\r\n\r\n> key=ed25519-base64 would generally be fine.\r\n\r\nok\r\n\r\n> ... I'd expect to add new otheralgorithmkey parameters ...as we'd define new key= prefixes\r\n\r\nOk.\r\n\r\n> RSA is forbidden... because there have been various attacks on multi-purpose RSA keys,\r\n> which we side-step by banning RSA here. See the links from #181\r\n\r\nInteresting\r\n\r\n> ... MI allows the headers and payload to be checked and processed incrementally\r\n\r\nAgree (I stubbed a crappy  MICE implementation in python, dunno if it's worth sharing).  \r\n\r\n>  Digest requires the recipient to receive and buffer the whole payload...\r\n\r\ndoesn't that depend on the hash algorithm? \r\n\r\n> If MICE changes to specify the top-level hash in the Digest header, \r\n> that'll still allow the fixed-size buffer.\r\n\r\nSo that's fine for you https://github.com/martinthomson/http-mice/issues/11 ?\r\n\r\nQuestions (I'll add to MICE):\r\n\r\n-  should the mi-sha256 header contain the buffer size?\r\n-  How can I validate the mi-sha256 hash of a given payload (eg. an existing file)?",
          "createdAt": "2018-07-10T10:17:01Z",
          "updatedAt": "2018-08-29T12:22:52Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I guess my \"non-repudiation has more to it\" comment was trying to ask for more precise requirements from you. I don't deal with non-repudiation, so I don't know what it should require. What do you and folks like the Berlin Group mean by \"non-repudiation\"? The [document you linked to](https://docs.wixstatic.com/ugd/c2914b_5351b289bf844c6881e46ee3561d95bb.pdf) doesn't mention key compromise or signing oracles. It mentions revocation, but doesn't describe how anyone discovers that a key is revoked. It mentions expiration, but seems to do so only around OAuth2 tokens and not signatures. There's just not enough there to pull requirements from. Actual security folks would probably notice even more ambiguities.\r\n\r\nI also don't know what it means to have a non-repudiation wrapper around the [google storage api](https://cloud.google.com/storage/docs/json_api/v1/objects/insert). It sounds like you'd need to store a duplicate copy of whatever was sent to the API, so that you could produce it with its signatures later?\r\n\r\nA \"request ID\" is probably not enough to tie a response to a particular request. It *could* be if we could trust everyone not to re-use IDs, even maliciously, but that's a tall order. It needs to be the bytes of the request itself, or their hash, which is difficult in HTTP where proxies modify the set of headers.\r\n\r\n`Digest:SHA-256=...` requires the whole payload to be buffered not because SHA-256 needs the whole payload at once to produce a hash\u2014it doesn't\u2014but because the program trying to consume the payload can't start processing the first byte until the whole hash is computed, which requires the last byte to be available before the first byte can be processed and released. `Digest:MI-SHA256=...` wouldn't have this problem because of the interaction between the content encoding and the digest algorithm.\r\n\r\nDiscussion about the details of the mi-* encoding does belong over in [martinthomson/http-mice](https://github.com/martinthomson/http-mice/issues?utf8=%E2%9C%93&q=is%3Aissue) and not here.",
          "createdAt": "2018-07-11T17:41:51Z",
          "updatedAt": "2018-07-11T17:41:51Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin \r\n\r\n> ... ask for more precise requirements from you\r\n\r\nThe [European eIDAS directive](https://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32014R0910&from=EN) defines requirements on electronic signatures. In the next days\r\nI will try summarize the parts which may be relevant to this discussion.\r\n\r\n> The document you linked to doesn't mention key compromise or signing oracles\r\n\r\nI can anticipate that a x509 signed document (eg. a .p7m) from an unrevoked key is considered non-repudiable. Eventual claims of frauds / compromised keys should be judged by a Court.\r\n\r\n> It mentions revocation, but doesn't describe how anyone discovers that a key is revoked.\r\n\r\nI will ask them clarification about their OCSP workflow (see eIDAS above).\r\n\r\n> It mentions expiration, but seems to do so only around OAuth2 tokens and not signatures. \r\n\r\nYes, I contacted them asking why not mimic JWT fields ;) I hope we all converge on this spec.\r\n\r\n> There's just not enough there to pull requirements from.\r\n> Actual security folks would probably notice even more ambiguities.\r\n\r\nThanks for your great analysis. I'll try to cover them all!\r\n\r\n> I also don't know what it means to have a non-repudiation wrapper around the google storage api.\r\n> It sounds like you'd need to store a duplicate copy of whatever was sent to the API, \r\n> so that you could produce it with its signatures later?\r\n\r\nThe idea was to:\r\n  - attach `Signature` headers to request and responses\r\n  - log those headers thus tracing the communications\r\n  - don't store a duplicate copy, just forward the data to the API after logging its signature\r\n\r\nImplementing this workflow with headers allows this process to be \"transparent\" and independent by the underlying API. Let's say I'd prefer to use http headers without altering the payload. \r\n\r\n\r\n> A \"request ID\" is probably not enough to tie a response to a particular request. \r\n\r\nRight, see the `request_hash` in the issue. The cbor-representation should do the job, right? https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cbor-representation \r\n\r\n> which is difficult in HTTP where proxies modify the set of headers.\r\n\r\niiuc if proxies mess with headers:\r\n\r\n  -  `Signature` is affected too, right?\r\n  -  the request/response flow won't finish successfully so you won't have your signed response, and the parties acknowledge there's an issue.\r\n\r\nThanks for all your time, again!",
          "createdAt": "2018-07-12T22:09:27Z",
          "updatedAt": "2018-08-29T12:25:12Z"
        }
      ]
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWUzNDA2NjgwMzE=",
      "title": "Accept-Signature specifies a syntax that violates the ABNF for sh-param-list",
      "url": "https://github.com/WICG/webpackage/issues/253",
      "state": "OPEN",
      "author": "CBonnell",
      "authorAssociation": "NONE",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "The Accept-Signature header (section 3.7) is defined as a sh-param-list. It also specifies that identifiers can be specified with a leading hyphen (\"-\") to denote a lack of support.\r\n\r\nHowever, the leading hyphen violates the ABNF for sh-param-list and identifier as defined in https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-07. Notably, sh-param-list has no provision to allow hyphens before the \"identifier\" (https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-07#section-3.3) and the identifier (https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-07#section-3.8) must begin with a lowercase letter.",
      "createdAt": "2018-07-12T14:40:42Z",
      "updatedAt": "2018-08-13T16:56:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWUzNDMyNTE0Njg=",
      "title": "Broken import with golang.org/x/net/http2 package ",
      "url": "https://github.com/WICG/webpackage/issues/268",
      "state": "CLOSED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It seems as if the `golang.org/x/net/http2` package moved its `lex` package elsewhere. Same issue, different repo logged here: https://github.com/ponzu-cms/ponzu/issues/245\r\n\r\n`$ go get -v github.com/WICG/webpackage/...`\r\n\r\n```github.com/WICG/webpackage (download)\r\nwarning: ignoring symlink /Users/averyharnish/go/src/github.com/WICG/webpackage/examples/pki\r\nFetching https://golang.org/x/net/lex/httplex?go-get=1\r\nParsing meta tags from https://golang.org/x/net/lex/httplex?go-get=1 (status code 200)\r\nget \"golang.org/x/net/lex/httplex\": found meta tag get.metaImport{Prefix:\"golang.org/x/net\", VCS:\"git\", RepoRoot:\"https://go.googlesource.com/net\"} at https://golang.org/x/net/lex/httplex?go-get=1\r\nget \"golang.org/x/net/lex/httplex\": verifying non-authoritative meta tag\r\nFetching https://golang.org/x/net?go-get=1\r\nParsing meta tags from https://golang.org/x/net?go-get=1 (status code 200)\r\ngolang.org/x/net (download)\r\npackage github.com/WICG/webpackage/go/bundle/cmd/gen-bundle\r\n\timports golang.org/x/net/lex/httplex: cannot find package \"golang.org/x/net/lex/httplex\" in any of:\r\n\t/usr/local/go/src/golang.org/x/net/lex/httplex (from $GOROOT)\r\n\t/Users/averyharnish/go/src/golang.org/x/net/lex/httplex (from $GOPATH)",
      "createdAt": "2018-07-20T21:23:02Z",
      "updatedAt": "2018-07-28T02:51:22Z",
      "closedAt": "2018-07-28T02:51:22Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes.\r\nWe are waiting for https://github.com/mrichman/hargo/pull/9 to get merged.",
          "createdAt": "2018-07-20T22:07:18Z",
          "updatedAt": "2018-07-20T22:07:18Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "Wasn't actually an issue, was running the go install command from the README which included a typo.  #275 fixes this",
          "createdAt": "2018-07-27T17:52:07Z",
          "updatedAt": "2018-07-27T17:52:07Z"
        }
      ]
    },
    {
      "number": 270,
      "id": "MDU6SXNzdWUzNDM4MzQ3OTM=",
      "title": " \"manifest\" section URL should first look if the resource is included in the bundle",
      "url": "https://github.com/WICG/webpackage/issues/270",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#manifest-section\r\n",
      "createdAt": "2018-07-23T23:49:24Z",
      "updatedAt": "2018-07-31T07:38:15Z",
      "closedAt": "2018-07-31T07:38:15Z",
      "comments": []
    },
    {
      "number": 276,
      "id": "MDU6SXNzdWUzNDU2MjU0Njc=",
      "title": "Make it easy to reuse the encoded header cbor when verifying signature",
      "url": "https://github.com/WICG/webpackage/issues/276",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We might want to adjust the signature message format so that it is easy to reuse the encoded headers when verifying the signature.\r\nThe `headers` required in Section 3.5 step 7.4.5 is a copy of the cbor appearing earlier. However, the fact that it appears inline in the map makes it hard for many cbor encoder implementation to reconstruct the cbor representation of the map without decode(encode(headers)), which is non-secure.\r\n\r\nMore discussion on the [crbug](https://bugs.chromium.org/p/chromium/issues/detail?id=863499)",
      "createdAt": "2018-07-30T06:19:51Z",
      "updatedAt": "2018-08-17T05:42:03Z",
      "closedAt": "2018-08-17T05:42:03Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#signed-message has an in-progress specification of how to build the signed message without re-encoding. I have no problem with making that easier.",
          "createdAt": "2018-07-30T19:58:25Z",
          "updatedAt": "2018-07-30T19:58:25Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm happy with your proposal.\r\n\r\nJust to enumerate alternatives:\r\n- Move `headers` out of the map #279\r\n    - slightly easier to implement, since we don't have to actually concat everything but construct hash func state but `headers` first, then progress the state with `headers` and then emit the final result\r\n- Don't use CBOR to encode {date, expires, headers, cert-sha256, validity-url}\r\n    - 64bit big-endian for date, expires\r\n    - bytes dump for cert-sha256, validity-url\r\n\r\nIIUC, the sole purpose of the `message` is to be used as input to signing algorithm, so we may not have to worry about its parsability so much and just focus on ease of its generation.",
          "createdAt": "2018-07-31T03:44:52Z",
          "updatedAt": "2018-07-31T03:44:52Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The CBOR map was originally designed to be clear about version changes, but that's now handled by the versioned context string. Given that, a pure concatenation of the input (making sure everything's length-prefixed or fixed length) may be better.",
          "createdAt": "2018-07-31T03:47:20Z",
          "updatedAt": "2018-07-31T03:47:20Z"
        }
      ]
    },
    {
      "number": 289,
      "id": "MDU6SXNzdWUzNTEwODgxNDU=",
      "title": "Feature detection and Accept: application/signed-exchanges headers",
      "url": "https://github.com/WICG/webpackage/issues/289",
      "state": "OPEN",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For feature detection some of us have been discussing that we could add Accept: application/signed-exchanges headers.  However given that SXG can have any resources it looks the UAs that support SXG always need to attach / append SXG type even when anything can be accepted, so it could look something like `Accept: application/signed-exchange;q=0.9,*/*;q=0.8` for default, non-specific subresource requests.  Would it be just or if we want to think about alternative feature detection mechanism (e.g. specific headers etc)?",
      "createdAt": "2018-08-16T07:33:00Z",
      "updatedAt": "2018-08-20T04:43:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 293,
      "id": "MDU6SXNzdWUzNTI4NTU5MTg=",
      "title": "Discourage centralization ",
      "url": "https://github.com/WICG/webpackage/issues/293",
      "state": "CLOSED",
      "author": "AhsanE",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In order to discourage centralization of the web, authors should have an incentive to keep their websites active.\r\n\r\nOne way is to make sure is that the author's server provides the client with the decryption key to decrypt the package.\r\n\r\ni.e:\r\n1. example.com signs and packages example.com/index.html and submits to google.com\r\n2. google.com distributes example.com/index.html \r\n3. users downloads example.com/index.html from google.com\r\n4. user connects to example.com for the index.html's decryption key\r\n5. browser decrypt the index.html package supplied by google with the decryption key supplied by example.com\r\n\r\nThis all should be optional to the author. Some authors might only want google.com to distribute the html/css/js for faster loading but ensure that the client has a first party contact with example.com too.  \r\n\r\nIt is already possible to do the same with javascript, but the web should also provide a native way to do this. \r\n",
      "createdAt": "2018-08-22T08:40:36Z",
      "updatedAt": "2018-09-16T13:12:34Z",
      "closedAt": "2018-09-16T13:12:34Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I\u2019m afraid this is confusing some of the cryptography, such as the notion\nof a \u201cdecryption\u201d key.\n\nIt sounds like you aren\u2019t concerned about the cryptography, per se, but\nwant to ensure origins remain in control, correct? This property is already\nmaintained, by requiring fresh signatures over the package, which are\ndistributed by `example.com` in your example. Does that address your use\ncase?\n",
          "createdAt": "2018-08-22T13:13:57Z",
          "updatedAt": "2018-08-22T13:13:57Z"
        },
        {
          "author": "AhsanE",
          "authorAssociation": "NONE",
          "body": "I am no expert in cryptography, but used a non-detailed overview to convey what I wanted (had no other words to explain) and know if it is practical. \r\n\r\n> It sounds like you aren\u2019t concerned about the cryptography, per se, but\r\nwant to ensure origins remain in control, correct? \r\n\r\nWe'll if control means that user can only access the site/content after pinging to the author's server, in this case \"example.com\".",
          "createdAt": "2018-08-22T14:16:52Z",
          "updatedAt": "2018-08-22T14:38:56Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I see. That's the opposite of the design goal for the use cases.",
          "createdAt": "2018-08-22T14:56:04Z",
          "updatedAt": "2018-08-22T14:56:04Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@AhsanE A signed exchange package is valid for up to 7 days. (The exact period is controllable by the author, but this is expected to be >0 days.)\r\n\r\nThis means that users may see content that appears to be from `example.com` (i.e. the URL bar of the browser reads `example.com`) up to 7 days after `example.com` has lost network connectivity and completely disappeared from the net.",
          "createdAt": "2018-08-22T16:28:34Z",
          "updatedAt": "2018-08-22T16:28:34Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "For all practical purposes the content in a web packages also has to be available at the packaged URL. If you load a package in a browser and hit reload, it would be a terrible user experience if the content wouldn't load again. While this certainly can happen theoretically, any practical use would try to avoid this problem as much as possible.",
          "createdAt": "2018-08-22T16:54:23Z",
          "updatedAt": "2018-08-22T16:54:23Z"
        }
      ]
    },
    {
      "number": 295,
      "id": "MDU6SXNzdWUzNTMzNDkyOTM=",
      "title": "Recommend that a browser \"reload\" contacts the logical origin",
      "url": "https://github.com/WICG/webpackage/issues/295",
      "state": "OPEN",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Recommend that if the user hits the \"reload\" button in their browser, the browser will contact the logical origin (i.e. the URL that is visible in the browser's URL bar) to determine freshness.\r\n\r\n(Currently not specified, but seem to be the expected behaviour, see e.g. [1](https://github.com/WICG/webpackage/issues/149#issuecomment-374011263), [2](https://github.com/WICG/webpackage/issues/293#issuecomment-415102090), [3](https://github.com/WICG/webpackage/issues/300#issuecomment-456581227).) ",
      "createdAt": "2018-08-23T12:01:00Z",
      "updatedAt": "2019-02-01T11:13:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "lidel",
          "authorAssociation": "NONE",
          "body": "I feel a better design would be an ability to opt out from a forced freshness check for specified time. \r\nThink how it is possible to cache HSTS settings in the browser by including a `max-age` option:\r\n\r\n- \"pressing F5 in web browser _does not contact the logical origin_ until snapshot from SXG is `max-age` old\"\r\n  - `max-age=0` would mean that pressing \"reload\" button will always contact the logical origin\r\n  - Shift+F5 would ignore SXG just like it ignores the cache\r\n\r\nThe `max-age` approach is more flexible and accounts for use cases where people want to avoid sending HTTP traffic to logical origin by any means necessary (cc https://github.com/ipfs/in-web-browsers/issues/121 @jimpick )",
          "createdAt": "2018-11-05T13:04:37Z",
          "updatedAt": "2018-12-14T13:46:15Z"
        }
      ]
    },
    {
      "number": 297,
      "id": "MDU6SXNzdWUzNTQ1NjQ2NTE=",
      "title": "Specify how to handle too-long URLs?",
      "url": "https://github.com/WICG/webpackage/issues/297",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new spec allows fallbackURLs up to 65536 bytes long, but several existing browsers have lower limits than that. Perhaps the fetch spec should say how browsers should respond if the fallbackUrl is too long, or alternatively specify a minimum length they must support. Otherwise, browsers may behave differently (e.g. network error, redirect to fallback URL, or display a trimmed URL). Or is this already covered by some other part of Fetch?",
      "createdAt": "2018-08-28T04:15:09Z",
      "updatedAt": "2018-11-28T20:06:39Z",
      "closedAt": "2018-11-28T20:06:39Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This should be more general than just web packaging. For example, a too-long 302 redirect should behave the same way. I've filed whatwg/fetch#841 to track it.",
          "createdAt": "2018-11-28T20:06:18Z",
          "updatedAt": "2018-11-28T20:06:18Z"
        }
      ]
    },
    {
      "number": 299,
      "id": "MDU6SXNzdWUzNTY2NTg3MDE=",
      "title": "Loading: Nested Signed Exchange is rejected only when comes with v=",
      "url": "https://github.com/WICG/webpackage/issues/299",
      "state": "OPEN",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just want to make sure this is what is intended: in Step 26 https://wicg.github.io/webpackage/loading.html#parsing-b1 says:\r\n\r\n> If parsedExchange\u2019s response's status is a redirect status or the signed exchange version of parsedExchange\u2019s response is not undefined, return a failure.\r\n\r\nThis means if an inner response's content type is `application/signed-exchange` but without `v=` UA just lets it go (and result in downloading for navigations, or may just return the outer response for other cases). This might be what the spec intends but felt a bit unclear so filing this issue. /cc @irori ",
      "createdAt": "2018-09-04T05:34:27Z",
      "updatedAt": "2018-11-17T00:23:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I didn't explicitly consider that case, but since the [HTTP fetch monkeypatch](https://wicg.github.io/webpackage/loading.html#mp-http-fetch) only processes a resource as a signed exchange if the `application/signed-exchange` mime type includes a `v=` parameter, this doesn't seem harmful.\r\n\r\nDo you think we should explicitly block `application/signed-exchange` without the `v=` to make mistakes easier to diagnose? I'd be inclined to do that in the Fetch monkeypatch rather than in the bit that blocks nested redirects, so that people hit it sooner.",
          "createdAt": "2018-11-17T00:23:29Z",
          "updatedAt": "2018-11-17T00:23:29Z"
        }
      ]
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWUzNTY2NjIyNTU=",
      "title": "Should newer HTTP cache contents override signed exchange's inner content?",
      "url": "https://github.com/WICG/webpackage/issues/300",
      "state": "OPEN",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the loading spec says the newer HTTP cache contents should override the stashed exchange if the cached one is newer, but discussing this with @sleevi we suspected this may not make a lot sense if the underlying HTTP cache is NOT single-keyed (e.g. is double-keyed / partitioned).  So the question here is how much real benefit would this behavior have, and if we should really implement it.\r\n\r\n(Context: Chromium currently doesn't implement this behavior, and no plan to do so until this issue is clarified or we see a real, clear benefit)",
      "createdAt": "2018-09-04T05:54:08Z",
      "updatedAt": "2019-01-22T22:05:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think it has some value in blocking some downgrade attacks when loading a signed exchange for a top-level origin the user has already visited, even if cross-origin subresources are double-keyed. It'll help less for catching downgrades of common subresources being re-used by a new site.\r\n\r\nWhat did you and @sleevi think it breaks?",
          "createdAt": "2018-11-17T00:42:05Z",
          "updatedAt": "2018-11-17T00:42:05Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this could still be beneficial for top-level origins.  Reg: what it may break: I think @sleevi's stance has been more about we'll need more investigation to see if it'd make the best sense.  And from impl pov: doing so simply requires more work, so we want to be very careful on the decisions.  (Interested in if @sleevi has renewed thoughts)",
          "createdAt": "2018-11-19T07:57:42Z",
          "updatedAt": "2018-11-19T07:57:42Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is the suggestion here that clicking on the reload button in the browser UI might not necessarily result in a network request to the origin if SXG content is available locally? This is the opposite of #295, FWIW.\r\n\r\nAlso, is there any difference between reload mechanisms? (The service worker spec requires [force reload to go to network in all cases](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#shift-reload).)",
          "createdAt": "2019-01-22T21:29:04Z",
          "updatedAt": "2019-01-22T21:29:04Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@ithinkihaveacat No, a browser reload should always try to check the origin. This issue is about whether, if you've recently visited the origin, but a distributor offers you an older SXG, whether you use the newer from-origin content or the older SXG.",
          "createdAt": "2019-01-22T22:05:03Z",
          "updatedAt": "2019-01-22T22:05:03Z"
        }
      ]
    },
    {
      "number": 303,
      "id": "MDU6SXNzdWUzNTY5NTU3Mzk=",
      "title": "signedexchange: decoder for version b2",
      "url": "https://github.com/WICG/webpackage/issues/303",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-04T20:02:48Z",
      "updatedAt": "2020-03-23T06:05:11Z",
      "closedAt": "2020-03-23T06:05:11Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "`dump-signedexchange` can already decode the b2 format.",
          "createdAt": "2020-03-23T06:05:11Z",
          "updatedAt": "2020-03-23T06:05:11Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "MDU6SXNzdWUzNjEwMzk1OTg=",
      "title": "Update loading spec per b2",
      "url": "https://github.com/WICG/webpackage/issues/310",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/loading.html makes several mentions of `b1`. It will need to updated to refer to `b2`, as well as changes to where inner URL and payload digest are found, per the changes in #296 ([change log](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#change-log)). Possibly other things?",
      "createdAt": "2018-09-17T20:52:52Z",
      "updatedAt": "2019-01-18T21:21:19Z",
      "closedAt": "2019-01-18T21:21:19Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "As long as Chrome supports loading both `b1` and `b2`, I'd like https://wicg.github.io/webpackage/loading.html#mp-http-fetch to accept both.\r\n\r\nhttps://github.com/WICG/webpackage/pull/285 has a change to use the fixed location of the URL to handle the 'anything else' case, which you'll want to adopt if you update for `b2` anywhere else.",
          "createdAt": "2018-09-18T22:48:08Z",
          "updatedAt": "2018-09-18T22:48:08Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Chrome M70+ has dropped support for `b1` and only supports `b2`.",
          "createdAt": "2018-09-19T01:50:00Z",
          "updatedAt": "2018-09-19T01:50:00Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Removing `b1` from the loading spec sounds good then.",
          "createdAt": "2018-09-19T02:15:54Z",
          "updatedAt": "2018-09-19T02:15:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #328.",
          "createdAt": "2019-01-18T21:21:19Z",
          "updatedAt": "2019-01-18T21:21:19Z"
        }
      ]
    },
    {
      "number": 314,
      "id": "MDU6SXNzdWUzNjUwNzg0NzU=",
      "title": "Integrity record size limit is missing from b2 snapshot",
      "url": "https://github.com/WICG/webpackage/issues/314",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt"
      ],
      "labels": [],
      "body": "[The snapshot](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#signature-validity) is missing the following text, present in the [spec](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html):\r\n\r\n\"If validating integrity using the selected header field requires the client to process records larger than 16384 bytes, return \u201cinvalid\u201d.\"\r\n\r\nHowever, this limitation still exists in the [implementation](https://cs.chromium.org/chromium/src/content/browser/loader/merkle_integrity_source_stream.cc?l=18&rcl=591949795043a818e50aba8a539094c321a4220c).",
      "createdAt": "2018-09-29T00:26:35Z",
      "updatedAt": "2018-09-29T00:26:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 315,
      "id": "MDU6SXNzdWUzNzE1ODUzNTU=",
      "title": "How to open a .wpk file?",
      "url": "https://github.com/WICG/webpackage/issues/315",
      "state": "CLOSED",
      "author": "jimbojetlag",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I noticed there are some sample .wpk file sin https://github.com/WICG/webpackage/tree/master/examples . Do browsers open these files at this point? If not, how are they supposed to be opened by the end user?",
      "createdAt": "2018-10-18T15:24:24Z",
      "updatedAt": "2018-10-25T08:03:50Z",
      "closedAt": "2018-10-25T08:03:50Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi! The examples in that directory are quite out-of-date. You can take a look at the instructions at https://github.com/WICG/webpackage/tree/master/go/signedexchange for how to generate a signed exchange, host it on a server, and browse it. They are intended for the end user, but for now, you need to enable an experimental flag in Chrome to view them.",
          "createdAt": "2018-10-18T23:12:32Z",
          "updatedAt": "2018-10-18T23:12:32Z"
        },
        {
          "author": "jimbojetlag",
          "authorAssociation": "NONE",
          "body": "That executable generates a .sxg file, when I tried to open it in Chrome by drang and drop, Chrome simply downloaded it.\r\n\r\nHow is it possible to share this package offline?",
          "createdAt": "2018-10-19T00:03:54Z",
          "updatedAt": "2018-10-19T00:03:54Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "With the current implementation, I believe sharing offline requires the receiver to host an HTTPS server on localhost. (i.e. Tools need to be built to enable this use-case.)\r\n\r\nHowever, the spec specifically calls attention to the [local disk use-case](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#privacy-considerations), so I imagine this is a temporary situation. It may be worth adding support for `file:` in the [loading spec](https://wicg.github.io/webpackage/loading.html), though that may be difficult given that the Fetch spec (that it monkeypatches) leaves `file:` [\"as an exercise for the reader\"](https://fetch.spec.whatwg.org/#scheme-fetch).",
          "createdAt": "2018-10-19T00:35:39Z",
          "updatedAt": "2018-10-19T18:01:16Z"
        },
        {
          "author": "jimbojetlag",
          "authorAssociation": "NONE",
          "body": "The specs have use cases for sharing _unsigned_ offline packages, which would not need a secure server.\r\n\r\nThink of it as how people would download and share html pages today, only instead of an index page + N asset files, it would be a single standard format package.",
          "createdAt": "2018-10-19T14:25:32Z",
          "updatedAt": "2018-10-19T14:25:32Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah yes, AFAIK, as of today, only a [snapshot of the signed exchanges spec](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html) is implemented in Chrome, and not the bundled exchanges spec.",
          "createdAt": "2018-10-19T15:45:59Z",
          "updatedAt": "2018-10-19T15:45:59Z"
        },
        {
          "author": null,
          "authorAssociation": "NONE",
          "body": "What's happening with Firefox and edge in terms of adaption or flags ?\r\nIs there a name for this functionality to allow checking on CanIUse website ?",
          "createdAt": "2018-10-24T07:35:49Z",
          "updatedAt": "2018-10-24T07:35:49Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think it's on CanIUse, but it is here: https://www.chromestatus.com/feature/5745285984681984\r\n\r\nThat has some info on adoption, but I don't know if it's up-to-date; I'm primarily a consumer of the standard and haven't been doing much of the standardization work. I'll defer to others on that.",
          "createdAt": "2018-10-25T00:21:33Z",
          "updatedAt": "2018-10-25T00:21:33Z"
        },
        {
          "author": "RByers",
          "authorAssociation": "MEMBER",
          "body": "Web packaging is really still being designed and implemented - with a focus on the privacy-preserving pre-rendering use case in Chrome. It's really nowhere near the point of being a useful feature for end users.",
          "createdAt": "2018-10-25T05:17:16Z",
          "updatedAt": "2018-10-25T05:17:16Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your interest!\r\n\r\nIn terms of *public* signals, the entry on chromestatus.com is up to date.\r\nStay tuned.",
          "createdAt": "2018-10-25T08:03:50Z",
          "updatedAt": "2018-10-25T08:03:50Z"
        }
      ]
    },
    {
      "number": 316,
      "id": "MDU6SXNzdWUzNzE3NDkwMTY=",
      "title": "Delete examples/ directory (except for firebase.json)",
      "url": "https://github.com/WICG/webpackage/issues/316",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "twifkak"
      ],
      "labels": [],
      "body": "The files in there (except for firebase.json) are out of date and caused some confusion in #315.",
      "createdAt": "2018-10-18T23:15:58Z",
      "updatedAt": "2018-11-14T21:55:17Z",
      "closedAt": "2018-11-14T21:55:17Z",
      "comments": []
    },
    {
      "number": 319,
      "id": "MDU6SXNzdWUzNzUzNzc3MTk=",
      "title": "dump-signedexchange: Implement signature verification",
      "url": "https://github.com/WICG/webpackage/issues/319",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "irori"
      ],
      "labels": [],
      "body": "Add a reference implementation of [signature validity](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity) check in go/signedexchange, and use it from `dump-signedexchange`.\r\n\r\nIt would help implementors of other signed exchange generators. Also, it will enable us to add roundtrip (sign-and-verify) tests.\r\n",
      "createdAt": "2018-10-30T08:46:48Z",
      "updatedAt": "2018-10-30T11:11:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM",
          "createdAt": "2018-10-30T11:11:49Z",
          "updatedAt": "2018-10-30T11:11:49Z"
        }
      ]
    },
    {
      "number": 321,
      "id": "MDU6SXNzdWUzNzYwMDk4NjM=",
      "title": "Reflecting the URL leads to content sniffing bugs",
      "url": "https://github.com/WICG/webpackage/issues/321",
      "state": "CLOSED",
      "author": "molnarg",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When a server returns a web package in the application/signed-exchange format, it'll embed the request URL in the returned binary blob in the fallbackUrl field. Depending on the server implementation, the encoding of bytes of the URL might vary. Some implementation might choose the easiest solution, which is to just reflect whatever representation the client sends.\r\n\r\nThis is problematic, because this gives attackers an easy injection point within the first few bytes of the file, which can be turned into code running in the victim origin using content sniffing. The Adobe PDF parser for example ignores the unknown prefix bytes if it finds a valid PDF signature within the first 1kb of the file.\r\n\r\nThe \"x-content-type-options: nosniff\" header instruct browsers to not do content sniffing, but plugins can choose to (and in many cases do) ignore them. Because of this, the usual suggestion is to host partially user controlled binary files only on sandbox domains (when it's not possible to sufficiently escape the user controlled parts, which is usually not the case).\r\n\r\nThis demo page is not vulnerable to this, because it requires a special Accept request header: https://azei-package-test.com/ Clients that can't interpret the web package format will never send this header, so they'll never see the signed exchange file format.\r\n\r\nOne solution would be to use some kind of encoding for all reflected values (e.g. base64) to avoid introducing a valuable injection point in the first place.",
      "createdAt": "2018-10-31T15:06:48Z",
      "updatedAt": "2018-12-19T22:43:35Z",
      "closedAt": "2018-12-19T22:43:35Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "(Just chiming in to provide some detail; don't consider my response authoritative as I'm not an owner of this repo.)\r\n\r\nIf I'm reading correctly, the spec defines [fallbackUrl as an absolute URL](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#application-signed-exchange) and then defines [absolute URLs per the URL parser](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#terminology), and the URL parser requires [only URL code points in the path](https://url.spec.whatwg.org/#path-state), and here are [the URL code points](https://url.spec.whatwg.org/#url-code-points).\r\n\r\nOf course, even if the URL is base64-encoded, the attacker could modify the length of the fallback URL to manipulate those 2 bytes.",
          "createdAt": "2018-10-31T18:52:05Z",
          "updatedAt": "2018-10-31T18:52:05Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @sleevi @jyasskin \r\n\r\nThanks for filing the issue.\r\n\r\nWould you mind expanding the attack scenario details?\r\nIf I understand this correctly, the assumptions are:\r\n1. A Target HTTP User-Agent (more generic than web browsers, incl. plugins) runs a content parser that ignores unknown prefix bytes.\r\n2. A SXG server which returns SXG of `fallbackUrl` which reflects the request URL enough to inject an attack vector.\r\n3. It is useful for the attack vector to run on an HTTP origin which the SXG server runs on.\r\n\r\nI buy that 1 and 3 can theoretically hold but I'm not sure if 2 holds, since there are multiple restriction to the URL.\r\n- The server should not return a sxg unless the absolute url is valid, incl. the URL code points restriction @twifkak mentioned.\r\n- The server need to host the resource, otherwise the server should not be able to generate a sxg since it would not have valid certificates for the resource.\r\n  - Still, bad servers may still create sxgs containing a 404 response. We may want to disallow sxg enclosing non-2XX responses in the format spec.",
          "createdAt": "2018-11-01T01:48:22Z",
          "updatedAt": "2018-11-01T01:48:22Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@molnarg Note that the fallback URL isn't supposed to be reflected from the request URI. Instead, it's the canonical location of the signed content, which should be completely under the control of the server.\r\n\r\nThat said, I can't rule out a naive server making the mistake you're suggesting. Such a server might also reflect data from some HTTP request headers (as Google did in https://crbug.com/901477#c18) into an early part of the signed exchange, which provides another injection point a couple hundred bytes in. For that matter, even the start of the body may be within the first 1kB, if the server chooses to reflect attacker-controlled data into the body, but I suppose that's a vulnerability even without signed exchanges, and so out of the scope of your complaint.\r\n\r\nI assume that base64-encoding works because nearly all file signatures include a byte outside the base64 alphabet? Even then, does the attacker-controlled URL length get around that restriction?\r\n\r\n@twifkak, unfortunately, the URL parser doesn't limit its accepted input to URL code points. Code points outside that range cause non-fatal [validation errors](https://url.spec.whatwg.org/#validation-error), and then the parser continues. [`%PDF-`](https://en.wikipedia.org/wiki/List_of_file_signatures) is accepted and can be reflected back out. This prevents the server's parsing of the request URL from protecting us, even if the server has a conformant URL parser.\r\n\r\nSo, the question is what to do. I don't like the idea of base64-encoding every bit of data that a server might reflect, but it's a last-resort option.\r\n\r\nWould it be acceptable to just add a security consideration that servers must not naively reflect the request URL or request headers and then sign them? ",
          "createdAt": "2018-11-28T23:31:43Z",
          "updatedAt": "2018-11-28T23:33:34Z"
        }
      ]
    },
    {
      "number": 322,
      "id": "MDU6SXNzdWUzNzYyMjI2NTM=",
      "title": "Reserve a HTTP/2 Error Code in the Error Code Registry",
      "url": "https://github.com/WICG/webpackage/issues/322",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "(filing an open issue so we wouldn't forget)\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.8.5",
      "createdAt": "2018-11-01T01:51:58Z",
      "updatedAt": "2018-11-01T01:51:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWUzNzYyNTQ2OTY=",
      "title": "Specify how intermediates should load Signed Exchanges with validityUrl",
      "url": "https://github.com/WICG/webpackage/issues/324",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt",
        "jyasskin",
        "kinu"
      ],
      "labels": [],
      "body": "The current loading spec talks about UAs which do not involve checking validityUrl data.\r\n\r\nWe expect intermediates to check validityUrl data, and we need to specify how their SXG fetch would work.",
      "createdAt": "2018-11-01T05:01:53Z",
      "updatedAt": "2018-11-01T05:01:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 335,
      "id": "MDU6SXNzdWUzNzg0OTgyMzM=",
      "title": "Does the spec say that duplicate header names are disallowed?",
      "url": "https://github.com/WICG/webpackage/issues/335",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt"
      ],
      "labels": [],
      "body": "I don't see it in https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#application-signed-exchange or https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation or https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#canonical-cbor. (Ditto for latest draft.)\r\n\r\nBut AFAICT this is required by chromium, and IIRC it was in a previous version of this spec.",
      "createdAt": "2018-11-07T22:33:21Z",
      "updatedAt": "2019-07-11T17:13:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate headers are disallowed from CBOR map not allowing duplicate key entries.\r\n\r\nI'll add a \"normative\".",
          "createdAt": "2018-11-07T23:13:49Z",
          "updatedAt": "2018-11-07T23:13:49Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, right. Yeah, an informative section would help.",
          "createdAt": "2018-11-08T04:10:26Z",
          "updatedAt": "2018-11-08T04:10:26Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "AFAICT, CBOR map allows duplicate key entries. https://tools.ietf.org/html/rfc7049#section-3.7 says:\r\n\r\n>    A CBOR-based protocol should make an intentional decision about what\r\n>    to do when a receiving application does see multiple identical keys\r\n>    in a map.  The resulting rule in the protocol should respect the CBOR\r\n>    data model: it cannot prescribe a specific handling of the entries\r\n>    with the identical keys, except that it might have a rule that having\r\n>    identical keys in a map indicates a malformed map and that the\r\n>    decoder has to stop with an error.\r\n\r\nhttps://www.rfc-editor.org/errata/eid4964 doesn't change that. Seems like this needs a normative comment.",
          "createdAt": "2019-07-11T17:13:24Z",
          "updatedAt": "2019-07-11T17:13:24Z"
        }
      ]
    },
    {
      "number": 336,
      "id": "MDU6SXNzdWUzNzg5ODc2OTM=",
      "title": "Transfer-Encoding in inner-exchange's response header.",
      "url": "https://github.com/WICG/webpackage/issues/336",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've noticed the `Transfer-Encoding` header usage in SXG inner response headers.\r\nWe should specify how it will work.\r\n\r\n- Option 1) Add to banned headers list.\r\n- Option 2) Clarify in the loading spec that...\r\n  - Option 2.a) Only compression schemes are allowed (Ban only `Transfer-Encoding: chunked`)\r\n  - Option 2.b) They are ignored.\r\n\r\nNote that Chromium ToT currently ~~ignores them. Which means, the response bytes are treated as they are raw bytes and doesn't go through decompressor/unchunking.~~ supports them",
      "createdAt": "2018-11-09T01:34:59Z",
      "updatedAt": "2019-01-10T17:31:58Z",
      "closedAt": "2019-01-10T17:31:58Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "My personal preference is Option 1, since we always mice encode the response stream.\r\n\r\nIf we want compression, then we can compress the outer-response.\r\nI think this aligns with the current bundling story where we want raw response bytes in order to achieve cross-resource compression.",
          "createdAt": "2018-11-09T01:38:22Z",
          "updatedAt": "2018-11-09T01:38:22Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like Chromium ToT actually supports `Transfer-Encoding: Chunked` inside the mice stream.",
          "createdAt": "2018-11-09T04:27:43Z",
          "updatedAt": "2018-11-09T04:27:43Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "How do/should inner and outer `Transfer-Encoding` interact?",
          "createdAt": "2018-11-09T04:29:04Z",
          "updatedAt": "2018-11-09T04:29:04Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to rejecting it.\r\n\r\nChromium accepting it is odd. Perhaps a quirk of MICE not being implemented at the same layer as other Content-Encodings? Usually TE is removed before CE. Also the usual reason to do chunked TE is if the sender does not know the size ahead of time and is streaming the output. But the MICE encoder cannot work streaming anyway since the blocks are processed in reverse.",
          "createdAt": "2018-11-09T21:34:15Z",
          "updatedAt": "2018-11-09T21:34:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "It might make sense to align what packaging does with what we're discussing in https://github.com/httpwg/http-core/issues/165",
          "createdAt": "2018-11-11T04:10:35Z",
          "updatedAt": "2018-11-11T04:10:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We should definitely try to align packaging with httpwg/http-core#165. Specifically, I'm guessing that [non-cached headers](https://github.com/httpwg/http-core/issues/165#issuecomment-436287105) should be banned in signed exchanges. \r\n\r\nThe only set from https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc I'm not sure of is `kSecurityStateHeaders`, primarily `strict-transport-security` since `public-key-pins` is deprecated or gone. That seems like a header that shared caches would include, but the browser's private cache wants to omit.\r\n\r\nI don't see an obvious argument to ban the non-updated headers. Is there one?\r\n\r\nIn the long run, I'd like to just delegate this list of non-cached headers to [draft-ietf-httpbis-cache](https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html), but I don't see any such list there now, so I'm happy to just list headers in this spec for now.",
          "createdAt": "2018-11-16T23:24:44Z",
          "updatedAt": "2018-11-16T23:24:44Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Considering that `kSecurityStateHeaders` are potentially state modifying in\nthe same way that cookies are, it seems they should also be prohibited.\n",
          "createdAt": "2018-11-16T23:30:59Z",
          "updatedAt": "2018-11-16T23:30:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi I'll split that decision out to #340 to avoid derailing this discussion.",
          "createdAt": "2018-11-17T00:10:34Z",
          "updatedAt": "2018-11-17T00:10:34Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "From this thread + #340, I'm convinced that we should ban all headers in https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc .",
          "createdAt": "2018-11-21T04:37:14Z",
          "updatedAt": "2018-11-21T04:37:14Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm hoping to delegate to the \"don't cache these\" list in https://github.com/httpwg/http-core/pull/181, which will take a bit longer to get into the HTTP draft. ",
          "createdAt": "2018-11-30T22:03:07Z",
          "updatedAt": "2018-11-30T22:03:07Z"
        }
      ]
    },
    {
      "number": 338,
      "id": "MDU6SXNzdWUzNzg5OTEzMTI=",
      "title": "Cache-Control header / past Expires in inner exchange's response.",
      "url": "https://github.com/WICG/webpackage/issues/338",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've seen SXG inner exchange's response headers containing:\r\n```\r\nCache-Control: no-cache, no-store\r\nExpires: <past date>\r\n```\r\n\r\nHow should we handle these cases?\r\n- Option 1) Add them to the banned headers list\r\n- Option 2) As proposed by @mnot in #326, enforce the [response cacheability algorithm](https://httpwg.org/specs/rfc7234.html#response.cacheability) in verification steps.\r\n\r\nMy preference is Option 2.",
      "createdAt": "2018-11-09T01:53:26Z",
      "updatedAt": "2018-11-09T02:05:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Why should these apply to verification? If a non-signed response comes with these response headers, the browser will display it, but not cache it. I would assume the same behavior would apply here.",
          "createdAt": "2018-11-09T02:05:31Z",
          "updatedAt": "2018-11-09T02:05:31Z"
        }
      ]
    },
    {
      "number": 340,
      "id": "MDU6SXNzdWUzODE4MDMyNjg=",
      "title": "Consider banning Strict-Transport-Security and Public-Key-Pins headers",
      "url": "https://github.com/WICG/webpackage/issues/340",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In https://github.com/WICG/webpackage/issues/336#issuecomment-439560219, @sleevi suggests that we add the contents of [`kSecurityStateHeaders`](https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc?l=77) to https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#stateful-headers.\r\n\r\n@sleevi, you're worried about attackers targeting sites that use a set of HSTS domains as an authentication cookie?\r\n\r\nHTTP will define some set of headers that shared caches don't store, and I'd like to just blindly ban that list in signed exchanges, but I do see an argument to be a bit stricter in signed exchanges, since with signed exchanges the attacker doesn't have to be the first to visit the cache.\r\n\r\nOn the other hand, to be vulnerable to this attack, a site has to be using HSTS in a user-hostile way.",
      "createdAt": "2018-11-17T00:10:08Z",
      "updatedAt": "2019-01-10T17:31:58Z",
      "closedAt": "2019-01-10T17:31:58Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "And, to be clear, the benefit of allowing `Strict-Transport-Security` in signed exchanges is that if we ban it, users can't bootstrap to HSTS before they're online, which increases the time they're vulnerable to network attackers.",
          "createdAt": "2018-11-17T00:16:34Z",
          "updatedAt": "2018-11-17T00:16:34Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "And the risk (in addition to the general risk of state modification via\nSXG) is that someone can serve a maxAge=0 to unset it, undetectably, and\nrepeatedly for the lifetime of the signature.\n",
          "createdAt": "2018-11-17T00:18:31Z",
          "updatedAt": "2018-11-17T00:18:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Do sites generally serve `maxAge=0` for some resources when they want most of their site to be served over HTTPS? If not, this seems similar to the risk of a vulnerability being repeatably served for the lifetime of its signature.",
          "createdAt": "2018-11-17T00:26:45Z",
          "updatedAt": "2018-11-17T00:26:45Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I don\u2019t know if it matters much what sites do, compared to the cognitive\ncost it would bring with reasoning.\n\nFor example, is maxAge relative to the first signature or the most recent\nsignature? If maxAge in SXG is <= what is served via TLS, then what is the\neffective maxAge? If the client has a stored maxAge > the SXG maxAge, what\nis the effective maxAge? Questions like this are all introduced by allowing\nstateful side-effects.\n\nCombine that with things like HSTS for subdomains, and could you use a\ncombination of SXG delivery to set a stateful identifier? That would be\ndependent on whether SXGs (or bundles) could be delivered for subresources,\nand how the browser handles subresources loads for HSTS. However, throw in\nportals and it continues to get more confusing.\n",
          "createdAt": "2018-11-17T00:33:01Z",
          "updatedAt": "2018-11-17T00:33:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Consider also a site that deployed HSTS and then had to turn it off for whatever reason. Normally one can assume that, after maxAge + timeHeaderWasDisabled, the entry will have expired in all clients. That property relies on liveness from TLS.",
          "createdAt": "2018-11-20T18:50:36Z",
          "updatedAt": "2018-11-20T18:50:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm surprised that https://tools.ietf.org/html/rfc6797#section-6.1.1 says \"The REQUIRED \"max-age\" directive specifies the number of seconds, after the reception of the STS header field, ...\" instead of incorporating the initial-age calculation specified in https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html#age.calculations.\r\n\r\nGiven that, I'm convinced by @davidben's point. (If the initial-age calculation were included, @sleevi's point would be more convincing. :smiley:)",
          "createdAt": "2018-11-20T19:06:27Z",
          "updatedAt": "2018-11-20T19:06:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess it's because HSTS is not really a property of the resource and really just connection metadata that we jam into HTTP responses because we have nothing better to do with it. :-) If you believe in that interepretation, then you would want the timer to start at the current time. Indeed if there's a site out there where no resource had been updated for years, all the age headers would be old and effectively disable HSTS.\r\n\r\nThough I suspect the actual answer is this was an oversight. :-) Otherwise it'd probably have done a better job of marking it a hop-by-hop header and all that.",
          "createdAt": "2018-11-20T19:22:46Z",
          "updatedAt": "2018-11-20T19:22:46Z"
        }
      ]
    },
    {
      "number": 342,
      "id": "MDU6SXNzdWUzODI4Mjk1ODQ=",
      "title": "Define the browser algorithm for determining cacheability of status codes",
      "url": "https://github.com/WICG/webpackage/issues/342",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "#326 leaves the loading spec more restrictive than the RFC draft in terms of which status codes are allowed. We should figure out how browsers implement https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html#response.cacheability and refer to that from the loading spec instead of blindly requiring only status 200, or we should tighten the RFC draft to require just that status.",
      "createdAt": "2018-11-20T20:10:38Z",
      "updatedAt": "2018-11-27T06:54:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "FYI:\r\n  https://wpt.fyi/results/fetch/http-cache/status.html?label=stable&aligned\r\nand:\r\n  https://github.com/httpwg/http-core/issues/120",
          "createdAt": "2018-11-27T06:54:43Z",
          "updatedAt": "2018-11-27T06:54:43Z"
        }
      ]
    },
    {
      "number": 347,
      "id": "MDU6SXNzdWUzODg1NDcxMDY=",
      "title": "Extend link HTTP header to support subresource signed exchange loading",
      "url": "https://github.com/WICG/webpackage/issues/347",
      "state": "OPEN",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I want to introduce two new fields in application/signed-exchange format.\r\n - Alternative-Signed-Exchange-Subresources map in unsigned field.\r\n - Allowed-Alternative-Signed-Exchange-Subresources list in signed field.\r\n \r\n## Problem\r\nCurrently content publishers can sign their HTML contents using their own private keys. User Agents (UAs) can trust the signed contents as if the contents are served from the publisher\u2019s origins even if they are served from other distributors\u2019 origins. The signed contents can be served from any distributors\u2019 origins. But if the publisher wants to serve subresources such as scripts and images from the distributors\u2019 origin, the publisher needs to change the subresource URLs in the HTML to point to each distributors\u2019 URL and need to sign for each distributor. The proposed two fields can solve this problem.\r\n\r\n**Alternative-Signed-Exchange-Subresources map:**\r\nA map from the original subresource requests to the SXG URLs. This field is not signed. So the distributor can change this field to point to their URLs.\r\n\r\n**Allowed-Alternative-Signed-Exchange-Subresources list:**\r\nThe subresource URL list which can be served using SXG instead of fetching the original URL. This field is signed by the publisher. So the distributor can\u2019t change this field.\r\n\r\n## Example\r\n**Publisher:** https://publisher.example/article_1.html\r\n```\r\n  <script src=\"framework.js\"></script>\r\n  <img src=\"article_1.jpg>\r\n```\r\n\r\n**SXG in Publisher:** https://publisher.example/article_1.html.sxg\r\n```\r\n[\r\n  // URL\r\n  'https://publisher.example/article_1.html',\r\n  // Signature\r\n  'sig1: sig=*...; integrity=\"digest/mi-sha256\";cert-url=\"https://publisher.example/cert\"',\r\n  // [New field] Alternative-Signed-Exchange-Subresources\r\n  // The key of the mapping may need Accept headers info in order to enable content\r\n  // negotiation (e.g. for WebP).\r\n  [\r\n    [{':url': 'https://publisher.example/framework.js', 'accept': '*/*'},\r\n     'https://publisher.example/framework.js.sxg'],\r\n    [{':url': 'https://publisher.example/article_1.jpg', 'accept': '*/*'},\r\n     'https://publisher.example/article_1.jpg.sxg']\r\n  ],\r\n  // Signed headers\r\n  [\r\n    { ':method': 'GET', 'accept': '*/*' },\r\n    {\r\n      ':status': '200',\r\n      // [New field]\r\n      ':allowed-alternative-signed-exchange-subresources':\r\n          '\"https://publisher.example/framework.js\",'\r\n          '\"https://publisher.example/article_1.jpg\"',\r\n      'content-encoding': 'mi-sha256-03',\r\n      'content-type': 'text/html; charset=utf-8',\r\n      'digest': 'mi-sha256-03=....'\r\n    },\r\n  ],\r\n  // Payload body\r\n  '<html><body>...'\r\n]\r\n```\r\n\r\n**SXG in Distributor:** https://distributor.example/article_1.html.sxg\r\n```\r\n[\r\n  // URL\r\n  'https://publisher.example/article_1.html',\r\n  // Signature\r\n  'sig1: sig=*...; integrity=\"digest/mi-sha256\";cert-url=\"https://distributor.example/publisher.example/cert\"',\r\n  // [New field] Alternative-Signed-Exchange-Subresources\r\n  [\r\n    [{':url': 'https://publisher.example/framework.js', 'accept': '*/*'},\r\n     'https://distributor.example/publisher.example/framework.js.sxg'],\r\n    [{':url': 'https://publisher.example/article_1.jpg', 'accept': '*/*'},\r\n     'https://distributor.example/publisher.example/article_1.jpg.sxg']\r\n  ],\r\n  // Signed headers (Same as the SXG in Publisher)\r\n  [\r\n    { ':method': 'GET', 'accept': '*/*' },\r\n    {\r\n      ':status': '200',\r\n      // [New field]\r\n      ':allowed-alternative-signed-exchange-subresources':\r\n          '\"https://publisher.example/framework.js\",'\r\n          '\"https://publisher.example/article_1.jpg\"',\r\n      'content-encoding': 'mi-sha256-03',\r\n      'content-type': 'text/html; charset=utf-8',\r\n      'digest': 'mi-sha256-03=....'\r\n    },\r\n  ],\r\n  // Payload body (Same as the SXG in Publisher)\r\n  '<html><body>...'\r\n]\r\n```\r\n\r\n## How UAs should work\r\n- When the user opens the SXG in the distributor, the UA must check the signature using the certificate in https://distributor.example/publisher.example/cert. (This is the existing behavior)\r\n- The UA processes the script tag and the img tag and decides to fetch the \"framework.js\" and the image \"article_1_small.jpg\".\r\n- Instead of fetching the original URL in publisher.example, UA should fetch the SXG files in distributor.example after checking the `Alternative-Signed-Exchange-Subresources` field and the `Allowed-Alternative-Signed-Exchange-Subresources` field.\r\n- If the original URL is not in the `Allowed-Alternative-Signed-Exchange-Subresources` field, the UA must fetch the original URL. This is intended to avoid the subresource monitoring attack.\r\n- If the original URL\u2019s origin is not same as the signed origin of the main SXG (publisher.example), the UA must fetch the original URL. This restriction is intended to avoid providing a way of tracking.\r\n- UAs should handle the preload link header in the signed response header in the same way. (ex: `link: <https://example.com/framework.js>;rel=\"preload\";as=\"script\"`)\r\n\r\n## Subresource monitoring attack\r\nWe need the signed `Allowed-Alternative-Signed-Exchange-Subresources` to avoid the subresource monitoring attack like this:\r\n- A publisher generates a SXG of a html which shows the user's icon using JS. `icon.src = USER_ID + '.png';`\r\n- An attacker sets the mapping info like this: `{ 'example.com/a.png': 'attacker.com/a.png.sxg', 'example.com/b.png': 'attacker.com/b.png.sxg', ....}`\r\n- If UA fetches the SXG of png when the image tag is added, the attacker can know the USER_ID. Even if UA only uses the prefetched SXG, the attacker distributor can intentionally delay returning the SXGs one by one to see when the load actually finishes by monitoring the onload event, therefore can know the USER_ID.\r\n\r\n## Tracking using subresource SXG\r\nWe need to prohibit the SXG loading for cross-origin subresources to avoid the user tracking like this:\r\n- A publisher sets one subresource to the `Allowed-Alternative-Signed-Exchange-Subresources` field (https://tracking.example/id.js)\r\n- The distributor server can let the publishers\u2019 site know about the user\u2019s ID (ABCD1234) by changing the `Alternative-Signed-Exchange-Subresources` field.\r\n - tracking.example/id.js points to tracking.example/ABCD1234.sxg (body is `const id='ABCD1234';)\r\n\r\nTracking is still possible even if we prohibit cross-origin subresources using the following logic. But this is more difficult.\r\n- A publisher sets 30 subresources to the `Allowed-Alternative-Signed-Exchange-Subresources` field (https://publisher.example/00, 01, ... 29)\r\n- The publisher prepares 60 files, 00_0.sxg (body is 0), 00_1.sxg (body is 1),  01_0.sxg (body is 0), 01_1.sxg (body is 1)...\r\n- The distributor server can let the publishers\u2019 site know about the user\u2019s ID in binary digits by changing the `Alternative-Signed-Exchange-Subresources` field.\r\n  - publisher.example/00 points to 00_0.sxg or 00_1.sxg\r\n  - publisher.example/01 points to 01_0.sxg or 01_1.sxg\r\n  - ....\r\n- This logic provides a way of user tracking of 2^30 users.\r\n",
      "createdAt": "2018-12-07T08:10:30Z",
      "updatedAt": "2019-09-27T04:30:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "The security implications of this are non-obvious, and may benefit from being fleshed out more. In particular, I always get uncomfortable when seeing new unsigned field - they make it dangerous for parsers and give attackers a lot of opportunities, some non-obvious.\r\n\r\nMy first thought was about substitution attacks - what prevents an attacker from modifying the URL for `framework.js.sxg` to point to `other-different-payload.js.sxg`. I'm assuming here that the answer is the SXG is strongly-bound to the request URL, and thus changing it to `other-different-payload.js.sxg` will cause it to fail when it attempts to match the request to the SXG - is that correct?\r\n\r\nThe next question is what the implications are of a version substitution of the SXG subresource. In this case, `framework.js.sxg` (v1) is served instead of the intended `framework.js.sxg` (v2). The best I can tell is the intent is to address that through the SXG signature expiration (that is, stop signing v1). This would be a 'new' problem, in as much as SXG-subresource-fetches and SXG-caching-inner-resources are not well-defined (or implemented) enough to be a thing that folks would rely on, even though they would also introduce these problems.\r\n\r\nThe final question is what the implications are of creating a bidirectional communication path. As you note, by virtue of the Allowed-Alternative-Signed-Exchange-Subresources, this potentially creates a communication channel between the distributor and the publisher when loading the SXG. The privacy implications are profound (as noted), but also the security implications of what happens if sites begin to rely on this communication channel, but that it is, by nature, unauthenticated (i.e. `publisher.example` can't tell whether it was `distributor.example` setting those bits or whether it was `evil-distributor.example` setting those bits.",
          "createdAt": "2018-12-07T21:44:44Z",
          "updatedAt": "2018-12-07T21:44:44Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> My first thought was about substitution attacks - what prevents an attacker from modifying the URL for framework.js.sxg to point to other-different-payload.js.sxg. I'm assuming here that the answer is the SXG is strongly-bound to the request URL, and thus changing it to other-different-payload.js.sxg will cause it to fail when it attempts to match the request to the SXG - is that correct?\r\n\r\nYes. UAs must check the subresource SXG's inner URL.\r\n\r\n> The next question is what the implications are of a version substitution of the SXG subresource. In this case, framework.js.sxg (v1) is served instead of the intended framework.js.sxg (v2). The best I can tell is the intent is to address that through the SXG signature expiration (that is, stop signing v1). This would be a 'new' problem, in as much as SXG-subresource-fetches and SXG-caching-inner-resources are not well-defined (or implemented) enough to be a thing that folks would rely on, even though they would also introduce these problems.\r\n\r\nPublishers must be careful to add subresources to the `Allowed-Alternative-Signed-Exchange-Subresources` field.\r\nIf framework.js.sxg (v1) has a security bug and the signature of SXG is still valid, the publisher must change the URL of framework.js.\r\n\r\n> The final question is what the implications are of creating a bidirectional communication path. As you note, by virtue of the Allowed-Alternative-Signed-Exchange-Subresources, this potentially creates a communication channel between the distributor and the publisher when loading the SXG. The privacy implications are profound (as noted), but also the security implications of what happens if sites begin to rely on this communication channel, but that it is, by nature, unauthenticated (i.e. publisher.example can't tell whether it was distributor.example setting those bits or whether it was evil-distributor.example setting those bits.\r\n\r\nIntroducing a new CSP directive `sxg-src` could be a solution for that.\r\nFor example, if the signed response header has `Content-Security-Policy: sxg-src https://distributor.example`, the sxg on `evil-distributor.example` should be blocked.",
          "createdAt": "2018-12-11T08:43:15Z",
          "updatedAt": "2018-12-11T08:43:15Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> Introducing a new CSP directive sxg-src could be a solution for that.\r\nFor example, if the signed response header has `Content-Security-Policy: sxg-src https://distributor.example`, the sxg on `evil-distributor.example` should be blocked.\r\n\r\nI don't think this addresses the substance of the concern. I was not attempting to say \"We should grant control to page authors\", I was trying to frame it as \"We need to carefully reason about the security implications of allowing this\". The goal of framing it like that is to understand if we're proposing a mechanism that is default-insecure, whether that's desirable in and of itself, and what solutions might exist.\r\n\r\nEven more concretely: I'm not convinced we should be displaying the publisher origin if we allow for arbitrary content injection by the distributor, which having such a channel would imply. I think we need to carefully reason about that. This statement is based on seeing the harm come from code-signing systems that allow for (limited) content injection/manipulation - such as Authenticode or macOS Bundles. It's certainly true that such unauthenticated injection allows for things developers perceive interesting and useful use cases - for example, injecting whether or not a user has opted-in to metrics collection services on the download page for an executable (e.g. Chrome) - but it's also true that such methods have caused a substantial number of security vulnerabilities (e.g. https://docs.microsoft.com/en-us/security-updates/securityadvisories/2014/2915720 )",
          "createdAt": "2018-12-11T16:12:34Z",
          "updatedAt": "2018-12-11T16:12:34Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "How about having the each signatures of subresources in `Allowed-Alternative-Signed-Exchange-Subresources` to prevent distributors from injecting arbitrary content?\r\n\r\n```\r\n[\r\n  // URL\r\n  'https://publisher.example/article_1.html',\r\n  // Signature\r\n  'sig1: sig=*...; integrity=\"digest/mi-sha256\";cert-url=\"https://distributor.example/publisher.example/cert\"',\r\n  // [New field] Alternative-Signed-Exchange-Subresources\r\n  [\r\n    [{':url': 'https://publisher.example/framework.js', 'accept': '*/*'},\r\n     'https://distributor.example/publisher.example/framework.js.sxg'],\r\n    [{':url': 'https://publisher.example/article_1.jpg', 'accept': '*/*'},\r\n     'https://distributor.example/publisher.example/article_1.jpg.sxg']\r\n  ],\r\n  // Signed headers (Same as the SXG in Publisher)\r\n  [\r\n    { ':method': 'GET', 'accept': '*/*' },\r\n    {\r\n      ':status': '200',\r\n      // [New field]\r\n      ':allowed-alternative-signed-exchange-subresources':\r\n          '\"https://publisher.example/framework.js\" '\r\n            '*MEUCIQDX...=* '  // The first signature of framework.js.sxg\r\n            '*MEQCIGjZ...=*,'  // The second signature of framework.js.sxg\r\n          '\"https://publisher.example/article_1.jpg\" '\r\n            '*lGZVaJJM...=* '  // The first signature of article_1.jpg.sxg\r\n            '*MEYCIQCN...=*',  // The second signature of article_1.jpg.sxg\r\n      'content-encoding': 'mi-sha256-03',\r\n      'content-type': 'text/html; charset=utf-8',\r\n      'digest': 'mi-sha256-03=....'\r\n    },\r\n  ],\r\n  // Payload body (Same as the SXG in Publisher)\r\n  '<html><body>...'\r\n]\r\n```",
          "createdAt": "2018-12-12T07:57:06Z",
          "updatedAt": "2018-12-12T07:57:06Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "As I mentioned previously, it's probably more useful to analyze the problem before we try to step forward to solve the problem. The latest proposed approach has, for example, the same deficiency w/r/t user tracking - if you treat `framework.js` as 'bit 0', `article_1.jpg` as 'bit 1', etc, then the existence of the two signatures lets you smuggle a bit at a time from the distributor by allowing the distributor to select which signature to use, which allows altering the content (e.g. `framework.js` having 0 bytes vs 1 byte).\r\n\r\nThis is why it's helpful to first make sure we've analyzed the problem, clearly stated it, and made sure it's not, in fact, a pre-existing problem, so then we can look at solution spaces or make informed tradeoff decisions.",
          "createdAt": "2018-12-12T14:18:06Z",
          "updatedAt": "2018-12-12T14:18:06Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "IIUC, the core goal here is that if `publisher.example` has signed all of `article1.html`, `framework.v2.js`, `article1.400x300.jpg`, and `article1.1600x1200.jpg`, we'd like `searchengine.example` to be able to prefetch the appropriate subset of those for their user to be able to view the article without any new fetches to `publisher.example`. (See [Privacy-Preserving Prefetch](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#private-prefetch).)\r\n\r\n[Bundles](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html) solve this, but they require `searchengine.example` to subset the bundle to omit whichever of `article1.400x300.jpg` or `article1.1600x1200.jpg` is the wrong size for the user. This ability to subset gives, I think, the same communication abilities @sleevi's worried about here, but Bundles do give us a straightforward way to prevent version skew. The Bundles implementation is also farther off than @horo-t, et. al. think they could implement this extension to the SXG format.\r\n\r\nWe've talked at times about adding a way to specify [external dependencies](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#external-dependencies) for bundles. The `Allowed-Alternative-Signed-Exchange-Subresources` list is similar to what we'd need for that.\r\n\r\nThe `Alternative-Signed-Exchange-Subresources` map fundamentally, tells the browser \"for this dependency that the SXG or bundle said you need, you can fetch it from this URL.\" I don't particularly like the idea of requiring the distributor to modify the SXG file itself in order to communicate that. Would a response header work? e.g.\r\n\r\n```http\r\nContent-Location: https://distributor.example/article1.html.sxg\r\nLink: <https://distributor.example/framework.v2.js.sxg>; anchor=\"https://publisher.example/framework.v2.js\"; rel=alternate_tbd\r\n```",
          "createdAt": "2018-12-12T22:38:31Z",
          "updatedAt": "2018-12-12T22:40:22Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin Your mention of bundles made me realize that there may be another implication of this - cache probing. That is, if the distributor can modify the URL used to fetch subresources, can it infer or learn what sub-resources the user may already have (cached or loaded) by seeing which requests are *not* made?\r\n\r\nThat is, if I fetch `article1.html.sxg` from `distributor.example`, and it refers to `publisher.example/resources/a.jpg`, `distributor.example` does not learn whether or not the resource was cached or loaded - because the user contacts `publisher.example` to fetch that resource. In the Bundles case, if the user issues a range request (for the bundle), then `distributor.example` can learn which resources are needed. The same would apply with this sort of modification - whether or not `distributor.example/sxgs/publisher.example/resources/a.jpg.sxg` was fetched reveals whether or not the user needed `publisher.example/resources/a.jpg`. This is similar to the privacy implications mentioned by @horo-t with regards to user IDs, but isn't mitigated by the `Allowed-Alternative...` solution.",
          "createdAt": "2018-12-12T22:48:11Z",
          "updatedAt": "2018-12-12T22:48:11Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "In what ways is the recommended value for `Allowed-Alternative-Signed-Exchange-Subresources` different from the value we'd recommend for a [`Link: <>; rel=preload`](https://w3c.github.io/preload/) header in the signed response? Could we just have the browser use the signed preloads for this purpose?",
          "createdAt": "2018-12-12T22:51:22Z",
          "updatedAt": "2018-12-12T22:51:22Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi Cute. I agree cache probing is a risk, but I think the UA can solve it the same way we solve other cache-based tracking attempts: we fetch the resource redundantly if the server we're fetching it from shouldn't know whether it's already cached. Edit: And searchengine.example needs to take that cost into account when deciding whether to offer a SXG for any particular resource.",
          "createdAt": "2018-12-12T22:54:51Z",
          "updatedAt": "2018-12-12T22:59:55Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin Sure, I didn't explicitly come out and say 'double-keyed caching', but I think that's the assumption. But that's something unique, in this case, because it's not double-keying based on the resource's logical origin (`publisher.example`) but instead based on the physical origin (`distributor.example`). Introducing that sort of split - where some of the security properties use physical and some logical - would benefit from that sort of analysis about the implications.",
          "createdAt": "2018-12-12T22:57:31Z",
          "updatedAt": "2018-12-12T22:57:31Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> In what ways is the recommended value for `Allowed-Alternative-Signed-Exchange-Subresources` different from the value we'd recommend for a [`Link: <>; rel=preload`](https://w3c.github.io/preload/) header in the signed response? Could we just have the browser use the signed preloads for this purpose?\r\n\r\nWouldn't it be both signed and unsigned preloads?\r\n\r\nThat is, `https://distributor.example/publisher.example/article_1.html.sxg` would `Link: <https://distributor.example/framework.v2.js.sxg>; rel=preload` when serving the SXG (i.e. the unsigned part), but then within the SXG, you'd do\r\n\r\n```\r\n  // Signed headers (Same as the SXG in Publisher)\r\n  [\r\n    { ':method': 'GET', 'accept': '*/*' },\r\n    {\r\n      ':status': '200',\r\n      ':link', '<https://publisher.example/framework.v2.js>; rel=preload',\r\n      ...\r\n    }\r\n   ...\r\n  ]\r\n```\r\n\r\nOr did I misunderstand the question?",
          "createdAt": "2018-12-12T23:02:20Z",
          "updatedAt": "2018-12-12T23:02:20Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "My `Link: <>; rel=preload` question was more for @horo-t than @sleevi. \ud83d\ude04 We have to look at the signed one for the same reasons `Allowed-...` has to be signed in the original post.\r\n\r\nI think it's more complex than \"double-keying\" or even \"physical\" vs \"logical\". We need to find a way to describe which entities (origins or [organi](https://developers.google.com/digital-asset-links/v1/getting-started)[zations](https://developer.apple.com/documentation/uikit/core_app/allowing_apps_and_websites_to_link_to_your_content/enabling_universal_links)) know that which other entities have asked the profile to download a URL. I think each entry in the cache winds up annotated with a list of entities that are allowed to know it's cached, and if you request it but aren't in that list, it gets refetched from the network. ... But I haven't thought that all the way through.",
          "createdAt": "2018-12-13T00:18:20Z",
          "updatedAt": "2018-12-13T00:18:20Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> My Link: <>; rel=preload question was more for @horo-t than @sleevi. \ud83d\ude04 We have to look at the signed one for the same reasons Allowed-... has to be signed in the original post.\r\n\r\nI think introducing a new Link header instead of `Alternative-Signed-Exchange-Subresources` is an alternative solution. But if we have `Alternative-Signed-Exchange-Subresources` field in SXG, we can easily host the SXG files in HTTP servers. The distributor doesn't need to implement the logic of setting the HTTP header for each SXG files. So I want to introduce the new field in SXG format.\r\n\r\n\r\n> I think it's more complex than \"double-keying\" or even \"physical\" vs \"logical\". We need to find a way to describe which entities (origins or organizations) know that which other entities have asked the profile to download a URL. I think each entry in the cache winds up annotated with a list of entities that are allowed to know it's cached, and if you request it but aren't in that list, it gets refetched from the network. ... But I haven't thought that all the way through.\r\n\r\nTo avoid letting the distributor know about the existence of publisher's content in the user's HTTPCache, UA must fetch `https://distributor.example/publisher.example/framework.js.sxg` even if `https://publisher.example/framework.js` is in the HTTPCache. But if `https://distributor.example/publisher.example/framework.js.sxg` is in the HTTPCache, UA doesn't need to fetch it again.",
          "createdAt": "2018-12-15T03:09:21Z",
          "updatedAt": "2018-12-15T03:09:21Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is why it's helpful to first make sure we've analyzed the problem, clearly stated it, and made sure it's not, in fact, a pre-existing problem, so then we can look at solution spaces or make informed tradeoff decisions.\r\n\r\nI think the problem of this idea is that the user can't notice the channel which can be used by the distributor to send arbitrary information to the publisher. Is my understanding correct?",
          "createdAt": "2018-12-15T03:09:46Z",
          "updatedAt": "2018-12-15T03:09:46Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": ">\n>\n> I think the problem of this idea is that the user can't notice the channel\n> which can be used by the distributor to send arbitrary information to the\n> publisher. Is my understanding correct?\n>\nWe can frame the problem like this:\n\nIn the existing Web platform, the document always explicitly requests any\ndependent information - if it isn\u2019t inline in the document itself, it\u2019s in\nthe headers or the subresources it loads. In all cases, the displayed page\nexplicitly makes the requests to get extra information.\n\nThis explicitness is good for security. It helps make sure that all the\ninformation in the page can be audited, and you can be sure where and how\ninformation makes it\u2019s way in. A page author can then use things like CSP\nto restrict the inflow and outflow of information even further.\n\nThis explicitness is also good for privacy. By making all information flow\noutgoing and explicit, users and extensions can inspect, audit, or alter\nthe outflow of information. This is used heavily by privacy preserving\nextensions and users.\n\nThe proposed CSP directive is trying to address the security aspect, by\ngiving page authors a means to control the content. It is unsafe by default\n- the SXG packager that didn\u2019t use the CSP could find unexpected content\ninjected, which is functionally indistinguishable from a MITM. We might say\nthat requires cleverness by the distributor, but if we\u2019re worried about\nsecurity as browser and spec authors, we need to worry about clever\ndistributors.\n\nThe problem with the approach is it doesn\u2019t address the privacy angle. This\nis when both the distributor and publisher are clever and collaborating.\nFor example, one clever attack around third-party cookie blockers would be\nto have the publisher publish a \u201ctracking\u201d SXG that can be hosted by\ndifferent distributors. The distributors could inject information in using\nthis channel - smuggling bits into the SXG. If the SXG has access to\nstorage or persistence APIs - for example, it can use IndexedDB or service\nworkers - then it can create a persistent record, associated with\n\u201cpublishers\u201d origin that the user visited \u201cdistributor\u201d. This would all be\ninvisible to the privacy conscious user, who would only see resource loads\nfrom the distributor - no third-party loads or cookies.\n\nThe only way a privacy conscious user could regain those privacy properties\nwould be to either block these subresource loads and substitutions, or\nblock all SXGs from being loaded by distributors. Both seem like they would\nbe a significant setback for the utility of this functionality and the\nutility of SXG in general, since privacy conscious browsers would likely do\none or both of these things.\n\nI think those two properties - that the page explicitly requests the data\nthat gets loaded in to itself (the security property) and that users,\nextensions, and privacy conscious browsers can then inspect, audit, alter,\nor block this data loading (the privacy properties) - are what the existing\nsystem has, and which this might undermine.\n\nIf that\u2019s a good framing of the problem, at least, then we may be able to\nidentify or come up with solutions that can meet both sets of needs.\n",
          "createdAt": "2018-12-15T06:26:55Z",
          "updatedAt": "2018-12-15T06:26:55Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the detailed framing of the problem.\r\n\r\nI think if the allowed-alternative-signed-exchange-subresources field must have the signatures of SXG https://github.com/WICG/webpackage/issues/347#issuecomment-446495503, we can solve the security issue.\r\n\r\nOne possible solution for the privacy issue is like this: Privacy conscious browsers can delay the subresource SXGs loading until the all subresource SXGs are successfully verified. If one of the SXGs has an error, the browsers must fetch the original publisher's URL. So the distributors can't use the smuggling bits in the SXG.",
          "createdAt": "2019-01-07T02:23:55Z",
          "updatedAt": "2019-01-07T02:23:55Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@horo-t I may be misunderstanding the proposal a bit, so I thought I'd try to write it out and check if it's what you're proposing:\r\n\r\n* Only declaratively-specified subresources would have this mapping applied, and only for first-order SXGs. That is, those SXGs loaded by JS (e.g. mutating a .src attribute) or those referenced within SXGs (for example, loading a CSS file that then loads dependent resources) won't go through this transformation. This is, AIUI, more restrictive than the generic preload scanner.\r\n* (Naive algorithm) After the page has fully loaded, and it's determined all URLs that this transformation would apply to, it then attempts to fetch all SXGs. After it has fully downloaded and verified the SXG (the entire resource), it may then either use all of those resources in lieu of the original URLs, or may otherwise restart and begin fetching those other URLs (throwing out all of the SXGs it downloaded)\r\n\r\nIs that roughly the proposal? I see lots of edge cases, so I wasn't sure if I was missing something fundamental. ",
          "createdAt": "2019-01-07T20:24:03Z",
          "updatedAt": "2019-01-07T20:24:03Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I forgot to say about the link headers.\r\n\r\nMy proposal for the privacy issue is:\r\n- Privacy conscious browsers can use subresource SXGs only when the subresources are listed in the link (rel=preload) header in the signed response headers.\r\n- While loading the main resource SXG, the browser checks the link header.\r\n- If there are corresponding SXGs in Alternative-Signed-Exchange-Subresources map, the browser fetchs the SXGs.\r\n- After finishing the verification of the all SXGs, the browser can load the subresources from the SXGs. If there is an error, the browser must fetch the original URL for the all subresources.\r\n",
          "createdAt": "2019-01-09T01:59:33Z",
          "updatedAt": "2019-01-09T01:59:33Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "We (@jyasskin, @sleevi, @kinu, @horo-t) discussed about this issue yesterday. This is the summary.\r\n\r\n- Goal:\r\n  - Only while prefetching a main SXG before the content document starts to be processed, allow subresources SXGs to be preloaded using existing prefetch+preload mechanisms (e.g. link headers).\r\n  - Allow these subresource preloads to also be served by SXGs from the SXG distributor/physical origin, allowing more efficient loading and w/o requiring a connection to the inner resource\u2019s logical origin.\r\n\r\n- To limit the complexity:\r\n  - We might restrict the usage of SXG subresource only for prefetches. No plan to support SXG subresources which were NOT prefetched.\r\n  - We might restrict the main SXG and the subresources SXGs to be served from the same host.\r\n\r\n#### Possible attacks:\r\n1. The Source (who has a link to the SXG) or Distributor sends a tracking ID to the Publisher\r\n   1.1. In query parameters or fragment\r\n   1.2. In the set of prefetched resources\r\n   1.3. In the content of prefetched resources\r\n   1.4. In the user history (referrer)\r\n2. If the subresource request from the SXG is observable by the Distributor:\r\n   2.1. The Publisher can send arbitrary information to the Distributor\r\n   2.2. Accidental information leak may occur.\r\n3. Version skew attack. An evil Distributor can serve old version JS which contains a bug.\r\n\r\n- Attack 1.1 is already possible without SXG.\r\n  - If the SXG's physical URL is observable by publishers, the Source can use it to send a tracking ID to publishers (attack 1.1). Signed Exchange Reporting to the publishers may expose this. https://github.com/w3c/network-error-logging/issues/99\r\n- If SXG subresources must be declared as prefetchable and all must be prefetched for any of the prefetches to apply:\r\n  - The Distributor can send only 1 bit (succeeded or failed) to the Publisher using the set of prefetched resources. (attack 1.2)\r\n  - This requirement also prevents the attack 2.1 and 2.2.\r\n- If the main SXG must have the subresources SXG's signatures in signed field:\r\n  - This Distributors can\u2019t send a tracking ID in the content of prefetched resources. (attack 1.3)\r\n  - This also prevents version skew attack (attack 3).\r\n  - This requirement may make the packaging tool complex.\r\n  - We might need to think about WebFonts case.\r\n- Publishers can know the source page URL which has a link to the SXG using document.referrer. (attack 1.4)\r\n  - The source page can send a tracking ID using the page URL.\r\n  - This is the status quo.\r\n  - document.referrer in SXG is not supported yet in Chromium (https://crbug.com/920905).\r\n",
          "createdAt": "2019-01-18T10:08:01Z",
          "updatedAt": "2019-01-18T10:08:01Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "If attack 1 is already possible with or without SXG (using either 1.1 or 1.4), why is it important to block 1.2?\r\n\r\nRequiring subresource signatures makes sense from a security perspective (to prevent content injection). blocking 1.3 is a nice side-effect of that.\r\n\r\nIt's also not immediately clear to me how limiting this to prefetches reduces the complexity or increases privacy. Can you elaborate on that?",
          "createdAt": "2019-01-31T10:11:15Z",
          "updatedAt": "2019-01-31T10:11:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Limiting it to prefetches prevents attack #<b></b>2. Unless you're thinking of a third kind of fetch besides prefetches and post-load fetches?\r\n\r\n@rbyers, do you have a feeling for which attacks we can exclude from the threat model because they're possible today?",
          "createdAt": "2019-01-31T16:51:39Z",
          "updatedAt": "2019-01-31T19:31:08Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't attack #2 readily available to any page with network access? e.g. can't they send a 1x1 pixel image to with request parameters `distributor.com/tracking` to leak whatever information that they so choose?",
          "createdAt": "2019-02-01T09:36:37Z",
          "updatedAt": "2019-02-01T09:36:37Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@yoavweiss No.\r\n\r\nWhen prefetching, the author has to declaratively commit to what to disclose, rather than being able to leak traffic from the current origin. Note the caveats on https://github.com/WICG/webpackage/issues/347#issuecomment-447541822 as well.\r\n\r\nI think an important gap in that comparison is that this is *not* loading `distributor.com/tracking`, but allowing any intermediary to insert and/or observe traffic in the session. While it's true that it's \"with the consent\" of the origin (by virtue of saying how they can collaborate), it's functionally indistinguishable from mixed content. That is, despite the HTTPS page 'wanting' to load the HTTP page, it's not in the user's security or privacy interests to do so. Similarly, unlike an explicitly keyed load of `distributor.com/example` (which you can do prior to signing the SXG, if you explicitly indicate to load that SXG), this would allow attackers full mutability of where that content is loaded from. That is, they're not just causing it to load from `distributor.com/tracking` but `{insert distributor here}`, which as the analysis above explains, turns into a full primitive for insecure side-channels and injection unless limited to prefetch.\r\n\r\nHopefully, that explains why it's not at all comparable.",
          "createdAt": "2019-02-03T15:54:01Z",
          "updatedAt": "2019-02-03T15:54:01Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Instead of adding two new dedicated fields (Allowed-Alternative-Signed-Exchange-Subresources,Alternative-Signed-Exchange-Subresources) in the application/signed-exchange format, extending the link header sounds reasonable.\r\n\r\nFor example:\r\n\r\nIn unsigned HTTP response from distributor.example:\r\n```\r\ncontent-type: application/signed-exchange\r\nlink: <https://distributor.example/publisher.example/script.js.sxg>;rel=\"alternate\";type=\"application/signed-exchange\";anchor=\"https://publisher.example/script.js\";\r\n```\r\nIn signed response header of SXG:\r\n```\r\nlink: <https://publisher.example/script.js>;rel=\"allowed-alt-sxg\";sig=\"MEUCIA...\"\r\nlink: <https://publisher.example/script.js>;rel=\"preload\";as=\"script\"\r\n```\r\n\r\n(Sorry for contradicting my [previous comment](https://github.com/WICG/webpackage/issues/347#issuecomment-447532457))\r\n",
          "createdAt": "2019-02-05T01:45:32Z",
          "updatedAt": "2019-02-05T01:45:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I looked through http://microformats.org/wiki/existing-rel-values and https://www.iana.org/assignments/link-relations/link-relations.xhtml but didn't see anything that seems to serve the purpose of `rel=\"allowed-alt-sxg\"`, so we're free to invent our own name.\r\n\r\nWe should think about whether to include the format version number in the `type=\"application/signed-exchange\"` bit. I suspect we *should* require that version number since the distributor has already received an `Accept` header saying which version(s) the client supports.\r\n\r\nShould we make `allowed-alt-sxg` a separate Link or an extra parameter to the `preload` Link? We have lots of precedent for [adding parameters](https://html.spec.whatwg.org/multipage/semantics.html#attr-link-integrity) to `preload`, but this one's a bit weird because we don't want it to affect preloads retrieved directly from the publisher.",
          "createdAt": "2019-02-07T00:45:16Z",
          "updatedAt": "2019-02-07T00:45:16Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, that makes that clearer. Thanks!",
          "createdAt": "2019-02-08T09:57:18Z",
          "updatedAt": "2019-02-08T09:57:18Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> We should think about whether to include the format version number in the `type=\"application/signed-exchange\"` bit. I suspect we _should_ require that version number since the distributor has already received an `Accept` header saying which version(s) the client supports.\r\n\r\nHaving the format version number in the `type=\"application/signed-exchange\"` bit sounds good to me.\r\n\r\n> Should we make `allowed-alt-sxg` a separate Link or an extra parameter to the `preload` Link? We have lots of precedent for [adding parameters](https://html.spec.whatwg.org/multipage/semantics.html#attr-link-integrity) to `preload`, but this one's a bit weird because we don't want it to affect preloads retrieved directly from the publisher.\r\n\r\nI think we should have the separate`allowed-alt-sxg` Link. If we have the signature param in `preload` Link, it will be completed to selectively preload images using [imagesrcset and imagesizes](https://github.com/whatwg/html/pull/4048).\r\n\r\nExample:\r\nIn unsigned HTTP response from distributor.example: \r\n```\r\ncontent-type: application/signed-exchange\r\nlink: <https://distributor.example/publisher.example/wide.jpg.sxg>;rel=\"alternate\";type=\"application/signed-exchange;v=XX\";anchor=\"https://publisher.example/wide.jpg\";\r\nlink: <https://distributor.example/publisher.example/narrow.jpg.sxg>;rel=\"alternate\";type=\"application/signed-exchange;v=XX\";anchor=\"https://publisher.example/narrow.jpg\";\r\n```\r\nIn signed response header of SXG:\r\n```\r\nlink: <https://publisher.example/wide.jpg>;rel=\"allowed-alt-sxg\";sig=\"MEUCIB...\"\r\nlink: <https://publisher.example/narrow.jpg>;rel=\"allowed-alt-sxg\";sig=\"MEUCIC...\"\r\nlink: <https://publisher.example/wide.jpg>;rel=preload; as=image;imagesrcset=\"https://publisher.example/wide.jpg 640w, https://publisher.example/narrow.jpg 320w\";imgesizes=\"(min-width: 400px) 50vw, 100vw\"\r\n```\r\n",
          "createdAt": "2019-02-25T07:03:20Z",
          "updatedAt": "2019-02-25T07:03:20Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed a crbug: https://crbug.com/935267",
          "createdAt": "2019-02-25T07:17:07Z",
          "updatedAt": "2019-02-25T07:17:07Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I [wrote](https://github.com/WICG/webpackage/issues/347#issuecomment-446495503) that 'allowed-alternative-signed-exchange-subresources' ('allowed-alt-sxg' in the current idea) should have the signatures of subresources.\r\nBut the signature is valid only for 7 days.\r\n\r\nInstead of the signature, I want to use SHA-256 hash of [`headerBytes`](https://wicg.github.io/webpackage/loading.html#the-signed-message) byte sequence which includes `digest` header and `content-type` header and other arbitrary headers.\r\nNote that we can't use the digest header for the integrity check. If we do so, subresource SXGs are used for user tracking by adding arbitrary headers or changing content-type to cause image load failure.\r\n\r\nThe signed response header of main SXG will be like this:\r\n```\r\nlink: <https://publisher.example/wide.jpg>;rel=\"allowed-alt-sxg\";header-integrity=\"sha256-h0KP...\"\r\nlink: <https://publisher.example/narrow.jpg>;rel=\"allowed-alt-sxg\";header-integrity=\"sha256-AmOC...\"\r\nlink: <https://publisher.example/wide.jpg>;rel=\"preload\";as=image;imagesrcset=\"https://publisher.example/wide.jpg 640w, https://publisher.example/narrow.jpg 320w\";imgesizes=\"(min-width: 400px) 50vw, 100vw\"\r\n```",
          "createdAt": "2019-02-27T06:39:56Z",
          "updatedAt": "2019-02-27T06:39:56Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "> Instead of fetching the original URL in publisher.example, UA should fetch the SXG files in distributor.example after checking the\r\n\r\nHow does this interact with service workers? Would the request go to publisher.example's service worker first?",
          "createdAt": "2019-03-14T03:49:11Z",
          "updatedAt": "2019-03-14T03:49:11Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "How about introducing a new method \"getPreloadedResponses()\" in FetchEvent?\r\nService workers can get the prefetched subresources which are preloaded while prefetching the main resource in the previous page.\r\n```\r\ninterface FetchEvent : ExtendableEvent {\r\n  ...\r\n  Promise<FrozenArray<Response>> getPreloadedResponses();\r\n};\r\n```",
          "createdAt": "2019-03-14T04:21:53Z",
          "updatedAt": "2019-03-14T04:21:53Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks it should probably clarify where the URL replacement happens in the Fetch process model?  Is the assumption that the replacement layer sits between the page and SW?",
          "createdAt": "2019-03-14T07:42:10Z",
          "updatedAt": "2019-03-14T07:42:10Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "Yes this is my point of confusion... would be useful to see the sequence of which service workers get consulted when and when the replacement happens for the main resource and the subresources.",
          "createdAt": "2019-03-14T07:46:07Z",
          "updatedAt": "2019-03-14T07:46:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@mattto To [preserve privacy during the prefetch](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#private-prefetch), the publisher's SW MUST NOT get an event saying which subresources are getting prefetched, even transitively.\r\n\r\nWe do need to specify that ... but doing so will be difficult until there's a specification of how `<link rel=\"prefetch\">` interacts with Service Workers at all.\r\n\r\nMy guess is that whatever bit of the browser is scanning a prefetched resource for preloads to prefetch recursively (whew) needs to maintain the mapping of available alternate SXGs, and replace the URLs before it invokes Fetch. @horo-t / @kinu, does that make sense?",
          "createdAt": "2019-03-15T22:15:14Z",
          "updatedAt": "2019-03-15T22:15:14Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "My current idea of Service Worker and subresource SXG prefetching integration is like this:\r\n\r\n1. The user opens \"https://aggregator.example/index.html\".\r\n1. When the UA processes `<link rel=\"prefetch\" href=\"https://distributor.example/publisher/article.sxg\">`:\r\n   * Invoke the FetchEvent of aggregator's SW with \"article.sxg\" request.\r\n   * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The SXG is stored to the HTTPCache.\r\n1. The response has the following headers:\r\n   * In unsigned outer HTTP response:\r\n     * `content-type: application/signed-exchange`\r\n     * `link: <https://distributor.example/publisher/script.js.sxg>;rel=\"alternate\";type=\"application/signed-exchange[;v=...]\";anchor=\"https://publisher.example/script.js\";`\r\n   * In signed inner response header:\r\n     * `link: <https://publisher.example/script.js>;rel=\"allowed-alt-sxg\";header-integrity=\"sha256-MEUCIA...\"`\r\n     * `link: <https://publisher.example/script.js>;rel=\"preload\";as=\"script\"`\r\n1. The UA processes the headeres, and starts prefetching \"https://distributor.example/publisher/script.js.sxg\".\r\n   * Invoke the FetchEvent of aggregator's SW with \"script.js.sxg\" request.\r\n   * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The SXG is stored to the HTTPCache.\r\n1. The user clicks the link of https://distributor.example/publisher/article.sxg\r\n   * Invoke the FetchEvent of distributor's SW with \"article.sxg\" request.\r\n   * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The SXG is served from the HTTPCache.\r\n1. The UA processes the SXG response as if it is a 303 redirect to \"https://publisher.example/article.html\" and set [request\u2019s \"stashed exchange\" to the parsedExchange](https://wicg.github.io/webpackage/loading.html#mp-http-fetch).\r\n   * Invoke the FetchEvent of publisher's SW with \"article.html\" request.\r\n     * FetchEvent.request.url is \"https://publisher.example/article.html\".\r\n     * FetchEvent.preloadResponse is a promise which returns the inner response.\r\n     * FetchEvent.getPreloadedResponses() returns a promise which returns the preloaded responses (In this case: \"https://publisher.example/script.js\").\r\n   * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The response [is set to the stashed exchange's response](https://wicg.github.io/webpackage/loading.html#mp-http-network-or-cache-fetch).\r\n1. The UA processes the link header.\r\n   * Invoke the FetchEvent of publisher's SW with \"script.js\" request. The SW can return the response which have been retrieved using getPreloadedResponses() at 6.\r\n   * If the SW didn't call respondWith(), Check the existence of the prefetched \"script.js.sxg\" in HTTPCache, and returns the inner response of it if exists. Othewise perform a HTTP-network-or-cache fetch.",
          "createdAt": "2019-03-18T06:10:43Z",
          "updatedAt": "2019-03-18T06:10:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I like that overall sketch.\r\n\r\n\"The SXG is stored to the HTTPCache.\" is ambiguous here, since we're designing for a multi-key'ed HTTP cache. We'll wind up using terminology from https://github.com/w3c/resource-hints/issues/82, but I think the goal is to put:\r\n\r\n1. `https://distributor.example/publisher/article.sxg` in the new prefetch cache and\r\n2. The **inner resource** from `https://distributor.example/publisher/script.js.sxg` in a cache that's promoted to the `https://publisher.example` origin's partition of the HTTP cache **only if** the navigation is to `https://publisher.example/article.html`.\r\n\r\nThis promotion to the HTTP cache reminds me of things @sleevi has been nervous of, and I don't understand his concerns well enough to know if they're assuaged by this happening only on navigation to the controlling top-level document.\r\n\r\n----\r\n\r\nSeparately, I haven't thought through whether we need the `FetchEvent.getPreloadedResponses()` method, and I suspect you should propose it separately from this SXG proposal. It probably makes sense, or doesn't, for *all* recursive prefetches, so should go to https://github.com/w3c/resource-hints?",
          "createdAt": "2019-03-18T23:20:51Z",
          "updatedAt": "2019-03-18T23:20:51Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @sleevi Reg: inner resource and HTTP cache, if we're feeling ready to talk about this I prefer we discuss the generic case first, possibly in a separate issue, before talking about this specific case, could we?\r\n\r\n@horo-t Reg: FetchEvent.getPreloadResponses(): why don't we just let FetchEvent.preloadResponse expose the preload-to-prefetched resource for the particular fetch (e.g. for \"script.js\")? It looks UA anyway needs to track the relationship until step 7, wasn't sure why returning an array in navigation request is better.  Either way I agree with @jyasskin that proposing this separately might be good, I think similar idea has been discussed somewhere else before (e.g. exposing prefetched response as FetchEvent.preloadResponse).\r\n\r\nBut also wondered if we do start to store innerResponse in HTTP cache when navigation happens something like 2. in [#issuecomment-474138609](https://github.com/WICG/webpackage/issues/347#issuecomment-474138609) then getPreloadResponses() might not be really needed?",
          "createdAt": "2019-03-19T01:04:24Z",
          "updatedAt": "2019-03-19T01:04:24Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "Thanks for sketching that out, that's very clear. I'll note that this adds more cases where `respondWith(fetch(event.request))` differs from not calling `respondWith()`. Historically we've tried to keep those equivalent, but maybe we've already lost that guarantee, and it aligns with the main resource SXG. Was there a discussion about the SW interaction described in https://wicg.github.io/webpackage/loading.html#overview?",
          "createdAt": "2019-03-19T01:27:27Z",
          "updatedAt": "2019-03-19T01:27:27Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu \r\nUsing FetchEvent.preloadResponse for the preload-to-prefetched resources sounds good to me.\r\nFetchEvent.getPreloadResponses() may be useful when we want to store the prefetched subresrouces to CacheStorage. But I don't think this is super important. \r\n\r\nI commented about using FetchEvent.preloadResponse in SW for prefetched resources at https://github.com/w3c/resource-hints/issues/78#issuecomment-474165639. Let's discuss about it there.\r\n",
          "createdAt": "2019-03-19T01:55:51Z",
          "updatedAt": "2019-03-19T01:55:51Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@mattto \r\nThe SW integration with signed exchange was added to the spec at https://github.com/WICG/webpackage/pull/281#discussion_r208055480. If we want to keep calling `respondWith(fetch(event.request))` and not calling `respondWith()` same behavior, we need to change the spec. I think we should discuss about it in a separate issue.  \r\n",
          "createdAt": "2019-03-19T02:22:24Z",
          "updatedAt": "2019-03-19T02:22:24Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "Thanks, filed #409 ",
          "createdAt": "2019-03-19T06:28:59Z",
          "updatedAt": "2019-03-19T06:28:59Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> 4. The UA processes the headeres, and starts prefetching \"https://distributor.example/publisher/script.js.sxg\".\r\n>    \r\n>    * Invoke the FetchEvent of aggregator's SW with \"script.js.sxg\" request.\r\n>    * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The SXG is stored to the HTTPCache.\r\n\r\nI find this part uncomfortable and hard to reason about. In a 'normal' TLS loading case, my understanding is that `aggregator.example` would have no knowledge of `distributor.example` preloading here, so this feels like a new information disclosure vector.\r\n\r\nIf I understand correctly, but wanting to confirm, we're reasoning that this isn't particularly new information, because `aggregator.example` can see the headers of the inner SXG, and thus know about the `link: ...;rel=\"preload\"` content, and thus know what the user will load anyways. Does that sound roughly correct?\r\n\r\nI think one area that would need more specificity here is what happens if `aggregator.example` does trigger a respondWith() call for the fetch to `distributor.example/publisher/script.js.sxg`.\r\n  1) What if they glue it to a fetch event of `otherdistributor.example/publisher/script.js.sxg'\r\n  2) What if they glue it to a fetch event of `publisher.example/script.js`\r\n  3) What if they glue it to a synthetic response (e.g. a blob) which has the same `header-integrity` value as expressed in the `rel=\"allowed-alt-sxg\"` (which AIUI refers to the hash of the inner content not the outer content?)\r\n\r\nSeparate from these concerns, as @jyasskin highlighted, we need to figure out what it means by storing in the HTTPCache / serving from the HTTPCache, and how those requests are inserted and matched. If I understood @kinu's [comment](https://github.com/WICG/webpackage/issues/347#issuecomment-474158214) it sounds like we're good to defer that?",
          "createdAt": "2019-03-20T16:12:58Z",
          "updatedAt": "2019-03-20T16:12:58Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Humm...\r\nNow I think we should skip service workers for prefetching requests (2 and 4 of https://github.com/WICG/webpackage/issues/347#issuecomment-473782344), at least for MVP (minimum viable product).\r\n\r\n\r\nIntroducing the new prefetch cache sounds good to me. If we can put the prefetched resources (https://distributor.example/publisher/article.sxg and https://distributor.example/publisher/script.js.sxg) and the certificate URL of each SXGs to the new prefetch cache, and we can use the cached resources when navigating from https://aggregator.example/index.html, this mechanism works even when double-key caching is enabled. (I'm trying to find a good way to implement this in Chromium.)\r\n\r\nI still don't know whether it is ok or not to store the inner resources (https://publisher.example/article.html and https://publisher.example/script.js) into the prefetch cache.\r\nIt is good for performance because we can skip the verification process.\r\n@sleevi Do you have any concern about it?",
          "createdAt": "2019-03-23T05:36:34Z",
          "updatedAt": "2019-03-23T05:36:34Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I have written two explainer documents.\r\n - [Signed Exchange subresource substitution](https://github.com/horo-t/subresource-signed-exchange/blob/master/signed-exchange-subresource-subtitution-explainer.md)\r\n    - This introduces rel=\"allowed-alt-sxg\" link header.\r\n    - By using this header, content publishers can declare that the UA can load the specific subresources from cached signed exchanges which were prefetched in the referrer page.\r\n - [Signed Exchange alternate link](https://github.com/horo-t/subresource-signed-exchange/blob/master/signed-exchange-alternate-link-explainer.md)\r\n    - This extends the usage of the existing rel=\"alternate\" link header.\r\n    - By using this header, UAs can recursively prefetch appropriate subresource signed exchanges while prefetching the main resource signed exchange.",
          "createdAt": "2019-07-11T00:16:40Z",
          "updatedAt": "2019-07-11T00:16:51Z"
        }
      ]
    },
    {
      "number": 349,
      "id": "MDU6SXNzdWUzOTAyMjY1NzM=",
      "title": "Clarify SXG + SW interactions",
      "url": "https://github.com/WICG/webpackage/issues/349",
      "state": "CLOSED",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The [\"Navigations and subresources redirect\" section of the Explainer](https://github.com/WICG/webpackage/blob/master/explainer.md#navigations-and-subresources-redirect) seems to suggest that once the SXG is unwrapped and the publishing URL is available, if the browser then discovers that a service worker is controlling the publishing URL, the request will be routed through the SW via the standard \"fetch\" event.\r\n\r\nThe SW then executes as normal with one exception: if the SW attempts a network request to the publishing URL (e.g. via `fetch()`), the browser will return the response stream embedded within the SXG instead of performing the network request. (That is, from the point of view of the browser, no network access will occur--the already-available response will be returned to the SW.)\r\n\r\nIt would be useful to know:\r\n\r\n- Whether the various mechanisms that currently allow the SW to avoid the various browser caches (e.g. [cache = \"no-store\"](https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)) will be respected. (If not, this introduces an awkward difference in behavior.)\r\n- Whether the response stream attached to the redirect will also be available via the [navigation.preload](https://developer.mozilla.org/en-US/docs/Web/API/NavigationPreloadManager) mechanism. (Also, was making the response available via this mechanism only considered? It seems a bit more compatible with what's actually going on, especially with respect to the time at which things occur.)\r\n\r\n/cc @jakearchibald @twifkak ",
      "createdAt": "2018-12-12T13:30:16Z",
      "updatedAt": "2018-12-13T17:59:17Z",
      "closedAt": "2018-12-13T17:59:17Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://wicg.github.io/webpackage/loading.html#mp-http-network-or-cache-fetch should give a precise answer to your questions, but please let me know if it's the wrong answer. :)",
          "createdAt": "2018-12-13T00:56:42Z",
          "updatedAt": "2018-12-13T00:56:42Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's perfect, thanks. (And sorry I missed it that section.)",
          "createdAt": "2018-12-13T17:59:17Z",
          "updatedAt": "2018-12-13T17:59:17Z"
        }
      ]
    },
    {
      "number": 350,
      "id": "MDU6SXNzdWUzOTA1MTE4Njk=",
      "title": "Implementation snapshot b3",
      "url": "https://github.com/WICG/webpackage/issues/350",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We would like to prepare another implementation snapshot `b3` to incorporate the recent changes to the format.\r\nOur plan is to ship Chrome M73 with `b3` support.\r\n\r\n## Highlight of changes since `b2`\r\n\r\nof which we would definitely want to make it in `b3`:\r\n- [x] `Variants` header-based request matching (post #285)\r\n  - [x] https://github.com/WICG/webpackage/pull/285\r\n  - [x] https://github.com/WICG/webpackage/pull/360\r\n  - [x] https://github.com/httpwg/http-extensions/pull/735\r\n  - [x] https://github.com/httpwg/http-extensions/issues/570\r\n  - [x] Version the Variant headers (httpwg/http-extensions#747)\r\n- [x] Header bans (#336, #340)\r\n- [x] Reject uncachable and incomplete responses (#326)\r\n- [x] UTF-8 decode the URL string (#346) \r\n- [x] Prevent content-type sniffing (#354)\r\n",
      "createdAt": "2018-12-13T04:19:05Z",
      "updatedAt": "2019-07-25T15:12:29Z",
      "closedAt": "2019-07-25T15:12:29Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Also include httpwg/http-extensions#735 per comments on #285.",
          "createdAt": "2018-12-13T04:40:40Z",
          "updatedAt": "2018-12-13T04:40:40Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@twifkak noted. Am I correct that it is part of #285?",
          "createdAt": "2018-12-13T04:43:58Z",
          "updatedAt": "2018-12-13T04:43:58Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@nyaxt #285 was landed with a dependency on httpwg/http-extensions, with the understanding that httpwg/http-extensions#735 would eventually land. Perhaps the snapshot, given it is time-sensitive, should reference it as a required amendment.",
          "createdAt": "2018-12-13T05:26:18Z",
          "updatedAt": "2018-12-13T05:26:18Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I just went over list of open PRs and found https://github.com/WICG/webpackage/pull/121 is not yet resolved.\r\n@jyasskin @davidben : I'd like to hear your latest thoughts. Do you think we should include the change in b3?",
          "createdAt": "2019-01-07T01:13:40Z",
          "updatedAt": "2019-01-07T01:13:40Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm currently inclined not to make the change in #121. We should encourage folks to use a unique URL for each version of the OCSP response, but signing it all together seemed to cause some problems for the Intermediate's serving infrastructure for not much benefit. (@twifkak had more details about the problems.)",
          "createdAt": "2019-01-08T00:34:23Z",
          "updatedAt": "2019-01-08T00:34:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I realized we should version our `Variants` headers too: https://github.com/httpwg/http-extensions/issues/747. It's not absolutely essential, since they're always embedded into a versioned SXG file, but it reduces the risk that it'll leak into the rest of the ecosystem.",
          "createdAt": "2019-01-08T00:42:23Z",
          "updatedAt": "2019-01-08T00:42:23Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this snapshot also needs to include the httpbis-header-structure upgrade, per http://crrev.com/c/1420506.",
          "createdAt": "2019-01-23T00:55:56Z",
          "updatedAt": "2019-01-23T00:55:56Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a timeline for when this will be included in the implementation checkpoints? https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02 has expired as of March 8",
          "createdAt": "2019-03-15T18:45:30Z",
          "updatedAt": "2019-03-15T18:45:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I-D expirations don't really mean anything, but you're right that we're overdue for publishing the -03 draft. I've started on it and should have a first version out for review today. Once I merge that, it'll be available at https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html. I can't publish anything to the IETF's server until [March 23](https://datatracker.ietf.org/submit/), but I may leave it open for several days to a week after that to make sure folks have time to review it.\r\n\r\nSorry for the slowness.",
          "createdAt": "2019-03-15T18:53:18Z",
          "updatedAt": "2019-03-15T18:53:18Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "Any chance this will be merged?",
          "createdAt": "2019-06-13T18:25:43Z",
          "updatedAt": "2019-06-13T18:25:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-03 is finally submitted. Sorry for the delay.",
          "createdAt": "2019-07-25T15:12:29Z",
          "updatedAt": "2019-07-25T15:12:29Z"
        }
      ]
    },
    {
      "number": 362,
      "id": "MDU6SXNzdWUzOTYzMjM5MTA=",
      "title": "Implement \"Implementation snapshot b3\"",
      "url": "https://github.com/WICG/webpackage/issues/362",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi",
        "nyaxt",
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "This issue tracks progress of implementation of [the b3 snapshot](https://github.com/WICG/webpackage/issues/350) in both gen-signedexchange and Chromium.\r\n\r\n| Task | [Go](https://github.com/WICG/webpackage/tree/master/go/signedexchange) | Chromium |\r\n|---|---|---|\r\n| New magic bytes \"1b3\" | #353 | https://crbug.com/919417 |\r\n| #360 CBOR no longer have request map | #357 | https://crbug.com/919420  |\r\n| ~~\"Response is complete\"~~ | #363 |  |\r\n| #360 shared cache cachable | #367 | [CL](https://chromium-review.googlesource.com/c/chromium/src/+/1400422) |\r\n| #339 Reject uncached headers | #373 |  https://crbug.com/920897  |\r\n| #360 Use Variants | #366 | https://crbug.com/923229  |\r\n",
      "createdAt": "2019-01-07T02:14:35Z",
      "updatedAt": "2019-01-24T08:00:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Go verifier changes (except Variants): https://github.com/WICG/webpackage/pull/384",
          "createdAt": "2019-01-24T08:00:44Z",
          "updatedAt": "2019-01-24T08:00:44Z"
        }
      ]
    },
    {
      "number": 365,
      "id": "MDU6SXNzdWUzOTYzNDUzOTI=",
      "title": "\"is complete\" check requires the entire response body. Streaming loading?",
      "url": "https://github.com/WICG/webpackage/issues/365",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Found by @irori while implementing \"is complete check\" #363 #364 \r\n\r\nWe introduced \"is complete\" check in #326.\r\n\r\nhttps://tools.ietf.org/html/rfc7234#section-3.1 says \r\n> A response message is considered complete when all of the octets\r\n   indicated by the message framing ([RFC7230]) are received prior to\r\n   the connection being closed.\r\n\r\nThis check is tricky to implement for streaming clients (e.g. Chromium).\r\n\r\nIf the offset at mice stream EOS doesn't match \"Content-Length\", what should the UA do?\r\n- If C-L > actual EOS. The response payload may be already fully consumed by the client.\r\n- The UA may track the expected C-L while running mice streaming encoder to:\r\n  - emit error if the mice stream payload exceeded the expected C-L\r\n  - emit error on the last chunk if the payload stream length doesn't match the expected C-L.\r\n\r\nI think we have at least the following options:\r\n- Option A: Implement the complex check.\r\n  - Chromium may need this anyway if we add support for mice decoder in for non-SXG raw HTTP.\r\n- Option B: Remove \"is complete\" check and replace it with plain 206 check.\r\n  - This was @kinu's preference in #326.\r\n- Option B': Check 206 && if Content-Length is formatted correctly (\"the response has valid message framing\")\r\n  - Not sure how much this is worth doing.\r\n\r\n@jyasskin, @irori, @kinu : Your thoughts welcome.\r\n",
      "createdAt": "2019-01-07T04:38:30Z",
      "updatedAt": "2019-01-10T07:23:41Z",
      "closedAt": "2019-01-10T07:23:41Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Another aspect of this is that https://tools.ietf.org/html/rfc7230#section-3.3.3 has a special case for \"Transfer-Encoding: chunked\" but not for \"Content-Encoding: mi-sha256\".\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-26#section-3.3.3 says\r\n>        If a message is received with both a Transfer-Encoding and a\r\n>        Content-Length header field, the Transfer-Encoding overrides the\r\n>        Content-Length.  Such a message might indicate an attempt to\r\n>        perform request smuggling (Section 9.5) or response splitting\r\n>        (Section 9.4) and ought to be handled as an error.  A sender MUST\r\n>        remove the received Content-Length field prior to forwarding such\r\n>        a message downstream.\r\n\r\nbut https://tools.ietf.org/html/draft-thomson-http-mice-03 allows its use with a `Content-Length` header. At least, its [examples](https://tools.ietf.org/html/draft-thomson-http-mice-03#section-4) contain `Content-Length` headers.",
          "createdAt": "2019-01-07T04:46:09Z",
          "updatedAt": "2019-01-07T04:46:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Because MICE is a *content* encoding, I believe the `Content-Length` refers to the encoded bytes, not the decoded ones, so it doesn't conflict like it does with a `Transfer-Encoding`. Given that, I don't think there's a \"complex check\" to fall back to.\r\n\r\nI haven't studied the completeness problem in depth, but I suspect we were just wrong to require the response to be complete, since a streaming client can't check that up front as we've required. Instead, we could either treat an incomplete response like it's an MI decoding error (which it might actually be since we'd append a `0` byte to the last record where it expects a continuation record's `1`?), or just as an incomplete response in the browser. ",
          "createdAt": "2019-01-08T00:27:52Z",
          "updatedAt": "2019-01-08T00:27:52Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> I haven't studied the completeness problem in depth, but I suspect we were just wrong to require the response to be complete, since a streaming client can't check that up front as we've required.\r\n\r\nSounds good. Do you have a preference on what check to replace it with? Does 206 check sound reasonable to you?",
          "createdAt": "2019-01-08T03:53:59Z",
          "updatedAt": "2019-01-08T03:53:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Is \"the 206 check\" just a check that the response status isn't 206? The loading spec currently requires exactly a 200 status, and I wonder if it'd make sense to have the IETF side also require that, until someone finds a use case for another status.",
          "createdAt": "2019-01-08T04:08:58Z",
          "updatedAt": "2019-01-08T04:08:58Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm convinced that the 200 status check in the loading spec is sufficient for now.\r\n\r\nI was thinking of banning \"Content-Range\" response from signed exchanges since I couldn't find good use-case for it. But after giving it more thought, I don't have a security threat scenario for that either. We can reconsider once we actually find issues.",
          "createdAt": "2019-01-08T06:32:55Z",
          "updatedAt": "2019-01-08T06:32:55Z"
        }
      ]
    },
    {
      "number": 366,
      "id": "MDU6SXNzdWUzOTYzNjk2Mzg=",
      "title": "dump-signedexchange: Implement Variants validation",
      "url": "https://github.com/WICG/webpackage/issues/366",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [
        "go"
      ],
      "body": "We need to update `dump-signedexchange` to support Variants header validation per #360 [change](https://github.com/WICG/webpackage/pull/360/files#diff-a2197f2cbc199dc1463dc10213fa40d9R957).\r\nThe [loading spec](https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/360.html#request-matching) may be easier to follow step-by-step.\r\n",
      "createdAt": "2019-01-07T06:55:13Z",
      "updatedAt": "2019-01-10T00:34:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Be aware of https://github.com/httpwg/http-extensions/pull/750, which specifies `Variants-05`, etc., when implementing this.",
          "createdAt": "2019-01-10T00:34:15Z",
          "updatedAt": "2019-01-10T00:34:15Z"
        }
      ]
    },
    {
      "number": 376,
      "id": "MDU6SXNzdWU0MDA0NzU0MzI=",
      "title": "Purge mechanisms",
      "url": "https://github.com/WICG/webpackage/issues/376",
      "state": "OPEN",
      "author": "yoavweiss",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Related to https://github.com/WICG/webpackage/issues/324\r\n\r\nWhile talking to @bratell-at-opera about signed exchanges, he raised concerns about invalid content continuing to circulate after its publisher realized it is invalid.\r\n\r\nThinking about that problem, it's very similar to the one for which CDNs offer purge mechanisms:\r\n* Articles may include typos, embarrassing mistakes or even false information that can expose the publisher from a legal perspective. Once that is discovered, publishers are likely to want to take down that content immediately.\r\n* E-commerce sites may include pricing mistakes, which they typically want to correct ASAP, as that content can cause them to lose money.\r\n* Court order compliance may also be a reason a content's publisher may want it to no longer be considered valid.\r\n\r\nTalking to @jyasskin, the `validityUrl` can be used in order to verify that the content is still valid from the publisher's perspective. Although it was meant for intermediaries, we can use the same value for browser-side validation, to make sure the browser doesn't display invalid content. \r\n\r\nThe browser would fetch the validity information when navigating to an SXG page. (assuming the browser is online)\r\nIf the SXG content is invalid, the browser would force its reload. Assuming that caches validate content regularly, very few users would actually witness those reloads, in the already rare case that content needed to be purged.\r\n\r\nThis won't solve purge for offline access, but that's similar to any offline content (e.g. in a PWA or a native app)\r\n\r\nThoughts?",
      "createdAt": "2019-01-17T21:42:23Z",
      "updatedAt": "2019-04-17T11:26:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I think there's a tension here; the more work put on repudiation (effectively what this is), the less useful this becomes to actually enabling a distributed, decentralized, or more robust Internet, which is at least where some of the interesting use cases are. Similarly, this might be mistaken as enabling a DRM-like solution, which is not a goal.\r\n\r\nConsidering that these same issues already exist if, for example, a site sets a long cache lifetime, I think it may be worthwhile exploring more about the \"what if we didn't offer a purge mechanism\", as it seems like it comes with very, very high tradeoffs.",
          "createdAt": "2019-01-17T21:46:38Z",
          "updatedAt": "2019-01-17T21:46:38Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "In some sense, repudiation is already possible, by signing `<script>fetchUpdatedContent()</script>`. This would be soft repudiation if the original content is signed and then replaced at runtime, and hard repudiation if only the script is signed (in which case, none of those benefits of SXG are realized).",
          "createdAt": "2019-01-17T21:59:43Z",
          "updatedAt": "2019-01-17T21:59:43Z"
        },
        {
          "author": "bratell-at-opera",
          "authorAssociation": "NONE",
          "body": "One reason I pointed out the risks above is that information and misinformation is currently getting weaponized on the Internet, and for information there are two important parts: The data and the source. If you can replay a historic (may it be 1 day historic) mistake or transient data as current information from a reputable source, that can be used to either mislead people or damage the reputation of a source that is trying to be accurate. Or both.\r\n\r\nClient caches don't have this particular weakness since you cannot transfer a cache to someone that you want to mislead. \r\n\r\n",
          "createdAt": "2019-01-17T23:17:30Z",
          "updatedAt": "2019-01-17T23:17:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The proposal would compromise the [anti-censorship](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#anti-censorship) use cases if the censor can compel the origin to respond to `validity-url` requests without the `signature` field, or when the censor can MitM requests to the origin. If not, the fact that `validity-url` requests fail open prevents the censor from using that to censor. The proposal would compromise anti-surveillance use cases in general. It wouldn't compromise [privacy-preserving-prefetch](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#private-prefetch) as long as we're careful to only fetch the `validity-url` _after_ the navigation.\r\n\r\nAs @twifkak says, publishers can build a repudiation mechanism using Javascript even if we don't build this into the browser, so the main question is whether we want to build it in by default.\r\n\r\nA goal to be able to repudiate inaccurate content conflicts, although maybe not fatally, with @ericlaw1979's desire to make this work for [Archival](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#archival).\r\n\r\nI agree with @bratell-at-opera that SXGs are more of a risk than just long cache lifetimes, because they can be used maliciously, and if #300 goes toward trusting the SXG over the cache, that's not even persistently fixed by hitting reload, unlike the cache itself.",
          "createdAt": "2019-01-17T23:54:37Z",
          "updatedAt": "2019-01-17T23:54:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fetching the `validity-url` also makes a stolen private key much more discoverable: the attacker either has to be on-path, or their attack gets exposed to the origin server as a fetch to some URL that can include whatever reporting we think is reasonable.",
          "createdAt": "2019-01-18T00:00:10Z",
          "updatedAt": "2019-01-18T00:00:51Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Good points regarding the tension of such validity mechanisms between keeping access to the content secret and making sure the content is still valid.\r\n\r\nFrom the publisher's side:\r\nMaybe it is worthwhile to add a new caching directive (e.g. \"cache-but-validate\") which would tell the UA if it should or shouldn't validate the content from the publisher's perspective. That way, a publisher that knows it provides data which is restricted in some parts of the world will avoid the validation phase, at a risk of persisting typos, and publishers that consider their content not sensitive will turn on validation to get better assurances against persistent typos or mistakes.\r\n\r\nFrom the user's side:\r\nMaybe in some browser modes (e.g. \"Privacy\" or \"incognito\" modes), UAs can ignore above directives and skip validation altogether, as an intervention. (at the risk of serving potentially-invalid content)",
          "createdAt": "2019-01-21T07:40:03Z",
          "updatedAt": "2019-01-21T07:40:03Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Are there other use cases besides supporting censorship and geoblocking? It\nseems developers already have the tools to accomplish that without\nintroducing additional SXG features, so I\u2019m wondering what\u2019s missing?\n",
          "createdAt": "2019-01-21T12:43:15Z",
          "updatedAt": "2019-01-21T12:43:15Z"
        },
        {
          "author": "bratell-at-opera",
          "authorAssociation": "NONE",
          "body": "With SXG I can put on the face of someone else and replay something they have said/published. The problem I'm thinking of isn't the replaying operation (I think it's perfectly fine to archive and show old web pages), but that it will be attributed to the source even if the source has changed their mind. \r\n\r\nThere has been numerous cases from the last few years where an initial news report turned out to be incorrect and was later changed, updated or corrected. As news sources have come under attack from decision makers it has become so much more important that information is up to date. If a decision maker or hostile power can replay a news source' mistakes or early best-effort reporting as \"current reporting\" that can be used to undermine the credibility of reputable news organizations, which is dangerous in so many ways.\r\n\r\nIt might be that this feature would be too dangerous for a news source to use and they should stay away from it, but I don't trust everyone to fully understand the implications of using SXG, especially if it will be heavily promoted and use encouraged by portal sites (like those run by Google and Microsoft).\r\n\r\nMaybe there are ways to handle this scenario that I'm missing but with what I understand it seems like SGX comes packaged with a big foot gun.",
          "createdAt": "2019-01-21T13:00:31Z",
          "updatedAt": "2019-01-21T13:00:31Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "It seems like that threat model is \u201cSomething was published without\nincluding subsequent corrections\u201d - but that use case already seems\naccounted for in the design. That is, as has been pointed out,\n\u201cresponsible\u201d organizations (which seems to be the presumption, given they\nsubsequently issue corrections) can, for example, use JS to ping to see if\nthere have been corrections. This doesn\u2019t seem dissimilar from the same\nroot cause as publishing a vulnerable (e.g. XSS) SXG.\n\nHowever, I think the tension here - between privacy on one hand and having\nthe \u201clatest\u201d edition, and censorship and being able to repudiate SXGs - is\nsomewhat intentional. SXG opts for more privacy and censorship resistance,\nand that admittedly does come with trade offs.\n",
          "createdAt": "2019-01-21T13:06:37Z",
          "updatedAt": "2019-01-21T13:06:37Z"
        },
        {
          "author": "bratell-at-opera",
          "authorAssociation": "NONE",
          "body": "An alternative to not displaying the resource (what you categorize as censorship) would be to stop labeling it with the original source.\r\n\r\nSo instead of \"foonews.com\" it would be \"foonews.com 3 June as per portalsite.com\", but that seems to be opposite of what \"portalsite.com\" wants and I don't really see what UI design would want or allow such a complicated explanation. Or an interstitial \"You are about to visit a revoked page, do you want to load the new version instead?\". Might also not be the choice of a UI designer, but I don't see \"refuse to display the page\" (what you call censorship) as the only way to handle a page a site no longer wants to spread.\r\n\r\nThen if the goal is that only portalsite.com should know who reads the pages (and have it be secret from foonews.com), then maybe portalsite.com can have some kind of proxy for checking whether a page has been revoked. Again, I'm not saying that would be the solution, but that there may be ways to fix the foot gun without losing any features.",
          "createdAt": "2019-01-21T13:38:21Z",
          "updatedAt": "2019-01-21T13:38:21Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I think there\u2019s a first step, which is agreeing whether or not it\nrepresents a problem. We should be very careful in designing functionality\nthat is inherently anti-privacy (functionally, the scheme just reinvented\nonline revocation checking, which most UAs find problematic). We\u2019ve also\nidentified multiple alternatives that don\u2019t require a new primitive and\nachieve the same result. The argument for the new primitive seems to be\nthat it will be a \u201cfoot gun\u201d unless it can be actively blocked at will, and\nI\u2019m not sure that\u2019s a shared perspective. Have I missed why the multiple\noptions publishers have, including not publishing an SXG, aren\u2019t sufficient?\n",
          "createdAt": "2019-01-21T13:44:23Z",
          "updatedAt": "2019-01-21T13:44:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "* I like the idea of including the signing date in the UI somewhere. I'm not sure it will fit, but we should ask our UI folks. Given the signing date, maybe with an oldness threshold defined by the publisher, I don't think there's any need to also list the distributor.\r\n* \"some kind of proxy for checking whether a page has been revoked\" is exactly the validity-url. It merely gives you a fresher signing timestamp, not TLS's full liveness property.",
          "createdAt": "2019-01-21T15:44:23Z",
          "updatedAt": "2019-01-21T15:44:23Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If a decision maker or hostile power can replay a news source' mistakes or early best-effort reporting as \"current reporting\" that can be used to undermine the credibility of reputable news organizations, which is dangerous in so many ways. \u2014 @bratell-at-opera \r\n\r\nTo build on this thought a little bit: in a part of the world where all of foonews.com traffic is routed through a central point, SXG gives portalsite.com the ability to selectively downgrade part of foonews.com without disrupting access to the rest of it. So /sport might be downgraded, but /weather stays fresh. Since some pages are fresh, users may not notice that /sport is actually outdated.\r\n\r\n(This \"attack\" is most effective if the CDN delivers SXG in which all links go back to the CDN itself (not the origin), but the CDN could require this for performance or availability reasons.)\r\n\r\nWithout SXG, a central point cannot disrupt access to a part of foonews.com--it can only block all of it, since it can't see what's being requested, or the content of individual URLs. (Similarly, portalsite.com could provide access to all of foonews.com with the exception of all articles that mention \"bananas\", which get a 404.)\r\n\r\n> It might be that this feature would be too dangerous for a news source to use and they should stay away from it but I don't trust everyone to fully understand the implications of using SXG\u2026\r\n\r\nCautious origins will probably need to either not publish SXGs, or only publish to CDNs it trusts. Allowing any CDN to cache content seems risky (even though allowing anyone to copy content is usually a helpful anti-censorship technique).",
          "createdAt": "2019-01-22T22:43:22Z",
          "updatedAt": "2019-01-22T22:43:22Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@ithinkihaveacat Note that there's no way for the CDN to deliver an SXG such that all links go back to the CDN itself. Even after bundling ships, the CDN would have to convince users to manually fetch content via the CDN, perhaps by blocking direct connections.",
          "createdAt": "2019-01-22T23:02:40Z",
          "updatedAt": "2019-01-22T23:02:40Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin There's not? I was thinking it would be possible, though via the mechanism of CDN policy, rather than a technical fix. e.g. a CDN will only cache content if all sub-resources are delivered from the CDN, and all links go back to the CDN. This would be faster for users, but would also lead users to think they're navigating around https://foonews.com, when they're actually on  https://portalsite.com/s/foonews.com.",
          "createdAt": "2019-01-22T23:34:36Z",
          "updatedAt": "2019-01-22T23:34:36Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "The WebKit team has similar concerns.\r\nAlways getting back to the publisher to validate that the content is still valid seems a good approach in the context of a browser.\r\nThis validation should not require any user credentials, which is an improvement over navigating to the publisher. If user is wary of doing such validation directly, user can ask its browser to do it through means like trusted third-party, Tor...",
          "createdAt": "2019-01-29T23:57:32Z",
          "updatedAt": "2019-01-29T23:57:32Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems that there is no definitely correct behavior for this. There is a significant amount of users who would prefer one behavior over the other to fulfill their needs (e.g. stronger privacy). \r\n\r\nThis suggests that:\r\n - It'd be best resolved through a user preference or equivalent.\r\n - Different browser vendors may have different opinions about what constitutes a good default.\r\n - The default value could be the same for all users or could be segmented, i.e. markets where surveillance is a significant user concern vs. not.\r\n\r\n(edit: I removed the reference to Issue 388 since the root concern is still being explored).",
          "createdAt": "2019-01-31T00:00:38Z",
          "updatedAt": "2019-01-31T00:37:42Z"
        },
        {
          "author": "wimleers",
          "authorAssociation": "NONE",
          "body": "Yesterday, it was announced that Google Chrome will be shipping this: https://webmasters.googleblog.com/2019/04/instant-loading-amp-pages-from-your-own.html. AFAICT this has not yet been addressed.\r\n\r\nOn the same day, Cloudflare announced support for Signed Exchanges: https://blog.cloudflare.com/announcing-amp-real-url/.",
          "createdAt": "2019-04-17T11:26:10Z",
          "updatedAt": "2019-04-17T11:26:10Z"
        }
      ]
    },
    {
      "number": 378,
      "id": "MDU6SXNzdWU0MDA5MjUwNDc=",
      "title": "Limit CanSignHttpExchange certificate lifetimes",
      "url": "https://github.com/WICG/webpackage/issues/378",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In [the blink-dev Intent-to-Ship thread](https://groups.google.com/a/chromium.org/d/msg/blink-dev/gPH_BcOBEtc/WXRzifVlDQAJ), @agwa suggests \r\n\r\n> It may also be a good idea to limit the lifetime of certificates used in SXG, to reduce the amount of time that an illegitimate certificate can be used, in case an attacker exploits a CA vulnerability to obtain future-dated good OCSP responses.\r\n\r\n* @agwa [suggests 7-14 days](https://groups.google.com/a/chromium.org/d/msg/blink-dev/gPH_BcOBEtc/eL5q1f-rDQAJ).\r\n* @clintwilson says [\"Something around 7-10 days would be a nice target IMO, but even restricting to 30-90 days would be a substantial improvement.\"](https://groups.google.com/a/chromium.org/d/msg/blink-dev/gPH_BcOBEtc/mfxmsbZ3DQAJ)\r\n* If we go to 7 days, we can probably get rid of any mention of OCSP responses. What's the longest certificate lifetime where folks would be comfortable dropping our requirement for OCSP stapling?\r\n* A very-short lifetime will be a problem if a CA has to temporarily disable issuance, for example after security weaknesses in certain domain validation methods are discovered. \r\n* Even a 90-day limit probably requires automated certificate rotation, a'la ACME. Shorter certainly does.\r\n* Should we say anything about re-using an old public key in a new certificate?\r\n\r\nThese requirements may well wind up in the [BRs](https://cabforum.org/baseline-requirements-documents/) instead of this repository's specs, but this issue will track getting them where they need to go.",
      "createdAt": "2019-01-18T23:17:47Z",
      "updatedAt": "2019-02-08T19:52:19Z",
      "closedAt": "2019-02-08T19:52:19Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We talked to @grittygrease from Cloudflare about shorter lifetimes. My (fallible) notes are:\r\n* 90-day lifetimes seem ok; anything shorter would require some code changes.\r\n* 7-day lifetimes would multiply the number of certificates they need to handle enough that current designs might not scale.\r\n* 7-day lifetime would limit uptime. In practice they see longer downtime periods for certificate issuance than OCSP.\r\n* Clock skew is an issue, but SXG's requirement for stapled OCSP responses hits those issues anyway.\r\n* Reusing key material across successive certificates doesn't help with any of the important problems.\r\n* 7-day certificates could make CT logs significantly bigger, which could hurt that ecosystem.\r\n* Future-dated OCSP responses seem like they should be forbidden by [BR](https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.2.pdf) 4.9.9 (\"OCSP responses MUST conform to RFC6960 and/or RFC5019.\") and those RFCs saying [\"The time at which the status was known to be correct SHALL be reflected in the thisUpdate field of the response.\"](https://tools.ietf.org/html/rfc6960#section-2.5) and [\"When pre-producing OCSPResponse messages, the responder MUST set the thisUpdate, nextUpdate, and producedAt times as follows: thisUpdate: The time at which the status being indicated is known to be correct.\"](https://tools.ietf.org/html/rfc5019#section-2.2.4), respectively. Thus, not too excited about shortening lifetimes past 90 days.\r\n\r\n",
          "createdAt": "2019-01-23T23:46:09Z",
          "updatedAt": "2019-01-23T23:46:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@clintwilson asked in #383 that we have \"some very rough consensus on max validity\" before we codify a particular limit.\r\n\r\n* Given Cloudflare's points, it seems like 7-day validities definitely won't work with the current state of the ecosystem.\r\n* 14-day probably has similar problems.\r\n* Anything longer than that still needs stapled OCSP responses, so doesn't help us simplify the format or parsing.\r\n* @sleevi mentioned somewhere that a 30-day max-validity was about the longest that would help mitigate future-dated OCSP responses (for CAs that don't believe they're already forbidden by the BRs).\r\n* A 60- or 90-day maximum still has the following benefits:\r\n  * Improves ecosystem agility by setting the upper-bound on how long it takes to roll out changes to certificate-related things.\r\n  * Bounds validation risks: if a validation method (e.g. [BR](https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.2.pdf) 3.2.2.4.1) or process (e.g. lack of a CAA record) isn't secure enough, then the lifetime is the upper-bound for the 'not secure' certificates, which could let us leave SXGs up while those certs expire.\r\n  * Bounds the length of time an undetected compromised key can be used.\r\n* @shigeki for Yahoo! Japan is worried about the viability of even a 90-day limit for their processes and the certificate reseller they use.\r\n\r\nThe max-validity is not intended to handle CA compromise like DigiNotar as suggested in https://github.com/WICG/webpackage/pull/383#issuecomment-457971640, since for that browsers would revoke the affected root.\r\n\r\nSo, let's see if we can find rough agreement on a max-validity that we expect to hold until at least January 2020. This could change early if a significant issue comes up or if Mozilla or Safari demand a particular max-validity in order to support the specification, but we won't expect to change it early.\r\n\r\nI'd like to pick 90 days because LetsEncrypt has shown it can work for lots of server operators, and I don't know of a similar proof of concept for shorter validity periods.\r\n\r\nI'm going to run a poll by posting 30-, 60-, and 90-day limits as Github comments. Use the :+1: reaction on an option if you're pretty sure it'll work for the ecosystem, and :-1: if you're pretty sure it won't, and feel free to write a longer answer as a comment. Thanks!",
          "createdAt": "2019-02-01T19:02:36Z",
          "updatedAt": "2019-02-01T19:11:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Bound the maximum Validity Period at 30 days.",
          "createdAt": "2019-02-01T19:03:01Z",
          "updatedAt": "2019-02-01T19:03:01Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Bound the maximum Validity Period at 60 days.",
          "createdAt": "2019-02-01T19:03:05Z",
          "updatedAt": "2019-02-01T19:03:05Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Bound the maximum Validity Period at 90 days.",
          "createdAt": "2019-02-01T19:03:10Z",
          "updatedAt": "2019-02-01T19:03:10Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I don't see any objections to 90 days, so I'll merge that as the limit, and will resist calls to change it again until next year.",
          "createdAt": "2019-02-08T19:20:37Z",
          "updatedAt": "2019-02-08T19:20:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #383, although folks should feel free to re-open this question in 2020.",
          "createdAt": "2019-02-08T19:52:18Z",
          "updatedAt": "2019-02-08T19:52:18Z"
        }
      ]
    },
    {
      "number": 387,
      "id": "MDU6SXNzdWU0MDQ1NDA5MTk=",
      "title": "Can SXG be used to track users?",
      "url": "https://github.com/WICG/webpackage/issues/387",
      "state": "OPEN",
      "author": "youennf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Scenario is the following:\r\n- User A goes to site S and gets a SXG\r\n- User A shares the SXG to user B\r\n- User B loads the SXG\r\n- Site S learns that there is a connection between user A and user B.\r\n\r\nOverall, SXG seems to ask publishers to use SXG so that content is not user-specific.\r\nBut there is currently no way for users to ensure that this is the case.\r\n\r\nOne possible solution is some kind of SXG transparency, as added https://github.com/WICG/webpackage/pull/381.\r\nIt is not clear whether that will scale though.\r\n\r\nAnother possibility is to get such a proof from the server itself.\r\nA specific credential less request from user B to the signed URL or to an URL generated from it by the client could do the trick. Liveness check could also piggy back on such a request.",
      "createdAt": "2019-01-29T23:59:33Z",
      "updatedAt": "2019-01-30T19:32:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Is there perhaps a bug in your description of the issue?\r\n\r\nThat is, does User B share with User A, or does User A share with user B?\r\n\r\nIt's not clear how the proof fetching would resolve this:\r\n* User A goes to site S and gets a SXG\r\n* User A[?] shares the SXG to user B[?]\r\n* User B loads the SXG\r\n* User B checks with the Origin X that the SXG is valid\r\n* [Origin X learns that there is a connection between User A and User B]\r\n* [Site S seems to still learn there's a connection between User A and User B]\r\n\r\nIt's not clear how the privacy issue is resolved by any supplementary requests from User B?",
          "createdAt": "2019-01-30T00:04:59Z",
          "updatedAt": "2019-01-30T00:04:59Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> Is there perhaps a bug in your description of the issue?\r\n\r\nCorrected, thanks!\r\n\r\n> That is, does User B share with User A, or does User A share with user B?\r\n\r\nUser A shares with user B indeed.\r\n\r\n> It's not clear how the privacy issue is resolved by any supplementary requests from User B?\r\n\r\nThe issue is how user B can make sure that the content provided by user A does not contain any info specific to user A.\r\n",
          "createdAt": "2019-01-30T00:07:24Z",
          "updatedAt": "2019-01-30T00:07:24Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@youennf Sorry for being dense, but could you more concretely expand \"user info\"?\r\n\r\nFor example, if the URL itself was distinguishing (for example, `example.com/article/share/some_random_id`), it seems that the information disclosure is possible.\r\n\r\nAlso, I may have been unclear whether Site S is the physical location/distributor of the SXG, or the logical location embodied/server reflected by the SXG. I didn't help with that, as I assumed \"Site S\" was the distributor (`cdn.example`) serving an SXG for Origin X (`example.com`). If the SXG is for `example.com/article/share/some_random_id`, then any liveness check seems like it would reveal a relationship between User A and User B to `example.com`. Similarly, if the \"unique\" SXG was served per-CDN, then `example.com` would also learn that the user was visiting `cdn.example` when User A performed their liveness check.\r\n\r\nHave I missed something in the analysis?",
          "createdAt": "2019-01-30T00:12:49Z",
          "updatedAt": "2019-01-30T00:12:49Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> @youennf Sorry for being dense, but could you more concretely expand \"user info\"?\r\n\r\nA random ID identifying the user. Or advertisements specific to the user.\r\n\r\n> For example, if the URL itself was distinguishing (for example, `example.com/article/share/some_random_id`), it seems that the information disclosure is possible.\r\n\r\nThis is the existing behavior and SXG does not make this worse if this info is in the URL.\r\nURLs are something very visible, and easy to process or analyze. Browsers can for instance act on them. Acting on content is much harder.\r\n\r\nA different way of seeing this issue is if user A shares an article containing some targeted adds.\r\nSharing the URL usually does not mean sharing the targeted adds.\r\nSXG might mean sharing the targeted adds.\r\nThe spec is pushing against that practice, having a way to actually enforce it seems good.\r\n\r\n> Also, I may have been unclear whether Site S is the physical location/distributor of the SXG, or the logical location embodied/server reflected by the SXG.\r\n\r\nI was thinking of S as example.com",
          "createdAt": "2019-01-30T00:51:16Z",
          "updatedAt": "2019-01-30T00:51:16Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Hope it's okay to comment here. Just wanted to mention the current AMP SXG implementation, in case some of that can inform the spec at all.\r\n\r\nIIUC, in the current implementation, a few things prevent this from happening without User A's cooperation:\r\n 1. amppackager fetches content from its backend server anonymously\r\n 2. amppackager only responds SXG if the [`AMP-Cache-Transform` request header](https://github.com/ampproject/amphtml/blob/master/spec/amp-cache-transform.md) is present, which typical UAs won't include\r\n 3. Chromium provides no UI for downloading or sharing an SXG that it has loaded (maybe DevTools? otherwise `curl`)\r\n 4. Chromium does not load SXGs on `file:`.\r\n\r\n(1) is unverifiable from User A's perspective, and (1) and (2) may not be true of all SXG servers. However, (3) and (4) are a function of the UA, and require that User A go out of their way to download and share.\r\n\r\nHowever, future UAs may add a share UI. Perhaps, then, the request of proof should occur at share-time, and not receive-time (addressing @sleevi's concern about the liveness check leaking the relationship). But then I'm not sure how such a request could be sufficiently anonymized (otherwise the server would just lie when generating its proof). Perhaps something akin to certificate transparency? But that likely has other problems.",
          "createdAt": "2019-01-30T02:09:08Z",
          "updatedAt": "2019-01-30T03:15:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've expanded the Watermarking section in #381 based on the discussion here.\r\n\r\nUser B's ability to check for watermarking via the validity-url is limited by the fact that we want a publisher to be able to keep old versions live when the changes aren't important. Otherwise, folks might be forced to stop using an app, or spend lots of expensive bytes, when they don't need to.\r\n\r\nHowever, to the extent that we think URLs are sufficiently analyzable by the browser (which I'm skeptical of, but https://github.com/WICG/webpackage/issues/387#issuecomment-458767722 endorses), maybe the browser can analyze the validity-url instead of just the request URL.",
          "createdAt": "2019-01-30T19:32:51Z",
          "updatedAt": "2019-01-30T19:32:51Z"
        }
      ]
    },
    {
      "number": 388,
      "id": "MDU6SXNzdWU0MDQ1NDE5OTY=",
      "title": "Should a SXG document be considered SecureContext or not?",
      "url": "https://github.com/WICG/webpackage/issues/388",
      "state": "OPEN",
      "author": "youennf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Say that liveness checks as described in https://github.com/WICG/webpackage/issues/376 are implemented and passing for a given SXG. It seems that the current document could be granted SecureContext.\r\n\r\nLet's say that liveness checks are not passing.\r\nIt seems that the level of security is not as high, which would mean that SecureContext should not be granted. Such variation may actually break content so it might be better to not render content to the user, and render the content fetched from the actual web site instead.\r\n\r\nA consequence is that while the liveness checks can be done in parallel to processing of the SXG (subresource loading, parsing...), the liveness checks should be validated before the first page rendering and any JavaScript execution.\r\n\r\nFor privacy/security purposes, even subresource loading should probably be postponed until these checks are done.",
      "createdAt": "2019-01-30T00:03:37Z",
      "updatedAt": "2019-04-09T12:15:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Could you explain why you don't believe that the level of security is as high? What are the properties that you think aren't met?",
          "createdAt": "2019-01-30T00:06:34Z",
          "updatedAt": "2019-01-30T00:06:34Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "As discussed in https://github.com/WICG/webpackage/issues/376, if there is a buggy SXG, chances are high that attackers will use it as much as possible.\r\nChances to get buggy SXG content is therefore bigger if you do get the SXG from somebody else than the publisher.\r\nThe liveness checks hopefully make the level of security on par.",
          "createdAt": "2019-01-30T00:13:42Z",
          "updatedAt": "2019-01-30T00:13:42Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Thanks! I was expecting you to say something about the key protection (which is similar to TLS session resumption, delegated credentials, secondary certs, and a host of other network-level things which may be invisible to the client), so that's a very different direction!\r\n\r\nWould this same logic apply to resources a client caches on disk, unrelated to SXG? That is, I'm trying to unpack what the property is that the HTTP disk cache provides (as we seen to be comfortable with SecureContext), but that SXGs do not.\r\n\r\nSimilarly, I'm trying to understand a bit more about where \"SecureContext\" is reflective of the integrity of the transport to when it becomes about the 'security' of the content. For example, whether we'd deny SecureContext for certain CSP policies. I had always imagined SecureContext to be about the transport-level security properties and integrity.",
          "createdAt": "2019-01-30T00:19:10Z",
          "updatedAt": "2019-01-30T00:19:10Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> Would this same logic apply to resources a client caches on disk, unrelated to SXG? That is, I'm trying to unpack what the property is that the HTTP disk cache provides (as we seen to be comfortable with SecureContext), but that SXGs do not.\r\n\r\nI think there is a difference between the two.\r\nA buggy HTTP disk cache entry is under the control of the client and the content publisher, the buggy SXG entry is not under the control of the content publisher.",
          "createdAt": "2019-01-30T00:53:15Z",
          "updatedAt": "2019-01-30T00:53:15Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "A cache entry isn\u2019t necessarily under the control of the publisher, is it?\nEspecially once the buggy entry is cached, only a Clear-Site-Data activity\nwould flush it, correct? Or is there some other element of control?\n\nI\u2019m trying to understand this concern more by trying to map to the world we\nhave, because I\u2019m not sure it\u2019s clear the property that is both missing and\ncritical enough to SecureContext to deny it for SXG, when we have much\nstronger signals of origin authenticity than TLS itself.\n\nFor example, in the world we have, we allow a site served over TLS to be\ntreated as SecureContext, even though it may have been served by a stale\nCDN that doesn\u2019t support Flushing. A site that \u201ccould\u201d flush their CDN, but\ndoesn\u2019t, doesn\u2019t seem fundamentally different from an SXG that \u201ccould\u201d have\na JS flush check, but doesn\u2019t. Should we deny SecureContext to known CDN\nASes, since we don\u2019t know whether the content is fresh?\n\nUnderstandably, there\u2019s a tradeoff for the priority of the constituencies,\nbut it\u2019s not clear why the freshness would impact SecureContext, or where\nthat threshold is.\n\nAlternatively, it may be that \u201cfreshness\u201d isn\u2019t the essential property, but\n\u201cvoluntary distribution agreement,\u201d since only CDNs with a private key\nassociates with that domain can serve that content. If that\u2019s the case, it\nseems alternative designs may exist to address the \u201crelationship\u201d property.\n",
          "createdAt": "2019-01-30T01:32:33Z",
          "updatedAt": "2019-01-30T01:32:33Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> only CDNs with a private key associates with that domain can serve that content\r\n\r\nRight, in such a case, there is a clear understanding that both parties are working together.\r\nProbably there are contracts between them, mechanisms for hot fixes...\r\n\r\nWith SXG, anybody can distribute the content.\r\nThe spec can probably add a way for a content provider to 'whitelist' some distributors so that these liveness checks be made optional for these 'trusted' distributors. I am not sure we should go there.",
          "createdAt": "2019-01-30T19:35:03Z",
          "updatedAt": "2019-01-30T19:35:03Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@youennf Thanks! I'm wanting to make sure I've got the problem well-framed enough to explore solutions. I mention this, because a liveness check is so critically disruptive to the privacy and performance properties of SXG that it seems like it would be a significant step back for a number of use cases.\r\n\r\nIt sounds like your primary concern is around \"A bug could be introduced in the content shipped in an SXG\", is that a fair (although grossly oversimplified) summary? If it is, could you help me unpack a bit more the type of \"bugs\" that would be concerning? Naively, I would get the impression that this is only concerned about scriptable content, but perhaps it's being seen to generalized to other types; for example, would an SXG of a CSS file be problematic? What about for a PNG file?\r\n\r\nThe concern - of a bug - sounds very different than the properties that SecureContext is meant to assert or guarantee. The client doesn't know about the relationship between the CDN and the Origin, for example, so at best, it merely seems to be an assumption that bugs \"could\" be fixed, not necessarily that they're prevented, purged, or otherwise managed. Given that SXGs (for scriptable content) have the ability to hotfix 'bugs', it seems similar to the status quo.\r\n\r\nI think it might be useful to compare with OCSP for checking certificate revocation. No UA has ever denied SecureContext or deferred processing content if an OCSP check does not succeed, which is (effectively) a \"liveness check\" for the TLS certificate. The closest that we got was Opera rendering the content, but degrading the UI, but they moved away from that. A liveness check for SXG would seem functionally identical to an OCSP request. Is there some property different for SXGs and TLS certs worth also capturing here?",
          "createdAt": "2019-01-30T19:55:53Z",
          "updatedAt": "2019-01-30T19:55:53Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "1. I'm curious about the distinction @youennf's making between liveness checks on signed exchanges (which he wants) vs liveness checks on certificate validity via OCSP (which @sleevi's saying Safari doesn't do). Is the important distinction that we trust people to protect their keys better than they avoid writing XSS bugs, or something else?\r\n2. The discussion of \"[SecureContext](https://w3c.github.io/webappsec-secure-contexts/#secure-contexts)\" would make more sense to me if it talked about whether signed exchanges should be considered same-origin with the same content retrieved over TLS. For example, an XSS exploit is likely to do more damage by leaking `localStorage` or `IndexedDB` information than by calling one of the [many fewer SecureContext APIs](https://cs.chromium.org/search/?q=SecureContext+lang:idl+-file:test&sq=package:chromium&type=cs). `[SecureContext]` APIs also often involve a permission prompt, and it'd be more plausible to delay those until we've fetched validity information, than to delay rendering or access to localStorage. So, did you mean to only talk about SecureContext, or to address the Origin of the signed content as a whole?",
          "createdAt": "2019-02-04T22:48:34Z",
          "updatedAt": "2019-02-04T22:48:34Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> for example, would an SXG of a CSS file be problematic? What about for a PNG file?\r\n\r\nI am mostly concerned about navigation loads. Once you have a document, other mechanisms like SRI can be used if need be.\r\n\r\n> 1. I'm curious about the distinction @youennf's making between liveness checks on signed exchanges (which he wants) vs liveness checks on certificate validity via OCSP (which @sleevi's saying Safari doesn't do)\r\n\r\nIIUIC, there were performance issues that make things difficult with OCSP checks.\r\nLiveness checks though are targeting the content author web site.\r\nThis web site has an incentive to deliver the content fast.\r\nChances are high that liveness checks will be fast as well.\r\n\r\n> 2\\. The discussion of \"[SecureContext](https://w3c.github.io/webappsec-secure-contexts/#secure-contexts)\" would make more sense to me if it talked about whether signed exchanges should be considered same-origin\r\n\r\nIn the case where signed exchanges are fetched same-origin, this is business as usual, probably no need for additional checks.\r\nWhen they are fetched from a cross-origin distributor, it seems the goal is that the generated document will have the origin of the content author, not the distributor origin.\r\n\r\n> 2\\. [many fewer SecureContext APIs](https://cs.chromium.org/search/?q=SecureContext+lang:idl+-file:test&sq=package:chromium&type=cs).\r\n\r\nConsequences with APIs like payment API might be bad.\r\nDitto for getUserMedia: for some websites, the user might not be prompted at all. Or microphone output is sent to someone unauthorized during a call.\r\n\r\n> 2\\. it'd be more plausible to delay those until we've fetched validity information, than to delay rendering or access to localStorage.\r\n\r\nThat might be feasible for some APIs but would add quite a bit of complexity.\r\nFor other APIs, like service worker, that seems pretty difficult.\r\n\r\n> a liveness check is so critically disruptive to the privacy and performance properties of SXG that it seems like it would be a significant step back for a number of use cases.\r\n\r\nThat is something that would be good to better understand. Maybe the use cases require different solutions or complementary solutions.\r\nI agree performance is important but there might be tradeoff with security, HTTPS is slower than HTTP for instance. Safari is implementing cache partitioning which has a theoretical perf hit.\r\nAs of privacy, if a page gets loaded, it will be easy for this page to trigger a load to its server so as to identify the user. Of course, there could be workarounds, like disabling the possibility for such pages to do any networking, but that might prevent any opportunity for the web page to implement hot fixes.\r\n\r\n\r\n",
          "createdAt": "2019-02-05T16:56:04Z",
          "updatedAt": "2019-02-05T16:56:04Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> I am mostly concerned about navigation loads. Once you have a document, other mechanisms like SRI can be used if need be.\r\n\r\nSorry, now I'm even more confused, in trying to understand the principle or goal you're trying to capture from not treating as `SecureContext`.\r\n\r\nIf it was about the transport properties, such as TLS, as it's used today, it would seem like it would matter equally regardless of content. You mentioned being concerned about bugs in the content, which seem possible there as well.\r\n\r\nHowever, the later parts of your reply leave me wondering whether the goal is to restrict access to certain APIs, and using `SecureContext` as a way of avoiding enumerating them individually / playing whack a mole. Going back to the original remarks, you mentioned that [it seems that the level of security is not as high](https://github.com/WICG/webpackage/issues/388#issue-404541996), but I'm not sure we've quite nailed down what that property is.\r\n\r\n> This web site has an incentive to deliver the content fast.\r\n\r\nI don't think the data supports this conclusion, as practiced today. But I also have concern that it's a bit at odds with the goals of improving distribution for Web developers and for users in emerging markets.\r\n\r\n> HTTPS is slower than HTTP for instance\r\n\r\nWhile not the issue for this, it would be useful if data could be shared on that. In many cases, we've seen HTTPS faster for users; whether through enabling new protocols (H/2 or QUIC) or through avoiding network (mis)management.\r\n\r\n> As of privacy, if a page gets loaded, it will be easy for this page to trigger a load to its server so as to identify the use\r\n\r\nI fear that may be overlooking significant use cases. I think one which we've heard from a number of developers is the idea to effectively prefetch or preload content in the background, to enable quick and efficient rendering. Using prefetch or preload, as they are today, reveals the user, just as much as liveness checks would. If this was aggregated across several domains, the act of that prefetching may reveal information about the content the user is viewing on the Distributor - for example, observing liveness fetches to `a.example`, `b.example`, and `c.example` may indicate you're viewing content related to those three domains.\r\n\r\nSpecifying a liveness check would introduce that same privacy risk, making it unlikely for Distributors to serve that content (versus, say, self-hosting it, as some may do today). Even restricting `SecureContext` can have impact - for example, in causing loads to be treated as mixed content and blocked (in the `Distributor` case) or allowing features that should be blocked (e.g. HTTP loads or WS).\r\n\r\nThis is why I'm so keen to understand those security properties we're talking about, and how we quantify them, in order to see if there are alternative, less disruptive solutions, which both help developers and help keep the platform consistent.",
          "createdAt": "2019-02-05T17:23:22Z",
          "updatedAt": "2019-02-05T17:23:22Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "> it'd be more plausible to delay those until we've fetched validity information, than to delay rendering or access to localStorage.\r\n\r\nFwiw I do like to avoid this too unless we find it'd be really the only desirable path. As far as I know (at least in most cases) security state is determined upon navigation / document creation, introducing a new intermediate state between non-SecureContext and SecureContext and allowing transition between them seems to open up another complex problem space, possibly too complex. I agree with @sleevi that we should nail down the security properties first. I also agree that the primary concern, i.e. bugs. seems something different from the property that SecurityContext is meant to guarantee.  Let me also /cc @mikewest reg: SecureContext",
          "createdAt": "2019-02-07T02:48:59Z",
          "updatedAt": "2019-02-07T02:48:59Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> > HTTPS is slower than HTTP for instance\r\n> \r\n> While not the issue for this, it would be useful if data could be shared on that. In many cases, we've seen HTTPS faster for users; whether through enabling new protocols (H/2 or QUIC) or through avoiding network (mis)management.\r\n\r\nSure, the point is that HTTPS initial objective was probably to be right in terms of security as well as reasonably efficient. Follow-up efforts made it even better. \r\nI would tend to do the same here.\r\n\r\n> you mentioned that [it seems that the level of security is not as high](https://github.com/WICG/webpackage/issues/388#issue-404541996), but I'm not sure we've quite nailed down what that property is.\r\n\r\nLet's have a try.\r\n\r\nA website has a security issue related to a particular resource. The web site is using things like proxy-revalidate to only need to care about client caches.\r\nThe web site decides to wipe client caches conditionally on some client-side cookie parameter.\r\nThe client loads a web page, the server checks the cookie and includes in the response a Clear-Site-Data HTTP response header to wipe out the whole client cache. The web site also updates the client cookie. If needed, the page also does a ping to the server to trigger Clear-Site-Data/page reload.\r\n\r\nIn a world without signed content, this might be good enough.\r\nIn a world with signed content, this might be broken.\r\n\r\nAfter the client cache is empty, an attacker makes the client download a signed content of the faulty resource. The ping to the server will not trigger any cache data clearing/reload.\r\n\r\nAccording https://wicg.github.io/webpackage/loading.html, the signed content is not added to the HTTP cache (as some kind of a protection?). Let's say now the above web site is using service worker and Cache API. The faulty resource will be stored opportunistically by the service worker (its cache was cleared) and will poison the web site persistently.\r\n\r\n> I also agree that the primary concern, i.e. bugs. seems something different from the property that SecurityContext is meant to guarantee\r\n\r\nSecureContext is about the trust you can have in a given document.\r\nAs stated above, the spec does not seem to have enough trust in signed contents to update the HTTP cache with it.\r\n\r\nWe can also look at the HTTPS state of the resource.\r\nIn the case a liveness check is done and succeeds, should the HTTPS state of the signed exchange be set to the HTTPS state of the liveness check? I would tend to say yes.\r\nIn the case a liveness check is not done or fails for some networking reason, what should be the HTTPS state of the signed exchange? IIUIC, the spec says to use the HTTPS state of the signed content load. This seems ok if the provider and distributor are using the same connection. I am not sure this is ok if the provider and distributor do not share the same connection.\r\n\r\nLet's say a content provider web site has a bad TLS setup.\r\nFor the sake of argument, the user agent will set the HTTPS state to deprecated for any load to the content provider server. User agent will set the HTTPS state to modern for any load made to the distributor server.\r\nIn a world without liveness checks, the user agent will initially load from the signed content and will set the document as secure. When reloading the page, the user agent will go to the content provider and make the document insecure.\r\nIn a world with liveness checks, the user agent offers a consistent behavior before and after reload.\r\n\r\n> Specifying a liveness check would introduce that same privacy risk, making it unlikely for Distributors to serve that content (versus, say, self-hosting it, as some may do today).\r\n\r\nNote that self-hosting also causes some privacy issues since the distributor might know all the newspaper articles a user is reading, and not only the first one if user is navigating to the content provider.\r\n\r\nAgreed on the principle that the privacy implications need to be cautiously evaluated.\r\nPrefetch/preload/liveness check should probably all be without credential.\r\nIf the liveness check is done at load/navigation time, there is nothing lost compared to regular loads in terms of privacy.\r\n\r\nSome flexibility can also be left to user agents in the way they implement liveness checks.\r\nA user agent may preconnect to the provider web site as soon as possible. If done at navigation time, Service Worker may come to the rescue.  Bundling might be also something that could be used to mutualize the liveness checks. Another user agent may send the liveness check earlier, based on some user specific knowledge or interaction heuristics.",
          "createdAt": "2019-02-08T18:44:30Z",
          "updatedAt": "2019-02-08T18:44:30Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> According https://wicg.github.io/webpackage/loading.html, the signed content is not added to the HTTP cache (as some kind of a protection?)\r\n\r\nThe reasoning for this isn't a security protection, it's about the privacy aspects. Those privacy aspects may be addressed/addressable in the context of double-keyed caches; however, since such work is not normatively specified right now, and there are UAs that don't double key, we took an approach to maximize privacy (in many of the design elements)\r\n\r\nThis same focus on privacy is why liveness checks are deeply concerning; as shown with OCSP, liveness checks fundamentally harm efforts to protect user privacy. The design goal has been to try to ensure that SXG not only does not introduce any privacy issues from the status quo, but to also take opportunities to improve it, where they exist.\r\n\r\n@jyasskin Would it make sense to capture this in the draft privacy considerations or as an explainer, perhaps? Namely, to capture some of the explicit design goals for (privacy and security) that contributed to the current design? It doesn't quite feel right in the spec, but it seems like it'd be useful context for folks reading to understand \"Why X, not Y?\"\r\n\r\n> Note that self-hosting also causes some privacy issues since the distributor might know all the newspaper articles a user is reading, and not only the first one if user is navigating to the content provider.\r\n\r\nCan you please explain how this would be? This only seems like it would be possible if the Publisher actively collaborated with the Distributor, by providing Distributor-specific SXGs in which all outbound links (e.g. to other articles of the Publisher) instead explicitly specify Distributor SXGs. In such an 'active collaboration' model, it's unclear whether this is a change from the status quo - the Publisher could do this via Pings or back channels, right?\r\n\r\n> Prefetch/preload/liveness check should probably all be without credential.\r\n\r\nI suspect we may have differing understandings of the processing model for SXGs as proposed, and the privacy properties we're trying to achieve.\r\n\r\nIt sounds as if your focus is on UA-provided information to the Distributor, such as credentials or other headers. However, a big concern on our end has been both the Publisher learning about the Distributor, and those on the network learning about activities on the Distributor.\r\n\r\nThe problem with liveness checks is that they undermine privacy in ways similar to XS-Search, even in a credential-less fetch. For example, consider if `distributor.example/page1` were to preload `publisher-1.example/`, `publisher-2.example/`, `publisher-3.example/`, while `distributor.example/page2` were to preload `publisher-a.example/`, `publisher-b.example/`, and `publisher-c.example`.\r\n\r\nWith a liveness check, credentialed or not, a network observer would be able to determine whether or not a user is on `distributor.example/page1` vs `distributor.example/page2` by observing whether or not requests were made to `publisher-1.example` vs `publisher-a.example`.\r\n\r\nSimilarly, on the publisher side, a publisher that received a liveness check to `publisher-1.example` would be able to know - at the time of preload/prefetch - that the user was was looking at `distributor.example/page1` if they knew about that association.\r\n\r\nAs we've seen across the Web ecosystem, privacy-conscious distributors are concerned about these sorts of side-channels - to both network observers and to less privacy-conscious publishers - and so take steps, such as rehosting content same-origin to prevent these sorts of side channels. SXGs are a means of achieving those privacy-preserving properties, while allowing meaningful and accurate attribution to users.\r\n\r\nHopefully this captures more clearly why liveness checks are fundamentally hostile to user privacy, and why they've been an important design consideration throughout. One would expect that the first steps a privacy-conscious browser or extension would take would be to disable them (or disable SXGs), both of which would then result in even worse consequences for the ecosystem, especially around privacy and authenticity of content.\r\n\r\nI'm hoping we can find alternative solutions that achieve that same goal, which is a critical use case here.\r\n\r\n> SecureContext is about the trust you can have in a given document.\r\n\r\nWe've tried very carefully to avoid overloaded terms like 'trust', which can mean varying things for recipients. In the context of the objectives that the [SecureContexts spec](https://w3c.github.io/webappsec-secure-contexts/) sets out, our view has been that it affords an appropriate level of confidentiality, integrity, and authenticity. Much of the threat model and considerations address this in the context of whether or not an origin has been authenticated.\r\n\r\nAs it relates to SXGs, I hope we've got agreement that the integrity and authenticity properties have been sufficiently maintained and are equivalent to that of TLS. The SXG spec notes that there are trade-offs with respect to confidentiality/privacy are noted in the privacy considerations.\r\n\r\nI think we want to be careful about 'trust', because a definition that also includes \"trust that there were no bugs\", or \"trust that the content is honest or accurate\", or more broadly, \"users can trust this\", require a lot of unpacking and have differing expectations. Much like TLS doesn't and shouldn't guarantee that the content is 'trustworthy' - merely that it was delivered over a connection with C/I/A properties - we have tried to avoid introducing those more subjective and problematic elements of trust.",
          "createdAt": "2019-02-08T19:21:39Z",
          "updatedAt": "2019-02-08T19:23:21Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "Below some more thoughts related to discussions we had with Jeffrey, Kouhei and Yoav during IETF 104.\r\n\r\n> With a liveness check, credentialed or not, a network observer would be able to determine whether or not a user is on `distributor.example/page1` vs `distributor.example/page2` by observing whether or not requests were made to `publisher-1.example` vs `publisher-a.example`.\r\n\r\nTrue.\r\nThat said, web packaging on its own is not sufficient to prohibit this to happen in a browser: reloading the page, clicking a link, the page loading some resources (high resolution images/videos)...\r\n\r\nCurrently, I think the benefits of a live check outweight its drawbacks, in the context of a browser.\r\nOther contexts, other additional technologies, other ways to do these kind of validations, might change things in the future.",
          "createdAt": "2019-04-01T17:51:54Z",
          "updatedAt": "2019-04-01T17:51:54Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "I think SecureContext should be granted provided a liveness check was done on the domain and passed, for a maximum of 30 days ago.\r\n\r\nThe reason, is that the minimum RGP (\"Redemption Grace Period\") according to ICANN, but are, by most registrars called a \"quarantine\" period, is 30 days.\r\nThis means, that we can be absolutely 100% sure, that a specific domain is in possession of the domain holder (or someone related to him - note that voluntary transfers are counted as \"related\"), atleast 30 days counted from the last liveness check.\r\n\r\nOnly past the 30 days there is a possibility that the domain have been aquired by a unrelated third-party.\r\n(For example, if a liveness check was done the second before the domain expired its renewal payment, after 30 days the domain would be free to be registred by someone else, whose might be affected by a signed SGX with regards to cross-origin)",
          "createdAt": "2019-04-09T06:59:31Z",
          "updatedAt": "2019-04-09T07:00:21Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I\u2019m not sure it\u2019s clear why the ICANN policies would relate at all to the\nliveness check. That seems largely orthogonal? In the event of a domain\nregistration change, the SXG certificate will have been revoked, or can be\nby the new holder, by virtue of the existing rules for certificates (e.g.\nthe Baseline Requirements, Section 4.9.1.1).\n",
          "createdAt": "2019-04-09T11:45:50Z",
          "updatedAt": "2019-04-09T11:45:50Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "The reason the liveness check should relate to the ICANN policies, is that within the grace period, we can, security-wise, know 100% that the content is trusted and by the domain owner.\r\n\r\nAway from that, the domain could potentially be by a new owner, and since automated CA's don't check whois for the domain expiration date, there will be no revocation, unless the new domain owner explicitly request it. He might not even be aware of the existence of the old cert.\r\n\r\nA TLS certificate for a domain who have changed owner, is of limited use for the old owner, as he would need to in some way capture or redirect traffic to his TLS server, and the 60 days left of the certificate, in worst case, also helps mitigate this issue.\r\n\r\nA SGX certificate however, is worser, as the signed content could be distributed, which creates a security hazard as CDNs propably will not do any further validations on content which is signed by the original domain owner where the SGX signature is still valid.\r\nThats why I propose tying the liveness check to ICANN policies, as the ICANN policies are minimum, no registrar ever are allowed to go below 30 days quarantine time.",
          "createdAt": "2019-04-09T12:10:19Z",
          "updatedAt": "2019-04-09T12:10:19Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I don\u2019t believe we can state \u201c100%\u201d, unless we\u2019re limiting the threat model\nto ONLY this specific attack. Note also that the ICANN policies only apply\nto a subset of TLDs (gTLDs), so it also does not provide a margin there.\n\nHowever, it does seem as if the concern is a misalignment between the\nlifetime of the assertion and the lifetime of the domain registration,\nwhich does seem as if it is a new concern (compared to those raised earlier\non the thread). I am curious whether a reduction in the certificate\nlifetime itself (e.g. from 90 days to 30) would be sufficient to mitigate\nthat concern, as an alternative to liveness checks.\n",
          "createdAt": "2019-04-09T12:15:53Z",
          "updatedAt": "2019-04-09T12:15:53Z"
        }
      ]
    },
    {
      "number": 389,
      "id": "MDU6SXNzdWU0MDYxMzc0NTM=",
      "title": "dump-signedexchange: make validation success/failure more obvious",
      "url": "https://github.com/WICG/webpackage/issues/389",
      "state": "CLOSED",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `dump-signedexchange` tool's `-verify` option sort of hides the validation result in the middle of its output. It would be useful if this were more prominently reported, especially in the failure case. Not a crucial thing, but it's not immediately obvious that validation has failed.\r\n\r\nScreenshot of successful validation:\r\n\r\n<img width=\"922\" alt=\"screenshot 2019-02-03 at 22 07 59\" src=\"https://user-images.githubusercontent.com/51244/52183540-9b2c6600-2800-11e9-96e2-00948b7648f4.png\">\r\n\r\nScreenshot of unsuccessful validation:\r\n\r\n<img width=\"922\" alt=\"screenshot 2019-02-03 at 22 08 23\" src=\"https://user-images.githubusercontent.com/51244/52183543-a2ec0a80-2800-11e9-99fd-6c8e4138f339.png\">\r\n",
      "createdAt": "2019-02-03T22:12:15Z",
      "updatedAt": "2019-02-15T05:25:16Z",
      "closedAt": "2019-02-15T05:25:16Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for filing this! Created #398.",
          "createdAt": "2019-02-15T02:25:04Z",
          "updatedAt": "2019-02-15T02:25:04Z"
        }
      ]
    },
    {
      "number": 390,
      "id": "MDU6SXNzdWU0MDY2NjYyNzk=",
      "title": "Accept-Encoding in Variants",
      "url": "https://github.com/WICG/webpackage/issues/390",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When fetching a Signed Exchange, Chromium sets `Accept-Encoding` request header to `gzip, deflate, br`. However, actually Chromium accepts differnt set of content encodings for Signed Exchange's outer and inner responses. `gzip`, `deflate`, and `br` are supported for outer responses, and only `mi-sha256-03` is supported for inner responses.\r\n\r\nThis is problematic when performing the [Request Matching](https://wicg.github.io/webpackage/loading.html#request-matching). For example if exchange has:\r\n```\r\n Variants: Accept-Encoding;mi-sha256-03\r\n Variant-Key: mi-sha256-03\r\n```\r\nIt will not match the `browserRequest` which has `Accept-Encoding: gzip, deflate, br`.\r\n\r\nWhat should we do?\r\n\r\nIdeas:\r\n- When making a redirect to the inner response, overwrite the request's `Accept-Encoding` header to `mi-sha256-03`.\r\n- Or, specify that Cache Behavior for Request Matching does not support Accept-Encoding content negotiation, because it makes little sense for signed exchange's inner responses (?)\r\n",
      "createdAt": "2019-02-05T07:56:57Z",
      "updatedAt": "2019-02-09T00:33:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "In the long run, I think it'll be useful to support encoded inner responses in *bundles* to optimize local disk storage. Since signed exchanges don't need to be random access, it's less important to support compressing the inner response if that makes the implementation trickier.\r\n\r\nIn the short run, I think it'd be fine to say that seeing `Accept-Encoding` in the `Variants` header results in a `mismatch` from https://wicg.github.io/webpackage/loading.html#request-matching. I won't get around to this in the next couple weeks.",
          "createdAt": "2019-02-09T00:33:59Z",
          "updatedAt": "2019-02-09T00:33:59Z"
        }
      ]
    },
    {
      "number": 391,
      "id": "MDU6SXNzdWU0MDcwMzY2MTI=",
      "title": "Limit Content-Encoding?",
      "url": "https://github.com/WICG/webpackage/issues/391",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "The chromium implementation doesn't support any inner content-encodings other than `mi-sha256-03`.\r\n\r\n1. Should the implementation snapshot document this upper bound? (And, AFAICT, it's also a lower bound via [signature validity](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#signature-validity) step 9.)\r\n\r\n2. Should the draft spec place any limits or suggestion on inner content-encoding? I don't suppose it could specify an allowed list of content encodings because that would preclude future integrity specs. But perhaps it could ban br, deflate, and gzip (unless there's a good reason to specify those on inner rather than outer). Perhaps it could mandate a maximum of one, but maybe that would preclude some future `Digest` header that requires nested encodings.",
      "createdAt": "2019-02-06T00:40:47Z",
      "updatedAt": "2019-06-01T23:20:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "From impl pov it's possible to support multiple content encodings with modest / reasonable amount of work, so if this could be important we can support that. (And sounds like a good idea reg: 1)\r\n\r\nFor 2: I generally agree that it may not make a lot sense to support br/gzip etc as that encoding can be rather applied to outer response/bundle but don't have a good idea what list we should use. Only allow mi-sha256 for now and extend the list whenever it becomes desirable?",
          "createdAt": "2019-02-13T03:40:44Z",
          "updatedAt": "2019-02-13T03:40:44Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "IMO, the implementation snapshot should document this, but I'm uncomfortable with an exactly-one Content-Encoding rule in the long run. It probably makes sense to ask the httpwg for some feedback here.",
          "createdAt": "2019-03-27T10:34:55Z",
          "updatedAt": "2019-03-27T10:34:55Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI: In the current work on `Digest` https://github.com/ioggstream/draft-polli-resource-digests-http/issues/20 we suggest that:\r\n\r\n- when signing the `Digest` header you MUST sign `Content-Type` and `Content-Encoding` too\r\n\r\nThis is because:\r\n\r\n```\r\nDigest := f(content-encoding(content-type( bits )))\r\n``` \r\n\r\nIn this spec then, I propose `Signed-Headers: content-type, content-encoding, ...` which in your case might provide some agility with future content codings (eg. mi-sha512, ...) without having to change the spec.",
          "createdAt": "2019-06-01T23:16:53Z",
          "updatedAt": "2019-06-01T23:20:52Z"
        }
      ]
    },
    {
      "number": 393,
      "id": "MDU6SXNzdWU0MDc1Nzc1NTg=",
      "title": "\"integrity header\" handling in loading spec",
      "url": "https://github.com/WICG/webpackage/issues/393",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The loading spec defines [integrity header](https://wicg.github.io/webpackage/loading.html#exchange-signature-integrity-header) as a list whose value is the result of splitting the `integrity` signature parameter on `/`.\r\n\r\nhttps://wicg.github.io/webpackage/loading.html#parsing-signature\r\n\r\n> 8. Set result\u2019s integrity header to the result of strictly splitting the \"integrity\" parameter of parsed[0] on U+002F (/).\r\n\r\nBut,\r\n\r\nhttps://wicg.github.io/webpackage/loading.html#read-a-body\r\n\r\n> 1. If signature\u2019s integrity header's first item is:\r\n>   \u21aa \"digest/mi-sha256-03\"\r\n\r\nThis can't be true. It should check if signature\u2019s integrity header is a two-elements list [\"digest\", \"mi-sha256-03\"]. Or maybe just let _integrity header_ a byte sequence, not a list?\r\n",
      "createdAt": "2019-02-07T07:53:22Z",
      "updatedAt": "2019-02-08T01:43:32Z",
      "closedAt": "2019-02-08T01:43:32Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Oops! This comes from #328, where I failed to catch that we needed to make the comparison match the fact that it's a list.\r\n\r\nI *think* we should just compare against the whole list here, instead of comparing by elements. I lean against representing it as just a byte sequence, since I do intend a hierarchical structure here, although a byte sequence would work just fine with the current state of the spec.",
          "createdAt": "2019-02-07T19:11:29Z",
          "updatedAt": "2019-02-07T19:17:10Z"
        }
      ]
    },
    {
      "number": 397,
      "id": "MDU6SXNzdWU0MDk2Mjc0MTI=",
      "title": "When to fallback redirect?",
      "url": "https://github.com/WICG/webpackage/issues/397",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current loading spec, redirect to the fallback URL happens only when [the signed exchange version is not supported](https://wicg.github.io/webpackage/loading.html#mp-http-fetch).\r\n\r\nHowever, Chromium implementation performs fallback redirect in the following cases (corresponding to the error codes [here](https://chromium.googlesource.com/chromium/src/+/HEAD/content/browser/web_package/signed_exchange_error.h)):\r\n\r\n- SXG was served from non-secure origin.\r\n- Unsupported version of SXG (could extract fallback URL).\r\n- SXG parse error (could extract fallback URL).\r\n- Network error occurred while loading SXG header.\r\n- Failed to fetch certificate chain.\r\n- Failed to parse certificate chain.\r\n- Signature verification failed.\r\n- Cert verification failed.\r\n- CT verification failed.\r\n- OCSP check failed.\r\n- Certificate Requirements aren't met.\r\n- SXG was served without `X-Content-Type-Options: nosniff` header.\r\n\r\nChromium doesn't fallbeck on the following errors:\r\n\r\n- SXG parse error (couldn't extract fallback URL).\r\n- Merkle integrity error.\r\n\r\nWe should clarify that which error should cause a fallback redirect, and spec them.\r\n",
      "createdAt": "2019-02-13T04:57:55Z",
      "updatedAt": "2019-05-24T18:30:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "/cc @twifkak for consumer side feedback",
          "createdAt": "2019-02-13T05:01:16Z",
          "updatedAt": "2019-02-13T05:01:16Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for opening the issue. Sorry for the delay; I've been sick and this slipped my radar.\r\n\r\nAs a consumer & distributor, my product preference is to make as many things as possible a fallback. That said, I understand there may be reasons _not_ to prefer that, and I would like to know more about them:\r\n - Debugging -- as a developer, I won't even notice that my SXG is invalid unless I have DevTools Network tab open _and_ I scroll all the way to the top. That said, it seems like the UA should prioritize the typical user's experience over developer experience.\r\n - What others?\r\n\r\nFrom your list above, I think there are some that I would feel safe removing fallback for today:\r\n - SXG was served from non-secure origin.\r\n - Network error occurred while loading SXG header. _(I assume this is a network error on the outer response?)_\r\n - SXG was served without `X-Content-Type-Options: nosniff` header.\r\n\r\nEssentially these are all the \"outer exchange\" things that are well-trodden and I feel confident we'll do correctly; also, they require that we _generate_ the correct response rather than that we _validate_ (but don't modify) a given response.\r\n\r\nI'm also okay with not falling back for Merkle integrity (this one was simple enough to check) or parse error (fallback seems dangerous).\r\n\r\nFor a distributor with the privacy-preserving-prefetch use case, the downsides of having a network error page are:\r\n - The user sees an error page instead of simply reduced page speed & extra network bytes.\r\n - The error page is unbranded. (In the early days of AMP, there used to be more [branded error pages](https://www.seroundtable.com/photos/google-amp-error-man-21686.html), but my understanding is that these have significantly reduced in frequency due to improvements in search infra.).\r\n\r\nThe potential reasons that our cache may serve an invalid SXG include:\r\n - A known limitation in our implementation (i.e. we haven't implemented validation X yet).\r\n - An unknown difference (i.e. a bug in either our cache's or the UA's implementation of SXG validation).\r\n - An intrinsically unsolvable difference (e.g. it's impossible to know the UA's trusted roots, or UA clock jitter [skew changing significantly from one request to another]).\r\n\r\nAt this point, I'm mostly worried about the first two. But I'm mostly guessing. After #374 (and after we implement server-side monitoring of those reports), I'll be able to respond more usefully.",
          "createdAt": "2019-02-20T01:01:27Z",
          "updatedAt": "2019-02-20T01:06:20Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "(I'm presuming that the fallback for SXG version mismatch happens before the network error for MICE decode failure. Otherwise, future Chromium versions will need to continue supporting old MICE versions.)",
          "createdAt": "2019-02-21T02:00:07Z",
          "updatedAt": "2019-02-21T02:00:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thank you for collating all the error cases so we can just go through them. My suggestion is:\r\n\r\n|Situation|Behavior|Notes|\r\n|---------|--------|-----|\r\nSXG was served from non-secure origin. | \ud83d\uded1Error\r\nUnsupported version of SXG (could extract fallback URL). | \u21aa\ufe0fFallback\r\nSXG parse error (could extract fallback URL). | \ud83d\uded1Error\r\nNetwork error while streaming SXG header or body. | \ud83d\uded1Error\r\nFailed to fetch certificate chain. | \ud83d\uded1Error\r\nFailed to parse certificate chain. | \ud83d\uded1Error\r\n[Signature parsing](https://wicg.github.io/webpackage/loading.html#parsing-signature) failed (This includes fetching and parsing the certificate) | \ud83d\uded1Error\r\nSignature isn't [valid](https://wicg.github.io/webpackage/loading.html#validating-signature) | \u21aa\ufe0fFallback | This could error instead on the last step, which actually runs the validation algorithm?\r\nCertificate doesn't have the CanSignHttpExchanges OID | \ud83d\uded1Error | Maybe we shouldn't make this exception from the next step.\r\nCertificate chain [does not have a trusted leaf for the origin](https://wicg.github.io/webpackage/loading.html#certificate-chain-has-a-trusted-leaf) for another reason | \u21aa\ufe0fFallback | This includes cert path building, OCSP checking, and CT checking.\r\nCertificate chain does not [establish cross-origin trust](https://wicg.github.io/webpackage/loading.html#exchange-signature-establishes-cross-origin-trust) for another reason | \ud83d\uded1Error | The non-certificate reasons can be checked on the distributor.\r\nSXG was served without X-Content-Type-Options: nosniff header. | \ud83d\uded1Error\r\nSXG parse error (couldn't extract fallback URL). | \ud83d\uded1Error\r\nMerkle integrity error. | \ud83d\uded1Error\r\n\r\n\r\nI basically want anything the distributor could catch to be an Error, while anything that clients might vary on (mostly time & crypto validity) should fall back. @sleevi, how do you feel about this list?",
          "createdAt": "2019-05-15T00:25:03Z",
          "updatedAt": "2019-05-15T00:25:03Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> I basically want anything the distributor could catch to be an Error, while anything that clients might vary on (mostly time & crypto validity) should fall back.\r\n\r\nAt first glance, that sounds like a great principle and I think your analysis is reasonable and spot-on. Signature isn\u2019t valid seems a reasonable error?",
          "createdAt": "2019-05-15T00:56:21Z",
          "updatedAt": "2019-05-15T00:56:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi https://wicg.github.io/webpackage/loading.html#validating-signature includes the check against the client's clock (which I think should definitely fall back) and the check that it's a secp256r1 key (where I want to have clients fall back when they remove broken crypto, but maybe we should do that with a version increment instead). \r\n\r\nWe should also make sure that the reporting API distinguishes between the cases that error vs fall back. Right now there are distinctions in the table above that aren't captured in the reporting API results.",
          "createdAt": "2019-05-15T03:34:04Z",
          "updatedAt": "2019-05-15T03:34:04Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Yeah, the approach for changing crypto primitives was definitely seen as a version-bumpable thing. Perhaps it's worth splitting out \"validate a signature\" and \"validate the timestamp\" as two separate things, the former being an error, the latter being a fallback?",
          "createdAt": "2019-05-15T15:42:19Z",
          "updatedAt": "2019-05-15T15:42:19Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Initial NEL analysis from AMP Cache is available to Googlers in http://b/126787670. Overall, error rate is relatively low, but I'd say not low enough to serve network errors in all cases.\r\n\r\nThe two most prevalent errors are cert_fetch_error & mi_error. My understanding is that these can be due to a bad connection, which is beyond the control of the distributor (e.g. may be due to ISP issues or spotty cell coverage). I'm thinking that these cases should continue to fall back. Otherwise, spotty connnections would disproportionately affect SXG, because browsers are willing to render unsigned HTML that was truncated or had failed subresources. Are there downsides to falling back in these cases?",
          "createdAt": "2019-05-21T02:36:34Z",
          "updatedAt": "2019-05-21T02:36:34Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Cert Fetch Errors are more similar to failures to fetch AIA (which causes\nhardfail) or OCSP (for which behaviour varies between browsers), right?\n\nAs to whether it\u2019s safe, the analysis would be:\n- Identifying all the information an adversary could learn by observing the\nfallback occurred\n- Identifying whether and how that information might already be available\n- Identifying how that information could be abused\n- Identifying what the process would be if we \u201cgot it wrong\u201d in the\nanalysis (in this case, what the implications would be if a browser had to\nsuddenly switch to block)\n",
          "createdAt": "2019-05-21T02:41:58Z",
          "updatedAt": "2019-05-21T02:41:58Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Reg. mi_error:\r\n\r\nFrom the implementation's POV, browser sends SXG's inner response header to the renderer as soon as the SXG header is validated. Merkle integrity error is detected after that, so it's too late to chagne the response to 303 redirect at that pont.",
          "createdAt": "2019-05-21T03:30:49Z",
          "updatedAt": "2019-05-21T03:30:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "cert_fetch_error: My instinct is that a failure to fetch the certificate from the same origin that's already transferring the signed exchange is similarly likely to a failure to fetch the signed exchange itself or the content from the publisher. Since we don't auto-reload on a network error, we shouldn't auto-redirect on one either.\r\n\r\nmi_error:\r\n\r\n1. It seems confusing to have a network error that truncates the SXG be expressed as `mi_error`. I think I'd want to see one of https://w3c.github.io/network-error-logging/#transmission-of-request-and-response-errors instead? @irori/@horo-t Is that plausible?\r\n\r\n2. I hope the browser can render the parts of the content that have already been verified, even if the connection is broken which truncates and invalidates the last chunk.",
          "createdAt": "2019-05-23T19:17:00Z",
          "updatedAt": "2019-05-23T19:17:00Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "> mi_error:\r\n> \r\n> 1. It seems confusing to have a network error that truncates the SXG be expressed as `mi_error`. I think I'd want to see one of https://w3c.github.io/network-error-logging/#transmission-of-request-and-response-errors instead? @irori/@horo-t Is that plausible?\r\n\r\nIIUC, currently both a `mi_error` and a transmission error are reported. I think it's possible to stop sending mi_error for network error cases, but I'll defer to @horo-t.\r\n\r\n> 2. I hope the browser can render the parts of the content that have already been verified, even if the connection is broken which truncates and invalidates the last chunk.\r\n\r\nChrome works in this way, although it's not guaranteed that response is loaded to the last validated chunk (internal buffer is discarded upon network error).\r\n",
          "createdAt": "2019-05-24T01:42:31Z",
          "updatedAt": "2019-05-24T01:42:31Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> > mi_error:\r\n> > \r\n> > 1. It seems confusing to have a network error that truncates the SXG be expressed as `mi_error`. I think I'd want to see one of https://w3c.github.io/network-error-logging/#transmission-of-request-and-response-errors instead? @irori/@horo-t Is that plausible?\r\n> \r\n> IIUC, currently both a `mi_error` and a transmission error are reported. I think it's possible to stop sending mi_error for network error cases, but I'll defer to @horo-t.\r\n\r\nI agree.\r\nWe should not send `mi_error` when caused by a transmission error.\r\nWe need to update both the loading spec and Chromium implementation.",
          "createdAt": "2019-05-24T10:32:46Z",
          "updatedAt": "2019-05-24T10:32:46Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarifications; looks like I misunderstood what `mi_error` meant for the user. Re: `cert_fetch_error`; I'll defer to you all, unless I learn that these errors are disproportionately large and can't be mitigated at implementation side, and I can come up with a good reason they're different from AIA fetch. (The only difference I can think of is that a secure fallback seems *possible* in this case.)",
          "createdAt": "2019-05-24T18:30:01Z",
          "updatedAt": "2019-05-24T18:30:01Z"
        }
      ]
    },
    {
      "number": 399,
      "id": "MDU6SXNzdWU0MTQzNzEwMTI=",
      "title": "Long-lived content",
      "url": "https://github.com/WICG/webpackage/issues/399",
      "state": "OPEN",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The use case document mentions the [ongoing web publication work](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#rfc.section.2.2.1). The key question has come up in many conversations, but I wanted to get it in GitHub. Certain types of publications, such as books, hope to live forever. Users expect to be able to access the content whether or not the publisher still exists. Moby-Dick was published 61,126 days ago, which is somewhat longer than the 7 days that signatures are valid. \r\n\r\nWhat options might publishers have? What happens if we create a bundle of unsigned exchanges? Much of our content would use JS only for a service worker. How does that impact the security issues?\r\n\r\n",
      "createdAt": "2019-02-26T00:21:52Z",
      "updatedAt": "2019-11-19T02:36:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "> The key question has come up in many conversations, but I wanted to get it in GitHub.\r\n\r\nThank you for doing so.\r\n\r\nService Worker probably complicates the situation...\r\nCould you clarify use cases for which web publications would use a Service Worker?\r\n\r\nI had assume that any Web Publication designed to be long-lived would be a self-contained piece of content that completely work offline by virtue of having all their resources included in the bundle.",
          "createdAt": "2019-02-26T00:49:57Z",
          "updatedAt": "2019-02-26T00:49:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "You can absolutely create a bundle of unsigned exchanges, but then you wouldn't execute as a [secure context](https://w3c.github.io/webappsec-secure-contexts/) **in a web browser**, and that would prevent you from [installing a Service Worker](https://w3c.github.io/ServiceWorker/#navigator-serviceworker).\r\n\r\nHowever, an ebook reader doesn't necessarily need to have the same security model as a web browser. You could treat a particular file as an origin, and then the bundle in that file would be a secure context. (We could potentially even do that in a web browser...) You could define your own X.509 certificate extension, with its own rules for validity. How do publishers want to handle old signatures using potentially-broken algorithms or potentially-compromised signing keys?\r\n\r\nIncidentally, I think I put the requirement that signatures are valid for at most 7 days in the wrong section. It's currently in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity, so it affects even signatures that have nothing to do with a browser's security model, but I think it should actually be in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust, where it would only affect the decision about whether to trust the signature in that one particular way. I'm not likely to get to that before at least April, so patches to do it are welcome.\r\n\r\n",
          "createdAt": "2019-03-07T00:17:26Z",
          "updatedAt": "2019-03-07T00:17:26Z"
        },
        {
          "author": "pagelab",
          "authorAssociation": "NONE",
          "body": "The EPUB format it's more appropriate for long lived content.",
          "createdAt": "2019-11-19T02:35:38Z",
          "updatedAt": "2019-11-19T02:36:08Z"
        }
      ]
    },
    {
      "number": 400,
      "id": "MDU6SXNzdWU0MTUzMzM1Njg=",
      "title": "Add an example SXG error report",
      "url": "https://github.com/WICG/webpackage/issues/400",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@horo-t, could you add an example ([`<div class=\"example\" id=\"example-network-error-log\">`](https://tabatkins.github.io/bikeshed/#notes-etc)) Network Error Log that could be produced by the spec you added in #374? https://wicg.github.io/webpackage/loading.html#queue-report would be a reasonable place to put it unless you think somewhere else will be more clear.",
      "createdAt": "2019-02-27T21:24:25Z",
      "updatedAt": "2019-03-24T09:31:48Z",
      "closedAt": "2019-03-24T09:31:48Z",
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure.",
          "createdAt": "2019-02-28T03:49:54Z",
          "updatedAt": "2019-02-28T03:49:54Z"
        }
      ]
    },
    {
      "number": 402,
      "id": "MDU6SXNzdWU0MTU0NDcyMjM=",
      "title": "Consider adding web package mime types to CORB",
      "url": "https://github.com/WICG/webpackage/issues/402",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "CORB seems like a good thing to enable for more mime types. Since there are very few users of our mime types, we should see if it makes sense to turn on CORB for them. We're trying to discourage personalized data in signed exchanges, but unsigned bundles could certainly have it.\r\n\r\n@anforowicz for any thoughts.",
      "createdAt": "2019-02-28T04:54:55Z",
      "updatedAt": "2019-03-02T02:10:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "Covering web package mime types by CORB sounds good to me (*).  Could you please point out in https://github.com/whatwg/fetch/issues/860 which mime types should be covered (anything beside \"`application/signed-exchange`\"?).\r\n\r\n(*) Ideally we would figure out a more systematic protection for no-cors resources (e.g. credential-less or cors-only fetches by default), but current ideas seem likely to break existing websites and therefore CORB seems like a necessary short-term approach.  (cc @annevk @csreis)",
          "createdAt": "2019-02-28T17:03:13Z",
          "updatedAt": "2019-02-28T17:03:13Z"
        },
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "@annevk points out (in https://github.com/whatwg/fetch/issues/721#issuecomment-468363310) that for other new types (e.g. for JavaScript modules) we successfully started requiring CORS right from the beginning.  Mentioning this, in case this is something we should consider for web packages (but maybe web package fetches are never initiated from a web page - requiring CORS doesn't seem to make sense for navigation-like fetches?).",
          "createdAt": "2019-02-28T19:05:25Z",
          "updatedAt": "2019-02-28T19:05:25Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "> @annevk points out (in [whatwg/fetch#721 (comment)](https://github.com/whatwg/fetch/issues/721#issuecomment-468363310)) that for other new types (e.g. for JavaScript modules) we successfully started requiring CORS right from the beginning. Mentioning this, in case this is something we should consider for web packages (but maybe web package fetches are never initiated from a web page - requiring CORS doesn't seem to make sense for navigation-like fetches?).\r\n\r\nRequiring CORS doesn't mitigate risks of info leak through Spectre or renderer compromise. i.e. any website should still be able to do no-cors requests (e.g. `<img src=\"//victim.tld/secret.sxg\">`) and information will be loaded into renderer. So CORB makes sense right now. But once [347](https://github.com/WICG/webpackage/issues/347) comes in, requiring CORS for subresource SXG files might be a good idea. Otherwise we probably need inner mime type based CORB blocking for SXG files.",
          "createdAt": "2019-03-01T06:47:40Z",
          "updatedAt": "2019-03-01T06:47:40Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We should think about banning no-cors requests even for `<img src=\"//victim.tld/secret.sxg\">`, since nobody yet uses `.sxg` images, but if we can't do that, I agree we should use @kinu's suggestion of CORB filtering based on the inner content type.",
          "createdAt": "2019-03-01T22:32:56Z",
          "updatedAt": "2019-03-01T22:32:56Z"
        },
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "@shhnjk , the proposal is to disallow no-cors requests altogether (e.g. even `<img src=\"//victim.tld/secret.sxg\">` would require CORS).\r\n\r\n@jyasskin and @kinu - CORB is needed to prevent a compromised renderer to just asking a NetworkService for the contents of the *whole* SXG.  I don't understand why in addition to blocking *whole* SXG, CORB would also want to look *into* SXG - maybe I am missing some details / scenarios where this is important (e.g. I don't really understand how SXG enters the picture and maybe intercepts image and/or XHR requests)?",
          "createdAt": "2019-03-01T22:44:16Z",
          "updatedAt": "2019-03-01T22:44:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@anforowicz (With the caveat that I know very little about the CORB landscape) *If* we allow no-cors requests that find an `application/signed-exchange` resource, that resource might contain either an image or an HTML file. If it's an image, then the compromised renderer should be able to retrieve it, just like it could retrieve an image that's not wrapped into a signed exchange. If it's HTML, the renderer should be blocked, just like it's blocked from retrieving a non-wrapped HTML file.\r\n\r\nI'd rather just block SXG responses to no-cors requests if we can and if that's sufficient, because that sounds simpler.",
          "createdAt": "2019-03-01T22:49:53Z",
          "updatedAt": "2019-03-01T22:49:53Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "> @shhnjk , the proposal is to disallow no-cors requests altogether (e.g. even `<img src=\"//victim.tld/secret.sxg\">` would require CORS).\r\n\r\n@anforowicz \r\nHow will you compare CORS against navigation requests?\r\nWhich CORS header will you compare? Outer or Inner?\r\nI don't think CORS will makes sense for SXGs which will be used for navigation requests. Yes, it makes sense to require CORS for subresource requests to SXG files (so that CORB `application/signed-exchange` by default would still work).",
          "createdAt": "2019-03-01T23:09:30Z",
          "updatedAt": "2019-03-01T23:09:30Z"
        },
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "> I'd rather just block SXG responses to no-cors requests if we can and if that's sufficient\r\n\r\nMaybe it is sufficient to restrict SXG, no-cors requests to only image/*, audio/*, video/*, application/javascript, text/css content types?\r\n\r\nBut then - where are the SXG contents \"opened\" / \"extracted\"?  We can't block things in the renderer (it is already too late there because of Spectre and/or risk of compromised renderers).",
          "createdAt": "2019-03-01T23:15:03Z",
          "updatedAt": "2019-03-01T23:15:03Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "@anforowicz -- SXG is basically considered at network layer concept, in Chromium implementation it's unwrapped way before the content hits the renderer so sniffing the inner type for CORB should work. (To add a little more technical detail-- it's currently done in the browser process, we've discussed unwrapping in Network Service but it hasn't happened because of lack of strong pros vs cons, but that part can be discussed separately)\r\n\r\nGiven that outer body wouldn't hit the renderer process and renderer will only see the inner response, I'm not fully convinced why they (e.g. jpg image delivered in SXG) need to be handled differently from others (e.g. regular jpg image)-- while, to be clear, I'm generally in favor of pushing the word towards no-no-cors/cors-only so can understand the motivation.",
          "createdAt": "2019-03-02T00:07:16Z",
          "updatedAt": "2019-03-02T00:07:16Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "> Given that outer body wouldn't hit the renderer process and renderer will only see the inner response, I'm not fully convinced why they (e.g. jpg image delivered in SXG) need to be handled differently from others (e.g. regular jpg image)\r\n\r\nMaybe I didn't understand how SXG works. So in current implementation, if there's a image request to SXG file (from non-SXG page) which contains HTML (i.e. `<img src=\"//other.tld/html.sxg\">`), will it be parsed in the browser process to serve inner content or will it be passed to renderer's image parser? \r\n\r\nMy understanding was that subresource request from normal HTML page to SXG file wouldn't trigger SXG parser in the browser. Is that right?",
          "createdAt": "2019-03-02T00:21:33Z",
          "updatedAt": "2019-03-02T00:23:59Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "@shhnjk Well current implementation doesn't support subresources, so we need talk about hypothetical code base, and I started to realize that this has more subtlety than I thought but let me try. (I suppose you're familiar with the chrome architecture)\r\n\r\nIf there's a image request where SXG for HTML is returned, it will be surely parsed in the browser process (or possibly in Network Service if we make the change) at least in our currenmt thinking. For https://github.com/WICG/webpackage/issues/347 this is not that hard because we can know what subresource requests may be fulfilled as SXGs before the renderer starts to consume the main resource. If we start to support regular subresource requests for SXGs things will become a bit trickier for saner cross-origin isolation, and we probably need to move the parsing code into the Network Service due to the architectural reasons. But all in all unwrapping wouldn't happen in the renderer process in subresource cases either.",
          "createdAt": "2019-03-02T01:08:18Z",
          "updatedAt": "2019-03-02T01:08:18Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "Right, so the concern is that until there is a support for subresource requests in SXG, subresource requests to SXG files will be handled by other parsers (which means outer body will hit the renderer). Which we want to avoid because renderer process can then get cross-origin information.\r\n\r\nBut since unwrapping happens inside browser process, content type sniffing is possible. So until there is a subresource support in SXG, blocking SXG mime type as a whole should be safe. Once subresource supports comes in, inner content type based CORB blocking could happen (either by safe list or unsafe list). Require CORS for all SXG subresource is a nightmare++ :D",
          "createdAt": "2019-03-02T01:57:48Z",
          "updatedAt": "2019-03-02T01:57:48Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay-- fair enough. Currently I don't think SXG spec says anything about main resource vs subresource (so it's just that impl has a gap), could we say something like \"the CORB protection for SXG should be also applied unless implementation supports SXG handling for subresources\" ?\r\n",
          "createdAt": "2019-03-02T02:10:44Z",
          "updatedAt": "2019-03-02T02:10:44Z"
        }
      ]
    },
    {
      "number": 403,
      "id": "MDU6SXNzdWU0MTYwNTMwODY=",
      "title": "Support loading Signed Exchanges from blob: or filesystem: URI",
      "url": "https://github.com/WICG/webpackage/issues/403",
      "state": "OPEN",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current loading spec is checking the `response\u2019s header list` in [Identifying signed exchanges](https://wicg.github.io/webpackage/loading.html#identifying-sxg) section.\r\nSo signed exchanges can't be loaded from blob: or filesystem: URI where no `header list` exists.",
      "createdAt": "2019-03-01T11:06:57Z",
      "updatedAt": "2019-03-01T18:32:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "Do you want to support data: URI too?",
          "createdAt": "2019-03-01T17:45:59Z",
          "updatedAt": "2019-03-01T17:45:59Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Note: If these are supported, they will probably meaningfully impact the\nNEL reporting aspects, particularly for publishers, but also potentially\nfor distributors. For example, if trying to report issues loading an SXG,\nif the top-level origin is a blob or data URI, that would create issues.\n",
          "createdAt": "2019-03-01T18:32:06Z",
          "updatedAt": "2019-03-01T18:32:06Z"
        }
      ]
    },
    {
      "number": 405,
      "id": "MDU6SXNzdWU0MjA3MzI4MTE=",
      "title": "Are OCSP responses with multiple SingleResponses allowed?",
      "url": "https://github.com/WICG/webpackage/issues/405",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust item 7.3 says:\r\n\r\n> Validate that `main-certificate` has an `ocsp` property\r\n> ({{cert-chain-format}}) with a valid OCSP response whose lifetime\r\n> (`nextUpdate - thisUpdate`) is less than 7 days ({{!RFC6960}}).\r\n\r\nBut per https://tools.ietf.org/html/rfc6960#section-4.2, an `OCSPResponse` may have multiple `SingleResponse`s, each with its own `nextUpdate` and `thisUpdate`. Are such OCSP responses disallowed by the spec? Otherwise, to which `SingleResponse` does this requirement apply?",
      "createdAt": "2019-03-13T21:42:16Z",
      "updatedAt": "2019-03-14T00:52:11Z",
      "closedAt": "2019-03-14T00:52:11Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> Are such OCSP responses disallowed by the spec?\r\n\r\nNot at present. Considering the implications to CAs, that would start getting into a policy/certificate profile doc beyond just the extension. Both 6960 and 5019 permit multiple `SingleResponse`s.\r\n\r\n> Otherwise, to which SingleResponse does this requirement apply?\r\n\r\nConsistent with the existing handling of OCSP and RFC 5019/5280/6960, provided that there is a `SingleResponse` that meets this criteria, one may consider the `OCSPResponse` valid for that certificate.",
          "createdAt": "2019-03-13T22:07:17Z",
          "updatedAt": "2019-03-13T22:07:17Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, OK, thanks for the clarification. Do you think it's worth clarifying that in the spec text, or is the implicit consistency sufficient?",
          "createdAt": "2019-03-13T22:18:50Z",
          "updatedAt": "2019-03-13T22:18:50Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "That's a good question! If @jyasskin is OK with adding more text, I don't think there's fundamental harm in specifying/clarifying. I think we'd want feedback from other UAs - I don't believe this would present any challenges for Mozilla, but for Apple/Microsoft, their OCSP stacks are maintained by different teams, and they may have spec language feedback and/or want to leave it opaque/implicit (as it is in TLS and RFC 5280)",
          "createdAt": "2019-03-13T22:34:03Z",
          "updatedAt": "2019-03-13T22:34:03Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I don't really want this specification to be in the business of defining how we interpret OCSP responses. The SingleResponse specifies a certID, and duplicates of those could be inconsistent in all sorts of ways that we don't call out. Let's just stay with the language used by other specs in this area. For example, https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.3.pdf section 4.9.10 just says, \"OCSP responses from this service MUST have a maximum expiration time of ten days.\"",
          "createdAt": "2019-03-13T23:19:59Z",
          "updatedAt": "2019-03-13T23:19:59Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, closing then.",
          "createdAt": "2019-03-14T00:52:11Z",
          "updatedAt": "2019-03-14T00:52:11Z"
        }
      ]
    },
    {
      "number": 409,
      "id": "MDU6SXNzdWU0MjI1NTU2MzQ=",
      "title": "SXG loading and service worker integration",
      "url": "https://github.com/WICG/webpackage/issues/409",
      "state": "CLOSED",
      "author": "mattto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm raising this issue as suggested by horo at https://github.com/WICG/webpackage/issues/347#issuecomment-474172523\r\n\r\nThe current spec has an Overview which explains service worker integration. I'm wondering whether some alternatives were considered and rejected.\r\n\r\n> If navigationPreload is enabled, the signed response will be available in the FetchEvent's preloadResponse. Note that this will also cause a network request for requests that aren\u2019t served from a signed exchange.\r\n\r\nI think this makes sense. My understanding is that if the request were to go to \"network\" (i.e., the service worker doesn't call respondWith()), the response would come from the signed exchange, so `preloadResponse` should be that response.\r\n\r\n> clone() the request and set its cache to \"only-if-cached\", to retrieve the matching response from either the signed exchange or the HTTP cache. Note that fetch()ing a new Request with the same url will not retrieve the response from the signed exchange.\r\n\r\nThis I'm not sure about. Historically `respondWIth(fetch(event.request))` is expected to have the same behavior as not calling `respondWith()`. Is it possible to arrange things such that fetch(event.request) gets the response from the signed exchange by default and you need to clone() request and set a flag to skip the signed exchange?",
      "createdAt": "2019-03-19T05:53:07Z",
      "updatedAt": "2019-03-21T14:41:01Z",
      "closedAt": "2019-03-21T14:41:01Z",
      "comments": [
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "One possibility (which @wanderview also mentions at https://github.com/w3c/resource-hints/issues/78#issuecomment-384981842 for prefetch) could be to tie the signed exchange to the request's [client](https://fetch.spec.whatwg.org/#concept-request-client), so that fetch(event.request) goes to the signed exchange by default, and you can construct a Request with a null `window` otherwise to disassociate from the signed exchange. Or introduce a similar property like `signedExchange`.",
          "createdAt": "2019-03-19T12:38:26Z",
          "updatedAt": "2019-03-19T12:38:26Z"
        },
        {
          "author": "wanderview",
          "authorAssociation": "NONE",
          "body": "Could we make Request cache value of \"default\" mean include checking the signed exchange by default and the \"reload\"/\"nocache\" would bypass it?",
          "createdAt": "2019-03-19T22:41:31Z",
          "updatedAt": "2019-03-19T22:41:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I intend that `respondWith(fetch(event.request))` does have the same behavior as not-calling `respondWith()` since the [stashed exchange](https://wicg.github.io/webpackage/loading.html#request-stashed-exchange) is attached to the request, and even follows its [clones](https://wicg.github.io/webpackage/loading.html#mp-request-clone). `respondWith(fetch(event.request.url))` does *not* have the same behavior, since the new request created from a plain URL doesn't include the stashed exchange.\r\n\r\nIf there's something in the algorithms that contradicts this, let me know so I can correct it (or realize that my intent is wrong, which is always possible).\r\n\r\nI think we talked about ways to make `respondWith(fetch(event.request.url))` also use the signed exchange and decided it was too complicated, but I don't remember where those conversations happened aside from my quick sketch in https://github.com/WICG/webpackage/pull/281#discussion_r208319315.",
          "createdAt": "2019-03-20T20:18:47Z",
          "updatedAt": "2019-03-20T20:22:15Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "Thanks, that's good to know! Actually after writing that comment I saw the request's \"signed exchange\" defined and then wondered why it wouldn't be used but didn't want to triple post :)\r\n\r\nI think the current Overview wording may be confusing... I'd suggest clarifying that respondWith(event.request) just works (it reads as if you must clone() and set the cache mode).\r\n\r\nI think I can see why having the same behavior for `respondWith(fetch(event.request.url))` would be difficult if the idea was that fetching `https://publisher.example.org/` would normally not retrieve contents from the SXG while fetching it while inside the SW's fetch event during the SXG would. There's nothing tieing the SW or fetch event to the SXG, except the request's internal signed exchange, so having a new request skip the SXG sounds reasonable to me.\r\n\r\nI'm also wondering now about the suggestion to set the cache mode to get the SXG content after cloning. Wouldn't just cloning without changing the cache mode work?\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-03-21T13:53:16Z",
          "updatedAt": "2019-03-21T13:53:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The overview says, \"If [a Service Worker] needs to know that signed exchange content is available for the request it\u2019s handling, it has two options:\" before saying to use the cache mode, and I think you didn't read that before jumping to the text about `respondWith()`. Adding more words will not help with that problem.",
          "createdAt": "2019-03-21T14:39:57Z",
          "updatedAt": "2019-03-21T14:40:51Z"
        }
      ]
    },
    {
      "number": 411,
      "id": "MDU6SXNzdWU0MjQzNTg0NTA=",
      "title": "Bundles of JS modules should be able to express their dependency graph cheaply",
      "url": "https://github.com/WICG/webpackage/issues/411",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "If you have 2 modules:\r\n\r\nA.mjs:\r\n```javascript\r\nimport \"B\"\r\n// Lots of code.\r\n``` \r\nB.mjs:\r\n```javascript\r\n// Lots more code.\r\n``` \r\n\r\nYou have to download A and parse it to figure out that it depends on B. Then you have to download B and execute it before you can use nearly any of the bytes you downloaded for A.\r\n\r\nBundles should help speed this up, either by directly expressing the import dependency graph in a way that the JS interpreter will trust, or by letting the bytes of the resources interleave so they can parse and execute in the order they arrive.",
      "createdAt": "2019-03-22T19:03:58Z",
      "updatedAt": "2019-07-20T22:51:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@wycats wanted this too, IIRC.",
          "createdAt": "2019-03-22T19:07:35Z",
          "updatedAt": "2019-03-22T19:07:35Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "NONE",
          "body": "Thanks for opening up this issue, @jyasskin . I'm really excited by this idea. Among complexities, in addition to describing the dependency structure, I'm wondering, how can you tell which Realm should the JavaScript module be run in? E.g., the bundle may include a page HTML with an iframe; I'm not sure if there are interactions with HTML modules as well.\r\n\r\nOne way that these semantics could be accessed today in HTML would be to insert many `<script type=module>` tags, in postorder for how the module graph would be traversed. If, in a bundled exchange package, the HTML file comes first, and then the scripts in the order that is in parallel with those script tags, then there would be somewhat similar observable behavior.\r\n\r\nIncluding a built-in feature for this model of execution could be better than a bunch of tags in a few ways:\r\n- Maybe most importantly, which @domenic marked as new behavior in his [summary](https://github.com/whatwg/html/issues/4400#issuecomment-474944947), is that the UA would be allowed to *not* yield to the event loop if the module is already fetched.\r\n  - @nyaxt mentioned in https://github.com/whatwg/html/issues/4400#issuecomment-469551063 that yielding to the event loop too many times could be difficult for browsers to make cheap.\r\n  - However, @smaug---- expressed concern about *optional* yielding to the event loop in https://github.com/whatwg/html/issues/4400#issuecomment-474569945.\r\n- Fewer script tags, meaning shorter HTML to download, less DOM and possible events, and less need of tooling to generate the HTML. (I'm not sure how much overhead this actually is.)\r\n\r\nBottom-up loading could benefit JavaScript in terms of enabling bytecode generation to have access to dependencies having already been parsed. This isn't so necessary today, but may be helpful with a newer version of the the [decorators proposal](https://github.com/tc39/proposal-decorators/).\r\n\r\nMy guess is that bottom-up loading with optional yields to the event loop would not be web-incompatible (as @yoavweiss [asked](https://github.com/whatwg/html/issues/4400#issuecomment-475142860)), since probably not many people are shipping big native module graphs yet, but it could violate JavaScript programmer expectations about atomicity of module loading, as @rniwa [raised](https://github.com/whatwg/html/issues/4400#issuecomment-474570663).\r\n\r\nI'd be curious to figure out what parts of this might be possible to experiment with in bundler software today, and what parts require new web platform primitives. I imagine browsers might be able to make smarter decisions about how to interleave JavaScript execution and network access.",
          "createdAt": "2019-03-23T00:32:11Z",
          "updatedAt": "2019-03-23T00:32:11Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "NONE",
          "body": "(Or, as the never-yielding complement to a bunch of script tags, you could have a single module script which imports all the modules that will eventually be used, in post-order. And of course tools could play around mixing these two together, but only statically.)",
          "createdAt": "2019-03-23T00:34:53Z",
          "updatedAt": "2019-03-23T00:34:53Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "FWIW, I'm inclined to have folks write the single module script that imports everything in post-order, until we show that it costs enough more than a better solution to justify the complexity of the better solution.",
          "createdAt": "2019-03-30T12:24:17Z",
          "updatedAt": "2019-03-30T12:24:17Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "This assumed that the modules have no side-effects, right?",
          "createdAt": "2019-04-21T18:03:42Z",
          "updatedAt": "2019-04-21T18:03:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@yoavweiss It assumes they don't have syntax errors that are supposed to prevent side effects from happening, but I think it otherwise preserves side effects.",
          "createdAt": "2019-04-21T23:58:46Z",
          "updatedAt": "2019-04-21T23:58:46Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "NONE",
          "body": "The never-yielding variant of generated import statements would preserve side effects (while defeating much of the benefit of the optimization)--the entire module graph is checked for errors before any of it runs. Otherwise, I agree with @jyasskin.",
          "createdAt": "2019-04-23T02:51:41Z",
          "updatedAt": "2019-04-23T02:51:41Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "One possible strategy might be to use Link headers:\r\n\r\nAs a server, I am empowered to express relationships of my choosing via a `Link` header. If the ask in this ticket is for JS modules to express their dependency graph clearly, I a server might facilitate this ask my using a link header like:\r\n\r\n`Link: <http://yoyodyne.net/lib/dep.js>; rel=dependency; as=module`\r\n\r\nThis is a declaration of a dependency of this script's resource. I don't know who or what would listen & detect this, or what they would do with this. But as a server, I can enumerate relations of this resource, for example `rel=depenency`, which would give the user-agent a way to understand dependencies without having to parse JS modules.\r\n\r\n[Link Preload](https://www.w3.org/TR/preload/#server-push-http-2) might be related. Server admins might consider adding a `preload` relationship everywhere there is a `dependency` relationship, to let the browser know it will be expected.",
          "createdAt": "2019-07-20T22:51:03Z",
          "updatedAt": "2019-07-20T22:51:03Z"
        }
      ]
    },
    {
      "number": 413,
      "id": "MDU6SXNzdWU0MjQ2NDQ3MTk=",
      "title": "Support use case: using web package for H2-style JS bundles",
      "url": "https://github.com/WICG/webpackage/issues/413",
      "state": "OPEN",
      "author": "dvoytenko",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Reflecting on [H2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/), there's still one common use case: a set of JS binaries are always downloaded together. This would typically be due to breaking down a big binary into smaller ones where:\r\n 1. The first binary is critical for immediate execution.\r\n 2. All other binaries could be delayed. But ideally not turned into a download waterfall.\r\n 3. Otherwise, the \"other\" binaries are never used by themselves, without the first binary.\r\n\r\nThis is one case, where H2 push would be useful and Web Packages could make this a much simpler and more predictable.\r\n\r\nTo further explain this, consider one big binary that looks like this:\r\n\r\n```\r\n// First critical block of JS.\r\n(function() {\r\n  global.doLater = function() {...};\r\n  // E.g. 20K of JS code.\r\n})();\r\n\r\n// Second non-critical block of JS.\r\ndoLater(function() {\r\n  // E.g. 40K of JS code.\r\n});\r\n\r\n// Third non-critical block of JS.\r\ndoLater(function() {\r\n  // E.g. 60K of JS code.\r\n});\r\n```\r\n\r\nThis kind of delivery could still save lots of CPU by not immediately executing block 2 and 3, but the main negative is that the overall binary is bigger and has to be fully parsed/compiled before anything can be executed, thus delaying execution of the critical block 1. While some engines are capable of lazy compiling some of the non-critical blocks, the full download/parse is still necessary.\r\n\r\nWeb Packages could help this case by splitting a big binary into smaller files and executing the smaller critical blocks as soon as they are downloaded/parsed.\r\n\r\n/cc @cramforce ",
      "createdAt": "2019-03-24T18:30:47Z",
      "updatedAt": "2019-03-26T22:51:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is similar to, but maybe not the same as https://github.com/WICG/webpackage/issues/411.\r\n\r\nWould you expect to wind up with `<script src=\"firstblock.bundle\"/> <script defer src=\"secondblock.bundle\"/> <script defer src=\"thirdblock.bundle\"/>` in the HTML, or some other structure to kick off loading the split-up script?",
          "createdAt": "2019-03-24T18:35:28Z",
          "updatedAt": "2019-03-24T18:35:28Z"
        },
        {
          "author": "dvoytenko",
          "authorAssociation": "NONE",
          "body": "It's similar and maybe would cooperate with #411, but not exactly the same. It'd be pretty close with [dynamic imports](https://github.com/tc39/proposal-dynamic-import). The benefit with Web Packages (similar to H2) would be that the download for secondary modules would be running implicitly, vs dynamically triggered by executing script.\r\n\r\nOtherwise, you're right, we'd wind up with dynamically inserted `<script async>` (maybe/maybe not `defer`) to trigger the parse/compile/execution. We'd win on download in this case, though it's possible that a smarter engine could also pre-parse/pre-compile related scripts in the web package if it gets a good idea that they will be used soon anyway.",
          "createdAt": "2019-03-25T01:57:09Z",
          "updatedAt": "2019-03-25T01:57:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think we should get some of that by using \r\n\r\n```html\r\n<link rel=preload as=bundle src=\"secondblock.bundle\" contents=\"bloomfilter-ewroDF8352DFi35GHDDI3=\">\r\n<link rel=preload as=script src=\"secondblock_main.js\">\r\n```\r\n\r\nThe first line (with TBD details in the syntax; credit to @yoavweiss) says to preload the bundle and which other resources it contains, while the second gives the JS engine enough information to start pre-parsing. I'm not certain if the second line actually does that today, but it seems like the right thing to try first?",
          "createdAt": "2019-03-25T05:57:47Z",
          "updatedAt": "2019-03-25T05:57:47Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "Preload doesn't parse today. I also hadn't seen the `contents` attribute. Is there a spec for that?\r\n\r\nOne benefit of a bundle over preload is that the optimization can be performed at the network layer without requiring to change the HTML. This is relevant for transparent deployability in CDNs and third-party scripts that don't own the HTML.",
          "createdAt": "2019-03-25T15:38:15Z",
          "updatedAt": "2019-03-25T15:38:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@yoavweiss sketched https://docs.google.com/document/d/1Hi8SvzLEXcBY7RsaSI9MUbgehuYJnKxLO6dFvvWZ5nY/edit a while ago to suggest a way to identify which subresources should be satisfied by the bundle, but there's no more formal spec.\r\n\r\nGood point that serving a bundle in response to a `<script src=\"foo.js\">` could be a transparent optimization if we do it right.\r\n\r\nI'm still not sure it makes sense to serve the two non-critical blocks in the same bundle as the one we want to execute immediately. How would you identify that they're downloaded and ready to call? How would you kick off their execution?",
          "createdAt": "2019-03-26T11:18:42Z",
          "updatedAt": "2019-03-26T11:18:42Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "My idea was that the whole bundle gets executed immediately. (But the main\nscript could also initiate that).\n\nThe big difference in executing all scripts in a bundle vs. a single script\nis that execution can start when the first script parsed, instead of\nwaiting for everything to parse. That is because JS mandates that scripts\nwith syntax errors must not be executed at all, and so for single-script\nexecution cannot start until download has completed.\n\nOn Tue, Mar 26, 2019 at 4:18 AM Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> @yoavweiss <https://github.com/yoavweiss> sketched\n> https://docs.google.com/document/d/1Hi8SvzLEXcBY7RsaSI9MUbgehuYJnKxLO6dFvvWZ5nY/edit\n> a while ago to suggest a way to identify which subresources should be\n> satisfied by the bundle, but there's no more formal spec.\n>\n> Good point that serving a bundle in response to a <script src=\"foo.js\">\n> could be a transparent optimization if we do it right.\n>\n> I'm still not sure it makes sense to serve the two non-critical blocks in\n> the same bundle as the one we want to execute immediately. How would you\n> identify that they're downloaded and ready to call? How would you kick off\n> their execution?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/413#issuecomment-476582405>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAFeTzgyJzaMEft82BrNcp2FCgQa8ibWks5vagISgaJpZM4cFq2h>\n> .\n>\n",
          "createdAt": "2019-03-26T20:22:06Z",
          "updatedAt": "2019-03-26T20:22:06Z"
        },
        {
          "author": "dvoytenko",
          "authorAssociation": "NONE",
          "body": "I think it'd be very reasonable to start with the main script initiating the execution of the others. Either by dropping new script tags or doing a dynamic import.",
          "createdAt": "2019-03-26T22:51:09Z",
          "updatedAt": "2019-03-26T22:51:09Z"
        }
      ]
    },
    {
      "number": 418,
      "id": "MDU6SXNzdWU0MjkyNzcwODg=",
      "title": "option to output JSON from dump-signedexchange",
      "url": "https://github.com/WICG/webpackage/issues/418",
      "state": "CLOSED",
      "author": "patrickkettner",
      "authorAssociation": "NONE",
      "assignees": [
        "hajimehoshi",
        "nyaxt",
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "Hi there!\r\nI was helping @ithinkihaveacat with some SXG tooling, and were wondering if y'all would accept a PR that would cause `dump-signedexchange` to output JSON rather than its current format (via a flag perhaps?) to help the data be easier to export. Wanted to confirm before I dive into the go code, however",
      "createdAt": "2019-04-04T13:23:41Z",
      "updatedAt": "2019-06-06T05:29:23Z",
      "closedAt": "2019-06-06T05:29:23Z",
      "comments": [
        {
          "author": "patrickkettner",
          "authorAssociation": "NONE",
          "body": "(cc @irori)",
          "createdAt": "2019-04-04T13:24:15Z",
          "updatedAt": "2019-04-04T13:24:15Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "The plan SGTM",
          "createdAt": "2019-04-04T13:30:46Z",
          "updatedAt": "2019-04-04T13:30:46Z"
        }
      ]
    },
    {
      "number": 419,
      "id": "MDU6SXNzdWU0Mjk2MjM5OTM=",
      "title": "Spec review",
      "url": "https://github.com/WICG/webpackage/issues/419",
      "state": "OPEN",
      "author": "jakearchibald",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I've been going through the spec to review its service worker interactions. Here are the questions/thoughts I had along the way:\r\n\r\n> Note that fetch()ing a new Request with the same url will not retrieve the response from the signed exchange.\r\n\r\nI don't think `fetch(event.request)` will get the signed exchange either right now. Calling `fetch(request)` calls `new Request(request)` internally, so https://fetch.spec.whatwg.org/#dom-request will need to be modified to preserve the stashed exchange.\r\n\r\nhttps://wicg.github.io/webpackage/loading.html#mp-http-fetch - I think these steps will be invoked twice if there's a service worker in the middle.\r\n\r\n1. Resource requested.\r\n1. Ask service worker for response.\r\n    1. Service worker calls `fetch(event.request)`.\r\n    1. Response is an SXG, so the steps in https://wicg.github.io/webpackage/loading.html#mp-http-fetch happen.\r\n    1. Redirect mode is \"manual\", so the redirect response is returned from the service worker.\r\n1. Response is an SXG, so the steps in https://wicg.github.io/webpackage/loading.html#mp-http-fetch happen.\r\n\r\nThis seems wrong when it comes to reporting, but maybe also bad that the SXG is parsed twice.\r\n\r\n> Set actualResponse\u2019s status to 303.\r\n\r\nIf the request was a POST request, what's the expected behaviour here? 303s will typically drop the request body from the redirected request.\r\n\r\nShould I be able to add a signed exchanged into the cache API? Right now it looks like a fetch to an SXG would create and follow the redirect, and I'd get the other-origin response rather than the SXG itself. Should the processing of SXG responses be limited to navigations?\r\n\r\n> If response is null and httpRequest\u2019s initiator is \"prefetch\" or \"preload\", return a network error.\r\n\r\nIs it odd that this happens with \"prefetch\" and \"preload\" only? Should it happen with `fetch('whatever.sxg')` too?",
      "createdAt": "2019-04-05T07:42:42Z",
      "updatedAt": "2019-04-05T07:42:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 420,
      "id": "MDU6SXNzdWU0MzA3Nzk3ODk=",
      "title": "Certificates for signed exchanges should be allowed also for TLS connections.",
      "url": "https://github.com/WICG/webpackage/issues/420",
      "state": "OPEN",
      "author": "sebastiannielsen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Pending Security + Privacy Review"
      ],
      "body": "I read this in the specification:\r\n\"Clients MUST NOT accept certificates with this extension in TLS connections (Section 4.4.2.2 of [RFC8446]).\"\r\n\r\nI don't see any specific reason for this. I would suggest removing this completely from specification, and allowing content to be signed with the same certificate as for TLS connections. (provided the certificate is allowed for signed exchanges)\r\n\r\nSince a signed exchange have a very specific format, I don't see any risk with for example an site-wide XSS becoming a signing oracle for signing exchanges, unless the administrator explicitly configures the page/server in that way for some specific application. (for example a timestamping service allowing signing of arbitary data which is then time-stamped)\r\n\r\nAnother way to improve on this, is to have a special magic value for the extension, that will allow dual usage, so if the extension, instead of having the null value ( 05 00 ), have the exact octet-binary value \"BOTH\" ( 04 42 4f 54 48 ), it will allow dual usage of the certificate.\r\n\r\nThus specification could be instead:\r\n\"A conforming CA MUST NOT issue certificates with this extension unless, for each dNSName in the subjectAltName extension of the certificate to be issued:\r\nAn \u201cissue\u201d or \u201cissuewild\u201d CAA property ([RFC6844]) exists that authorizes the CA to issue the certificate; and\r\nThe \u201ccansignhttpexchanges\u201d parameter (Section 4.2.1) is present on the property and is equal to \u201cyes\u201d or \"both\".\r\nA conforming CA MUST NOT issue certificates with this extension set to \"BOTH\", unless \"cansignhttpexchanges\" is equal to \"both\".\r\n\r\nClients MUST NOT accept certificates with this extension in TLS connections, unless the extension has the exact octet-binary value BOTH ( 04 42 4f 54 48 ) (Section 4.4.2.2 of [RFC8446]).\"\r\n\r\nFor this, the cansignhttpexchanges CAA value must also be extended with a \"both\" option to allow certificates to be issued with the BOTH extension value. (if \"yes\", it will only allow NULL, but if \"both\", it will alllow both NULL and BOTH values)\r\n\r\n------\r\n\r\nI also read this:\r\n\"TLS server certificates must be accessible from online servers, so they\u2019re easier to steal or use as signing oracles than an offline key. An exchange\u2019s signing key doesn\u2019t need to be online.\"\r\n and this:\r\n\"Using an exchange-signing key in a TLS (or other directly-internet-facing) server increases the risk that an attacker can steal the private key, which will allow them to mint packages (similar to Section 6.4) until their theft is discovered.\"\r\n\r\nThis is very untrue, as most content-signing servers will of course be directly internet-facing. A majority of server operators will just configure their servers to sign static content when requested, or possibly with a client whitelist (like cloudflares IPs) to prevent it from signing content for others.\r\nThus their CanSignHttpExchanges certificate will in most cases, reside side-with-side with their TLS certificate in the same folder on the same machine.\r\n\r\nOnly more sensitive and advanced companies will make content-signing servers airgapped.\r\n\r\nThe only way to enforce secure usage of such a certificate and make sure its \"airgapped\", is to require it to be loaded on a secure element with presence validation. This is a requirement imposed by most CA's for sub-CA certificates.\r\n\r\nThe only risk I see with completely dropping the restriction, is that a stolen content-signing certificate could be used to host a TLS server used for example phishing attacks and such.\r\n\r\nThats why it might be good to instead use the proposed NULL and BOTH values, so theres 3 types of certificates:\r\n1: Certificates ONLY valid for TLS connections.\r\n2: Certificates valid for BOTH.\r\n3: Certificates ONLY valid for Signed-exchanges.\r\n\r\nthus a server operator is able to choose the security level that fits them best.",
      "createdAt": "2019-04-09T05:55:03Z",
      "updatedAt": "2019-05-29T16:57:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Would it be possible to explain why it is desirable?\n\nCross-protocol attacks have caused a number of severe security issues - as\ndemonstrated by things as \u201csimple\u201d as between QUIC and TLS or TLS1.3 vs\nTLS1.2. Just as these protocols admonish users to make use of separate keys\nand identities, it seems there is no significant benefit, compared to the\nsignificant risk it introduces to users.\n\nFurthermore, ensuring key separation helps encourage better key hygiene for\nthe purposes being used. This is similar to the discussion of TLS Delegated\nCredentials, in that separating online and offline key pairs, via distinct\ntechnical capability, is highly desirable.\n\nFinally, given that SXGs, as a general technology, come with new trade offs\nand risks with respect to impersonation (if the key is compromised), the\nexplicit extension also serves to ensure direct and affirmative consent by\nthe site to use SXGs (e.g. via the CAA check)\n\nAs such, the use of the extension plays a critical and essential, perhaps\nirreplaceable, role in the overall security of SXG. It would have to be\ndemonstrated a significant and serious benefit to consider removing, and\nnecessary to introduce comparable security measures. Perhaps the spec can\nmake it clearer why this is such an essential property, so that proposals\nto remove it can be accompanied with the same thorough and thoughtful\nsecurity mitigations.\n",
          "createdAt": "2019-04-09T11:39:50Z",
          "updatedAt": "2019-04-09T11:39:50Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "1: My stance on it, is that its up to the server administrator if they want to share keys should be able to do that.\r\n\r\n2: I didn't say that the extension should be removed. What I said, is that the limitation where a certificate with said extension cannot be used as a TLS server certificate, should be removed.\r\nThe extension is good and need to be there, as SGX creates new risks.\r\n\r\nHowever, another solution is to extend the extension with the BOTH/NULL alternatives, so the ability of the certificate can be gated into \"Only TLS\", \"BOTH\" and \"Only SGX\", with accompanying CAA checks, so the server administrator can choose exactly how he wants to do it.",
          "createdAt": "2019-04-09T11:59:04Z",
          "updatedAt": "2019-04-09T11:59:04Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "On Tue, Apr 9, 2019 at 7:59 AM Sebastian Nielsen <notifications@github.com>\nwrote:\n\n> 1: My stance on it, is that its up to the server administrator if they\n> want to share keys should be able to do that.\n>\n\nIt\u2019s unclear. Are you disagreeing that there are fundamental cryptographic\ncross-protocol risks introduced by the reuse of keys in unrelated\nprotocols? It is basic cryptographic practice to ensure that unrelated\nprotocols should use unrelated keys. While significant effort has been made\nto reduce the cross-protocol confusion, the prohibition serves as a\ncritical and essential safety margin.\n\nCould you help explain the concern/motivation more? It\u2019s unclear whether\nthis is motivated by a concern of simply obtaining an additional\ncertificate, or whether there is some other consideration at play.\n",
          "createdAt": "2019-04-09T12:08:18Z",
          "updatedAt": "2019-04-09T12:08:18Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "No im not disagreeing with it.\r\n\r\nYes I do understand there need to exist a safety margin, but the final authority of a domain, should be able to decide if that safety margin should be in effect or not.\r\n\r\nThe advantage of being able to use the same certificate for more tasks, is multi-fold.\r\nFirst, by having lesser amount of keys and certificates in system, the certificates and keys can be secured more, and lesser management overhead.\r\n1: If its the same server serving both normal TLS content and SGX content, theres no security gain in having 2 certificates and 2 keys on the same machine.\r\n2: If you use a HSM or crypto accelerator that only supports one key and/or chain, it would be preferable to be able to use that.\r\n3: If the CA charges for certificates, having 2 certificates would of course incur additional costs than 1 certificate.",
          "createdAt": "2019-04-09T12:31:26Z",
          "updatedAt": "2019-04-09T12:31:26Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "On Tue, Apr 9, 2019 at 8:31 AM Sebastian Nielsen <notifications@github.com>\nwrote:\n\n> No im not disagreeing with it.\n>\n> Yes I do understand there need to exist a safety margin, but the final\n> authority of a domain, should be able to decide if that safety margin\n> should be in effect or not.\n>\n\nUltimately, the User Agent is responsible for ensuring the user\u2019s security\nneeds are met, above and beyond what domain holders may wish.\n\nThis is why User Agents disable SHA-1 or 1024-but RSA keys, or denote\ncertain powerful features to HTTPS. Yes, a domain operator may be\ninterested in setting their security policies lower, but such desire is\ncounter to the security of users needs.\n\nThe advantage of being able to use the same certificate for more tasks, is\n> multi-fold.\n> First, by having lesser amount of keys and certificates in system, the\n> certificates and keys can be secured more, and lesser management overhead.\n>\n\nThis does not seem to logically follow. Given that TLS keys are online,\nwhile SXG keys are inherently offline, coupling these two functionally\nreduces the security of the system and users. Every operation involving\nsuch shared keys needs to fully consider both protocols, causing more\nmanagement overhead.\n\n1: If its the same server serving both normal TLS content and SGX content,\n> theres no security gain in having 2 certificates and 2 keys on the same\n> machine.\n>\n\nThis does not logically follow. With SXG, there is no technical need to\ninstall keys on the server. Such a thing would seem counter to best\npractice.\n\n2: If you use a HSM or crypto accelerator that only supports one key and/or\n> chain, it would be preferable to be able to use that.\n>\n\nAre you aware of any such products? I have yet to encounter one in my\ncareer. In general, HSMs are unable to be deployed for TLS at scale, as\nmodern HSMs and \u201caccelerators\u201d (more of a 90s concept) are unable to\nperform signatures at the pace of modern large scale deployments. On the\nother hand, SXGs, and their infrequent signatures, absolutely make these\ntechnologies viable again for key protection.\n\n3: If the CA charges for certificates, having 2 certificates would of\n> course incur additional costs than 1 certificate.\n>\n\nI agree that this is a possibility, but it\u2019s not a technological concern.\nYou can choose CAs, for example, that do not charge for certificates at\nall, or which charge for validations (which both types of certificates can\nbe issued from a single validation). I totally understand and appreciate\nthe concern here - it\u2019s one introduced whenever anything involving\ncertificates is used - but it does not seem necessary to weaken the\ncryptographic security in order to address. As demonstrated by current and\npast CA practices, it also seems to be a practice going out of vogue and\nmore hypothetical?\n\n>\n",
          "createdAt": "2019-04-09T12:44:36Z",
          "updatedAt": "2019-04-09T12:44:36Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "1: I agree about the user agent responsible for end user security, and of course it should restrict certain sensitive features to HTTPS.\r\n\r\nBut in my opinion, the user agent should not put any restrictions on how the server operator may manage their keys and certificates.",
          "createdAt": "2019-04-09T12:58:18Z",
          "updatedAt": "2019-04-09T12:58:18Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Do we agree that User Agents already place restrictions on how servers\nmanage their keys (e.g. no 1024-bit) and certificates (e.g. expiration\npolicies, weak signatures)? This does not seem to be a change from the\nstatus quo.\n\nWe seem to be in agreement that an SXG key is more valuable than a TLS key,\ndue to the ability to mount off-path attacks, so it seems there\u2019s clear\njustification for putting stronger protection requirements on the SXG key.\nThose requirements are incompatible with TLS, due to TLS requiring online\nsigning.\n\nAssuming we had a technology which allowed a TLS key to be protected to\nthat same level, such as TLS Delegated Credentials proposes (moving the TLS\nkey offline, in favor of ephemeral assertions), then we also seem to be in\nagreement that there are still fundamental cryptographic reasons to keep\nkey material separate, to defend against cross-protocol attacks.\n\nI don\u2019t mean to dismiss the feedback, but to walk through how the\nconclusion was reached - which is that it is essential to the security of\nend users to ensure a TLS server does not reuse an SXG key. While of course\nsuch thing is possible by virtue of a CA issuing two certificates for the\nsame key - such a thing should be seen as a security vulnerability, rather\nthan an expected or accepted practice.\n",
          "createdAt": "2019-04-09T13:06:26Z",
          "updatedAt": "2019-04-09T13:06:26Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "I don't agree with the assertion that SXG key is strictly more valuable than a TLS key. An attacker that has possession of a TLS key can perform a MITM attack that steals authentication credentials such as cookies, while an attacker in possession of an SXG certificate can only display arbitrary content as the site owner. In some respects, being able to MITM TLS is a more powerful attack.\r\n\r\nWith that said, not all clients will implement the MUST NOT. This means that there will be a risk that a compromised SXG certificate can be used to MiTM a TLS connection, just not with Chrome. This puts all users of non-conforming browsers at risk.\r\n\r\nWhat is the point of adding this restriction to not allow TLS with the certificate if the extension is not marked critical? It seems to only protect users of conforming browsers while exposing other users to risk. I understand this has been discussed before (https://github.com/WICG/webpackage/issues/238) but it's not clear the conclusions still hold given that a large percentage of user agents that will not be updated to respect this MUST NOT.\r\n\r\nIn my opinion, this spec should be non-discriminatory and pick a side. Either SXG certificates should be permitted for use in TLS (maintaining the legacy browser behavior), or certificates should be forbidden to be used for TLS and the extension made critical (to protect the users of legacy browsers).\r\n\r\nI'm not swayed by the argument that just because some TLS clients use system PKI validators, that this extension should not be made critical. This is a big change to how the PKI is used and clients who want to support it should make correct validation of the certificate a requirement on platforms they run on. Fudging this with a MUST NOT that will only be used for a subset of clients does not improve the situation.",
          "createdAt": "2019-05-02T22:45:19Z",
          "updatedAt": "2019-05-02T22:45:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't agree with the assertion that SXG key is strictly more valuable than a TLS key. An attacker that has possession of a TLS key can perform a MITM attack that steals authentication credentials such as cookies, while an attacker in possession of an SXG certificate can only display arbitrary content as the site owner. In some respects, being able to MITM TLS is a more powerful attack.\r\n\r\nIn a web context, an attacker that can display arbitrary content as the site owner can, in turn, run arbitrary JS as the site owner. That allows them to read credentials for that origin, make credentialed requests as that origin, etc.",
          "createdAt": "2019-05-02T23:44:07Z",
          "updatedAt": "2019-05-02T23:44:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've been convinced that neither SXG keys nor TLS keys are strictly more powerful than the other, especially since we're talking in #376 and elsewhere of checking SXG contents against a live TLS connection. The difference in power is complicated and probably not too helpful in deciding this particular issue.\r\n\r\nI think @sebastiannielsen is right that many servers will put their SXG key on the same internet-facing server as their TLS key, unless we require it to be on a secure element, which I suspect will limit adoption too much.\r\n\r\nHowever, I'm also sympathetic to @sleevi's point that we want a buffer around the possibility of cross-protocol attacks. Especially since the SXG signed-message format is still evolving, I don't want to accidentally enable cross-protocol attacks in a future update, after we've allowed the keys to be used for TLS servers. On the other hand, it seems like it'll be easy to enable TLS use later, using the mechanism @sebastiannielsen suggests, once the format has settled down.\r\n\r\nOn the third hand, @grittygrease is right that not all clients will implement the MUST NOT, and so we have to be careful about cross-protocol attacks during the SXG evolution anyway, so maybe we should make that explicit by allowing use for TLS.",
          "createdAt": "2019-05-03T00:05:34Z",
          "updatedAt": "2019-05-03T00:05:34Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "@sleevi Also the reason to drop SHA-1 certificates, is not about key management or security of a single website. Its more about the security of ALL websites.\r\nBecause, a malicious actor could, with a valid SHA-1 certificate, be able to generate another such, with hash collision, to be valid to for example github.com or google.com\r\n\r\nSo even if one single website would be allowed to use SHA-1 certificates, it would hurt the security of all websites.\r\nIn the same way, most (if not all) CA's require sub-CA keys to be on a secure element, just because if one such leaks, ALL websites will be in danger, even a website that doesn't use that sub-CA.\r\n\r\nThat doesn't stand for TLS/SGX certificates. Even if I would publish the private key for my certificate to my website, it wouldn't hurt the security for any other website than mine.\r\n\r\nThus any cross-protocol attacks, if found, would only affect those websites that do use the same certificate for TLS and SGX.\r\n\r\nThus I stand my position on that the website administrator should be in full control of if a certificate should be allowed for either TLS, SGX or both.\r\nAlso there should possible be some mechanism preventing CA's from charging extra for SGX-enabled certificates, maybe in some baseline requirements or something.\r\nCurrently its one certificate each - and you also have to submit 2 full validations with papers and pay everything for most CA's (it was just StartSSL that did have the concept with a \"validation\" being valid for multiple certificates) - now Im talking about organizational certificates and not domain-only certificates.\r\n\r\nIf you had both certificates combined into one, you would only need to submit everything once - and only pay once. Some CA's might then charge extra for a combined cert because they know you save on not having to get 2 certificates, and there should be some mechanism preventing this, possible in baseline requirements.",
          "createdAt": "2019-05-03T05:38:45Z",
          "updatedAt": "2019-05-03T05:38:45Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Let's avoid the question of how much CAs charge for certificates here.",
          "createdAt": "2019-05-03T21:02:09Z",
          "updatedAt": "2019-05-03T21:02:09Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "On Fri, May 3, 2019 at 1:38 AM Sebastian Nielsen <notifications@github.com>\nwrote:\n\n> @sleevi <https://github.com/sleevi> Also the reason to drop SHA-1\n> certificates, is not about key management or security of a single website.\n> Its more about the security of ALL websites.\n> Because, a malicious actor could, with a valid SHA-1 certificate, be able\n> to generate another such, with hash collision, to be valid to for example\n> github.com or google.com\n>\n\n1024-bit certificates, then.\n\n<http://google.com>\n>\n> Thus I stand my position on that the website administrator should be in\n> full control of if a certificate should be allowed for either TLS, SGX or\n> both.\n>\n\nUser agents priorities dictate that the user comes first. Poor security\npractices by a website jeopardize user security. This is similar to UAs\nhaving policies about which ciphersuites in TLS they support, which CAs\nthey support, or even requiring TLS at all for certain features.\n\nArguments in favor of web developers need to consider risks to users, both\nfrom that of a single site and from an ecosystem perspective if all sites\nadopted that.\n\nThe key management issues highlight a significant change, just as the work\nproposed for Secondary Certificates would significantly alter the TLS key\nrisks.\n",
          "createdAt": "2019-05-03T21:21:35Z",
          "updatedAt": "2019-05-03T21:21:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi I'm mostly convinced by @grittygrease's argument that since we don't want to make the extension critical (doing so would prevent Chrome from adopting), any protocol confusion attacks put the users of non-adopting browsers at risk, and so we should allow use of SXG certs for TLS in order to make sure we pay attention to preventing protocol confusion attacks. How are you feeling about that argument?",
          "createdAt": "2019-05-03T21:45:48Z",
          "updatedAt": "2019-05-03T21:45:48Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I don\u2019t find it a particularly compelling argument for removing any\nprotections. I also don\u2019t deny the current design is significantly weaker\nthan desirable, from a security POV.\n\nDuring the design, we discussed other ways we could mitigate the risk. The\ncurrent design was chosen to favor the ease of adoption for CAs, but since\nit seems there\u2019s concern that it may not be sufficient, we should revisit\nthose designs.\n\nFor example, we discussed previously the use of EKUs, much in the same way\nCode signing and TLS certificates are distinguished. This requires CAs\nperform new issuance ceremonies for intermediates, before they can issue\nSXG certificates, but also allows for reliable and interoperable\nenforcement between SXG supporting clients and those that don\u2019t.\n",
          "createdAt": "2019-05-03T21:56:13Z",
          "updatedAt": "2019-05-03T21:56:13Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "@jyasskin @sleevi Is there a timeline for moving the PKIX components of Chrome from the OS into the browser? Doing so would allow this extension to be marked as critical, which would go a long way towards solving this issue.",
          "createdAt": "2019-05-29T16:04:45Z",
          "updatedAt": "2019-05-29T16:04:45Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "The decision here was not based solely on Chrome. This is an issue\nvirtually every implementation will face.\n",
          "createdAt": "2019-05-29T16:35:32Z",
          "updatedAt": "2019-05-29T16:35:32Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "Once the underlying PKIX packages on the OS are updated, this should no\nlonger be an issue, right? Or are you indicating that there is a broader\npattern that makes extensions that introduce new security risks difficult\nto make critical?\n\nOn Wed, May 29, 2019 at 9:35 AM sleevi <notifications@github.com> wrote:\n\n> The decision here was not based solely on Chrome. This is an issue\n> virtually every implementation will face.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/420?email_source=notifications&email_token=ABHDHZ3LLZNNARYQYSKJUIDPX2WFVA5CNFSM4HEOU6G2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWP5FLQ#issuecomment-497013422>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABHDHZ25U3OO7EPVXJMARYTPX2WFVANCNFSM4HEOU6GQ>\n> .\n>\n",
          "createdAt": "2019-05-29T16:39:15Z",
          "updatedAt": "2019-05-29T16:39:15Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "A design which forces the extension critical forces an implementation decision for UAs to either:\r\n  * Lock the UAs/consumers to the OS version, and either only update them in sync, or only make functionality available on certain OSes for these externalized reasons. This is often bad for the Web and for users, especially given the update cadence of OS vs browsers.\r\n  * Force implementors (which, in the case of SXG, is intended to be more than 'just' browsers) to ship their own PKI library, which is often a net-negative for user security [in the aggregate](https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html), and a significant implementation cost.\r\n\r\nI think the comment in https://github.com/WICG/webpackage/issues/420#issuecomment-488858875 is making an implicit, but unsupported, assumption that an SXG certificate is at greater risk of compromise than a TLS certificate, and that therefore disadvantages legacy clients if that key is compromised because it can be used in MITM. It's unsupported, because SXG-supporting clients would be at just as much (if not greater) risk of malicious SXGs, and thus the assumption that SXG would encourage laxer key hygiene isn't actually explained. It also ignores the other benefits of having the explicit extension and signal, and doesn't explain or justify why using it in TLS is desirable or useful, other than it would avoid having to think about key protection - which is exactly what the extension is trying to force contemplation of (among other things).",
          "createdAt": "2019-05-29T16:57:04Z",
          "updatedAt": "2019-05-29T16:57:04Z"
        }
      ]
    },
    {
      "number": 421,
      "id": "MDU6SXNzdWU0MzM1NTIyODA=",
      "title": "dump-signedexchange should decode mice payload",
      "url": "https://github.com/WICG/webpackage/issues/421",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "`dump-signedexchange` tool currently output raw MICE payload to stdout.\r\nWe should provide an option to decode+check integrity of MICE payload, and that should be the default behavior.\r\n\r\n@hajimehoshi are you interested in owning this?",
      "createdAt": "2019-04-16T02:14:41Z",
      "updatedAt": "2019-04-16T03:00:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually `dump-signedexchange` decodes MICE if `-verify` is given. It would be useful if MICE is decoded by default, though.",
          "createdAt": "2019-04-16T03:00:37Z",
          "updatedAt": "2019-04-16T03:00:37Z"
        }
      ]
    },
    {
      "number": 422,
      "id": "MDU6SXNzdWU0MzUwMDc4NzU=",
      "title": "Avoiding Built-In Tracking in Signed Packages",
      "url": "https://github.com/WICG/webpackage/issues/422",
      "state": "OPEN",
      "author": "johnwilander",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi! John Wilander from Apple's WebKit team here.\r\n\r\nWe are concerned with the privacy implications of User A and user B not getting the same package when they load the same webpage, or to put it another way, **personalized signed packages with cross-site tracking built in.**\r\n\r\n## Threat Model\r\n\r\n### The Actors\r\n\r\n* **The user.** This is the human who relies on the user agent to protect their privacy.\r\n* **The user agent.** This is the web browser that tries to protect the user's privacy.\r\n* **AdTech or adtech.example.** This is a website that the user engages with as first-party site and that has a financial interest in 1) knowing what the user does on other websites to augment its rich profile of the user and 2) individual targeting of ads, based on its rich profile of the user.\r\n* **News or news.example.** This is a news website which wants its articles to be served as signed packages with the user agent's URL bar showing news.example.\r\n\r\n### The Threat\r\n\r\n1. The user does not want AdTech to be able to augment its profile of them while reading articles on news.example.\r\n2. The user does not want AdTech's rich profile of them to influence the content of ads or articles on news.example.\r\n\r\n### The Attack\r\n\r\nThis is how AdTech could foil the user agent's privacy protections with the current signed packages proposal:\r\n\r\nNews wants to take part in signed package loading but thinks the actual packaging is cumbersome and costly in terms of engineering resources.\r\n\r\nAdTech has a financial incentive to help News get going with signed packages because the technology makes AdTech's services better. Because of this incentive, AdTech decides to offer News a more convenient way to do the packaging; it offers to pull unsigned articles directly from News's servers and do packaging for them. News just has to set up a signing service that AdTech can call to get signatures back, or just hand a signing key straight to AdTech. News sees the opportunity to reduce cost and takes the offer.\r\n\r\nAdTech also has a financial incentive to identify the user on news.example to augment its profile of the user and to earn extra money by serving the user individually targeted ads, but it can't do so because the user's user agent is protecting the user's privacy. However, the request to get a signed News package is actually made to adtech.example, containing the user's AdTech cookies. To achieve their goals and earn more money, AdTech's decides to create news.example packages on the fly, bake in individually targeted ads plus an AdTech user ID for profile enrichment, and sign the whole thing with News's key.\r\n\r\nThis is a case of cross-site tracking. The user is on a news.example webpage, convinced that their user agent protects them from AdTech tracking them on this site, but instead they got a signed package with tracking built in.\r\n\r\n### How the Attack Relates To Other Means of Cross-Site Tracking\r\n\r\nOften when we criticize new, technically distinct tracking vectors, we are told that \u201cyou can track users in so many ways so why care about this one?\u201d In the case of signed packages we hear about means of tracking such as doctored links where cross-site tracking is built into the URL, or server-side exchanges of personally identifiable information such as users' email addresses.\r\n\r\nFirst, we don't think past mistakes and flaws in web technologies is a valid argument for why new web technologies should enable cross-site tracking.\r\n\r\nSecond, WebKit is working hard to prevent cross-site tracking, including new limits and restrictions on old technologies. Piling on more such work is not acceptable to us.\r\n\r\nFinally, the success of new web technologies such as signed packages relies on better security and privacy guarantees than what we've had in the past. We want progression in this space, not the status quo.\r\n\r\n## Potential Mitigations and Fixes\r\n\r\nA mitigation we'd like to discuss is this:\r\n\r\n1. The server responding with the signed package is required to send the signature up front. This is to incentivize AdTech to not sign other websites' packages on the fly.\r\n2. The user agent makes an ephemeral, cookie-less preflight request to news.example to get the signature and then validates the package from adtech.example against that signature.\r\n3. We add a signed time stamp to the package signature to avoid AdTech telling News to get signatures from adtech.example backend and send personalized signatures back as preflight responses. With such time stamps, the user agent can decide to not accept signatures younger than, say one minute. For this to work we need signed, official time.\r\n\r\nThe above scheme would make it significantly harder to \u201cpersonalize\u201d packages.\r\n\r\nAnother potential mitigation would be some kind of public repository of signatures to check against.\r\n",
      "createdAt": "2019-04-19T00:26:44Z",
      "updatedAt": "2019-04-24T22:44:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Thanks for filing this John!\n\nI had one quick question regarding the original proposal - the suggestion\nof a signed timestamp seems to introduce a trusted third party to the\nnegotiation, the timeserver. Do you have any sense or thought as to who\nwould operate such a timeserver, or how a U-A would select such a thing, as\nit seems like it could either lie (if using a simple time signing protocol)\nor collude with adtech.example (if using a more robust protocol, like\nRoughtime)\n",
          "createdAt": "2019-04-19T01:05:33Z",
          "updatedAt": "2019-04-19T01:05:33Z"
        },
        {
          "author": "kevinsimper",
          "authorAssociation": "NONE",
          "body": "@sleevi Trusted time could be provided by a blockchain, that would allow something that can't be tampared. \r\n\r\n@johnwilander Could content-addressable be regarded as a potential solution as well? By using that solution you could verify by third-party that you didn't get something customized, as yours would be different than everyone else. \r\n",
          "createdAt": "2019-04-19T05:38:59Z",
          "updatedAt": "2019-04-19T05:38:59Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> @sleevi <https://github.com/sleevi> Trusted time could be provided by a\r\n> blockchain, that would allow something that can't be tampared.\r\n>\r\n\r\nThanks for the reply!\r\n\r\n\r\nI think it would probably be more productive if we avoid abstract\r\ntechnology hypotheticals, and instead focus on concrete or actual\r\nsolutions. The problem with abstractions is that they largely tend to punt\r\nthe problem being discussed onto the abstraction, rather than providing a\r\nsolution themselves. That is, \u201cimagine if we had a perfect X that didn\u2019t\r\nhave problem Y\u201d doesn\u2019t quite solve for Y, and now we also have to solve\r\nfor X to find an actual X with that property \ud83d\ude05\r\n\r\n\r\nMy previous question acknowledges the possibility of the use of Merkle\r\nTrees as a basis for time, by focusing on an actual time protocol (that\u2019s\r\nwhat Roughtime is), and then discusses actual challenges with it that would\r\nstill exist, as a way of trying to better understand the actual\r\nrequirements. Collusion by adtech.example is an (extreme) possibility, and\r\nthus it seemed important to understand the requirements here, since it\r\nseemed like there might be some unstated requirements hidden between that\r\nlast bullet point. \ud83e\udd14\r\n\r\n\r\n> @johnwilander <https://github.com/johnwilander> Could content-addressable\r\n> be regarded as a potential solution as well? By using that solution you\r\n> could verify by third-party that you didn't get something customized, as\r\n> yours would be different than everyone else.\r\n>\r\n\r\n\r\nCould you explain how you see this working? Content-addressable storage\r\ndoesn\u2019t actually provide the guarantee you stated, at least as commonly\r\nunderstood by how CAS works. Indeed, one can view the existing SXG proposal\r\nas functionally CAS with an attached signature.\r\n\r\n\r\nIf you mean something like a peer-to-peer distribution network, using\r\nthings like DHT or the like, none of the existing technologies seem to\r\nprovide that guarantee. Understanding a bit more about what is meant by\r\nthis question helps better understand what you see the provided properties\r\nas.\r\n\r\n\r\nIf the suggestion is to use a Trusted Third Party and report the hash you\r\nsee, that of course comes with serious privacy concerns for the end user -\r\nit adds yet another way to see what the user is doing. It also introduces a\r\ncentralized censorship mechanism, by coercing the TTP to lie about whether\r\nit has seen a package, and thus preventing it from loading. However, one\r\ndoesn\u2019t typically think of a TTP as being CAS.\r\n\r\n\r\nThis is why I focused on trying to understand the proposal itself first, to\r\nmake sure we don\u2019t rabbit hole on such challenges until we\u2019re all on the\r\nsame page with base understanding \ud83d\ude03\r\n",
          "createdAt": "2019-04-19T10:45:30Z",
          "updatedAt": "2019-04-19T10:52:47Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "body": "> Thanks for filing this John! I had one quick question regarding the original proposal - the suggestion of a signed timestamp seems to introduce a trusted third party to the negotiation, the timeserver. Do you have any sense or thought as to who would operate such a timeserver, or how a U-A would select such a thing, as it seems like it could either lie (if using a simple time signing protocol) or collude with adtech.example (if using a more robust protocol, like Roughtime)\r\n\r\nHi Ryan!\r\n\r\nSigned, trusted time is a Hard Thing, at least the last time I dug into it. It even plays into human culture where citizens of some countries would trust the government to issue such timestamps and others would rather have an independent non-profit do it.\r\n\r\nI do not have a ready solution. But there seems to be a few interested parties who want these signed exchanges, Google and Cloudflare being two. Maybe these parties can propose a solution that we can review? Even if we don't achieve a perfect solution, something transparent and explicitly designed to prohibit abuse may be enough to instill (more) trust in this technology.\r\n\r\nThere is at least one more benefit of signed, trusted timestamps in these packages and that is the ability to audit when content was created. A temporary compromise of News's publishing apparatus could issue fake news and then push that news to a micro targeted audience to sway public opinion \"dark ads\"-style. Trustworthy timestamps in packages would at least allow for an audit after the fact. Or if abuse gets really ugly, user agents could support things like \"News was compromised between TimeA and TimeB and doesn't know what was published and signed under its name during that time. Therefore all News packages signed between TimeA and TimeB are blocked.\"",
          "createdAt": "2019-04-19T15:07:43Z",
          "updatedAt": "2019-04-19T15:08:31Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> I do not have a ready solution. But there seems to be a few interested parties who want these signed exchanges, Google and Cloudflare being two. Maybe these parties can propose a solution that we can review? Even if we don't achieve a perfect solution, something transparent and explicitly designed to prohibit abuse may be enough to instill (more) trust in this technology.\r\n\r\nI definitely think it's something worth discussing, and I'm wanting to make sure to tease out the requirements a bit more up front, so we can find something workable.\r\n\r\nYou mentioned trusted time, which evokes protocols like [Roughtime](https://roughtime.googlesource.com/roughtime) (which, incidentally, Cloudflare [also supports](https://blog.cloudflare.com/roughtime/) ). However, the 'trusted' part of that time is achieved by having the Roughtime client send a random 'nonce', and that doesn't seem like a good fit here, for a number of reasons.\r\n\r\nFrom the threat model described, my understanding of how the suggested mitigation would work is that sounds like you're talking more-so about a Time-Stamping authority - some third-party (or set of third-parties) to attest that, at a given time, it was aware of a given hash. Does that sound roughly correct?\r\n\r\nTypically, these sorts of approaches imply direct trust in the TSA to always be honest. I was trying to understand how much or how little of your threat model included the TSA as a bad actor - for example, understanding whether or not the threat includes `adtech.example` colluding with (or operating their own) time-stamping authority. If the threat model is considering this, what sort of mitigations would be seen as acceptable versus unacceptable, to help inform possible solutions?\r\n\r\nFor example, if the idea is Apple (or other UAs) would select a TSA and explicitly trust it, say, using business controls like audits - an approach Mozilla is taking with their selection of [trusted recursive resolvers](https://blog.nightly.mozilla.org/2018/06/01/improving-dns-privacy-in-firefox/) - then there are simpler options with very little technical complexity, because it's addressed by the business controls. However, if the idea is that there should be zero trust in the trusted time server, except that which can be proved mathematically, then that would require much more complex solutions, which haven't yet been solved for related areas.\r\n\r\n> There is at least one more benefit of signed, trusted timestamps in these packages and that is the ability to audit when content was created. A temporary compromise of News's publishing apparatus could issue fake news and then push that news to a micro targeted audience to sway public opinion \"dark ads\"-style. Trustworthy timestamps in packages would at least allow for an audit after the fact. Or if abuse gets really ugly, user agents could support things like \"News was compromised between TimeA and TimeB and doesn't know what was published and signed under its name during that time. Therefore all News packages signed between TimeA and TimeB are blocked.\"\r\n\r\nI think this would be best discussed in a separate issue, and understanding the use case more. It seems that there are several use cases mixed up in here, such as repudiation (or revocation) and transparency. Given that almost every technical solution to these sorts of use cases introduces negative effects, they're likely topics in themselves, and worth tracking as such. For example, repudiation/revocation (the compromise scenario described) has commonly enabled greater centralization and censorship, and the transparency aspect comes at significant cost to user privacy (the ability to say \"I know you read/published targeted article X\").\r\n\r\nI don't want to lose sight of these, but also don't want to miss out on the big picture here, so if you have a write-up for these use cases and could file them as new issues, I think we'd be happy to engage. I'm not sure I understand your specific goals there well enough to do it myself :)",
          "createdAt": "2019-04-19T15:48:39Z",
          "updatedAt": "2019-04-19T15:49:12Z"
        },
        {
          "author": "nminnov",
          "authorAssociation": "NONE",
          "body": "> I definitely think it's something worth discussing, and I'm wanting to make sure to tease out the requirements a bit more up front, so we can find something workable.\r\n\r\nAgree that the requirements need to be understood and appreciated before discussing the \"how\". Would you agree that:\r\n- \"The Threat\" as described is indeed a threat to privacy\r\n- the threat needs to be addressed",
          "createdAt": "2019-04-19T22:00:34Z",
          "updatedAt": "2019-04-19T22:00:34Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "body": "> > I do not have a ready solution. But there seems to be a few interested parties who want these signed exchanges, Google and Cloudflare being two. Maybe these parties can propose a solution that we can review? Even if we don't achieve a perfect solution, something transparent and explicitly designed to prohibit abuse may be enough to instill (more) trust in this technology.\r\n> \r\n> I definitely think it's something worth discussing, and I'm wanting to make sure to tease out the requirements a bit more up front, so we can find something workable.\r\n> \r\n> You mentioned trusted time, which evokes protocols like [Roughtime](https://roughtime.googlesource.com/roughtime) (which, incidentally, Cloudflare [also supports](https://blog.cloudflare.com/roughtime/) ). However, the 'trusted' part of that time is achieved by having the Roughtime client send a random 'nonce', and that doesn't seem like a good fit here, for a number of reasons.\r\n> \r\n> From the threat model described, my understanding of how the suggested mitigation would work is that sounds like you're talking more-so about a Time-Stamping authority - some third-party (or set of third-parties) to attest that, at a given time, it was aware of a given hash. Does that sound roughly correct?\r\n\r\nYes.\r\n\r\n> Typically, these sorts of approaches imply direct trust in the TSA to always be honest. I was trying to understand how much or how little of your threat model included the TSA as a bad actor - for example, understanding whether or not the threat includes `adtech.example` colluding with (or operating their own) time-stamping authority. If the threat model is considering this, what sort of mitigations would be seen as acceptable versus unacceptable, to help inform possible solutions?\r\n\r\nAdTech operating the TSA sounds problematic. But a shared TSA, funded/controlled/audited by multiple stakeholders could probably work. Also transparency will work in our favor here. It should be easy to check the integrity of the TSA, not just for UAs but for anyone.\r\n\r\n> For example, if the idea is Apple (or other UAs) would select a TSA and explicitly trust it, say, using business controls like audits - an approach Mozilla is taking with their selection of [trusted recursive resolvers](https://blog.nightly.mozilla.org/2018/06/01/improving-dns-privacy-in-firefox/) - then there are simpler options with very little technical complexity, because it's addressed by the business controls. However, if the idea is that there should be zero trust in the trusted time server, except that which can be proved mathematically, then that would require much more complex solutions, which haven't yet been solved for related areas.\r\n\r\nHaving not discussed the TSA issue in detail with my team, I'd say zero trust is not a must to get something on the table for serious review.\r\n\r\n> \r\n> > There is at least one more benefit of signed, trusted timestamps in these packages and that is the ability to audit when content was created. A temporary compromise of News's publishing apparatus could issue fake news and then push that news to a micro targeted audience to sway public opinion \"dark ads\"-style. Trustworthy timestamps in packages would at least allow for an audit after the fact. Or if abuse gets really ugly, user agents could support things like \"News was compromised between TimeA and TimeB and doesn't know what was published and signed under its name during that time. Therefore all News packages signed between TimeA and TimeB are blocked.\"\r\n> \r\n> I think this would be best discussed in a separate issue, and understanding the use case more. It seems that there are several use cases mixed up in here, such as repudiation (or revocation) and transparency. Given that almost every technical solution to these sorts of use cases introduces negative effects, they're likely topics in themselves, and worth tracking as such. For example, repudiation/revocation (the compromise scenario described) has commonly enabled greater centralization and censorship, and the transparency aspect comes at significant cost to user privacy (the ability to say \"I know you read/published targeted article X\").\r\n\r\nI hesitated bringing up the auditing+dark ads case because, as you say, it's a separate issue. I just wanted to mention it here to make it clear that trusted time stamps might have other benefits too.\r\n\r\n> I don't want to lose sight of these, but also don't want to miss out on the big picture here, so if you have a write-up for these use cases and could file them as new issues, I think we'd be happy to engage. I'm not sure I understand your specific goals there well enough to do it myself :)\r\n\r\nI'll hold off for now to make sure that the cycles I have to spare are spent on this issue here. :)",
          "createdAt": "2019-04-19T22:21:37Z",
          "updatedAt": "2019-04-19T22:21:37Z"
        },
        {
          "author": "frivoal",
          "authorAssociation": "NONE",
          "body": "Unless, I am missing something, this boils down to \"if you hand someone your private keys, they can impersonate you while doing things you wouldn't\". Right?\r\n\r\nIf I understand correctly, the atracks that this enables seem already possible when handing your private keys to a CDN so that it can do https on your behalf.\r\n\r\nAs you said in the initial post, just because a similar attack already exists doesn't mean we shouldn't do anything about it. So I am absolutely in favor of mitigating this if we can.\r\n\r\nHowever, I think it is worth considering what happens if we cannot. On balance, it seems to me that this might still be an overall improvement to security, because of the https/CDN case.\r\n\r\nThe attack described here is possible when news.example chose to let adtech.example do the crypto on their behalf. But they can (and should) do it themselves. However, in the https/CDN case, news.example has no choice: if it wants cdn.example to do https on the unchanged URLs, it has to hand over it's private keys. However, with signed exchanges, it becomes possible for news.example to sign its content itself, and have the signed package be delivered via CDNs without revealing its private keys to anyone.\r\n\r\nUnless I am misunderstanding this, this means that while the introduction of signed packages may make it tempting to \"do the wrong thing\" (share your private keys) in more cases, it also makes it possible to do the right thing (do all the signing yourself) in cases where it previously was not. Whether that's a net positive probably depends on how strong the temptation is (i.e. how easy it is to sign packages yourself, how much will addTech.example pay you to do it on your behalf, etc).",
          "createdAt": "2019-04-20T01:27:26Z",
          "updatedAt": "2019-04-20T01:27:26Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "body": "> Unless, I am missing something, this boils down to \"if you hand someone your private keys, they can impersonate you while doing things you wouldn't\". Right?\r\n> \r\n> If I understand correctly, the atracks that this enables seem already possible when handing your private keys to a CDN so that it can do https on your behalf.\r\n\r\nActually, that is not the case.\r\n\r\nGoing back to the threat:\r\n1. The user does not want AdTech to be able to augment its profile of them while reading articles on news.example.\r\n2. The user does not want AdTech's rich profile of them to influence the content of ads or articles on news.example.\r\n\r\nIn the case of News handing AdTech a private key to do CDN things from a *.news.example subdomain, the user agent will send news.example's cookies in requests for articles (and possibly in requests to the CDN subdomain). This allows the user agent to protect the user's privacy by blocking adtech.example from accessing **its** cookies as third-party resource on a news.example page.\r\n\r\nIn the case of a signed package loaded from adtech.example, the user agent will send adtech.example's cookies in the request which allows AdTech to leverage its rich profile of the user to \"personalize\" content and ads as well as plant an AdTech user ID in the package to use in third-party requests to enrich its profile of the user.\r\n\r\n> As you said in the initial post, just because a similar attack already exists doesn't mean we shouldn't do anything about it. So I am absolutely in favor of mitigating this if we can.\r\n> \r\n> However, I think it is worth considering what happens if we cannot. On balance, it seems to me that this might still be an overall improvement to security, because of the https/CDN case.\r\n> \r\n> The attack described here is possible when news.example chose to let adtech.example do the crypto on their behalf. But they can (and should) do it themselves. However, in the https/CDN case, news.example has no choice: if it wants cdn.example to do https on the unchanged URLs, it has to hand over it's private keys. However, with signed exchanges, it becomes possible for news.example to sign its content itself, and have the signed package be delivered via CDNs without revealing its private keys to anyone.\r\n> \r\n> Unless I am misunderstanding this, this means that while the introduction of signed packages may make it tempting to \"do the wrong thing\" (share your private keys) in more cases, it also makes it possible to do the right thing (do all the signing yourself) in cases where it previously was not. Whether that's a net positive probably depends on how strong the temptation is (i.e. how easy it is to sign packages yourself, how much will addTech.example pay you to do it on your behalf, etc).\r\n\r\nGiven my explanation above, I'll let you revisit your analysis before commenting further.",
          "createdAt": "2019-04-20T02:15:25Z",
          "updatedAt": "2019-04-20T02:15:25Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "Question: the same planting of IDs can always be done via link\naugmentation. My understanding is that Safari is trying to protect against\nthat by blocking query/fragment on cross origin navigation.\n\nCould an SXG navigation be made equivalent to a cross-origin navigation by\nsaying: UA will only render the SXG if\n- the original request was cookieless\n- was a get request\n- has no query string or fragment\n- the path of the SXG request is the same as the path on the target domain.\n\n\nOn Sat, Apr 20, 2019, 11:15 AM John Wilander <notifications@github.com>\nwrote:\n\n> Unless, I am missing something, this boils down to \"if you hand someone\n> your private keys, they can impersonate you while doing things you\n> wouldn't\". Right?\n>\n> If I understand correctly, the atracks that this enables seem already\n> possible when handing your private keys to a CDN so that it can do https on\n> your behalf.\n>\n> Actually, that is not the case.\n>\n> Going back to the threat:\n>\n>    1. The user does not want AdTech to be able to augment its profile of\n>    them while reading articles on news.example.\n>    2. The user does not want AdTech's rich profile of them to influence\n>    the content of ads or articles on news.example.\n>\n> In the case of News handing AdTech a private key to do CDN things from a\n> *.news.example subdomain, the user agent will send news.example's cookies\n> in requests for articles (and possibly in requests to the CDN subdomain).\n> This allows the user agent to protect the user's privacy by blocking\n> adtech.example from accessing *its* cookies as third-party resource on a\n> news.example page.\n>\n> In the case of a signed package loaded from adtech.example, the user agent\n> will send adtech.example's cookies in the request which allows AdTech to\n> leverage its rich profile of the user to \"personalize\" content and ads as\n> well as plant an AdTech user ID in the package to use in third-party\n> requests to enrich its profile of the user.\n>\n> As you said in the initial post, just because a similar attack already\n> exists doesn't mean we shouldn't do anything about it. So I am absolutely\n> in favor of mitigating this if we can.\n>\n> However, I think it is worth considering what happens if we cannot. On\n> balance, it seems to me that this might still be an overall improvement to\n> security, because of the https/CDN case.\n>\n> The attack described here is possible when news.example chose to let\n> adtech.example do the crypto on their behalf. But they can (and should) do\n> it themselves. However, in the https/CDN case, news.example has no choice:\n> if it wants cdn.example to do https on the unchanged URLs, it has to hand\n> over it's private keys. However, with signed exchanges, it becomes possible\n> for news.example to sign its content itself, and have the signed package be\n> delivered via CDNs without revealing its private keys to anyone.\n>\n> Unless I am misunderstanding this, this means that while the introduction\n> of signed packages may make it tempting to \"do the wrong thing\" (share your\n> private keys) in more cases, it also makes it possible to do the right\n> thing (do all the signing yourself) in cases where it previously was not.\n> Whether that's a net positive probably depends on how strong the temptation\n> is (i.e. how easy it is to sign packages yourself, how much will\n> addTech.example pay you to do it on your behalf, etc).\n>\n> Given my explanation above, I'll let you revisit your analysis before\n> commenting further.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/422#issuecomment-485050921>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAAV4T7K56Y2MSSAM5EN423PRJ4D5ANCNFSM4HHBF6UQ>\n> .\n>\n",
          "createdAt": "2019-04-20T03:26:20Z",
          "updatedAt": "2019-04-20T03:26:20Z"
        },
        {
          "author": "frivoal",
          "authorAssociation": "NONE",
          "body": "> Given my explanation above, I'll let you revisit your analysis before commenting further.\r\n\r\nThanks, I had indeed missed that key distinction. Revising what I said earlier, my understanding is now:\r\n* The ability to inject customized/undesired things into the page is the same for the https+CDN and for the adTech packager\r\n* The ability to use cookies meant for adTech to identify the user in order to inform what kind of custom/undesired things to inject into the page is **not** the same in both scenario\r\n\r\nYou were focused on the second thing, while I was on the first.\r\n\r\nThat said, I wonder if the ability to modify the page before serving it and to inject arbitrary stuff along the way does not enable the malicious CDN to get back the same information with additional network requests from the page once it is loaded. Maybe blocking third party cookies effectively prevents this, but I don't feel overly confident. Once you hand your private keys to a third party, it seems hard to limit what they can do.",
          "createdAt": "2019-04-20T05:08:15Z",
          "updatedAt": "2019-04-20T05:08:15Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "body": "Hi Malte!\r\n\r\n> Question: the same planting of IDs can always be done via link augmentation. My understanding is that Safari is trying to protect against that by blocking query/fragment on cross origin navigation. Could an SXG navigation be made equivalent to a cross-origin navigation by saying: UA will only render the SXG if - the original request was cookieless - was a get request - has no query string or fragment - the path of the SXG request is the same as the path on the target domain.\r\n> [\u2026](#)\r\n\r\nI avoided bringing this up to not inflate my original description and take focus off of the particular issue with built-in tracking. What you mention are additional things we'll have to do to protect signed packages, but they apply to arbitrary navigations that start on AdTech's site.",
          "createdAt": "2019-04-20T12:47:12Z",
          "updatedAt": "2019-04-20T12:47:12Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It might take me until Wednesday, but I'd like to check this threat model into the repository as a description of the anti-tracking requirements that at least Apple wants on the design. I'm then going to add the other attacker abilities and constraints that I think I've seen in the Twitter discussion and comments here, along with the attacker goals that we want the design to frustrate.\r\n\r\nI think it'll be more productive to get agreement on a full understanding of the requirements before we look for solutions or try to knock over the solutions that have already been proposed.",
          "createdAt": "2019-04-20T18:49:03Z",
          "updatedAt": "2019-04-24T22:43:18Z"
        },
        {
          "author": "kevinsimper",
          "authorAssociation": "NONE",
          "body": "@johnwilander \r\n> But a shared TSA, funded/controlled/audited by multiple stakeholders could probably work. Also transparency will work in our favor here. It should be easy to check the integrity of the TSA, not just for UAs but for anyone.\r\n\r\nThis sounds exactly like a blockchain. (and I don't work or have investments in blockchains). It can be transparent, it is easy to check the integrity, and has many stakeholders. I know it overused and many have burnt out on the concept, but it is a valid technology. There is even work to do with \"verifiable delay function\".\r\n\r\n\r\n@sleevi \r\n> Collusion by adtech.example is an (extreme) possibility, and thus it seemed important to understand the requirements here, since it seemed like there might be some unstated requirements hidden between that last bullet point. \ud83e\udd14\r\n\r\nYeah, and I was also hesitant to suggest it as it is a misused concept for a lot of stuff. I didn't suggest any particular blockchains. Your merkledag reference gives me clues that you have considerations about it \ud83d\udc4d \r\n\r\n\r\n---\r\n\r\nIf the requirement is to keep it simple and solutions could be also to so some kind of proof of work, which would make it very expensive to make one on the fly, but cheap to do once. This also avoids contacting anybody else as the proof can be verified easily by the user agent.",
          "createdAt": "2019-04-20T20:35:16Z",
          "updatedAt": "2019-04-20T20:35:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://github.com/WICG/webpackage/pull/424 tries to document the threat model we're trying to handle here, along with a couple notes on the mitigations I've seen proposed so far. How's it look?",
          "createdAt": "2019-04-24T22:44:15Z",
          "updatedAt": "2019-04-24T22:44:15Z"
        }
      ]
    },
    {
      "number": 423,
      "id": "MDU6SXNzdWU0MzYyNzQyODY=",
      "title": "Cross-site loads of signed packages should be done stateless and with no personalization",
      "url": "https://github.com/WICG/webpackage/issues/423",
      "state": "OPEN",
      "author": "johnwilander",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As brought up by @cramforce in https://github.com/WICG/webpackage/issues/422#issuecomment-485054801, we should require cross-site loads of signed packages to be stateless. Specifically:\r\n- The request chain must be credential-less. Maybe we can leverage some Fetch policy here.\r\n- It must be an HTTP GET request.\r\n- The request URL must not have a query string or fragment.\r\n- The path of the package request must be the same as the path on the target domain.\r\n\r\nThe above requirements are to ensure that cross-site tracking or personalization information is not transferred in the request for the package.",
      "createdAt": "2019-04-23T16:13:05Z",
      "updatedAt": "2019-07-11T19:53:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dfabulich",
          "authorAssociation": "NONE",
          "body": "A common tracking technique is to put personalized information in the ETag, e.g. `ETag: W/your-login-id-plus-content-hash` \r\n\r\nThus, to be truly stateless, the request would also have to prevent conditional GET requests (`If-None-Match`, `If-Modified-Since`)",
          "createdAt": "2019-05-14T17:42:00Z",
          "updatedAt": "2019-05-14T17:42:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "From the Chrome anti-tracking team, we agree that SXGs should require mitigations for cross-site information flow. We think the suggestions here should be adopted, though of course details like how to trigger such a credential-less navigation still need to be worked out.\r\n\r\nA minor quibble/note, the last two points as written require a distinct distributor origin per publisher origin, which seems off. (It even risks the SXG prefetch leaking the distributor origin via DNS and SNI.) I would suggest rephrasing it as: the path + query string of the navigation needs to be some specific deterministic function of the SXG target URL. For instance, `https://distributor.example/.well-known/sxg/[some encoding or cryptographic hash of target URL]`.",
          "createdAt": "2019-07-11T19:53:34Z",
          "updatedAt": "2019-07-11T19:53:34Z"
        }
      ]
    },
    {
      "number": 430,
      "id": "MDU6SXNzdWU0Mzk4MjQzOTA=",
      "title": "Proposal: Required Domains extension for certificates",
      "url": "https://github.com/WICG/webpackage/issues/430",
      "state": "OPEN",
      "author": "grittygrease",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Pending Security + Privacy Review"
      ],
      "body": "It's been widely discussed that SXG certificates enable off-path attacks. This means that an attacker that has stolen an SXG private key and created SXG content can send it to a client from any server controlled by that attacker, such as a phishing site, and the browser will trust it. This opens up a lot of possibilities for impersonation that are not currently available to an attacker that compromises a TLS certificate. An attacker with a TLS certificate needs to somehow get a client that is already connecting to a site (via DNS and TCP/IP) to connect to a server under their control to fetch the content. This usually requires DNS poisoning or being on-path between the victim and the server.\r\n\r\nBecause SXG introduces a new off-path vector of attack, it's worth considering ways to mitigate this attack vector in the specification. This is the situation we found ourselves in for the Secondary Certificates project (https://tools.ietf.org/html/draft-bishop-httpbis-http2-additional-certs-05), which allows attackers with specially-issued secondary certificates to serve content from multiple sites over the same connection, which enables similar off-path attacks.\r\n\r\nThe mitigation that was discussed in Secondary Certificates to prevent arbitrary off-path domain hijacking was a simple one: we proposed that for a certificate to be used as secondary, it needs an additional field called \"Required Domain\". In order to accept a certificate with a \"Required Domain\" extension, the server must have previously served a certificate that covers the required domain on the same connection. This has the nice property that if a secondary certificate is compromised, it can only be used to hijack traffic if they also have control over the secondary domain.\r\n\r\nI'd like to suggest that this mechanism be considered here for SXG certificates. In order to serve an SXG from a cache, the certificate would need to have that cache's domain in its set of \"Required Domains\". This would drastically reduce the capabilities of an attacker who steals an SXG cert key, mints SXGs and serves them from an arbitrary phishing domain.",
      "createdAt": "2019-05-02T23:03:23Z",
      "updatedAt": "2019-05-08T21:23:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We've talked about ideas in this direction, although not exactly this one, and while they improve security, they also worsen, for example, @ekr's concern that the feature increases large organizations' control over the internet. For example, we don't want `publisher.example` to be able to declare that only Google is allowed to cache their SXGs.\r\n\r\n@martinthomson, will your document discuss how Mozilla feels about mitigating stolen private keys vs mis-issued certificates? IIUC, this suggestion doesn't help with mis-issued certificates.",
          "createdAt": "2019-05-02T23:27:15Z",
          "updatedAt": "2019-05-02T23:27:15Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "It seems like there are two questions here, actually:\r\n\r\n1. Should it be possible for publishers to constrain the origins where there content can be cached?\r\n2. Should certificates contain that constraint so that stolen keys are not a compromise threat?\r\n\r\nObviously, the answer to (2) is \"no\" if the answer to (1) is \"no\", but that's not a complete answer. It seems like what's really at stake is whether we think of an SXG as a portable object or as a cooperative venture between the publisher and the cache.",
          "createdAt": "2019-05-02T23:31:38Z",
          "updatedAt": "2019-05-02T23:31:38Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "A useful variant may be to allow certificates to grant all origins to serve their SXG, but also provide a mechanism to restrict them. That would enable use of the SXG primitive for for decentralized web use cases, while also allowing publishers to restrict distribution.",
          "createdAt": "2019-05-03T00:33:26Z",
          "updatedAt": "2019-05-03T00:33:26Z"
        }
      ]
    },
    {
      "number": 431,
      "id": "MDU6SXNzdWU0Mzk5MzM2NTY=",
      "title": "Go: Avoid mutating (signedexchange.Exchange).Payload",
      "url": "https://github.com/WICG/webpackage/issues/431",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi",
        "nyaxt",
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "cc: @twifkak \r\n\r\nIn the current code, the `Payload []byte` field may contain payload either before or after mice encoding.\r\nThis is confusing behavior and we should avoid.\r\n\r\nPerhaps we should factor out other `Exchange` members to a separate struct.\r\n#427 would also benefit from such change.",
      "createdAt": "2019-05-03T08:06:54Z",
      "updatedAt": "2019-05-03T08:07:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 432,
      "id": "MDU6SXNzdWU0NDE5ODI5OTU=",
      "title": "Prevent fallback loop when publisher publishes invalid SXG",
      "url": "https://github.com/WICG/webpackage/issues/432",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://crbug.com/939684 handles this by removing `application/signed-exchange` from the `Accept` header on fallback, but @gregable mentions the possibility of not-checking the signature for a same-origin signed exchange.\r\n\r\nThis interacts with #397 in that we'll want to make sure the loop prevention works for every reason we might use the fallback URL.",
      "createdAt": "2019-05-08T23:15:32Z",
      "updatedAt": "2019-05-09T19:39:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We also need to remember to check either [`Service-Worker-Allowed`](https://w3c.github.io/ServiceWorker/#service-worker-allowed) or a similar mechanism to make sure folks don't impersonate a path they're not authoritative for.",
          "createdAt": "2019-05-09T19:39:45Z",
          "updatedAt": "2019-05-09T19:39:45Z"
        }
      ]
    },
    {
      "number": 433,
      "id": "MDU6SXNzdWU0NDMxNzc5NTc=",
      "title": "Is it OK to let the publishers know the SXG distributor's URL?",
      "url": "https://github.com/WICG/webpackage/issues/433",
      "state": "OPEN",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Pending Security + Privacy Review",
        "architecture",
        "feature request"
      ],
      "body": "I have stopped working on Signed Exchange Reporting for publishers. https://github.com/w3c/network-error-logging/issues/99#issuecomment-490739647\r\nThis is mainly because it is not clear whether is it OK to let the publisher know the distributor's URL.\r\n\r\nIf my understanding is correct, we can't know redirecting URLs.\r\nThe publisher can only know \"aggregator.example/feed\" using referrer in this case: \r\n- aggregator.example/feed -> redirect.example/publisher.example/article (returns 301 redirect) -> publisher.example/article\r\n\r\nSo I think it sounds reasonable not to let the publisher know the SXG distributor's URL.\r\n\r\nAnd also if the publishers can know the distributor's URL, this can be used for user tracking.\r\nExample:\r\n https://TRACKING_ID.distributor.example/publisher.example/article.html.sxg\r\n https://distributor.example/TRACKING_ID/publisher.example/article.html.sxg\r\nI think we should avoid adding new features which can be used for user tracking.",
      "createdAt": "2019-05-13T02:14:41Z",
      "updatedAt": "2019-05-20T05:46:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Is the above different from the distributor adding an `<a ping=\"publisher.example/collection_endpoint/TRACKING_ID\">` to the SXG link?",
          "createdAt": "2019-05-13T05:52:29Z",
          "updatedAt": "2019-05-13T05:52:29Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "From the user tracking point of view, it is almost same.",
          "createdAt": "2019-05-13T13:04:50Z",
          "updatedAt": "2019-05-13T13:04:50Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, since we enable `ping` attributes, `onclick` events, redirections and multiple other ways of communicating that information out-of-band, I don't see why we'd want to block this particular one.",
          "createdAt": "2019-05-13T13:50:58Z",
          "updatedAt": "2019-05-13T13:50:58Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I\u2019m not sure I see how you see those others as substantively similar. They\nseem very different than what I\u2019ve seen discussed/proposed.\n\nFor example, `ping` lets you initiate as the outgoing link - but the\nproposal here does not establish any relationship between the distributor\nand the link provider. Further, `ping` let\u2019s you notify that a link is\nbeing followed, but not the final target of that link.\n\nI think it\u2019s unlikely to sway anyone to simply state that there are\nparallels, because it doesn\u2019t establish the parallels, nor that those\ncurrent behaviours are desired. A more thorough analysis would be useful,\nif that is the one to justify this.\n",
          "createdAt": "2019-05-13T13:54:39Z",
          "updatedAt": "2019-05-13T13:54:39Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe I misunderstood the threat model. Are we worried that publishers will know about tracking IDs without the distributor actively communicating them?",
          "createdAt": "2019-05-13T14:40:23Z",
          "updatedAt": "2019-05-13T14:40:23Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Fair point. I don't think we've articulated a particular threat model or set of threat models. The question is, as I understood it, trying to articulate the potential risks.\r\n\r\nWe've got at least four parties in play:\r\n- The Publisher, the provider of the SXG\r\n- The Distributor, the hoster of the SXG resource\r\n- The \"Sender\", the one who provides the outbound link or initiates loading of SXG (I hesitate to use the term aggregator, as I think it implies a particular type of Sender)\r\n- The User, for whom we are the agent.\r\n\r\nOne potential risk is, as @horo-t noted, about active collusion between Publisher and Distributor in a way that allows them to exchange information.\r\n  - As you note, if the Sender is colluding, then there's no need for the Publisher to have special capabilities / adding special capabilities does not change this, since they can always get the information out-of-band from the Sender.\r\n  - However, if the Sender is not colluding / party to the threat, then I think this changes the calclus\r\n\r\nAnother potential risk is where the User does not wish the Publisher to learn about the Distributor they're using, especially if it may reveal the User's activity with the Sender. This is one of the tensions we noted early on with reporting the Distributor to the Publisher - whether or not it aligns with the user's interests, or whether it allows the Publisher to learn information about the User based on the Distributor.\r\n\r\nI'm sure there are other scenarios being overlooked here, but I think it's a fair point that we're likely talking about different things, but which collectively go to identify whether or not it's OK.",
          "createdAt": "2019-05-13T14:52:16Z",
          "updatedAt": "2019-05-13T14:53:10Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#424 has an attempt to build an anti-tracking threat model, although I'm sure it's incomplete. In particular, there's only a tracking risk if the same request or JS environment exposes both the Distributor's tracking ID and the Publisher's tracking ID. Simply sending `https://DISTRIBUTOR_TRACKING_ID.distributor.example/publisher.example/article.html.sxg` to the publisher with no other information isn't enough, since it doesn't include the publisher's tracking ID.\r\n\r\n`<a ping>` is specified to [`include` credentials](https://html.spec.whatwg.org/multipage/links.html#hyperlink-auditing), so anyone trying to block tracking will need to change that along with any restrictions on reporting the distributor URL to the publisher. I think we should design for uncertainty in how far that effort will go, rather than assuming we need to pre-emptively block all communication via this one channel.\r\n\r\n#424 doesn't cover the worry about the Publisher learning things about the User's interaction with the Sender because that's a more immediate risk than anti-tracking (i.e. fixing it doesn't assume a pile of other changes to the web platform). We should also write that more immediate threat model. If someone other than me can volunteer, it'll get done faster.",
          "createdAt": "2019-05-13T21:01:21Z",
          "updatedAt": "2019-05-13T21:02:11Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> Simply sending https://DISTRIBUTOR_TRACKING_ID.distributor.example/publisher.example/article.html.sxg to the publisher with no other information isn't enough, since it doesn't include the publisher's tracking ID.\r\n\r\nI'm not sure that analysis is correct. When the SXG is loaded, the Publisher's JS will have access to localState and other storage mechanisms, and thus if the Distributor ID is exposed, can link that with the Publisher ID stored in localStorage and link them, right?\r\n\r\nWe talked a little about this in #347, in the context of what information about the content the Distributor can infer, as well as what affects the Distributor can have on the Publisher and how it loads its content.",
          "createdAt": "2019-05-13T22:11:27Z",
          "updatedAt": "2019-05-13T22:11:27Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi I think having the DISTRIBUTOR_TRACKING_ID in the publisher's javascript context is \"with other information\", but I want us to be clear that it's the combination that enables tracking. Maybe browsers that want to prevent identifier correlation can block JS access to the full URL but still send reports to the publisher via credential-less HTTP requests, for example.",
          "createdAt": "2019-05-13T22:27:22Z",
          "updatedAt": "2019-05-13T22:27:22Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Re, linking+tracking: we briefly explored this in the Navigation Timing thread, but I'll reiterate it here as well.. We don't necessarily need to expose the full distributor URL to satisfy some of the [core use cases](https://github.com/w3c/navigation-timing/issues/107) from a publisher's perspective: providing the origin, or even just the eTLD+1 if we're concerned about tracking ID being embedded in the subdomain, is likely good enough.\r\n\r\nIn absence of any signals about the distributor, my fear is that the publishers would simply default to whitelisting a small set of distributors that \"they trust\" \u2014 e.g. trust not to have negative impact on user experience, expect insights from distributors about such page loads in return, etc.",
          "createdAt": "2019-05-17T20:35:07Z",
          "updatedAt": "2019-05-17T20:35:07Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "If https://github.com/WICG/webpackage/issues/430 was resolved in such a way that Publishers had to explicitly allowlist Distributors, would that obviate the need for exposing this information?\r\n\r\nAlternatively, it would seem if https://github.com/WICG/webpackage/issues/430 is not accepted - that is, neither an allowlist nor blocklist is pursued - it would seem that would obviate the Publisher\u2019s ability to place such restrictions, thus reducing the risk of such ossification of Distributors.\r\n\r\nIt\u2019s not clear to me, though, which of these outcomes was being imagined with the remark about lacking signals.",
          "createdAt": "2019-05-17T21:22:59Z",
          "updatedAt": "2019-05-17T21:22:59Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, if the Sender is not colluding / party to the threat, then I think this changes the calclus\r\n\r\nHow does this change the calculus of distributor/publisher being able to correlate tracking IDs? The sender (aka [embedder](https://github.com/WICG/webpackage/blob/master/explainer.md#signed-exchange-loading-sketch)) cannot read or intercept the bytes that the distributor sends to the user. ISTM the distributor could send an unsigned response containing any of the usual tricks, followed by a redirect to the SXG, and the sender couldn't prevent this with static analysis. (Perhaps there's another way the sender could prevent this that I'm not seeing...)",
          "createdAt": "2019-05-19T05:25:54Z",
          "updatedAt": "2019-05-19T05:29:36Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> How does this change the calculus of distributor/publisher being able to correlate tracking IDs?\r\n\r\nApologies, as I suppose my example could have been clearer. I was trying to highlight that there are more risks than 'just' tracking IDs, and this adds to the security and privacy complexity.\r\n\r\nThe Sender may not wish for the Publisher to learn about what the user is doing on the Sender. This is similar to, but distinct from, the User Privacy case; I think that many of their mitigations end up looking similar, but there are cases where the User may be fine with the information leakage, but the Sender not, and vice-versa, which is why I tried to enumerate them as separate in the considerations.\r\n\r\nBasically, I'm trying to treat all of this from the lens of side-channels. Functionally, the Distributor gets to be the 'last mile' to the user for Publisher's content. This can be seen in some of the motivations for the [RUM use-case](https://github.com/w3c/navigation-timing/issues/107). However, SXGs allow both the Sender and Distributor to look into what Publisher is sending, and further, be able to influence how that information is loaded. This can lead to accidental or intentional side channels (like those in #347 ) that allow the Sender/Distributor to learn not just about Publisher's content, but about the User's state at Publisher.\r\n\r\nFrom the perspective of URLs, I'm trying to work through cases where the User or Sender may not want the Publisher to know about the URL they're viewing (or that of the Distributor's), and then see if and how we can balance those cases against the desire for the Publisher to control the Distributor (as in #430 )",
          "createdAt": "2019-05-20T05:46:55Z",
          "updatedAt": "2019-05-20T05:46:55Z"
        }
      ]
    },
    {
      "number": 434,
      "id": "MDU6SXNzdWU0NDQ1MTczNzQ=",
      "title": "Spec makes it difficult to distinguish signed and unsigned parameters",
      "url": "https://github.com/WICG/webpackage/issues/434",
      "state": "OPEN",
      "author": "sleevi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The [`Signature` header](https://github.com/WICG/webpackage/blob/7aef9b9bd97ab3ea432f4cec22cc7020267f7c29/draft-yasskin-http-origin-signed-responses.md#the-signature-header--signature-header) makes use of Structured Headers to encapsulate a number of parameters.\r\n\r\nHowever, the structural layout of the specification makes it difficult to easily determine what parameters are signed and unsigned. Through a careful reading, it would appear that only `cert-url` is unsigned.\r\n\r\nThis came up when trying to evaluate the proposal in #397 to understand the assurance level of different fields, at different points within the algorithm. For example, the current algorithm for [validating a signature](https://github.com/WICG/webpackage/blob/7aef9b9bd97ab3ea432f4cec22cc7020267f7c29/loading.bs#L775) would appear to be making use of a signed field before the signature has actually been verified.\r\n\r\nA few thoughts come to mind to help simplify this:\r\n- In the discussion of the parameters that participate in the signature, clearly indicate whether each parameter is covered by the 'sig' or not.\r\n- In the discussion of validation algorithms, either\r\n  1. Ensure that signature validation is consistently performed before any accesses to unvalidated data\r\n  1. Use descriptive labels to indicate the level of assurance that each field as. For example, `unverified-validityUrl` becomes `signed-validityUrl` after the signature has been checked, while `integrity` becomes `unverified-integrity`, transitions to `signed-integrity` after signature validation, and becomes `verified-integrity` after the (certificate and revocation) checks.\r\n\r\nThe idea here is to try to encapsulate, in the spec, the state machine that each of these variables goes through, so that it's clear whether we're operating on 'untrusted' (not yet signature checked / certificate checked) data or after. While an implementation may simply use the same variable throughout the implementation, the annotations help highlight the assurance. This also helps for future spec changes, because any reordering of sequences would cascade into re-evaluating the labels for any variables.\r\n\r\nOr this might all be a terrible idea, but it was definitely hard to read and reason about the algorithm without knowing clearly whether the variables were signed and when/if they'd been validated.",
      "createdAt": "2019-05-15T15:53:37Z",
      "updatedAt": "2019-05-15T15:53:37Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 435,
      "id": "MDU6SXNzdWU0NDU1MTcwMzA=",
      "title": "Content-Type version identifier, should it be case-sensitive?",
      "url": "https://github.com/WICG/webpackage/issues/435",
      "state": "CLOSED",
      "author": "Gregable",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For a server returning a signed exchange, the content type will be something like:\r\n\r\n```\r\ncontent-type: application/signed-exchange;v=b3\r\n```\r\n\r\nAs per https://www.w3.org/Protocols/rfc1341/4_Content-Type.html, the `application/signed-exchange` and `v` parts of this are case-insensitive, whereas the `b3` part (parameter value) is not well defined in the RFC:\r\n\r\n> Parameter values are normally case sensitive, but certain parameters are interpreted to be case- insensitive, depending on the intended use.\r\n\r\nI don't see anything explicit in the Signed Exchange spec about the case-sensitivity of the parameter value. Should we call this out explicitly?\r\n\r\nIt's a small point, but I would also suggest that it seems a little error-prone to have this entire string be case-insensitive except for one character (the `b`). Perhaps we should define the version identifier to also be case-insensitive for consistency. Thoughts?",
      "createdAt": "2019-05-17T16:13:18Z",
      "updatedAt": "2019-07-01T22:21:39Z",
      "closedAt": "2019-07-01T22:21:39Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The Signed Exchange spec does give an ABNF for the parameter value of `DIGIT/%x61-7A` (should be `1*(DIGIT/%x61-7A)`), i.e. only lowercase ASCII letters.\r\n\r\nI'm not certain that's the right behavior, but I'm inclined to keep it since it limits unnecessary variation in server behavior.\r\n",
          "createdAt": "2019-07-01T22:21:39Z",
          "updatedAt": "2019-07-01T22:21:39Z"
        }
      ]
    },
    {
      "number": 436,
      "id": "MDU6SXNzdWU0NDU4NjA3MjU=",
      "title": "Could an SXG cache know how long you \"lingered\" on a page it served?",
      "url": "https://github.com/WICG/webpackage/issues/436",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The thread at https://twitter.com/colinbendell/status/1129040437929492480 describes this attack. If the cache serves an SXG to the user, but leaves the connection open. According to the thread, this would allow it to learn the time until the user unloaded that document (e.g. clicked a link, closed the tab, etc.). Is this possible given the current spec / implementation snapshot? If so, is there a way to mitigate it?",
      "createdAt": "2019-05-19T20:28:21Z",
      "updatedAt": "2019-05-21T00:57:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This *might* work, depending on how browsers decide to close hung or very-slow connections. If it works for signed exchanges, it probably also works for subresources, although that's a less serious problem since the main page at least has to opt into any subresource origins being able to learn this information.\r\n\r\nThe mitigation would probably be to have browsers leave hung connections open until some timeout, whether or not the page depending on that connection unloads during the timeout.",
          "createdAt": "2019-05-21T00:22:38Z",
          "updatedAt": "2019-05-21T00:22:38Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed re: subresources.\r\n\r\nThat mitigation helps guard against attackers interested in short stay durations. To guard against attackers interested in long stay durations, perhaps SXG could have that hung-connection timeout be relatively short, and apply to all open connections (effectively `Connection: close` if there are no pending prefetches). Though the former would negatively affect users with bad connections.\r\n\r\nIs this outside the scope of the spec and its dependencies? If I find it's possible, should I open a bug against the Chromium implementation instead?",
          "createdAt": "2019-05-21T00:46:34Z",
          "updatedAt": "2019-05-21T00:51:49Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I don\u2019t think Connection: Close will have the desired semantics, especially\nin the case of HTTP/2. And I\u2019m a bit apprehensive of having to change the\nfundamental networking implementation to accommodate if a connection has\nbeen tainted by an SXG loss - that sort of complexity discourages\nimplementation. Browser stacks don\u2019t have anything like that, even for slow\nconnections.\n\nAre there other options or ideas worth exploring?\n",
          "createdAt": "2019-05-21T00:57:51Z",
          "updatedAt": "2019-05-21T00:57:51Z"
        }
      ]
    },
    {
      "number": 438,
      "id": "MDU6SXNzdWU0NTAwNTUzODk=",
      "title": "bundle tool install error",
      "url": "https://github.com/WICG/webpackage/issues/438",
      "state": "CLOSED",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [
        "irori"
      ],
      "labels": [],
      "body": "The signedexchange tools installed easily, but I get an error trying to install the bundle tools: \r\n\r\n```\r\n$ go get -u github.com/WICG/webpackage/go/bundle/cmd/...\r\npackage github.com/influxdata/influxdb/client/v2: cannot find package \"github.com/influxdata/influxdb/client/v2\" in any of:\r\n\t/usr/local/go/src/github.com/influxdata/influxdb/client/v2 (from $GOROOT)\r\n\t/Users/cramerd/go/src/github.com/influxdata/influxdb/client/v2 (from $GOPATH)\r\n\r\n```\r\nGoing to https://github.com/influxdata/influxdb finds:\r\n\r\n> If you are looking for the InfluxDB 1.x Go Client, we've created a new [repo](https://github.com/influxdata/influxdb1-client) for that. \r\n",
      "createdAt": "2019-05-29T22:56:36Z",
      "updatedAt": "2019-05-30T19:49:01Z",
      "closedAt": "2019-05-30T19:49:00Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. https://github.com/mrichman/hargo/pull/12 should fix this.",
          "createdAt": "2019-05-30T02:31:57Z",
          "updatedAt": "2019-05-30T02:31:57Z"
        },
        {
          "author": "dauwhe",
          "authorAssociation": "NONE",
          "body": "It works! Thanks!",
          "createdAt": "2019-05-30T19:49:00Z",
          "updatedAt": "2019-05-30T19:49:00Z"
        }
      ]
    },
    {
      "number": 441,
      "id": "MDU6SXNzdWU0NTQ2NDAwODE=",
      "title": "dump-signedexchange: command not found",
      "url": "https://github.com/WICG/webpackage/issues/441",
      "state": "CLOSED",
      "author": "prash-mi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I am trying to install 'dump-signedexchange' on Linux (Debian) and Mac(v10.14) running go 1.12.5, using this command:\r\n\r\n`go get -u github.com/WICG/webpackage/go/signedexchange/cmd/...`\r\n\r\nbut its simply exiting with no output on the console: \r\n\r\n```\r\n$ go get -u github.com/WICG/webpackage/go/signedexchange/cmd/...\r\n$ dump-signedexchange\r\nbash: dump-signedexchange: command not found\r\n```\r\n\r\nIs there an alternate way to install it?\r\n\r\n\r\n",
      "createdAt": "2019-06-11T11:42:22Z",
      "updatedAt": "2019-06-20T04:57:55Z",
      "closedAt": "2019-06-20T04:57:55Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "`go get` installs the binaries at `$HOME/go/bin` by default :)",
          "createdAt": "2019-06-11T15:33:09Z",
          "updatedAt": "2019-06-11T15:33:09Z"
        },
        {
          "author": "prash-mi",
          "authorAssociation": "NONE",
          "body": "Thanks @hajimehoshi . (Somehow I was expecting the binary to be available in the $PATH, my bad!)\r\n\r\nOne follow-up, would you know how to use `-verify` with `dump-signedexchange`, the following command is not returning:\r\n`\r\n./dump-signedexchange -verify https://staging.example.com \r\n `\r\n\r\nI want to verify signed exchange on a staging server",
          "createdAt": "2019-06-12T07:13:50Z",
          "updatedAt": "2019-06-12T07:13:50Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "`dump-signedexchange` is not returning because it's waiting for SXG input from stdin. The following command pipe would do the work:\r\n```\r\ncurl https://staging.example.com | dump-signedexchange -verify\r\n```\r\n\r\nOnce https://github.com/WICG/webpackage/pull/429/ is merged, `dump-signedexchange` will accept the `-uri` flag:\r\n```\r\n./dump-signedexchange -verify -uri https://staging.example.com\r\n```",
          "createdAt": "2019-06-12T09:01:54Z",
          "updatedAt": "2019-06-12T09:01:54Z"
        },
        {
          "author": "prash-mi",
          "authorAssociation": "NONE",
          "body": "Thanks for the update @irori . One followp, I tried this command with a couple of URLs with and without signexchange implemented and got the same response, here is the output:\r\n\r\nThis URI has SGX enabled on prod: \r\n`curl -si -H 'amp-cache-transform: google' -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3' https://www.oyorooms.com/hotels-in-delhi/ | dump-signedexchange -verify`\r\nOutput:\r\n`2019/06/14 14:19:25 singedexchange: unknown magic bytes: [72 84 84 80 47 50 32 50]`\r\n\r\nThis URI is not having SGX enabled: \r\n`curl -si -H 'amp-cache-transform: google' -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3' https://mweb-demos.appspot.com | dump-signedexchange -verify`\r\nOutput:\r\n`2019/06/14 14:21:31 singedexchange: unknown magic bytes: [72 84 84 80 47 50 32 50]`\r\n\r\nCan you please let me know that what output is expected when SGX is enabled ?\r\n\r\n",
          "createdAt": "2019-06-14T08:58:41Z",
          "updatedAt": "2019-06-14T08:58:41Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Curl's `-i` option outputs HTTP response headers to the stdout, so `dump-signedexchange` tries to parse it as SXG format (`[72,84,84,80,47,50,32,50]` == \"HTTP/2 2\" in ASCII).\r\n\r\nNow https://github.com/WICG/webpackage/pull/429 is merged, you can use `dump-signedexchange` with the `-uri` flag:\r\n\r\n```\r\n$ dump-signedexchange -requestHeader 'amp-cache-transform: google' -uri https://www.oyorooms.com/hotels-in-delhi/ -verify -payload=false\r\n\r\nformat version: 1b3\r\nrequest:\r\n  method: GET\r\n  uri: https://www.oyorooms.com/hotels-in-delhi/\r\n  headers:\r\nresponse:\r\n  status: 200\r\n  headers:\r\n    Content-Encoding: mi-sha256-03\r\n...\r\n```\r\n",
          "createdAt": "2019-06-19T04:22:24Z",
          "updatedAt": "2019-06-19T04:22:24Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, but feel free to add comments if you have further questions.",
          "createdAt": "2019-06-20T04:57:55Z",
          "updatedAt": "2019-06-20T04:57:55Z"
        }
      ]
    },
    {
      "number": 442,
      "id": "MDU6SXNzdWU0NTUwMTA5NTg=",
      "title": "Can parameterised identifiers in Signature header have extra parameter?",
      "url": "https://github.com/WICG/webpackage/issues/442",
      "state": "OPEN",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "According to https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-header, each parameterised identifier MUST have parameters 'sig', 'integirty', and so on. Then is it okay for them to contain other parameters not referred as 'necessary' in the spec?",
      "createdAt": "2019-06-12T04:52:42Z",
      "updatedAt": "2019-06-27T21:55:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The spec currently says it's allowed.\r\n\r\nAnother reasonable point in the design space would be to say that a particular parameterised identifier from the list is only valid in this version of the specification if it has exactly the set of parameters required or explicitly allowed in this version of the spec. Then future evolution could work by adding extra elements to the list instead of adding extra parameters to elements that might be interpreted by old implementations.\r\n\r\nThe current design for evolving the spec, which is currently only implemented as the `application/signed-exchange` format, is to increment the overall version number and rely on content negotiation to pick the right file, which doesn't need an extension point here at all. However, there's some interest in making the format a little more extensible than that, so we should come back to this when we think that through.",
          "createdAt": "2019-06-27T21:55:33Z",
          "updatedAt": "2019-06-27T21:55:33Z"
        }
      ]
    },
    {
      "number": 445,
      "id": "MDU6SXNzdWU0NTcyNjIzNzI=",
      "title": "Content-Type requirement for bundled responses",
      "url": "https://github.com/WICG/webpackage/issues/445",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#load-response\r\n\r\n> 9. If headers does not contain a Content-Type header, return an error.\r\n>\r\n>    The client MUST interpret the following payload as this specified media type instead of trying to sniff a media type from the bytes of the payload, for example by appending an artificial X-Content-Type-Options: nosniff header field ([FETCH]) to headers.\r\n\r\nShould we require `Content-Type` for 3xx redirection responses that don't have response body?\r\n\r\n",
      "createdAt": "2019-06-18T05:02:57Z",
      "updatedAt": "2019-08-09T18:37:41Z",
      "closedAt": "2019-08-09T18:37:41Z",
      "comments": []
    },
    {
      "number": 446,
      "id": "MDU6SXNzdWU0NTkzNDI3MjY=",
      "title": "Bundle parsing algorithm doesn't describe when to apply critical section",
      "url": "https://github.com/WICG/webpackage/issues/446",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 3.3.3, parsing the critical section, is only referenced in 3.1, which is non-normative, and 6.2, which is just some registry bits. However, if I'm understanding this right, webbundle parsers *today* need to correctly handle it. Otherwise, critical sections defined in the future won't work properly. Should section 3.3 include it?\r\n\r\nRelatedly, given how critical (hah) it is, maybe it makes sense to put it in section-lengths, and have it be 3-tuples of name, length, boolean. That saves parsers an extra seek and read.",
      "createdAt": "2019-06-21T19:32:01Z",
      "updatedAt": "2019-06-21T19:45:56Z",
      "closedAt": "2019-06-21T19:45:56Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I see. It's parsed as part of step 17.6 when you process all the metadata sections.",
          "createdAt": "2019-06-21T19:45:56Z",
          "updatedAt": "2019-06-21T19:45:56Z"
        }
      ]
    },
    {
      "number": 449,
      "id": "MDU6SXNzdWU0NjM4OTM5NzY=",
      "title": "Expose signing date to Javascript",
      "url": "https://github.com/WICG/webpackage/issues/449",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "While a publisher could manually incorporate the signing time into the content of their signed package, it would be easier for libraries to use that time, for example to [check that content isn't \"too old\"](https://github.com/WICG/webpackage/issues/376), if there were a standard place to look for it.\r\n\r\nFor signed exchanges, we could put it into the `Document`, for example `document.package.signedAt`. However:\r\n\r\n1. A signed exchange can have multiple signatures with different signing times. The most important one is the one that establishes cross-origin trust, but libraries might want to be able to see other signatures.\r\n1. We also want to be able to see the signing time for members of bundles, which might work better as a field in the [`Response`](https://fetch.spec.whatwg.org/#concept-response), and then we might refer to the Response or the relevant fields from any Document [initialised from it](https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object)...\r\n1. This might be a concept we should expose for other cached things, in which case the place we expose it should make sense for non-packaged things. At that point, would we just expose the `Date` HTTP header? The signing time(s) could be different from the `Date`, so we might want to expose both anyway.",
      "createdAt": "2019-07-03T18:24:51Z",
      "updatedAt": "2019-07-03T18:41:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I'd like to avoid exposing this, for now.\r\n\r\nAs you note, there isn't a notion of a single signing date, but there may be multiple. It's also important the the signing dates may change over time as content is resigned, but the 'logical' date of the content, if you will, may not have changed. That is, if I append a signature, is it refreshing the lifetime of the data?\r\n\r\nOther signing solutions make sure to treat these elements as distinct; even counter-signature schemes like timestamping schemes treat signing and timestamping independently.\r\n\r\nFrom an [Extensible Web Manifesto](https://github.com/extensibleweb/manifesto) perspective, it seems like SXG and Bundles provide all the necessary building blocks to explore a variety of solutions. Further, as you note, the 'Date' header may be sufficient in the future, or may be generally applicable even to content from the disk cache.\r\n\r\nBy avoiding prematurely standardizing it, we ensure that there are not implicit or explicit dependencies, by 'things-that-are-packaged', on 'how-they-are-packaged'. For example, I want to avoid a situation where moving from one signature to many signatures complicates the API, or if a trusted timestamping service would be introduced, where there are multiple notions of 'signing date'. The less we expose, the better, and authors have the flexibility to explore the paths with their cows for the platform to later standardize :)",
          "createdAt": "2019-07-03T18:41:44Z",
          "updatedAt": "2019-07-03T18:41:44Z"
        }
      ]
    },
    {
      "number": 462,
      "id": "MDU6SXNzdWU0Njk4OTEwMDI=",
      "title": "dump-certurl and dump-signedexchange do not verify the dates of OCSP response",
      "url": "https://github.com/WICG/webpackage/issues/462",
      "state": "OPEN",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When `NextUpdate` is in the past, signed exchanges are invalid. `dump-certurl` and `dump-signedexchange` do not currently check these dates -- they should.",
      "createdAt": "2019-07-18T17:15:37Z",
      "updatedAt": "2019-07-18T17:15:37Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 463,
      "id": "MDU6SXNzdWU0NzExNjUxODc=",
      "title": "Document how the web relies on transport security",
      "url": "https://github.com/WICG/webpackage/issues/463",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "At IETF105, @DKG explained a worry that I think several people have: The web's only current security system is based on proving that the transport channel is connected to an appropriate endpoint. Signed Web Packages try to replace that with object security, proof that the right person signed the resource at some time. Since the web is big, it's hard to be confident that we're not going to break anything by making that change.\r\n\r\nSo, we should try to make a complete list of how the web tries to be secure, describe how those attempts rely on transport security, and describe how that's affected by a switch to object security.",
      "createdAt": "2019-07-22T15:38:46Z",
      "updatedAt": "2019-07-22T15:38:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 465,
      "id": "MDU6SXNzdWU0NzE4MzA3NTM=",
      "title": "Write a Human Rights Considerations section",
      "url": "https://github.com/WICG/webpackage/issues/465",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "The first step is to answer the rough questionnaire at https://tools.ietf.org/html/draft-irtf-hrpc-guidelines-03.",
      "createdAt": "2019-07-23T17:31:21Z",
      "updatedAt": "2019-07-23T17:31:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 468,
      "id": "MDU6SXNzdWU0NzMxMzc3ODE=",
      "title": "Clarify what URL schemes are allowed in Bundled Exchanges",
      "url": "https://github.com/WICG/webpackage/issues/468",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "Current bundle spec says that [Bundled Exchanges parser must fail if URL have a fragment or credentials](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#index-section), but says nothing about the URL scheme.\r\n\r\nIn Signed Exchange, [exchange's URL must be `https:`](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#application-signed-exchange). Sould Bundled Exchanges follow this, or should also allow `http:`? Since exchange is defined as HTTP request+response pair, I think non-http(s) schemes don't make sense.\r\n",
      "createdAt": "2019-07-26T01:42:32Z",
      "updatedAt": "2020-01-29T04:49:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Especially for books, there's some use for the [`cid:`](https://tools.ietf.org/html/rfc2392) scheme for things that exist within the package but aren't reachable with an HTTP lookup. I haven't thought through all the details of which schemes actually work.\r\n\r\nWe could restrict bundle resource URLs to http(s) anyway and loosen that when we get a more concrete use case, or we could restrict them just in the browser-side loading spec for now. I don't have a strong preference here.",
          "createdAt": "2019-08-09T00:40:28Z",
          "updatedAt": "2019-08-09T00:40:28Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it. For now, I'm going to restrict them to http(s) in Chromium implementation.\r\n\r\n> We could restrict bundle resource URLs to http(s) anyway and loosen that when we get a more concrete use case, or we could restrict them just in the browser-side loading spec for now. I don't have a strong preference here.\r\n\r\nI don't have a preference either.\r\n",
          "createdAt": "2019-08-16T05:04:57Z",
          "updatedAt": "2019-08-16T05:04:57Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm trying to implement \"Save page as Web Bundle\" feature in Chromium (https://crbug.com/1040752). This feature will provide users with a way to save the selialized current page as a Web Bundle file. This will behave almost same as the existing \"Save page as MHTML\" feature.\r\n\r\nFor serializing a page, we want to use the `cid:` scheme for two purposes.\r\n\r\n1. URL for subframes:\r\n   - We can\u2019t use the original URL of subframe, because there may be the same URL subframes which contents are different when they are serialized. And also inline iframe `<iframe srcdoc=\u201d...\u201d>` doesn\u2019t have a URL. So we need `cid:` scheme for it.\r\n   - See this doc https://goo.gl/GYT7Br#heading=h.jb2ehfs7vtcw about how Chromium handles iframes while generating MHTML. \r\n\r\n1. Style elements\r\n   - Chrome also uses `cid:` scheme for stlye element while generating MHTML.\r\n   - See this doc https://goo.gl/GYT7Br#heading=h.1mjt2ly8g7u about how Chromium handles style elements while generating MHTML. \r\n   - Even if we can't use `cid:` scheme for Web Bundles, we can just put the serialized CSS text into the style elemnts. But if we can use `cid:` scheme, we can reuse the existing logic for MHTML.\r\n",
          "createdAt": "2020-01-28T01:59:27Z",
          "updatedAt": "2020-01-28T01:59:27Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Having endorsed `cid:` [before](https://github.com/WICG/webpackage/issues/468#issuecomment-519735907), I'm now nervous about using it for this, as its [definition](https://tools.ietf.org/html/rfc2392) is very tied to MIME, which packages aren't. That said, it'll probably work fine.\r\n\r\nI *think* we could use a [`urn:uuid:` URI](https://tools.ietf.org/html/rfc4122) for this purpose. Even if y'all go with `cid:` now to re-use the MHTML code paths, please try to architect it so that we could switch as the standardization process proceeds.",
          "createdAt": "2020-01-28T21:43:41Z",
          "updatedAt": "2020-01-28T21:43:41Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Using `urn:uuid:` URI sounds good.\r\nWe need to slightly change the serialization logic, but it is possible to implement.\r\n",
          "createdAt": "2020-01-29T04:49:44Z",
          "updatedAt": "2020-01-29T04:49:44Z"
        }
      ]
    },
    {
      "number": 469,
      "id": "MDU6SXNzdWU0NzMxNzMzMDI=",
      "title": "Requirements of bundle's primaryUrl",
      "url": "https://github.com/WICG/webpackage/issues/469",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges",
        "needs spec"
      ],
      "body": "[Section 2.2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#semantics-load-metadata) of Bundled Exchanges spec says:\r\n\r\n> primaryUrl  The URL of the main resource in the bundle.\r\n\r\nDoes this mean that the bundle's index section must have an entry for `primaryUrl`? If so, \"Parsing the index section\" section should check that condition.\r\n(Also, that would imply that requirements of exchange URLs are applied to `primaryUrl` too.)",
      "createdAt": "2019-07-26T04:36:22Z",
      "updatedAt": "2019-08-16T22:58:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think it's plausible to consider bundles that don't include their primary URL, and are just used to serve its subresources, but that's a little weird, so I'm happy to ban it for now.",
          "createdAt": "2019-08-09T00:30:24Z",
          "updatedAt": "2019-08-09T00:30:24Z"
        },
        {
          "author": "toyoshim",
          "authorAssociation": "NONE",
          "body": "Exchange URLs have a restriction that it could not contain a fragment part, but how about primaryURL?\r\n\r\nThere may be a case that author want it to point the anchor point in an exchange. But in such case, we will see a conflict if the given bundle's URL also had a fragment part (*1), and it's unclear what is the right URL to navigate. Probably it's fine to have the same restriction to disallow fragment parts unless someone find an important use-case.\r\n\r\n(*1) an example:\r\nWhen a user navigate to https://www.example.com/example.wbn#first_section, primaryUrl may be https://www.example.com/primary_url#overview.",
          "createdAt": "2019-08-16T08:15:00Z",
          "updatedAt": "2019-08-16T08:15:00Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think we should ban fragments in the primaryURL.",
          "createdAt": "2019-08-16T22:58:38Z",
          "updatedAt": "2019-08-16T22:58:38Z"
        }
      ]
    },
    {
      "number": 470,
      "id": "MDU6SXNzdWU0NzM0NDU3NDY=",
      "title": "Extend Accept-Signature to include app/s-e response type",
      "url": "https://github.com/WICG/webpackage/issues/470",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "[The Accept-Signature header](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#accept-signature) says:\r\n\r\n> When a server receives an `Accept-Signature` header field in a client request, it SHOULD reply with any available `Signature` header fields for its response that the `Accept-Signature` header field indicates the client supports.\r\n\r\nHowever, the same-origin `Signature` response may be less reliable than `application/signed-exchange`, due to possible undesired transformations of signed data (headers or payload). Consider modifying this section to say that a server MAY reply with an `application/signed-exchange` instead.",
      "createdAt": "2019-07-26T16:44:12Z",
      "updatedAt": "2019-08-16T22:59:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "That sounds like a good change.",
          "createdAt": "2019-08-16T22:59:32Z",
          "updatedAt": "2019-08-16T22:59:32Z"
        }
      ]
    },
    {
      "number": 471,
      "id": "MDU6SXNzdWU0NzM0NDgwNjA=",
      "title": "Consider removing or generalizing Accept-Signature identifiers",
      "url": "https://github.com/WICG/webpackage/issues/471",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Once https://github.com/WICG/webpackage/issues/187 is fixed, the signaling of requested algorithms may be redundant, or worse, ossifying.\r\n\r\nIt's not clear to me if some signaling may still be useful e.g. whether this is meant for SRI or top-level. Is there harm in the server sending all signatures in all cases?",
      "createdAt": "2019-07-26T16:50:44Z",
      "updatedAt": "2019-07-26T16:50:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 472,
      "id": "MDU6SXNzdWU0NzM5NTU0MTM=",
      "title": "Signature Validation of Bundled Exchanges",
      "url": "https://github.com/WICG/webpackage/issues/472",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bundled Exchanges spec [defines the format of signature section](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#signatures-section) but doesn't define how to validate it.\r\n\r\nI can imagine how validation works; To validate `(authority, sig, signed)` triple in `vouched-subsets`, a client would run an algorithm similar to the [SXG's Signature validity](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity) but its entities replaced as follows:\r\n\r\n- `requestUrl` -> `signed.subset-hashes` which includes `whatwg-url`\r\n- `responseHeaders` -> `signed.subset-hashes` which includes `header-sha256`\r\n- `payload` -> `payload` in the responses section\r\n- `signature` -> `sig`\r\n- `integrity` -> `payload-integrity-header` included in `signed.subset-hashes`\r\n- `validity-url` -> `signed.validity-url`\r\n- `cert-sha256` -> `signed.auth-sha256`\r\n- `date` -> `signed.date`\r\n- `expires` -> `signed.expires`\r\n- `certificate-chain` -> `authorities`\r\n- `main-certificate` -> `authorities[authority]`\r\n\r\nDoes this align with your idea? @jyasskin\r\n\r\nQuestions:\r\n\r\n- Will signing message be the `signed` binary string itself? It doesn't have the 64-spaces padding nor a context string.\r\n- What's the content of resource at `validity-url`?\r\n- Do the requirements of SXG headers (e.g. no uncached fields) apply to BXG too? Response headers are not included in bundle's metadata, so it'd have to be checked in a later step of loading (it wouldn't be a big deal though).\r\n- What about the certificate requirements?\r\n- Is it possible to unify the algorithm to SXG's validation algorithm? It would make implementation simpler.\r\n",
      "createdAt": "2019-07-29T09:47:51Z",
      "updatedAt": "2019-08-29T07:58:56Z",
      "closedAt": "2019-08-29T07:58:56Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "In general, bundle signature checking should happen before the `signed` `bstr` is parsed into fields. Then a resource gets checked against the `subset-hashes` as it's being loaded. Looking at https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#load-response, I need to change that to check the `headers` `bstr` against the `header-sha256` before parsing it.\r\n\r\n1. To check a TLS-like X.509 certificate's signature, I believe the message needs to be the concatenation of:\r\n   1. A string that consists of octet 32 (0x20) repeated 64 times.\r\n   1. A context string: the ASCII encoding of \"Web Package 1\". (\"Web Package 1 b1\" for the b1 implementation version.)\r\n   1. A single 0 byte which serves as a separator.\r\n   1. The `signed` `bstr`.\r\n\r\n   For non-X.509 authorities, I think we don't really need that prefix, but I'm not sure if we should keep it just to keep everything uniform.\r\n\r\n1. I haven't worked out what the `validity-url` will point to yet. I think it may be the same as in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#updating-validity with the `signatures` field's value changed from `[ + bytes ]` to the `signatures` CDDL rule from https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#signatures-section.\r\n\r\n1. Yes, the restrictions on headers will need to be processed while loading the resource, rather than while parsing the metadata. I think the same set of \r\n\r\n1. Also the same certificate requirements as SXG for cross-origin trust.\r\n\r\n1. If we want to unify Signed Exchange signature checking with Bundle signature checking, I'd push for changing the SXG `Signature` string (\"sigLength bytes holding the Signature header field\u2019s value\" from https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#application-signed-exchange) into a format where the signed data can also be checked before it's parsed.",
          "createdAt": "2019-08-09T22:10:36Z",
          "updatedAt": "2019-08-09T22:10:36Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I'm working on a bundle signing tool based on this information. ([WIP code here](https://github.com/irori/webpackage/tree/sign-bundle))\r\n\r\nTwo additional questions:\r\n\r\n- Is `payload-integrity-header` the same format as the SXG signature's `integrity` parameter (like \"digest/mi-sha256-03\")?\r\n- Is `auth-sha256` the hash of the DER-encoded X.509v3 certificate (that matches SXG's `cert-sha256`), or the hash of the `authority` (= `augmented-certificate`) CBOR item?\r\n",
          "createdAt": "2019-08-15T06:25:05Z",
          "updatedAt": "2019-08-15T06:25:05Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "1. My intent is that `payload-integrity-header` is the same format as the SXG signature's `integrity` parameter.\r\n1. My intent is that `auth-sha256` is the hash of the same bytes as the SXG's `cert-sha256`. I think there's a possibility that both of those will change, but  I think they'll change together if they do.",
          "createdAt": "2019-08-16T22:22:18Z",
          "updatedAt": "2019-08-16T22:22:18Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Now we have signature generation / verification implementation in the Go tools (#490 #493).",
          "createdAt": "2019-08-29T07:58:55Z",
          "updatedAt": "2019-08-29T07:58:55Z"
        }
      ]
    },
    {
      "number": 473,
      "id": "MDU6SXNzdWU0NzQwMTg2NzI=",
      "title": "Certificate verification error ERR_CERT_AUTHORITY_INVALID",
      "url": "https://github.com/WICG/webpackage/issues/473",
      "state": "CLOSED",
      "author": "iesiyok",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi there,\r\n\r\nI am doing the same instructions here https://github.com/WICG/webpackage/tree/master/go/signedexchange without the trusted signed exhanges.\r\n\r\n```\r\n>echo \"<h1>hi</h1>\" > payload.html\r\n>openssl ecparam -out priv.key -name prime256v1 -genkey\r\n>openssl req -new -sha256 -key priv.key -out cert.csr -subj '/CN=localhost/O=Test/C=US'\r\n>openssl x509 -req -days 360 -in cert.csr -signkey priv.key -out cert.pem \\\r\n  -extfile <(echo -e \"1.3.6.1.4.1.11129.2.1.22 = ASN1:NULL\\nsubjectAltName=DNS:localhost\")\r\n>gen-certurl -pem cert.pem -ocsp <(echo ocsp) > cert.cbor\r\n>gen-signedexchange \\\r\n  -uri https://localhost:1447/welcome/hello.html \\\r\n  -content ./payload.html \\\r\n  -certificate cert.pem \\\r\n  -privateKey priv.key \\\r\n  -certUrl https://issuer.org.dev:1448/cert.cbor \\\r\n  -validityUrl https://localhost:1447/resource.validity.msg \\\r\n  -o payload.sxg\r\n```\r\n\r\nI am using nginx:\r\n>vim nginx.conf\r\n```\r\nserver {\r\n      listen 1448 ssl;\r\n      server_name issuer.org.dev;\r\n       ssl_certificate      cert_ca/sites/issuer/dev.issuer.org.crt;\r\n       ssl_certificate_key  cert_ca/sites/issuer/dev.issuer.org.key;\r\n       ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n       ssl_prefer_server_ciphers  on;\r\n       ssl_ciphers  ECDH+AESGCM:ECDH+AES256:ECDH+AES128:DH+3DES:!ADH:!AECDH:!MD5;\r\n       ssl_dhparam cert/dhparam.pem;\r\n       ssl_session_cache   shared:SSL:40m; #40M size of cache\r\n       ssl_session_timeout 2h; #2 hours\r\n       ssl_session_tickets on;\r\n      root /usr/local/etc/openresty/cert_ca/sites/webserver/v2;\r\n      location /cert.cbor {\r\n       \r\n      }\r\n\r\n      location /payload.sxg {\r\n\r\n        add_header Cache-Control \"no-transform\";\r\n        add_header X-Content-Type-Options \"nosniff\";\r\n\r\n      }\r\n    }\r\n\r\n```\r\n\r\n>curl -k -i https://issuer.org.dev:1448/payload.sxg           \r\n```\r\nHTTP/1.1 200 OK\r\nServer: openresty/1.15.8.1\r\nDate: Mon, 29 Jul 2019 12:09:39 GMT\r\nContent-Type: application/signed-exchange;v=b3\r\nContent-Length: 570\r\nLast-Modified: Mon, 29 Jul 2019 11:55:26 GMT\r\nConnection: keep-alive\r\nETag: \"5d3edeae-23a\"\r\nCache-Control: no-transform\r\nX-Content-Type-Options: nosniff\r\nAccept-Ranges: bytes\r\nWarning: Binary output can mess up your terminal. Use \"--output -\" to tell \r\nWarning: curl to output it to your terminal anyway, or consider \"--output \r\nWarning: <FILE>\" to save to a file.\r\n```\r\n\r\n>curl -k -i https://issuer.org.dev:1448/cert.cbor  \r\n```\r\nHTTP/1.1 200 OK\r\nServer: openresty/1.15.8.1\r\nDate: Mon, 29 Jul 2019 12:10:34 GMT\r\nContent-Type: application/cert-chain+cbor\r\nContent-Length: 419\r\nLast-Modified: Mon, 29 Jul 2019 11:54:48 GMT\r\nConnection: keep-alive\r\nETag: \"5d3ede88-1a3\"\r\nAccept-Ranges: bytes\r\nWarning: Binary output can mess up your terminal. Use \"--output -\" to tell \r\nWarning: curl to output it to your terminal anyway, or consider \"--output \r\nWarning: <FILE>\" to save to a file.\r\n```\r\n\r\n\r\n```\r\n>vim a.html\r\n<html>\r\n<head>\r\n\t<link rel=\"prefetch\" href=\"https://issuer.org.dev:1448/payload.sxg\" >\r\n</head>\r\n<body>\r\n</body>\r\n</html>\r\n```\r\n\r\n>`google-chrome a.html --args --user_data_dir=/dev/null Support/Google/Chrome/Default --ignore-certificate-errors-spki-list=`openssl x509 -noout -pubkey -in cert.pem | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64` --enable-features=SignedHTTPExchange`\r\n\r\n>The page is empty and inspect gives two errors like the following:\r\n\r\n**Certificate verification error: ERR_CERT_AUTHORITY_INVALID\r\nFailed to load resource: net::ERR_INVALID_SIGNED_EXCHANGE**\r\n\r\nWhat could I do to solve this?\r\n",
      "createdAt": "2019-07-29T12:17:53Z",
      "updatedAt": "2019-08-02T08:54:53Z",
      "closedAt": "2019-08-02T08:54:53Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "ERR_CERT_AUTHORITY_INVALID error suggests that `--ignore-certificate-errors-spki-list` flag is not working as intended.\r\n\r\nWhen you launched `google-chrome`, did you see an infobar saying \"You are using unsupported command-line flag: --ignore-certificate-errors-spki-list=<base64 value>. Stability and security will suffer.\" ? If not, try again after closing all other Google Chrome windows.\r\n",
          "createdAt": "2019-07-30T08:28:27Z",
          "updatedAt": "2019-07-30T08:28:27Z"
        },
        {
          "author": "iesiyok",
          "authorAssociation": "NONE",
          "body": "Thank you very much for your support.\r\n\r\nI exactly see the infobar saying \"You are using unsupported command-line flag: --ignore-certificate-errors-spki-list=. Stability and security will suffer.\"\r\n\r\nI couldn't find anything about this problem,",
          "createdAt": "2019-07-30T09:24:36Z",
          "updatedAt": "2019-07-30T09:24:36Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to confirm, the infobar showed some base64 encoded string after `--ignore-certificate-errors-spki-list=`, right?\r\n\r\nIf not, just run\r\n```\r\nopenssl x509 -noout -pubkey -in cert.pem | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64\r\n```\r\nand see what happens.",
          "createdAt": "2019-07-30T09:51:55Z",
          "updatedAt": "2019-07-30T09:51:55Z"
        },
        {
          "author": "iesiyok",
          "authorAssociation": "NONE",
          "body": "No, it shows the base64 \r\n\r\nYou are using unsupported command-line flag: --ignore-certificate-errors-spki-list=Elmufwo55170Htld8S5/7ffozDOe9khQzoxDqfltY2I=.  Stability and security will suffer.\r\n\r\nBut, the inspect doesn't show any warnings any more, \r\nI believe it's working now even though there is this unsupported command-line flag.\r\n\r\nThank you very much for your support.",
          "createdAt": "2019-07-30T10:31:06Z",
          "updatedAt": "2019-07-30T10:37:14Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "I wonder if the problem is `--user_data_dir=/dev/null`; try putting an empty directory there.",
          "createdAt": "2019-07-30T15:35:53Z",
          "updatedAt": "2019-07-30T15:35:53Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, that should be `user-data-dir` with dashes not underscores.",
          "createdAt": "2019-07-30T15:36:40Z",
          "updatedAt": "2019-07-30T15:36:40Z"
        },
        {
          "author": "iesiyok",
          "authorAssociation": "NONE",
          "body": "I think it works now, but I couldn't figure out how to use this with link prefetch.\r\nImagine I just have a json file packed with sxg.\r\nIn html header I prefetch it, \r\n<link rel=\"prefetch\" href=\"https://issuer.org.dev:1448/payload.sxg\" >\r\n\r\nin body, I want to use it if its signature is verified.\r\n\r\n$.get( \"https://issuer.org.dev:1448/payload.sxg\", function( data ) {\r\n  console.log( data );\r\n});\r\n\r\nBut it gives me the raw .sxg content:\r\nsxg1-b3\u0000\u0000!https://localhost:1447/hello.html\u0000\u0001W\u0000\u0000\ufffdlabel;cert-sha256=*HrdZMVAqYm+rynoFP3GM89JfKxwqfbTbSPAXG7ysMrU=*;cert-url=\"https://issuer.org.dev:1448/cert.cbor\";date=1564498201;expires=1564501801;integrity=\"digest/mi-sha256-03\";sig=*MEUCIQD/FQBZ9rBybf0c4u0BTK8rheTOgkkjtWmy1xqqkcunYAIgS3GMVx7wJ/5Sn/536+R3GQnslM92SqtCZNfyThwM3oE=*;validity-url=\"https://localhost:1447/resource.validity.msg\"\ufffdFdigestX9mi-sha256-03=KJEdU9urAJP74QIDJW9z7/ehLlmaZmbRdlYb73Nu/3k=G:statusC200Lcontent-typeX\u0018text/html; charset=utf-8Pcontent-encodingLmi-sha256-03\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000{\r\n ...............\r\n\r\nI want to get the json content, are there any events that I can check if the signature verified and I can take the content without the signature and so on?\r\n",
          "createdAt": "2019-07-30T15:41:51Z",
          "updatedAt": "2019-07-30T15:41:51Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "In Chrome, currently signed exchanges cannot be used as XHR targets. It can be used only as main resources, for example:\r\n\r\n```\r\n<head>\r\n<link rel=\"prefetch\" href=\"https://issuer.org.dev:1448/payload.sxg\" >\r\n</head>\r\n<a href=\"https://issuer.org.dev:1448/payload.sxg\">navigate to SXG</a>\r\n```\r\n\r\nThis prefetches a sxg, and if a user clicks the link, navigates to the sxg content (using the prefetched sxg resource).\r\n",
          "createdAt": "2019-07-31T05:22:34Z",
          "updatedAt": "2019-07-31T05:22:34Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, but feel free to add comments if you have further questions.",
          "createdAt": "2019-08-02T08:54:53Z",
          "updatedAt": "2019-08-02T08:54:53Z"
        }
      ]
    },
    {
      "number": 477,
      "id": "MDU6SXNzdWU0NzYyNzA2ODI=",
      "title": "Study tlsnotary.org experience",
      "url": "https://github.com/WICG/webpackage/issues/477",
      "state": "CLOSED",
      "author": "safinaskar",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi. There is a https://tlsnotary.org/ project, which has somewhat similar goal with \"Signed HTTP exchanges\", i. e. an ability to prove that http(s) exchange was performed. But https://tlsnotary.org/ is different in many aspects. Please, learn their experience",
      "createdAt": "2019-08-02T16:52:56Z",
      "updatedAt": "2019-08-02T19:36:38Z",
      "closedAt": "2019-08-02T17:18:21Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "tlsnotary.org describes an online protocol that depends critically on the order of messages sent between the auditor (client in web packaging terms?), auditee (distributor in web packaging terms?), and server (publisher in web packaging terms), in particular information transferred from the auditor to the server, while web packaging intends to work offline. It also says changes in TLS1.2 broke it. So, I don't think it's likely to give useful information to the web packaging effort. If you know of particular experience from that project that's relevant here, I'd still be happy to hear it.",
          "createdAt": "2019-08-02T17:18:21Z",
          "updatedAt": "2019-08-02T17:21:48Z"
        },
        {
          "author": "safinaskar",
          "authorAssociation": "NONE",
          "body": "@jyasskin. I didn't use that project, I just have read that site. tlsnotary also have https://tlsnotary.org/pagesigner.html , i. e. tool for offline proving. But it requires trusted server. And authors propose using Amazon virtual server with published sources",
          "createdAt": "2019-08-02T19:04:49Z",
          "updatedAt": "2019-08-02T19:04:49Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, thanks for the link. I'm just a consumer of the spec, not an author, but here's my attempt to learn from that site.\r\n\r\nIIUC, if this worked on TLS1.3, it might be usable as a way to generate SXGs from sites that don't generate one themselves. AFAIK, that's not a goal of web packaging (though I'm not sure I've heard that it's an explicit non-goal). To do so would require additional work to protect those sites from attacks such as [downgrade](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#seccons-downgrades) / [misleading content](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#seccons-misleading-content).\r\n\r\nFor sites that generate SXGs, then doing so is a lot less complex (and thus easier to reason about) than the tlsnotary solution.\r\n\r\nOTOH, it alone doesn't solve all the issues necessary to trust the content enough to render it in a user-agent, such as downgrades, cert revocation, and cert misissuance. So a solution built on this would need much of the extra SXG infrastructure anyhow.\r\n\r\nIn addition, it seems like the PageSigner approach depends on trust in the central \"oracle\" servers in order to trust the integrity. SXG has some central dependencies (on PKI infra & CT logs), but creating new ones seems risky.",
          "createdAt": "2019-08-02T19:27:35Z",
          "updatedAt": "2019-08-02T19:36:38Z"
        }
      ]
    },
    {
      "number": 478,
      "id": "MDU6SXNzdWU0NzY3Mjg2OTM=",
      "title": "Allowable HTTP status code for Bundle?",
      "url": "https://github.com/WICG/webpackage/issues/478",
      "state": "OPEN",
      "author": "toyoshim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, file formats just expect the status code should be exactly 3 ASCII decimal digits.\r\n\r\nBut for SignedExchanges, the \"Loading Signed Exchanges\" spec allows only 200 for the status code (https://wicg.github.io/webpackage/loading.html#parse-cbor-headers step 2).\r\n\r\nProbably, BundledExchanges also needs a similar restriction, but probably we want range requests and redirects work (206, 307, 308).\r\n\r\nFor Chrome implementation, we will start from just allowing only 200 for the initial experimental implementation, but will support others if we want.\r\n\r\ncrbug.com/990733 tracks the Chrome side implementation.",
      "createdAt": "2019-08-05T08:38:54Z",
      "updatedAt": "2019-09-05T08:54:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "toyoshim",
          "authorAssociation": "NONE",
          "body": "cc: @irori @kinu @jyasskin ",
          "createdAt": "2019-08-05T08:39:26Z",
          "updatedAt": "2019-08-05T08:39:26Z"
        },
        {
          "author": "toyoshim",
          "authorAssociation": "NONE",
          "body": "Here is the discussion for SignedExchange case; https://github.com/WICG/webpackage/pull/326",
          "createdAt": "2019-08-05T09:05:01Z",
          "updatedAt": "2019-08-05T09:05:01Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think it probably makes sense to allow redirects in the bundle, but given the complexity of partial responses, I'd be inclined to keep them out until we find a more concrete use case. A bundle could still serve a partial request when it contains a complete response, although in cases where that's important, we probably also want a more seekable encoding than mi-sha256.\r\n\r\nFor now, +1 on having the Chrome implementation only handle 200s.",
          "createdAt": "2019-08-05T17:59:28Z",
          "updatedAt": "2019-08-05T17:59:28Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that it could be useful to support range requests / 206. (We were looking into a use case where we want to support video resources in a bundle)  While- if we want to support it with mi-sha256 UA still probably needs to read everything in-memory or somewhere, so you're right that we might want a more seekable encoding :thinking: ",
          "createdAt": "2019-09-05T08:54:37Z",
          "updatedAt": "2019-09-05T08:54:37Z"
        }
      ]
    },
    {
      "number": 496,
      "id": "MDU6SXNzdWU0OTM2NjI4NzY=",
      "title": "Provide a formal way for one bundle of JS Modules to optionally reuse already loaded modules from another bundle ",
      "url": "https://github.com/WICG/webpackage/issues/496",
      "state": "OPEN",
      "author": "bahrus",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This whole proposal is vague enough in my mind that I don't know if what I'm asking for is applicable or not.  I'm providing all my uncertainties, hoping that what I'm asking for will be clearer.  Hopefully this isn't totally irrelevant :-)\r\n\r\nLet's say two different [packages](https://github.com/WICG/webpackage/issues/411) may depend on possibly different versions of a common JS module (or is that never going to happen?).  It's great that ES Modules can (normally) be able to work with different versions at the same time, due to scope isolation, and not contend with \"dll hell\" type issues.  Packaging should honor that by default, erring on the side of caution.\r\n\r\nBut what about if the two packages aren't that particular about what version they can use (think specifying version ranges in npm dependencies)?  I'm assuming that packages wouldn't be able to figure that out on the fly.  So I would guess an ideal option might be manually creating a third package that contains the common dependencies.  In an ideal world, that all seems fine (I guess), no issues there.  And I'm also quite fine with the concept that we don't always live in an ideal world, and there will be scenarios where applications **download** multiple packages containing some redundancies.\r\n\r\nBut **downloading** is one thing.  **Loading** redundant modules into memory is also something that would be good to minimize where possible.  And there's one scenario where it's vital, and that has to do with using ES6 Symbols cross-package. \r\n\r\nI raised the issue in the [import maps proposal](https://github.com/WICG/import-maps/issues/132), thinking the issue would applicable there, but it isn't.  I just wanted to basically raise the same issue here, in case it is relevant here.\r\n\r\nI'm afraid I don't understanding the packaging proposal enough to propose anything concrete, but basically in the case of ES6 Symbols, I want to *require* only loading that module once, regardless of which one downloads first, but more generally, be able to specify ranges of acceptable versions, and reuse which one is loaded into memory first. ",
      "createdAt": "2019-09-14T20:23:11Z",
      "updatedAt": "2019-09-14T20:23:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 497,
      "id": "MDU6SXNzdWU0OTUwMDcwOTk=",
      "title": "unbundling tool?",
      "url": "https://github.com/WICG/webpackage/issues/497",
      "state": "OPEN",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I've been making bundles of exchanges from directories of files. It might be nice if there was a tool to do the reverse.\r\n\r\nFor the ESCAPE Workshop, I was going to submit my paper as a bundle, but I figured the organizers couldn't unbundle it :)",
      "createdAt": "2019-09-18T06:03:38Z",
      "updatedAt": "2020-01-23T07:18:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "casey",
          "authorAssociation": "NONE",
          "body": "Somewhat related: It would be nice if an unbundling tool could write a manifest file containing enough information for the original bundle to be losslessly reconstituted from the unbundled files + the manifest. Perhaps it could just be a normal bundle, but refer to the resources by hash, instead of containing the contents inline.",
          "createdAt": "2020-01-23T07:18:01Z",
          "updatedAt": "2020-01-23T07:18:18Z"
        }
      ]
    },
    {
      "number": 498,
      "id": "MDU6SXNzdWU0OTUwNTgxODc=",
      "title": "publishing use cases for persistent storage for bundles",
      "url": "https://github.com/WICG/webpackage/issues/498",
      "state": "OPEN",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We hope that bundles (most likely unsigned?) would be used for distributing publications, such as ebooks. We do hope that some sort of persistent storage would be available on the user's device. Here's a list of a few use cases, [created by @jaypanoz](https://github.com/kobolabs/epub-spec/issues/38#issuecomment-365185776):\r\n\r\n\r\n* storing a list of quizzes/games which have already been done so that it doesn\u2019t reset every time you open the publication;\r\n* storing a list of values for a checklist so that you can automatically save the progress;\r\n* saving a drawing in a canvas \u2013 although this is a little bit of a hack as it can only store strings and you must base64-encode it on the fly\u2026 but when you\u2019ve got nothing else, it does the job;\r\n* saving the current position in an overflowing element since mishandling can happen (turning the page accidentally, which loads a new resource and resets the state of the current one);\r\n* saving the origin of a redirection to easily get back to the previous page if needed \u2013 yeah I know there\u2019s a \u201cprevious button\u201d in the bottom left corner but sometimes it takes years for users to discover it;\r\n* more generally saving any information you\u2019ll retrieve later, which can go from practical things like the examples above, to technical things like storing the results of a feature detect requiring to create an element, test its styles and remove it, which will cause a repaint (there are obviously different strategies to deal with upgrades or invalidate those results whenever needed there).\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2019-09-18T08:06:40Z",
      "updatedAt": "2019-09-18T08:06:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 499,
      "id": "MDU6SXNzdWU1MDA3NTg1MTc=",
      "title": "Can the manifest section be optional?",
      "url": "https://github.com/WICG/webpackage/issues/499",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges",
        "needs spec"
      ],
      "body": "Currently Bundled Exchanges [must have a `manifest` section](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#load-metadata). It was reasonable in the past because its `start_url` could be used to indicate the default resource in the bundle, but we now have the [primary URL](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#semantics-load-metadata) which is meant to be the bundle's main resource URL.\r\n\r\nAlso, in some use cases (for example [Save and share a web page](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#snapshot)) manifest may not be available.\r\n",
      "createdAt": "2019-10-01T08:59:48Z",
      "updatedAt": "2019-10-16T23:52:27Z",
      "closedAt": "2019-10-16T23:52:27Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think it's a good idea to make the manifest optional, since the only field we actually need from the manifest is the `start_url`.",
          "createdAt": "2019-10-04T18:45:42Z",
          "updatedAt": "2019-10-04T18:45:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #505.",
          "createdAt": "2019-10-16T23:52:27Z",
          "updatedAt": "2019-10-16T23:52:27Z"
        }
      ]
    },
    {
      "number": 500,
      "id": "MDU6SXNzdWU1MDEwNTc2Mzk=",
      "title": "SXG files can't be protected by nonce-based CSP",
      "url": "https://github.com/WICG/webpackage/issues/500",
      "state": "OPEN",
      "author": "shhnjk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "SXG file is valid for 7 days (IIRC), and that file will serve static response header specified inside SXG file. This doesn't align with the concept of nonce-based CSP, where server needs to serve random nonce for every request.\r\n\r\nSince SXG might have DOM-based XSS, attacker can just read nonce inside the SXG file and use same nonce in the XSS payload.\r\n\r\nWe should expose option to service CSP nonce, which is generated by browser when rendering SXG file. Publisher of SXG file can specify `<script nonce={}>`, where browser will replace `{}` with randomly generated nonce for every request. This should be safe because SXG file is a static file, so there is no threat for stored or reflected XSS. The only concern is the DOM XSS.",
      "createdAt": "2019-10-01T18:05:45Z",
      "updatedAt": "2019-10-08T18:15:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "CC: @mikewest @arturjanc",
          "createdAt": "2019-10-01T18:07:20Z",
          "updatedAt": "2019-10-01T18:07:20Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks for noticing this! Would it be better to ban nonces from packaged resources entirely? Or https://lists.w3.org/Archives/Public/public-webappsec/2014Sep/0055.html suggests an 'unsafe-static-inline', which might be equivalent to your `nonce={}` suggestion.",
          "createdAt": "2019-10-02T04:49:54Z",
          "updatedAt": "2019-10-02T04:49:54Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "My suspicion is that something like Trusted Types is going to be a better defense against DOM-based XSS than CSP.\r\n\r\nThat said, I have been thinking about a variant of CSP in which the browser would send out a nonce along with each request (I wrote a doc internally back in July... I should publish it somewhere), and expect the server to reflect it. It seems like that might be something we could assume for SXG, as you've noted above.",
          "createdAt": "2019-10-02T07:00:27Z",
          "updatedAt": "2019-10-02T07:00:27Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(https://github.com/mikewest/strict-csp-for-everyone/, FWIW)",
          "createdAt": "2019-10-02T07:10:37Z",
          "updatedAt": "2019-10-02T07:10:37Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": ">Thanks for noticing this! Would it be better to ban nonces from packaged resources entirely? Or https://lists.w3.org/Archives/Public/public-webappsec/2014Sep/0055.html suggests an 'unsafe-static-inline', which might be equivalent to your nonce={} suggestion.\r\n\r\nI think browser should implement a way to serve nonce for static files. It's not only SXG that requires this feature, but also [extensions](https://bugs.chromium.org/p/chromium/issues/detail?id=965986).\r\n\r\n>My suspicion is that something like Trusted Types is going to be a better defense against DOM-based XSS than CSP.\r\n\r\nThen maybe we enforce Trusted Types to SXG files that has CSP? That way, we break all SXGs and the web is now safe\ud83d\ude0a  ",
          "createdAt": "2019-10-02T18:38:20Z",
          "updatedAt": "2019-10-02T18:38:20Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "I would say that Trusted Types and Mike's https://github.com/mikewest/strict-csp-for-everyone/ proposal are interesting platform solutions to this problem, and I'd bank on them being the recommended solutions for static content in the future.\r\n\r\nCurrently, CSP nonces have limitations which makes them a fairly poor fit for any cacheable content. Instead, an approach that could work well for SXG is hash-based CSP where external scripts are loaded via a bootstrapping script, as outlined in https://csp.withgoogle.com/docs/faq.html#static-content. My guess is that this would be fairly straightforward to deploy and can be useful until the other features ship.",
          "createdAt": "2019-10-04T09:26:19Z",
          "updatedAt": "2019-10-04T09:26:19Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "I agree with @arturjanc. So should we BAN nonce in SXGs until those feature ships? ",
          "createdAt": "2019-10-04T17:57:16Z",
          "updatedAt": "2019-10-04T17:57:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm happy to ban nonces in SXGs. Should they be banned or ignored for all cacheable content (which [is a superset of SXGs](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust))?",
          "createdAt": "2019-10-04T18:41:09Z",
          "updatedAt": "2019-10-04T18:41:09Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "I don't think it's really necessary to have special logic for CSP in SXG. It's already possible to configure your CSP in ways that gives you no security benefit (e.g. `script-src 'unsafe-inline' https:`) and it's up to the developer to define a policy that will work for their setup. \r\n\r\nAlso, there is one mode of deploying nonce-based CSP in SXGs that could be useful:\r\n1. Set a CSP of `script-src 'nonce-staticknownvalue' 'strict-dynamic'`\r\n2. Add the nonce to all scripts in the SXG `<script nonce=\"staticknownvalue\">`.\r\n3. In the SXG, after `DOMContentLoaded`, add a new CSP via a `<meta>` element with a random, dynamically generated nonce and `strict-dynamic`:\r\n`script-src 'nonce-[Math.random()]' 'strict-dynamic'`\r\n\r\nSince both the original CSP and the dynamically added one will apply simultaneously, and their nonces will be different, the only scripts that will be able to be loaded by the SXG are those created by APIs allowed by `'strict-dynamic'`. This would protect the SXG from any injections that happen after `DOMContentLoaded`, assuming the lack of script gadgets.\r\n\r\nI wouldn't claim that it's a *good* way to use nonces, but it could be an interesting alternative to hashes in some scenarios. So allowing them in SXG files and cacheable content may offer some benefits (in addition to not introducing the complexity of different CSP behavior depending on the type of document.)",
          "createdAt": "2019-10-05T14:42:21Z",
          "updatedAt": "2019-10-05T14:42:21Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I generally agree with Artur's comments.\r\n\r\nI'd also note that hashes are probably a better answer, especially given the timeframe in which a specific bundle is known to be good. Some script files do change every 7 days, but many don't, and would be best locked-in via hashes. Since I imagine that bundler scripts must exist regardless in order to deal with the signature mechanism, it seems reasonable to point folks in that direction (with Artur's crazy hacks as a backstop).",
          "createdAt": "2019-10-07T09:00:39Z",
          "updatedAt": "2019-10-07T09:00:39Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "Agreed :)",
          "createdAt": "2019-10-07T13:47:28Z",
          "updatedAt": "2019-10-07T13:47:28Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Is that consensus to close this issue? If not, what's the next step?",
          "createdAt": "2019-10-08T18:11:45Z",
          "updatedAt": "2019-10-08T18:11:45Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "Probably add security consideration, or inform SXG users to not to use nonce and use hash instead, if they are using CSP in SXG's inner response.",
          "createdAt": "2019-10-08T18:14:15Z",
          "updatedAt": "2019-10-08T18:14:15Z"
        }
      ]
    },
    {
      "number": 502,
      "id": "MDU6SXNzdWU1MDI5MjE0NjM=",
      "title": "How can I trigger SGX responses from an AMP cache?",
      "url": "https://github.com/WICG/webpackage/issues/502",
      "state": "CLOSED",
      "author": "coventry",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Cloudfront recently blogged [a demo](https://blog.cloudflare.com/real-urls-for-amp-cached-content-using-cloudflare-workers/#generating-http-signed-exchanges-with-workers) of \"HTTP signed exchanges in action on 1-800-Flowers,\" using Chrome Beta for Android. Is there a way to replicate that interaction using `curl`, so that the signed exchange is returned and I can inspect the headers? I can't figure out how to get a response via `curl` which includes a `Signature:` header, or otherwise seems to be a signed exchange.\r\n\r\nApologies if this is a bit off-topic for a repo which seems to be mostly focused on the webpackage standard. If there are better places to ask this question, I'd be grateful for pointers.",
      "createdAt": "2019-10-05T05:59:28Z",
      "updatedAt": "2019-10-05T19:38:16Z",
      "closedAt": "2019-10-05T19:12:54Z",
      "comments": [
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From Google's AMP cache, you can trigger SXG responses via by passing an `accept: application/signed-exchange;v=b3` request header:\r\n\r\n```sh\r\ncurl -sS --output - -H 'accept: application/signed-exchange;v=b3' https://amp-dev.cdn.ampproject.org/wp/s/amp.dev/\r\n# SXG response\r\n```\r\n\r\nFrom an *origin*, you will typically need to pass both `accept: application/signed-exchange;v=b3` and `amp-cache-transform: google;v=\"1..100\"`:\r\n\r\n```sh\r\ncurl -sS --output - -H 'accept: application/signed-exchange;v=b3' -H 'amp-cache-transform: google;v=\"1..100\"' https://amp.dev/\r\n# SXG response\r\n```\r\n\r\n(You need both headers because there's no reason for origins to return SXGs to browsers--the URL is already \"correct\" and there's some overhead to processing SXGs.)\r\n\r\nThis should work the same way when Cloudflare is the origin, but testing just now there seem to be a few issues with the `1800flowers.com` server.\r\n\r\nBoth of these SXG responses can be piped into the [`dump-signedexchange` binary](https://github.com/WICG/webpackage/tree/master/go/signedexchange#dump-a-signed-exchange-file) to verify the response:\r\n\r\n```sh\r\n$ curl -sS --output - -H 'accept: application/signed-exchange;v=b3' -H 'amp-cache-transform: google;v=\"1..100\"' https://amp.dev/ | dump-signedexchange -verify\r\nformat version: 1b3\r\nrequest:\r\n  method: GET\r\n  uri: https://amp.dev/\r\n  headers:\r\n...\r\n```",
          "createdAt": "2019-10-05T18:59:34Z",
          "updatedAt": "2019-10-05T18:59:34Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Some documentation on signed exchanges in AMP is available at https://amp.dev/documentation/guides-and-tutorials/optimize-and-measure/signed-exchange/. For future such questions, AMP's [support page](https://amp.dev/support/) recommends Stack Overflow with the [amp-html tag](https://stackoverflow.com/questions/tagged/amp-html). If that fails, you can try #signed-exchanges on http://bit.ly/amp-slack-signup.",
          "createdAt": "2019-10-05T19:12:54Z",
          "updatedAt": "2019-10-05T19:12:54Z"
        },
        {
          "author": "coventry",
          "authorAssociation": "NONE",
          "body": "Thank you both very much for your help!",
          "createdAt": "2019-10-05T19:38:16Z",
          "updatedAt": "2019-10-05T19:38:16Z"
        }
      ]
    },
    {
      "number": 507,
      "id": "MDU6SXNzdWU1MTA2OTg2MTQ=",
      "title": "Specs rely on expired versions of Structured Headers draft",
      "url": "https://github.com/WICG/webpackage/issues/507",
      "state": "OPEN",
      "author": "clelland",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`draft-yasskin-httpbis-origin-signed-exchanges-impl.md` appears to be pinned to Structured Headers draft 10, which expired in April. `parser.go` looks like it references version 9. draft-yasskin-http-origin-signed-responses.md is not pinned to any particular version, and so generates references to the latest draft (13) when built, but references concepts which do not exist in that draft.\r\n\r\nCurrent versions do not use 'Parameterised List' any more, but the general 'List' structure should suffice for signed-exchanges, likely without any effective syntax changes.\r\n\r\n",
      "createdAt": "2019-10-22T14:33:13Z",
      "updatedAt": "2019-10-22T14:33:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 522,
      "id": "MDU6SXNzdWU1MTk3NTQyMzE=",
      "title": "js/bundle: Cannot generate large bundle",
      "url": "https://github.com/WICG/webpackage/issues/522",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "irori"
      ],
      "labels": [
        "bug"
      ],
      "body": "This generates broken bundle:\r\n\r\n```JavaScript\r\nconst wbn = require('wbn');\r\nconst builder = new wbn.BundleBuilder('http://example.com/');\r\nbuilder.addExchange('http://example.com/', 200,\r\n                    {'content-type': 'application/octet-stream'},\r\n                    new Uint8Array(1024*1024));  // 1MB content\r\nconst buf = builder.createBundle();\r\n```\r\n\r\nThe CBOR encoder we use is implemented using Node streams. It [chokes if it is given large (>16kB) input synchronously](https://github.com/hildjj/node-cbor#highwatermark), and generates truncated output.\r\n",
      "createdAt": "2019-11-08T05:03:00Z",
      "updatedAt": "2019-11-12T01:16:10Z",
      "closedAt": "2019-11-12T01:16:10Z",
      "comments": []
    },
    {
      "number": 526,
      "id": "MDU6SXNzdWU1MjA5NTU2NTg=",
      "title": "WebBundle for sub-resources",
      "url": "https://github.com/WICG/webpackage/issues/526",
      "state": "OPEN",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Current Spec seems based on top level url(html) + subresouces.\r\nbut I think it can use for bundling subresource like JS modules.\r\n\r\nin current real world, JS modules are depends on tiny modules in npm.\r\nif you write correct import maps and serve node_modules directory on server will solve dependencies\r\non the browser.\r\n\r\nbut npm modules are so tiny (substack way), so there cause tons of fetch likely over 100.\r\nand Chrome Team reports this will cause IPC bottle neck.\r\n\r\nhttps://docs.google.com/document/d/1ds9EEkcDGnt-iR8SAN-_7nsOfw7gsMfhZjzZ_QAIyjM/edit\r\n\r\nfinally they recommend to use webpack and make them in single bundle.js. and developers doing that.\r\n\r\nthis means we don't use ES modules directory, even if spec has done, and impl has almost done in browser. `import` notation is only a keyword for webpack, and `<script type=text/javascript src=bundle.js>`. too sad to see them.\r\n\r\nif we can use WebBundles for bundling npm modules and fetch them in one time.\r\nand also browser extract and handle them as if they are fetched each-by-each.\r\nbrowser can cache as separated req/res pare, we can use them via `import`.\r\n\r\nwebbundle for subresources are also fine for WebFont(multi weight), CSS Sprite(bundle images), Favicon(apple-touch-icon, favicon.ico etc).\r\n\r\nso I believe webbundle will change our web content deployment.",
      "createdAt": "2019-11-11T13:14:04Z",
      "updatedAt": "2019-11-11T13:14:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 527,
      "id": "MDU6SXNzdWU1MjEwMjU0Nzg=",
      "title": "variation based on content-language ?",
      "url": "https://github.com/WICG/webpackage/issues/527",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "on 3.3.1. Parsing the index section\r\nhttps://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#index-section\r\n\r\n> For example, given a variants-value of Accept-Encoding;gzip;br, Accept-Language;en;fr;ja, the list of location-in-responses pairs will correspond to the VariantKeys:\r\n\r\nit seems based on Content-Encoding/Language instead of Accept-Encoding/Language ?",
      "createdAt": "2019-11-11T15:23:30Z",
      "updatedAt": "2019-11-14T20:11:19Z",
      "closedAt": "2019-11-14T20:11:19Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "What makes you think it should be based on Content instead of Accept? AFAIK Variant is based on request headers. See, for instance: https://tools.ietf.org/html/draft-ietf-httpbis-variants-05#appendix-A.2",
          "createdAt": "2019-11-11T22:12:53Z",
          "updatedAt": "2019-11-11T22:12:53Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "This example is correct. Variants header field values are request header based, as @twifkak mentioned.\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-variants-05#section-2\r\n\r\n>  The Variants HTTP response header field indicates what\r\n>  representations are available for a given resource at the time that\r\n>  the response is produced, by enumerating the request header fields\r\n>  that it varies on, along with the values that are available for each.\r\n",
          "createdAt": "2019-11-14T20:11:19Z",
          "updatedAt": "2019-11-14T20:11:19Z"
        }
      ]
    },
    {
      "number": 528,
      "id": "MDU6SXNzdWU1MjEwMzQ1MzI=",
      "title": "file format detection",
      "url": "https://github.com/WICG/webpackage/issues/528",
      "state": "OPEN",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.3.3\r\n\r\n> 2. If reading 10 bytes from stream returns an error or doesn\u2019t return the bytes with hex encoding \u201c86 48 F0 9F 8C 90 F0 9F 93 A6\u201d (the CBOR encoding of the 6-item array initial byte and 8-byte bytestring initial byte, followed by \ud83c\udf10\ud83d\udce6 in UTF-8), return a \u201cformat error\u201d.\r\n\r\nI think this will cause implements like below\r\n\r\n```js\r\nhead = read_first_10_byte(path)\r\n\r\nif (head == [86 48 F0 9F 8C 90 F0 9F 93 A6]) {\r\n  // this is web bundle\r\n  switch (parse_cbor(path)['version']) {\r\n    // version switch\r\n  }\r\n} else {\r\n  // this is not web bundle\r\n}\r\n```\r\n\r\nbut if webbundle format will change like below in the future. and also version ++.\r\n\r\n```js\r\nwebbundle = [\r\n  magic\r\n  version // *2*\r\n  primary-url\r\n  section-lengths\r\n  sections\r\n  extension // *new*\r\n  length\r\n]\r\n```\r\n\r\nthe length of array will increase and first 10 byte will change.\r\n\r\nthis cause previous code not working, should be like this\r\n\r\n```js\r\nhead = read_first_10_byte(path)\r\n\r\nif (head == [86 48 F0 9F 8C 90 F0 9F 93 A6]) {\r\n  // this is web bundle\r\n  switch (parse_cbor(path)['version']) {\r\n    // version switch\r\n  }\r\n} else if (head == [*87* 48 F0 9F 8C 90 F0 9F 93 A6]\r\n  // this is also new web bundle\r\n  switch (parse_cbor(path)['version']) {\r\n    // version switch\r\n  }\r\n} else {\r\n  // this is not web bundle\r\n}\r\n```\r\n\r\nso, this version model is not allow adding meta-section to webbundle cbor array.\r\nif you think *cbor array should not change from 6 forever*, it works.\r\nbut I think it seems better to find other way to \r\n\r\n1. magic number should usable for file detection\r\n2. cbor structure update could detect by version, and not affect to 1\r\n\r\nfor example\r\n\r\n```js\r\nwebbundle = [\r\n  magic\r\n  body\r\n  length\r\n]\r\n\r\nbody = [\r\n  version\r\n  primary-url\r\n  section-lengths\r\n  sections\r\n]\r\n```",
      "createdAt": "2019-11-11T15:39:36Z",
      "updatedAt": "2019-12-11T02:58:51Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 531,
      "id": "MDU6SXNzdWU1MjEzOTYzNTg=",
      "title": "<base href=\"/\" /> breaks request URLs from web bundle",
      "url": "https://github.com/WICG/webpackage/issues/531",
      "state": "CLOSED",
      "author": "lacolaco",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`go/bundle` cannot make a valid bundle for HTML which includes `<base href=\"/\" />`. In the case, `.wbn` file will be actually created but HTTP requests from the document are broken. These URLs start with `file://` schema. \r\n\r\n![image](https://user-images.githubusercontent.com/1529180/68654082-0cace980-04e2-11ea-9ce4-3f80c8528ace.png)",
      "createdAt": "2019-11-12T08:20:19Z",
      "updatedAt": "2019-11-12T20:52:39Z",
      "closedAt": "2019-11-12T20:52:39Z",
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an issue of Chromium's experimental implementation.\r\nCould you please file a bug in https://crbug.com ?",
          "createdAt": "2019-11-12T19:37:27Z",
          "updatedAt": "2019-11-12T19:37:27Z"
        },
        {
          "author": "lacolaco",
          "authorAssociation": "NONE",
          "body": "@horo-t I've filed. https://bugs.chromium.org/p/chromium/issues/detail?id=1023929",
          "createdAt": "2019-11-12T20:07:49Z",
          "updatedAt": "2019-11-12T20:07:49Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you.\r\nClosing this issue.",
          "createdAt": "2019-11-12T20:52:38Z",
          "updatedAt": "2019-11-12T20:52:38Z"
        }
      ]
    },
    {
      "number": 532,
      "id": "MDU6SXNzdWU1MjIzNDUxNTU=",
      "title": "Bundle replay as alternative to 'Save Page As...'",
      "url": "https://github.com/WICG/webpackage/issues/532",
      "state": "OPEN",
      "author": "ikreymer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It's great to see the initial bundle replay implementation in Chrome 80!\r\n\r\nI wanted to suggest an archival use case, from perspective of individual users.\r\nI think web bundles could provide alternative to the existing 'Save Page As...' functionality, which is essentially broken for many modern websites. The idea would be to allow users to 'save' a page as a bundle, and replay the page as best as possible. \r\n\r\nThe goal would be to make this work without requiring sites having to become more bundle-friendly or require signing.\r\n\r\nFor bundles to work as a 'generic' save page alternative, I think two extensions would be really useful:\r\n\r\n- Support for non-GET requests, because many sites use other methods during normal operation. I see that this has been closed in #70. Unfortunately, many sites currently use\r\nPOST in normal operation. An example: Twitter uses POST during normal operation. If a user were to save a Tweet, then a critical POST request would be missed, and shows up as an error.\r\n\r\n- Support for custom request/response resolution, perhaps via a 'bundle scoped service worker' that could override fetch() and handle domain-specific requests. Replaying of network traffic is necessarily non-deterministic as often timestamps are added, so a request for `https://example.com/?_=123` might be replayed as `https://example.com/?_124`. If there was a way for a 'worker' in a site to handle fetch(), it could then resolve these in a bundle-specific way.\r\n\r\nA bit more background: I've been working on a project called Webrecorder, which allows users to capture network traffic and replay it back (though a server proxy). In a way, it is designed to be as close as possible to a working 'save page as...'. This implementation uses a backend server.\r\n\r\nI've also have a service-worker based prototype, https://wab.ac/ which allows replay of HAR, WARC and now bundle WBN files in any browser that supports service workers.\r\nIt uses the 'wayback-machine style' URL rewriting approach, but of course it would be better if it could be done 'natively' in the browser, and bundles provide an exciting possibility for that.\r\n\r\nI've wondering if there is any interest, perhaps down the road, in expanding bundles to be able to support features needed to 'fix' Save Page As... for users? Or expanding the bundle spec so that extensions could be implemented to facilitate better replay of 'saved' pages?",
      "createdAt": "2019-11-13T16:49:57Z",
      "updatedAt": "2019-11-13T16:50:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 533,
      "id": "MDU6SXNzdWU1MjM5MTA1ODY=",
      "title": "Add display mode for web bundles",
      "url": "https://github.com/WICG/webpackage/issues/533",
      "state": "CLOSED",
      "author": "AshleyScirra",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It might be interesting to support other display modes in web bundles, e.g. \"standalone\", much like the manifest can set for PWAs.\r\n\r\nThen you could end up in the situation where you have a .wbn file you double click and it runs in an app-like window without the browser address bar - much like an Electron/NW.js app, but actually running in the browser.",
      "createdAt": "2019-11-16T23:38:20Z",
      "updatedAt": "2019-11-17T06:48:19Z",
      "closedAt": "2019-11-17T06:48:03Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Bundles have a [\"manifest\" section](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#manifest-section) which is intended to point to an App Manifest inside the bundle, which in turn can set the [display mode](https://www.w3.org/TR/appmanifest/#display-member). So I think this is already done and am closing the issue, but feel free to reopen with more explanation of what's missing. \ud83d\ude42",
          "createdAt": "2019-11-17T06:48:01Z",
          "updatedAt": "2019-11-17T06:48:19Z"
        }
      ]
    },
    {
      "number": 535,
      "id": "MDU6SXNzdWU1MjM5OTgxNjk=",
      "title": "Example not working for me",
      "url": "https://github.com/WICG/webpackage/issues/535",
      "state": "CLOSED",
      "author": "kohlerm",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The preact-todomvc example at https://web.dev/web-bundles/ \r\ndoes not work for me. \r\nI get an error at the end. \r\n\r\n../go/bin/gen-bundle -dir build -baseURL https://preact-todom.vc -primaryURL https://preact-todom.vc -o todomvc.wbn\r\n2019/11/17 15:58:06 Creating exchange: build -> https://preact-todom.vc/\r\n2019/11/17 15:58:06 Creating exchange: build/app.js -> https://preact-todom.vc/app.js\r\n2019/11/17 15:58:06 Creating exchange: build/index.html -> https://preact-todom.vc/index.html\r\n2019/11/17 15:58:06 Creating exchange: build/todomvc-common/base.css -> https://preact-todom.vc/todomvc-common/base.css\r\n2019/11/17 15:58:06 Creating exchange: build/todomvc-common/base.js -> https://preact-todom.vc/todomvc-common/base.js\r\n2019/11/17 15:58:06 Creating exchange: build/todomvc.css -> https://preact-todom.vc/todomvc.css\r\n2019/11/17 15:58:06 Failed to write exchange. err: bundle: No exchange for primary URL https://preact-todom.vc\r\n",
      "createdAt": "2019-11-17T15:04:15Z",
      "updatedAt": "2019-11-20T10:44:25Z",
      "closedAt": "2019-11-19T01:48:42Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for trying it out.\r\n\r\nThere was an error in the command line. The correct command is:\r\n```\r\n./go/bin/gen-bundle -dir build -baseURL https://preact-todom.vc/ -primaryURL https://preact-todom.vc/ -o todomvc.wbn\r\n```\r\n(note the trailing '/' in the URLs)\r\n\r\nThe web.dev article is already [fixed](https://github.com/GoogleChrome/web.dev/pull/1888).\r\n",
          "createdAt": "2019-11-19T01:48:42Z",
          "updatedAt": "2019-11-19T01:48:42Z"
        },
        {
          "author": "kohlerm",
          "authorAssociation": "NONE",
          "body": "Thanks works fine now!",
          "createdAt": "2019-11-20T10:44:25Z",
          "updatedAt": "2019-11-20T10:44:25Z"
        }
      ]
    },
    {
      "number": 544,
      "id": "MDU6SXNzdWU1MzcyNjcyMDI=",
      "title": "Ensure watermarked signed bundles don't allow user ID transfer",
      "url": "https://github.com/WICG/webpackage/issues/544",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "Pending Security + Privacy Review",
        "bundled-exchanges"
      ],
      "body": "@MattMenke2 pointed out that if a server can get a large number of unique packages generated for two different origins (either by having signing keys for both origins or by getting those origins to cooperate), it can build a bundle that will transfer a user ID between those two origins, given our current idea of how bundle loading will work. That is:\r\n\r\n1. When client C fetches `https://evil.example/the_bundle`, evil.example puts signed HTML files from the two origins into the bundle, each embedding a unique ID. (If the IDs are different, evil.example just records that they refer to the same user.) At this point, https://github.com/WICG/webpackage/blob/master/explainers/anti-tracking.md says evil.example doesn't have access to its own user ID, but this doesn't save us.\r\n1. C redirects to `origin1.example/index.html`, which has access to both `origin1.example`'s online storage and the embedded unique ID, so it reports that `origin1.example`'s user ID is associated with the unique ID.\r\n1. The user now navigates C to `origin2.example/index.html`. Our current notion of how bundles should work says that this doesn't go back to the network, since the user has already downloaded the content and shouldn't need to fetch it again. However, at this point, the new page has access to both `origin2.example`'s online storage and the embedded unique ID, so it reports that association, and learns that origin2's user ID is associated with origin 1's user ID.\u220e\r\n\r\nThe simplest fix is to [remove](https://www.w3.org/TR/security-privacy-questionnaire/#drop-feature) the ability to include multiple signed top-level origins in the same bundle. Or, similarly, declare that the top-level origin of the entire bundle is the one identified in its start URL, so no other origins within the bundle can access their online storage.\r\n\r\nA requirement that signatures are X minutes old, as suggested in #422, doesn't help here, since evil.example can just stockpile unique IDs for that long.\r\n\r\nIf we can find a way to identify the a large number of different resources are available at the same URL, we could use that mechanism to re-allow multiple top-level resources.",
      "createdAt": "2019-12-12T23:25:23Z",
      "updatedAt": "2019-12-12T23:25:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 550,
      "id": "MDU6SXNzdWU1NTM0OTI0MDQ=",
      "title": "Sort order example for map keys in canonical CBOR may be incorrect",
      "url": "https://github.com/WICG/webpackage/issues/550",
      "state": "CLOSED",
      "author": "casey",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I was just reading through [the Signed HTTP Exchanges draft](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-canonical-cbor-serializatio), and I think the given example for how keys in a CBOR map should be sorted is incorrect.\r\n\r\nThe example reads:\r\n\r\n```\r\nThe keys in every map MUST be sorted in the bytewise\r\nlexicographic order of their canonical encodings. For example,\r\nthe following keys are correctly sorted:\r\n\r\n1. 10, encoded as 0A.\r\n2. 100, encoded as 18 64.\r\n3. -1, encoded as 20.\r\n4. \"z\", encoded as 61 7A.\r\n5. \"aa\", encoded as 62 61 61.\r\n6. [100], encoded as 81 18 64.\r\n7. [-1], encoded as 81 20.\r\n8. false, encoded as F4.\r\n```\r\n\r\nHowever, section 3.9 of [RFC 7049](https://www.rfc-editor.org/rfc/rfc7049.txt) states:\r\n\r\n```\r\n   o  The keys in every map must be sorted lowest value to highest.\r\n      Sorting is performed on the bytes of the representation of the key\r\n      data items without paying attention to the 3/5 bit splitting for\r\n      major types.  (Note that this rule allows maps that have keys of\r\n      different types, even though that is probably a bad practice that\r\n      could lead to errors in some canonicalization implementations.)\r\n      The sorting rules are:\r\n\r\n      *  If two keys have different lengths, the shorter one sorts\r\n         earlier;\r\n\r\n      *  If two keys have the same length, the one with the lower value\r\n         in (byte-wise) lexical order sorts earlier.\r\n```\r\n\r\nIt's a little odd, but this reads to me as if keys should be sorted by key length first, and only then should keys with the same length be lexically sorted. This would give the sorting:\r\n\r\n```\r\n1. 10, encoded as 0A.\r\n2. -1, encoded as 20.\r\n3. false, encoded as F4.\r\n4. 100, encoded as 18 64.\r\n5. \"z\", encoded as 61 7A.\r\n6. [-1], encoded as 81 20.\r\n7. \"aa\", encoded as 62 61 61.\r\n8. [100], encoded as 81 18 64.\r\n```",
      "createdAt": "2020-01-22T11:55:07Z",
      "updatedAt": "2020-01-23T07:16:23Z",
      "closedAt": "2020-01-22T21:09:06Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is something that's changing between RFC 7049 and [CBORbis](https://cbor-wg.github.io/CBORbis/draft-ietf-cbor-7049bis.html#core-deterministic-encoding-requirements), where the new version defines two possible key orderings for individual protocols to pick between. We're using the newer one, that doesn't mix values of different major types. We're still compatible with RFC 7049, which says \"Those protocols are free to define what they mean by a canonical format and what encoders and decoders are expected to do.\"",
          "createdAt": "2020-01-22T21:09:06Z",
          "updatedAt": "2020-01-22T21:09:06Z"
        },
        {
          "author": "casey",
          "authorAssociation": "NONE",
          "body": "Ah, gotcha, thank you for the clarification!",
          "createdAt": "2020-01-23T07:16:23Z",
          "updatedAt": "2020-01-23T07:16:23Z"
        }
      ]
    },
    {
      "number": 551,
      "id": "MDU6SXNzdWU1NTY0NzQ0ODE=",
      "title": "Correct / real URLs should be enforced, to avoid breaking adblockers",
      "url": "https://github.com/WICG/webpackage/issues/551",
      "state": "OPEN",
      "author": "pes10k",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "privacy-tracker"
      ],
      "body": "Currently there is no enforced relationship between the URL used to look up resources in the package, and where the resource came from online.  Consistent URLs are an imperfect, but extremely useful signal for privacy protecting tools (filter lists, adblockers, disconnect, Firefox and Edge built in protections, safe browsing, etc.).  \r\n\r\nThe current proposal would allow for all WebPackage'd sites to circumvent all URL based tools by simply randomizing URLs as a post processing step in [amppackager](https://github.com/ampproject/amppackager) or similar.  This could even be done per-request per page.  Since URLs are effectively just indexes into the package (and not keys for decision making, caching, etc), they can be changed arbitrarily w/o affecting how the package loads, but preventing the URL-based privacy preserving tools from running.\r\n\r\nA (partial) possible solution to the problem is to play a [cut-and-choose](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/zhu), commitment-auditing style games with the URLs.  At package time, the packager has to make commitments about which URL each resource came from, and the size, shape etc of the resource.  These can be made / mixed with the URL of the page being packaged. \r\n\r\nThe client can then, w/ some probability, audit some number of the URLs in the package.  If the commitments fail, deterring counter measures can be taken against the packing origin (e.g. global decaying block list of misbehaving packagers, etc).",
      "createdAt": "2020-01-28T21:18:35Z",
      "updatedAt": "2020-04-01T01:34:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Because this is an issue where the potential attackers may not have thought of all the attacks we want to defend against, I don't want to discuss this issue in public. I'm going to try to discuss it in https://github.com/WICG/webpackage/security/advisories/GHSA-g5qv-3cw4-38gv instead. Send me an email with an aspect of the problem that isn't yet discussed here in order to be added to that discussion.",
          "createdAt": "2020-02-05T20:09:21Z",
          "updatedAt": "2020-02-05T20:09:21Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "just wanted to check in on this, has anything changed / any updates?\r\n\r\n",
          "createdAt": "2020-04-01T01:34:13Z",
          "updatedAt": "2020-04-01T01:34:13Z"
        }
      ]
    },
    {
      "number": 555,
      "id": "MDU6SXNzdWU1NjM3OTI3MjI=",
      "title": "loading spec: Content sniffing prevention steps are missing in Parsing b3 algorithm",
      "url": "https://github.com/WICG/webpackage/issues/555",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#354 added two steps in the [Parsing b2 CBOR headers](https://wicg.github.io/webpackage/loading.html#parse-b2-cbor-headers) algorithm:\r\n\r\n> 7. If responseHeaders does not contain `Content-Type`, return a failure.\r\n> 8. Set `X-Content-Type-Options`/`nosniff` in responseHeaders.\r\n\r\nBut it did not add them into the [Parsing **b3** CBOR headers](https://wicg.github.io/webpackage/loading.html#parse-cbor-headers) algorithm.\r\n",
      "createdAt": "2020-02-12T06:56:11Z",
      "updatedAt": "2020-02-12T06:56:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 556,
      "id": "MDU6SXNzdWU1NjQ1NTYyNDU=",
      "title": "\"These are encoded so that the normal algorithm for computing an origin from a URL works\" is false",
      "url": "https://github.com/WICG/webpackage/issues/556",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md#urls-for-bundle-components is incorrect as due to the scheme you'll get an opaque origin.",
      "createdAt": "2020-02-13T09:40:10Z",
      "updatedAt": "2020-04-07T00:12:42Z",
      "closedAt": "2020-04-07T00:12:42Z",
      "comments": []
    },
    {
      "number": 562,
      "id": "MDU6SXNzdWU1NzcyNTg1MjI=",
      "title": "Unclear error processing model for mismatched types",
      "url": "https://github.com/WICG/webpackage/issues/562",
      "state": "OPEN",
      "author": "domenic",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(Forked from https://github.com/WICG/origin-policy/issues/87#issuecomment-596029083)\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-the-signature-header specifies types for various parameters, but from what I can tell the processing model in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#section-3.5-7.1.1 does not explain what to do when the types mismatch.\r\n\r\nIt seems like maybe the intention is to return \"invalid\", but if so I'd expect an explicit step, like \"If integrity is not a string, return \"invalid\".",
      "createdAt": "2020-03-07T02:03:38Z",
      "updatedAt": "2020-03-07T02:03:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 564,
      "id": "MDU6SXNzdWU1ODYwMzQ2ODE=",
      "title": "go/signedexchange: gen-certurl should fail on invalid OCSP",
      "url": "https://github.com/WICG/webpackage/issues/564",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "Currently, `dump-certurl` warns if the input has an invalid OCSP response, but `gen-certurl` happily creates such cert chains.\r\n\r\n`gen-signedexchange` refuses to create an invalid SXG unless `-ignoreErrors` flag is given. `gen-certurl` should behave similarly.\r\n",
      "createdAt": "2020-03-23T08:50:18Z",
      "updatedAt": "2020-03-23T08:50:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 568,
      "id": "MDU6SXNzdWU1OTUxNDg4MDc=",
      "title": "Chrome refuses to load generated bundles",
      "url": "https://github.com/WICG/webpackage/issues/568",
      "state": "CLOSED",
      "author": "mgissing",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I have been trying to create my own web bundles (with both gen-bundle and the JS encoder)\r\nand I noticed that sometimes Chrome (both 80 release and 83.0.4102.0 Win x64) rejects the bundle with ERR_INVALID_WEBBUNDLE (no further info in console or devtools)\r\n\r\nAfter fiddling with it a bit, it seems that Chrome is very picky about the order the exchanges appear in.\r\nI am sure that its not the content, since it is reproducible with just changing a single file name.\r\nIf I sort the result URLs first by length and then lexically everything works fine.\r\n\r\nNot sure if this is the right location to report this since it might be Chromium related - but if anyone is interested I can provide more details and a minimal example\r\n",
      "createdAt": "2020-04-06T14:08:39Z",
      "updatedAt": "2020-04-10T08:09:31Z",
      "closedAt": "2020-04-10T08:09:30Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "The [`index` section](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#name-parsing-the-index-section) must be a deterministically encoded CBOR map, which means its entries must be sorted. The order of responses in the `responses` section is arbitrary.\r\n\r\nWould you file a Chromium bug (with example `.wbn` if possible) from http://crbug.com/new with `Blink>Loader>WebPackaging` component? Chromium should at least output detailed error message in console.\r\n\r\nThanks!",
          "createdAt": "2020-04-07T00:07:43Z",
          "updatedAt": "2020-04-07T00:07:43Z"
        },
        {
          "author": "mgissing",
          "authorAssociation": "NONE",
          "body": "Filed chromium issue https://bugs.chromium.org/p/chromium/issues/detail?id=1068481\r\nAfter looking a bit further into the issue it seems that both the JS encoder and the gen-bundle get the sort order wrong. \r\nBoth go \"bytes.compare(..)\" and Buffer.compare() in node do not sort by length first but only by byte values and then length\r\n\r\nhttps://github.com/WICG/webpackage/blob/7412e313f959808ed927cfd4156acffb8bbd9420/go/signedexchange/cbor/encoder.go#L228\r\n\r\n",
          "createdAt": "2020-04-07T08:30:20Z",
          "updatedAt": "2020-04-07T08:46:03Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "`encoder.go` sorts map keys by CBOR-encoded bytes of keys, i.e. \"z\" (encoded as `61 7A`) comes before \"aa\" (encoded as `62 61 61`). See the unit test of the encoder:\r\n\r\nhttps://github.com/WICG/webpackage/blob/7412e313f959808ed927cfd4156acffb8bbd9420/go/signedexchange/cbor/encoder_test.go#L188\r\n\r\nEffectively it sorts keys by length and then by value.\r\n\r\nHow did you create your bundle file? Was it created by `gen-bundle`, the `wbn` JS library, or any other tool?\r\n",
          "createdAt": "2020-04-08T02:09:24Z",
          "updatedAt": "2020-04-08T02:09:24Z"
        },
        {
          "author": "mgissing",
          "authorAssociation": "NONE",
          "body": "Sorry I missed the part were the sort includes the length prefix - thats fine.\r\nI have written my own encoder on top of CBOR and with sorting that works fine now.\r\n\r\nRegarding gen-bundle - maybe I'm using it wrong:\r\nThis is the file structure:\r\n\r\n```\r\nDummyPage/index.html\r\n          test.jpg\r\n          unused.jpg\r\n          unused2.jpg\r\n```\r\n\r\nThis doesnt work:\r\n`gen-bundle -baseURL http://example.org/ -primaryURL http://example.org/index.html -dir  DummyPage -o notworking.wbn`\r\n\r\nThis does:\r\n`gen-bundle -baseURL http://example.org/ -primaryURL http://example.org/ -dir  DummyPage -o working.wbn`\r\n\r\n[bundle-working-dump.txt](https://github.com/WICG/webpackage/files/4449270/bundle-working-dump.txt)\r\n[bundle-notworking-dump.txt](https://github.com/WICG/webpackage/files/4449271/bundle-notworking-dump.txt)\r\n\r\nAlso I was wondering if  \"Content-Encoding: gzip\" in responses is supposed to work in Chrome right now - currently Chrome seems to ignore that\r\n",
          "createdAt": "2020-04-08T08:44:37Z",
          "updatedAt": "2020-04-08T08:44:37Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "For `index.html`, `gen-bundle` generates a redirect (301) resposnse to `./` (as you can see in [bundle-notworking-dump.txt](https://github.com/WICG/webpackage/files/4449271/bundle-notworking-dump.txt)). But currently Chromium cannot handle it. This is tracked at https://crbug.com/1040831.\r\n\r\nWe'd like to support `Content-Encoding: gzip` in bundled respohnses in the future, but it doesn't work currently. This is tracked at https://crbug.com/1063738.\r\n\r\nI think this WICG/webpackage issue can be closed. Please watch the Chromium issues for progress.",
          "createdAt": "2020-04-10T08:09:30Z",
          "updatedAt": "2020-04-10T08:09:30Z"
        }
      ]
    },
    {
      "number": 569,
      "id": "MDU6SXNzdWU1OTU2OTIzMTI=",
      "title": "Question about compressed content",
      "url": "https://github.com/WICG/webpackage/issues/569",
      "state": "CLOSED",
      "author": "mgissing",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Is it an intended use case to allow \"Content-Encoding: gzip\" or similar in the the web bundle and have a compressed body?\r\nI know you could zip the whole bundle but for passing it around as a compact file it would really be useful",
      "createdAt": "2020-04-07T08:33:42Z",
      "updatedAt": "2020-04-07T16:44:31Z",
      "closedAt": "2020-04-07T16:44:31Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yes. https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-compress-stored-packages says this indirectly.",
          "createdAt": "2020-04-07T16:44:28Z",
          "updatedAt": "2020-04-07T16:44:28Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0OTIzODcxMTE=",
      "title": "Adds a few example pack files and component files.",
      "url": "https://github.com/WICG/webpackage/pull/1",
      "state": "CLOSED",
      "author": "mrdewitt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also defines a \".attributes\" file for those files that should be\r\nincluded with either specific headers or from subpackages.",
      "createdAt": "2016-11-04T17:54:51Z",
      "updatedAt": "2016-12-02T23:38:29Z",
      "closedAt": "2016-12-02T23:38:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1Mzc1MQ==",
          "commit": {
            "abbreviatedOid": "727697f"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2016-11-04T17:57:49Z",
          "updatedAt": "2016-11-04T17:57:49Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Would be nice to avoid base64 from the start... would guthub barf if it was just a binary image?\n",
              "createdAt": "2016-11-04T17:57:49Z",
              "updatedAt": "2016-12-02T23:38:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0OTQyMTgwOTg=",
      "title": "readme: tiny typo fix",
      "url": "https://github.com/WICG/webpackage/pull/4",
      "state": "MERGED",
      "author": "isaacs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "s/subresourcves/resources/",
      "createdAt": "2016-11-17T17:57:26Z",
      "updatedAt": "2016-11-17T21:54:18Z",
      "closedAt": "2016-11-17T21:54:18Z",
      "mergedAt": "2016-11-17T21:54:18Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyNjA3Nw==",
          "commit": {
            "abbreviatedOid": "0418647"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2016-11-17T21:50:09Z",
          "updatedAt": "2016-11-17T21:50:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0OTQyMTgzMzU=",
      "title": "readme: tiny typo fix",
      "url": "https://github.com/WICG/webpackage/pull/5",
      "state": "MERGED",
      "author": "isaacs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "s/tot he/to the/",
      "createdAt": "2016-11-17T17:58:43Z",
      "updatedAt": "2016-11-17T21:49:30Z",
      "closedAt": "2016-11-17T21:49:30Z",
      "mergedAt": "2016-11-17T21:49:30Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyNTg2OQ==",
          "commit": {
            "abbreviatedOid": "11ad43b"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!\n",
          "createdAt": "2016-11-17T21:49:18Z",
          "updatedAt": "2016-11-17T21:49:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0OTYzNzcxMjM=",
      "title": "Adds a comment about relative indexing.",
      "url": "https://github.com/WICG/webpackage/pull/18",
      "state": "MERGED",
      "author": "mrdewitt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes Issue #17.",
      "createdAt": "2016-12-03T00:37:02Z",
      "updatedAt": "2016-12-06T23:18:06Z",
      "closedAt": "2016-12-06T02:53:06Z",
      "mergedAt": "2016-12-06T02:53:06Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0OTY2MTY0ODM=",
      "title": "Adds an initial version of a packager script.",
      "url": "https://github.com/WICG/webpackage/pull/19",
      "state": "MERGED",
      "author": "mrdewitt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This script can be updated alongside the explainer to give a concrete\r\nanswer to many format-related questions, and to uncover and resolve\r\nambiguities in the proposed spec.\r\n\r\nMany parts of the spec are unimplemented as yet.",
      "createdAt": "2016-12-05T21:52:18Z",
      "updatedAt": "2016-12-06T02:50:50Z",
      "closedAt": "2016-12-06T02:50:50Z",
      "mergedAt": "2016-12-06T02:50:50Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! This looks like a good start, looking forward for the rest of it.",
          "createdAt": "2016-12-06T02:50:14Z",
          "updatedAt": "2016-12-06T02:50:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0OTg5NTM3NTU=",
      "title": "Explicitly note Content Index Entries content boundaries",
      "url": "https://github.com/WICG/webpackage/pull/21",
      "state": "MERGED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just explicit bound checking.",
      "createdAt": "2016-12-21T15:37:00Z",
      "updatedAt": "2017-01-04T01:45:50Z",
      "closedAt": "2017-01-04T01:45:50Z",
      "mergedAt": "2017-01-04T01:45:50Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwNDY3MDc=",
          "commit": {
            "abbreviatedOid": "0a169b3"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-01-04T01:45:43Z",
          "updatedAt": "2017-01-04T01:45:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0OTk1NTY3NzY=",
      "title": "No need for algorithm header, fixes #14",
      "url": "https://github.com/WICG/webpackage/pull/22",
      "state": "MERGED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #14 ",
      "createdAt": "2016-12-28T14:48:53Z",
      "updatedAt": "2017-01-05T02:08:54Z",
      "closedAt": "2017-01-05T02:08:54Z",
      "mergedAt": "2017-01-05T02:08:54Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Yes, X.509 certs always have the algorithm.  What are types of certs are\nyou thinking - (Open)PGP?\n\nOn Wed, Jan 4, 2017 at 10:04 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> *@bmeck* commented on this pull request.\n> ------------------------------\n>\n> In README.md <https://github.com/dimich-g/webpackage/pull/22>:\n>\n> > @@ -185,13 +185,14 @@ The example contains an HTML page and an image. The package is signed by the exa\n>  Important notes:\n>\n>  1. The very first header in Package Header section of the package is **Package-Signature**, a new header that contains a signed hash of the Package Header section (not including Package-Signature header) and Content Index. It also contains a reference (via cid: UUID-based URL) to the part that contains the public key certificate (or if needed, a chain of certificates to the root CA).\n> -2. The **algorithm** attribute contains a type of hash and signature algorithm used ('sha384-with-ECDSA' in this case) and the encrypted hash of the Content Index. It is encoded as [Integrity Metadata in SRI spec](https://www.w3.org/TR/SRI/#integrity-metadata). *Should there be '-with-ECDSA' since certificate specifies the key's algorithm?*\n> -2. The Content Index contains hashes of all parts of the package, so it is enough to validate the index to trust its hashes, then compute the hash of the each part upon using it to validate each part. Hashes have hash algorithm specified in front.\n> -3. The inclusion of certificate makes it possible to validate the package offline (certificate revocation aside, this can be done out-of-band when device is actually online).\n> -4. Certificate is included as one of standard the DER-encoded resource (with proper Content-type).\n> +2. The **algorithm** must be encoded within the certificate that signed the package.\n> +3. The Content Index contains hashes of all parts of the package, so it is enough to validate the index to trust its hashes, then compute the hash of the each part upon using it to validate each part. Hashes have hash algorithm specified in front.\n> +4. Content Index Entry `part-location` and `part-size` must not refer to locations outside of the package which contains the entry or locations within nested packages. They may refer to the boundaries of a nested package.\n>\n> if we only have X.509 I think it will always contain a Signature\n> Algorithm, but I might want to investigate other cert types to see if they\n> also always carry that.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/22>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNW6WNocVAy99JuZEOG0Zj2IbmGqHks5rO7URgaJpZM4LW92->\n> .\n>\n",
          "createdAt": "2017-01-04T15:24:01Z",
          "updatedAt": "2017-01-04T15:24:01Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol PGP in real world scenarios I could see being a candidate. I once heard of npm modules potentially being signed for publish using developer SSH keys, but I don't want that.",
          "createdAt": "2017-01-04T15:28:45Z",
          "updatedAt": "2017-01-04T15:28:45Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol PGP Version3 appears to mandate the hash algorithm as well, but only in the signature packet https://tools.ietf.org/html/rfc4880#section-5.2.2, not in the key packet https://tools.ietf.org/html/rfc4880#section-5.2.2 . To remove the algorithm in `Package-Signature` we would also need to mandate a signature packet which somewhat defeats the purpose here.",
          "createdAt": "2017-01-04T17:41:27Z",
          "updatedAt": "2017-01-04T17:41:27Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Or we decide that signing of web packages via PGP key isn't a goal.  And\nwhile I love many things about PGP (having worked with Phil and the\noriginal team back in the 90's) - it unfortunately never reached wide\nadoption.  I think we would better served with an X.509-only based solution\nthat is simpler.\n\nOn Wed, Jan 4, 2017 at 12:41 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> PGP Version3 appears to\n> mandate the hash algorithm as well, but only in the signature packet\n> https://tools.ietf.org/html/rfc4880#section-5.2.2, not in the key packet\n> https://tools.ietf.org/html/rfc4880#section-5.2.2 . To remove the\n> algorithm in Package-Signature we would also need to mandate a signature\n> packet which somewhat defeats the purpose here.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/22#issuecomment-270434932>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNdbNTK2scugXzM1WV7POZGlhh5k7ks5rO9nHgaJpZM4LW92->\n> .\n>\n",
          "createdAt": "2017-01-04T18:33:02Z",
          "updatedAt": "2017-01-04T18:33:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5ODAzODc=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "this change lgtm pending small adjustment for clarity",
          "createdAt": "2017-01-03T18:10:00Z",
          "updatedAt": "2017-01-03T18:14:19Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "For clarity, could you change \"locations within nested packages\" to \"to locations within nested packages\"",
              "createdAt": "2017-01-03T18:10:00Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwNDczOTU=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-04T01:56:23Z",
          "updatedAt": "2017-01-04T01:56:24Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@mrdewitt I'm separately merging your suggestion since it was a part of another pr, thanks!\r\n@bmeck There should at least be an algorithm used for the hash, right? While the encryption algorithm is specified in the certificate, the specific form of hash used here can vary (not a part of cert) so needs to be mentioned.\r\n",
              "createdAt": "2017-01-04T01:56:24Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxMjQ3NjM=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-04T14:55:03Z",
          "updatedAt": "2017-01-04T14:55:03Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@dimich-g ah yes, that is a good point the I was just looking at how Content Index Entry has its own algorithm and missed that we still need the hash-algorithm in the Package-Signature. I put the hash algorithm back in Package-Signature, but we can still drop the cert one.",
              "createdAt": "2017-01-04T14:55:03Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxMjU3ODE=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-04T14:59:59Z",
          "updatedAt": "2017-01-04T14:59:59Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "fixed.",
              "createdAt": "2017-01-04T14:59:59Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxMjY3ODg=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-04T15:04:49Z",
          "updatedAt": "2017-01-04T15:04:49Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "if we only have X.509 I think it will always contain a Signature Algorithm, but I might want to investigate other cert types to see if they also always carry that.",
              "createdAt": "2017-01-04T15:04:49Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0OTk2Njg0NjQ=",
      "title": "[do not merge] MIME boundary => chunked encoding",
      "url": "https://github.com/WICG/webpackage/pull/23",
      "state": "CLOSED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This allows for:\r\n\r\n* streaming without worrying about collision and without the need to pre-parse the file\r\n* signatures to be preserved even if chunk sizes differ due to streaming\r\n\r\nfixes #6",
      "createdAt": "2016-12-29T15:37:47Z",
      "updatedAt": "2017-03-29T14:20:52Z",
      "closedAt": "2017-03-29T14:20:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "marked [do not merge]\r\n\r\nneed to discuss the outer boundaries more in depth so that package level header and trailer are clear.",
          "createdAt": "2016-12-30T14:07:54Z",
          "updatedAt": "2016-12-30T14:07:54Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I am thinking you mean \"part\" to be body of a resource within the package.\r\n\r\nThis does allow encoding resources into multiple chunks. Individual chunk lengths are not related to total size of a resource.",
          "createdAt": "2017-01-03T18:58:58Z",
          "updatedAt": "2017-01-03T18:58:58Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "After a while of thinking I cannot easily preserve nesting packages while maintaining streamking via normal chunked encoding. A variant seems possible, but the problem comes from:\r\n\r\n```\r\n... outer webpackage ...\r\n<- no delimiter for declaring entering nested package\r\n<- would need add extra wrapping header + chunked encoding content\r\ninner package <- all chunked (even headers :( )\r\n<- extra `0\\r\\n` is a bit odd\r\n... outer webpackage ...\r\n```\r\n\r\nI will investigate some other framing mechanism which can support streaming nested packages without this problem.",
          "createdAt": "2017-01-16T22:31:30Z",
          "updatedAt": "2017-01-16T22:31:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Could you update this to use `\\n` line endings? Right now git thinks every line is changed.\r\n\r\nDo we need to be able to stream the nested packages? It'd be a little weird for the main server to be reflecting a stream served from another server, since it couldn't then take over and serve part of its own content if the nested server pauses. That ... makes me think we should actually be using something from HTTP2 directly for the streaming case and only use a packaging format for serializing the content.",
          "createdAt": "2017-01-25T22:44:37Z",
          "updatedAt": "2017-01-25T22:44:37Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin for streaming onto a disk (from any source) we don't have the guarantees of a HTTP/2 style multiplexing stream.",
          "createdAt": "2017-01-25T23:11:30Z",
          "updatedAt": "2017-01-25T23:11:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think that mixes two use cases.\r\n1. Server sends content as it's generated, rather than waiting for a whole file to be ready at once. For this, you have HTTP2.\r\n2. Serialize content to disk and share it to peers. At this point, you've downloaded the whole thing and can use an encoding that needs lengths up front. You might have to do a second pass over the data.\r\n\r\nI could be missing something.",
          "createdAt": "2017-01-25T23:17:42Z",
          "updatedAt": "2017-01-25T23:17:42Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin \r\n\r\n1) Content can be served via means other than HTTP, and HTTP2 is still very far from having even a small penetration.  We need something that works over any protocol.\r\n\r\n2) But if you modify the stream/data - you break the signatures.  That's not good.",
          "createdAt": "2017-01-25T23:19:34Z",
          "updatedAt": "2017-01-25T23:19:34Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I don't think the packaging format needs to solve problems that new transports have already solved. People who don't upgrade to the new transports just have to deal with the problems of the transports they're using.\r\n\r\nI do think there's a problem with including offsets in the signed data, but I need to double-check with security folks that it's safe to avoid it.",
          "createdAt": "2017-01-25T23:21:23Z",
          "updatedAt": "2017-01-25T23:21:23Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "I agree that we don't need to solve problems already solved - and I don't think we are doing that here.  Instead, we are designing a protocol and storage system neutral solution.\r\n\r\nActually the opposite - if the offsets aren't signed, you have a big hole in your signature model.",
          "createdAt": "2017-01-25T23:24:58Z",
          "updatedAt": "2017-01-25T23:24:58Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "closing due to newer PR and the move to CBOR",
          "createdAt": "2017-03-29T14:20:52Z",
          "updatedAt": "2017-03-29T14:20:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5ODMxMzM=",
          "commit": {
            "abbreviatedOid": "52476a7"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Does this change merge the concept of chunk length and part length?  It might be that for streaming the server won't even know the length of individual parts, meaning that it'd need to send down a part as multiple chunks.",
          "createdAt": "2017-01-03T18:25:56Z",
          "updatedAt": "2017-01-03T18:25:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0OTk2NzgwNDU=",
      "title": "[WIP][DO-NOT-MERGE] extracting binaries",
      "url": "https://github.com/WICG/webpackage/pull/24",
      "state": "CLOSED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Will update as discussion on https://github.com/dimich-g/webpackage/issues/20 evolves.",
      "createdAt": "2016-12-29T17:11:58Z",
      "updatedAt": "2017-05-30T17:13:40Z",
      "closedAt": "2017-05-30T17:13:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "fixed",
          "createdAt": "2017-05-30T17:13:40Z",
          "updatedAt": "2017-05-30T17:13:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTkzMzA=",
          "commit": {
            "abbreviatedOid": "2ff5310"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T23:41:48Z",
          "updatedAt": "2017-02-08T23:41:48Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Dumb question: why do you want an executable signature in the package? OSes wouldn't generally know to check it before running the executable, and once it's running, it can also ignore its own signature. ",
              "createdAt": "2017-02-08T23:41:48Z",
              "updatedAt": "2017-02-08T23:41:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAwNzE2NjU4",
      "title": "avoid colliding MIME for Content Index",
      "url": "https://github.com/WICG/webpackage/pull/25",
      "state": "MERGED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes https://github.com/dimich-g/webpackage/issues/9 by using a sub tree of `application/package.index`",
      "createdAt": "2017-01-09T16:34:57Z",
      "updatedAt": "2017-01-24T02:08:05Z",
      "closedAt": "2017-01-24T02:07:46Z",
      "mergedAt": "2017-01-24T02:07:46Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I am neutral on this topic overall given how UA generally treat MIME type as opaque strings.",
          "createdAt": "2017-01-13T19:57:35Z",
          "updatedAt": "2017-01-13T19:57:35Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks a lot, this is a good suggestion!",
          "createdAt": "2017-01-24T02:08:05Z",
          "updatedAt": "2017-01-24T02:08:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzU4MjE=",
          "commit": {
            "abbreviatedOid": "9d0019f"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I wonder if it can be a new tree ('package.') or if it should be something like vnd.package.index",
          "createdAt": "2017-01-13T19:35:10Z",
          "updatedAt": "2017-01-13T19:35:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAxMzgzODYw",
      "title": "Explicitly mandate X.509 cert and leave verification to host",
      "url": "https://github.com/WICG/webpackage/pull/27",
      "state": "MERGED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes https://github.com/dimich-g/webpackage/issues/16",
      "createdAt": "2017-01-13T03:31:41Z",
      "updatedAt": "2017-01-13T19:19:02Z",
      "closedAt": "2017-01-13T19:19:02Z",
      "mergedAt": "2017-01-13T19:19:02Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzI0MzI=",
          "commit": {
            "abbreviatedOid": "882eef6"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-01-13T19:18:41Z",
          "updatedAt": "2017-01-13T19:18:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAyODM0MjE4",
      "title": "Fix a bunch of typos and missing links.",
      "url": "https://github.com/WICG/webpackage/pull/28",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I'm not sure I've got the right fix for each of these; feel free to say anything should be different.",
      "createdAt": "2017-01-24T01:06:12Z",
      "updatedAt": "2017-01-26T22:36:47Z",
      "closedAt": "2017-01-26T00:55:36Z",
      "mergedAt": "2017-01-26T00:55:36Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2017-01-26T00:55:57Z",
          "updatedAt": "2017-01-26T00:55:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNjUxNzA=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-24T01:08:47Z",
          "updatedAt": "2017-01-24T01:10:41Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "It seems from the FAQ that this link is wrong. I'd strongly suggest using a scheme that doesn't collide with anything that already has a definition.",
              "createdAt": "2017-01-24T01:08:47Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            },
            {
              "originalPosition": 53,
              "body": "#25 handles this better.",
              "createdAt": "2017-01-24T01:09:59Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            },
            {
              "originalPosition": 75,
              "body": "Please double-check this paragraph.",
              "createdAt": "2017-01-24T01:10:22Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzM2MzI=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-24T02:28:53Z",
          "updatedAt": "2017-01-24T02:28:53Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Right. The cid: schema is not really the right one here. Chrome uses URLs like cid:[uuid] in MHTML generation and this is apparently not standard, but then again MHTML is not well formed standard either... I've picked the cid: schema after Chrome's MHTML implementation, but perhaps urn:uuid: would work better, and it is standard:  http://www.ietf.org/rfc/rfc4122.txt\r\nIf you think it is better here, please feel free to change to it or let me know and I'll change after merging this PR.",
              "createdAt": "2017-01-24T02:28:53Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzM2NDE=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-24T02:28:56Z",
          "updatedAt": "2017-01-24T02:28:56Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Indeed. I've merged #25.",
              "createdAt": "2017-01-24T02:28:56Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzM3MDU=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Great, thanks a lot for reading and fixing those!\r\nI want to merge it, there are 2 comments...",
          "createdAt": "2017-01-24T02:29:42Z",
          "updatedAt": "2017-01-24T02:29:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NjE2MjQ=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-25T17:56:22Z",
          "updatedAt": "2017-01-25T17:56:22Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I'm happy to use `urn:uuid:` for UUIDs. I've made that a separate commit since it touches several parts of the document.",
              "createdAt": "2017-01-25T17:56:22Z",
              "updatedAt": "2017-01-25T17:56:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAzMzkzNzYy",
      "title": "Add some discussion of the security issues.",
      "url": "https://github.com/WICG/webpackage/pull/31",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* Outdated certificates and packages.\r\n* That there may not be a single certificate chain.\r\n\r\n@estark37",
      "createdAt": "2017-01-26T21:32:47Z",
      "updatedAt": "2017-06-08T18:34:00Z",
      "closedAt": "2017-06-08T00:08:13Z",
      "mergedAt": "2017-06-08T00:08:13Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "This conversation has also taken place as part of #16. where its been pointed out that TLS-based certs won't work (as @sleevi says here).  Other types of certs - that aren't tied to domains, but instead of orgs or individuals - will need to be used.\r\n\r\nBut regardless, the set of valid and/or trusted roots needs to come from somewhere that may (or may not) be able to be mandated as part of the standardization.  And as part of that, you need to consider other standards in this area such as the [EUTL](https://ec.europa.eu/digital-single-market/en/eu-trusted-lists-trust-service-providers).",
          "createdAt": "2017-01-27T19:06:56Z",
          "updatedAt": "2017-01-27T19:06:56Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@lrosenthol That's not an accurate statement - that is, that other types of certs _will_ need to be used, or more generally, that certificates not bound to domains should be used. And the EUTL should absolutely be ignored in this space - not even bothered with.\r\n\r\n@dimich-g I think the question was worded incorrectly; that is, you don't want to get a \"second\" TLS certificate that you use for signing, because as far as design goes, you're setting people up to fail if they have two certificates, interchangable, but one should be used for TLS and one not. To reduce the risk of cross-protocol attacks, you want to ensure that Certificate A (which can/should/is bound to a domain) cannot be used in Protocol B, and that Certificate B (which can/should/is bound to a domain) should not be used in Protocol A.\r\n\r\nI don't anticipate being able to provide a more thorough review of the cryptography in the next few days, but there are definitely red flags with what's currently specified - ranging from the discussion of Key Usage to these issues of cross-protocol confusion. The signature design also doesn't account for the ability to perform counter-signatures, which is generally seen as a necessary scheme in document/code signing solutions (in Authenticode, it's used for timestampping; in Chrome extensions, it's used to vet that it's a Google WebStore delivered extension; in Android APKs, it's used to comply with local laws). ",
          "createdAt": "2017-01-27T19:13:41Z",
          "updatedAt": "2017-01-27T19:13:41Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@sleevi \r\n>And the EUTL should absolutely be ignored in this space - not even bothered with.\r\n>\r\nThen you and I are going to have to agree to disagree.  The EUTL is a requirement for adoption of signatures within the URL for various business processes.  In the context of the use of this technology for publications, it would be necessary to be allow compatibility with it.  I am **not** suggesting mandating, just compatibility.\r\n\r\n>doesn't account for the ability to perform counter-signatures\r\n>\r\nI don't believe that the current design prevents counter sigs, but I agree that it's not called out - and you are right, it should be as it is an important technology.  It's also going to be important for publications where the author may sign the original publication with the publisher adding theirs at the final release stage.",
          "createdAt": "2017-01-27T19:20:08Z",
          "updatedAt": "2017-01-27T19:20:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi At the moment, we don't have a specification, just a sketch. Would you prefer that we non-cryptographers come up with a draft specification that you can review, or would you rather we write down a list of requirements and wait for a real cryptographer to design the right system?",
          "createdAt": "2017-01-27T19:34:37Z",
          "updatedAt": "2017-01-27T19:34:37Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin Either way, knowing your goals clearly will help make sure whatever solution meets those goals - whether it's starting from a point in the draft where you're trying to accomplish those goals, or whether it's starting from scratch to build something to achieve those goals. Knowing, for example, whether you're exclusively targeting UAs or whether, as it seems suggested both here and the draft, you're imagining things like JS packaging or document delivery, is itself a useful aspect.",
          "createdAt": "2017-01-27T19:47:18Z",
          "updatedAt": "2017-01-27T19:47:18Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@sleevi - there are at least three different groups that are looking to\npotentially leverage this work\n- Browsers (which I assume you meant when you said UA, but is just one\nclass of UA for the OWP)\n- Application environments (eg. Node+Electron)\n- Documents & Publications (eg. Web Publications)\n\nThis to me means a common model and file format.  However, I see no reason\nwhy the types of certificates allowed/used couldn't be different in each\ncase.\n\nOn Fri, Jan 27, 2017 at 2:47 PM, sleevi <notifications@github.com> wrote:\n\n> @jyasskin <https://github.com/jyasskin> Either way, knowing your goals\n> clearly will help make sure whatever solution meets those goals - whether\n> it's starting from a point in the draft where you're trying to accomplish\n> those goals, or whether it's starting from scratch to build something to\n> achieve those goals. Knowing, for example, whether you're exclusively\n> targeting UAs or whether, as it seems suggested both here and the draft,\n> you're imagining things like JS packaging or document delivery, is itself a\n> useful aspect.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/31#issuecomment-275756952>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNTKdgi9WOU5pXoSFrmb4-VWDM0b0ks5rWknHgaJpZM4LvKkh>\n> .\n>\n",
          "createdAt": "2017-01-27T19:51:10Z",
          "updatedAt": "2017-01-27T19:51:10Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify, I would expect Node and Electron to use Code Signing based x.509 certs rather than regular TLS certs. In particular, the origin of applications might not be tied to a specific WWW domain but an app store submission (like Android APK).",
          "createdAt": "2017-03-31T13:39:58Z",
          "updatedAt": "2017-03-31T13:39:58Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Points by @mrdewitt addressed, merged.",
          "createdAt": "2017-06-08T00:09:52Z",
          "updatedAt": "2017-06-08T00:09:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NzA5NzU=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T16:06:54Z",
          "updatedAt": "2017-01-27T16:06:54Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "@sleevi, @estark37 said I should ask you if packagers are going to cause problems by including the certificates needed to chain to the roots of multiple different clients. She referenced https://groups.google.com/a/chromium.org/d/msg/net-dev/H-ysp5UM_rk/TqoyjV1eDAAJ as an example of servers choosing to make the client download some intermediates, which won't work as well for offline verification.",
              "createdAt": "2017-01-27T16:06:54Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MDEwMjI=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T18:31:31Z",
          "updatedAt": "2017-01-27T18:31:32Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "@jyasskin I'll read up on the full proposal, but it sounds like you're suggesting using CA-rooted certificates, possibly even TLS certificates, for the packaging. That's not ideal for a number of reasons - this included - so I'll take a scan through and see what alternatives might be worth suggesting.",
              "createdAt": "2017-01-27T18:31:31Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MDQ5Mjg=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T18:50:28Z",
          "updatedAt": "2017-01-27T18:50:28Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Thanks. The main constraint that I think leads us to use CA-rooted certificates is that we need the packages to be trusted as coming from particular web origins. I'm happy with anything else that proves an origin to the displaying browser.",
              "createdAt": "2017-01-27T18:50:28Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MDU3ODk=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T18:54:53Z",
          "updatedAt": "2017-01-27T18:54:53Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Right, unfortunately, this introduces subtle-but-significant cross-protocol attacks when you re-use a TLS certificate to sign this data, unfortunately, so this is going to be quite difficult to get what you want.",
              "createdAt": "2017-01-27T18:54:53Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MDgyNjI=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T19:06:54Z",
          "updatedAt": "2017-01-27T19:06:55Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "@sleevi is this true even if the publisher of the package obtains a separate TLS certificate for signing packages? Sort of similar to how code-signing certificates are separate form TLS ones.",
              "createdAt": "2017-01-27T19:06:54Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1OTk1MTc=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-03T18:41:52Z",
          "updatedAt": "2017-04-03T18:46:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'm confused - local sharing doesn't typically have per-byte costs.  Storage and downloading do.",
              "createdAt": "2017-04-03T18:41:52Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 7,
              "body": "Seems to me that rewording this without the numbered list would be clearer.  \"It may be feasible to periodically check for OCSP notification that a package's certificate has been revoked.  Other channels for notifying about vulnerable packages have not yet been discussed/designed.\"",
              "createdAt": "2017-04-03T18:43:30Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 22,
              "body": "This makes me think that analogue to the HEAD request where the client could fetch only the manifest/index and revalidate stale portions would be useful.",
              "createdAt": "2017-04-03T18:44:36Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 42,
              "body": "s/is/must be/",
              "createdAt": "2017-04-03T18:45:20Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2MTMxMTI=",
          "commit": {
            "abbreviatedOid": "e72aa6e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-07T17:04:42Z",
          "updatedAt": "2017-04-07T17:36:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Indeed, that was worded badly. I meant that the use case happens where global connectivity is expensive, and have now updated the PR wording.",
              "createdAt": "2017-04-07T17:04:42Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 7,
              "body": "Done.",
              "createdAt": "2017-04-07T17:05:36Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 22,
              "body": "Yeah. We should define an optimized update mechanism, although validation might be simpler.",
              "createdAt": "2017-04-07T17:09:23Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 42,
              "body": "I'm going to undo the change to this section until we can update all the use cases.",
              "createdAt": "2017-04-07T17:25:55Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 105,
              "body": "#44 takes agl's advice to use the same signing format as TLS (and I used a different context string to distinguish package signatures from handshake signatures). I'd like to postpone the question of exactly what origin-trusted certificates will convince browsers to load a package until a later PR.\r\n\r\nThe current format even looks like it'll represent packages that have only signatures that aren't origin-trusted. Although web browsers would refuse to load those packages, they're useful for Node and Publishers.",
              "createdAt": "2017-04-07T17:28:48Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA0NTk3MTE2",
      "title": "Add some open questions, and refine a same-origin use case.",
      "url": "https://github.com/WICG/webpackage/pull/34",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-02-03T19:34:39Z",
      "updatedAt": "2017-04-07T17:41:54Z",
      "closedAt": "2017-04-07T17:41:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this PR is obsolete after some of the other PRs were merged. Sorry for not catching that before you reviewed it.",
          "createdAt": "2017-04-07T17:41:51Z",
          "updatedAt": "2017-04-07T17:41:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1OTg5NTI=",
          "commit": {
            "abbreviatedOid": "18061fb"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-03T18:40:00Z",
          "updatedAt": "2017-04-03T18:40:42Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Can you clarify what \"the implementation has to be secure against even signed content\" means?  Do you mean that we have to verify signatures?",
              "createdAt": "2017-04-03T18:40:00Z",
              "updatedAt": "2017-04-03T18:40:42Z"
            },
            {
              "originalPosition": 29,
              "body": "This only proves anything for same-origin content, right?",
              "createdAt": "2017-04-03T18:40:36Z",
              "updatedAt": "2017-04-03T18:40:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA1MDk3NzQ5",
      "title": "Sketch an update to the package format and its signatures.",
      "url": "https://github.com/WICG/webpackage/pull/36",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I haven't updated the Use Cases yet, but here are some thoughts on how we should update the format to deal with #33 (@bmeck), Ryan's security concerns in #31, #29 (@jianli-chromium), and #10, #11, and #12 (@lrosenthal). I've tried to mark all the places that still need work with \"TODO\", but I may have missed some.",
      "createdAt": "2017-02-07T21:28:52Z",
      "updatedAt": "2017-03-30T17:49:01Z",
      "closedAt": "2017-03-30T06:34:10Z",
      "mergedAt": "2017-03-30T06:34:09Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a bit raw still, we'll need to clarify some topics, something that jumps at me:\r\n- subpackages. seems w/o signed manifest it's impossible to have them\r\n- subpackages - can they be external (by URL)\r\n- index and manifest seem to have duplicated list of resource uris\r\n- the COSI seems interesting but is it the right one?\r\n- obviously, the examples should be updated, etc.",
          "createdAt": "2017-03-30T06:37:34Z",
          "updatedAt": "2017-03-30T06:37:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDQ1ODc=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T19:21:37Z",
          "updatedAt": "2017-02-08T19:21:37Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "What makes the overall length of the package needed at the beginning?",
              "createdAt": "2017-02-08T19:21:37Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDU0MTQ=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T19:24:43Z",
          "updatedAt": "2017-02-08T19:24:43Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "As far as binary format goes, we might as well consider at least 32-bit alignment, since it may make memory-mapped files easier/faster to interpret.",
              "createdAt": "2017-02-08T19:24:43Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDU5MjQ=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T19:26:53Z",
          "updatedAt": "2017-02-08T19:26:53Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "I'd remove TODO. If it's not right, it'll be obvious on review/registration.\r\nThe package does need a mime type as it requires a different parser/handler typically, so the only issue may be actual names.",
              "createdAt": "2017-02-08T19:26:53Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NTU0NDk=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:05:53Z",
          "updatedAt": "2017-02-08T20:05:53Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "It's not essential. I included it as a way to validate that the length at the end is actually referring to a package, but the other constraints here probably do that just fine. I can remove it.",
              "createdAt": "2017-02-08T20:05:53Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NTU3ODg=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:07:16Z",
          "updatedAt": "2017-02-08T20:07:16Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "I suspect that \"package\" is too general to suggest, and that we should suggest something more specific like `webpackage` or `httppackage` (since it holds HTTP responses).",
              "createdAt": "2017-02-08T20:07:16Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NTYxNjM=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:08:54Z",
          "updatedAt": "2017-02-08T20:08:54Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Right, I'm torn between allowing alignment for the binary parts, vs compressing the integers better. The amount of data here is pretty small, so I decided that decoding speed wasn't critical enough to worry about alignment. 'course, it's also not enough to really worry about the size.",
              "createdAt": "2017-02-08T20:08:54Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NjM5Mzc=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:45:32Z",
          "updatedAt": "2017-02-08T20:45:32Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "Signatures are also optional. Not-signed packages may have a lot of utility since they can be produced locally and shared easily. The limits on contents are obvious, but for many use cases (packaging a movie that has its own DRM schema embedded, or a static snapshot of a page) the signing is not needed.",
              "createdAt": "2017-02-08T20:45:32Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NjQ3NDY=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:49:16Z",
          "updatedAt": "2017-02-08T20:49:16Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "This makes it not clear what certificates and for what signature are included. The original idea went with a packages being authonomous units (since if signed, they most likely will be signed by separate domain owners, using separate certs etc). It's unclear why including certs needed to verify a subpackage is needed in a containing package, if that is what you meant.",
              "createdAt": "2017-02-08T20:49:16Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NjQ5MjM=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:50:02Z",
          "updatedAt": "2017-02-08T20:50:02Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "My thought is that unsigned packages would omit the manifest. Can you think of a reason to include a manifest without signing it? Note that the index is always unsigned.",
              "createdAt": "2017-02-08T20:50:02Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NjU3OTA=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:53:44Z",
          "updatedAt": "2017-02-08T20:53:44Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Again, not signed resources have their use and may be used even wider than signed, at least initially. Likely need to preserve optional nature of signing.",
              "createdAt": "2017-02-08T20:53:44Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTA0OTQ=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T22:47:12Z",
          "updatedAt": "2017-02-08T22:47:12Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "This needs to be clarified wrt subpackages. If a subpackage has its own index, it should not be duplicated. Realistically, the process of serving resources from the packages should include memory cache of indices of subpackages, so there is no need to flatten the index. If I understand the sentence correctly, of course.",
              "createdAt": "2017-02-08T22:47:12Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTMwOTE=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T23:01:40Z",
          "updatedAt": "2017-02-08T23:01:40Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "At the moment, I have a single block of certificates, which are used to validate all the signatures anywhere. If we want to send the sub-package's certificates with that sub-package, we'd need to include extra certificate blocks. That said, `application/pkcs7-mime` can actually wrap both certificates and signed data, so we could store the manifests in that format and avoid having any separate certificate block.",
              "createdAt": "2017-02-08T23:01:40Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTM2ODI=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T23:05:13Z",
          "updatedAt": "2017-02-08T23:05:13Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "We could give the top-level index a way to refer to subpackage indices, but I think that would constrain subpackages to be contiguous, which might break the ability to deduplicate shared dependencies. It seems more straightforward to ask the top-level package to regenerate the sub-package's indices.",
              "createdAt": "2017-02-08T23:05:13Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNTQzMjU=",
          "commit": {
            "abbreviatedOid": "b097d44"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T22:17:35Z",
          "updatedAt": "2017-02-10T22:17:35Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "We met and decided to use 8-byte numbers everywhere here, and to ignore alignment everywhere else.",
              "createdAt": "2017-02-10T22:17:35Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMTczODA=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks fine, still need to revisit other issues on formatting of content. I have nits, but nothing blocking.",
          "createdAt": "2017-02-27T15:48:14Z",
          "updatedAt": "2017-02-27T15:56:02Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "I don't think this is needed as we are not requesting updates via this format.",
              "createdAt": "2017-02-27T15:48:14Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            },
            {
              "originalPosition": 201,
              "body": "This needs to be reworded, `The message to sign` is confusing, are we talking about the whole package, the manifest, or an individual resource. I assume we are only talking about the manifest.\r\n\r\nThe wording here makes it sound like after generating a manifest we put the signatures on the resources.",
              "createdAt": "2017-02-27T15:52:28Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            },
            {
              "originalPosition": 174,
              "body": "need to bikeshed the format here, HTTP Header on same line as other data seems an odd choice and hard to deal with.",
              "createdAt": "2017-02-27T15:53:18Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMTM4OTA=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-27T22:01:16Z",
          "updatedAt": "2017-03-27T22:01:16Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "Yep, the new CBOR-based format avoids this problem.",
              "createdAt": "2017-03-27T22:01:16Z",
              "updatedAt": "2017-03-27T22:01:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMTM5MDA=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-27T22:01:18Z",
          "updatedAt": "2017-03-27T22:01:18Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Works for me; removed.",
              "createdAt": "2017-03-27T22:01:18Z",
              "updatedAt": "2017-03-27T22:01:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMTM5Mjc=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-27T22:01:23Z",
          "updatedAt": "2017-03-27T22:01:23Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "I was talking about the manifest, and this wording got replaced when I switched to the CBOR format. See if the new wording in https://github.com/jyasskin/webpackage/tree/sketch-new-signing#manifest makes sense?",
              "createdAt": "2017-03-27T22:01:23Z",
              "updatedAt": "2017-03-27T22:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MzYyNDg=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-29T14:22:44Z",
          "updatedAt": "2017-03-29T14:22:44Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "+1",
              "createdAt": "2017-03-29T14:22:44Z",
              "updatedAt": "2017-03-29T14:22:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MzYzNTE=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-29T14:23:06Z",
          "updatedAt": "2017-03-29T14:23:06Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "+1",
              "createdAt": "2017-03-29T14:23:06Z",
              "updatedAt": "2017-03-29T14:23:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA1MjkwNDUz",
      "title": "Add a list of goals and non-goals.",
      "url": "https://github.com/WICG/webpackage/pull/37",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It's a fairly long list. Did I miss anything?",
      "createdAt": "2017-02-08T19:47:21Z",
      "updatedAt": "2017-05-19T21:58:24Z",
      "closedAt": "2017-03-30T03:10:43Z",
      "mergedAt": "2017-03-30T03:10:43Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I lean towards \"self-extracting\" as required for Node. It really is just adding a `length` field at the end of the file as long as we can check file signature somehow, don't really need anything else.",
          "createdAt": "2017-02-27T15:39:45Z",
          "updatedAt": "2017-02-27T15:39:45Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Two things\n\n1 - To me, self-extracting implies that there is code in the package that\ncan extract its own contents.  I would actually find that to be an\nanti-goal.  In fact, it almost screams security problem.\n\n2 - For publication use cases, \"non-origin-identity\" is a\nrequirement/goal.  Do you want me to submit the PR on that?\n\nOn Mon, Feb 27, 2017 at 10:39 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> I lean towards \"self-extracting\" as required for Node. It really is just\n> adding a length field at the end of the file as long as we can check file\n> signature somehow, don't really need anything else.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/37#issuecomment-282755705>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNU8QOYB3H4GpbFRs5YQfdykO9CU2ks5rgu5BgaJpZM4L7Ris>\n> .\n>\n",
          "createdAt": "2017-02-27T15:46:26Z",
          "updatedAt": "2017-02-27T15:46:26Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol we can rename it to w/e else but that is the common name for archive formats that allow the behavior we have described. It is up to the runtime env to provide proper mechanics to load things safely. I just need the format to allow the archive to be concatenated on the end of a binary and find the start of the archive safely.",
          "createdAt": "2017-02-27T15:58:08Z",
          "updatedAt": "2017-02-27T15:58:08Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Ah - it's not that the package itself is self-extracting - but that it can\nbe used in a self-extracting context.  Then maybe just add \"compatible\"\n(ie. self-extracting compatible)?\n\nOn Mon, Feb 27, 2017 at 10:58 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> we can rename it to w/e else\n> but that is the common name for archive formats that allow the behavior we\n> have described. It is up to the runtime env to provide proper mechanics to\n> load things safely. I just need the format to allow the archive to be\n> concatenated on the end of a binary and find the start of the archive\n> safely.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/37#issuecomment-282761478>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNRe4TAEgv2eiZQPa-e3F7IumdYBUks5rgvKQgaJpZM4L7Ris>\n> .\n>\n",
          "createdAt": "2017-02-27T18:26:52Z",
          "updatedAt": "2017-02-27T18:26:52Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've marked that Node requires the packages to be compatible with self-extraction, and I'm almost certain we can accommodate it, but I've left it in the Nice-to-have section because Node support *at all* is just nice-to-have.",
          "createdAt": "2017-03-21T22:40:20Z",
          "updatedAt": "2017-03-21T22:40:20Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Publication use cases are also nice-to-have, but packages with non-origin identities are hard enough to fit into web browsers that I think this PR is right to list it as a non-goal. We could explore it further in a separate issue/PR if you really want.",
          "createdAt": "2017-03-21T23:48:49Z",
          "updatedAt": "2017-03-21T23:48:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNTEzNTU=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T21:59:24Z",
          "updatedAt": "2017-02-10T21:59:24Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "The goal's name \"sub-packages\" refers to our current solution to the real goal which is \"multiple origins can make same-origin requests\"",
              "createdAt": "2017-02-10T21:59:24Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNjQyOTE=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T23:30:27Z",
          "updatedAt": "2017-02-10T23:30:27Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "TODO: Add DRM support as a non-goal.",
              "createdAt": "2017-02-10T23:30:27Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNjYwNTQ=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T23:46:02Z",
          "updatedAt": "2017-02-10T23:46:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Changed to \"multiple-origins\".",
              "createdAt": "2017-02-10T23:46:02Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNjYwNjE=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T23:46:05Z",
          "updatedAt": "2017-02-10T23:46:05Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Done.",
              "createdAt": "2017-02-10T23:46:05Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNzQyODM=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-11T01:32:32Z",
          "updatedAt": "2017-02-11T01:32:32Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think it can be simplified by dropping 'TLS' requirement since unsigned content also makes sense. The TLS can be used in lieu of signature verification (but even that is more complicated, with countersigning) - so lets just keep streamed-loading as a goal regardless trust issues. ",
              "createdAt": "2017-02-11T01:32:32Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIwOTQ1MDk=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-15T19:53:38Z",
          "updatedAt": "2017-02-15T19:53:38Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done, especially given the fact that TLS doesn't guarantee resources aren't dropped.",
              "createdAt": "2017-02-15T19:53:38Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE0NjcyMjk4",
      "title": "Remove COSE and use TLS1.3's signing algorithm.",
      "url": "https://github.com/WICG/webpackage/pull/44",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "COSE is more complex than we need, and exposes us to any bugs in generic COSE\r\ntools.\r\n\r\nWe're not necessarily going to allow certificates that can be used for TLS\r\ntraffic, but using their signing format removes one thing that'd block it.\r\n\r\nThese are requests from @agl.",
      "createdAt": "2017-04-06T19:03:12Z",
      "updatedAt": "2017-05-04T16:27:33Z",
      "closedAt": "2017-05-03T19:53:50Z",
      "mergedAt": "2017-05-03T19:53:50Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": []
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE1NjQ1Njg4",
      "title": "Consolidate resource-keys into the index.",
      "url": "https://github.com/WICG/webpackage/pull/46",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This requires the index where it used to be optional.\r\n\r\nFixes #41.",
      "createdAt": "2017-04-12T22:04:30Z",
      "updatedAt": "2017-05-11T00:02:11Z",
      "closedAt": "2017-05-11T00:02:03Z",
      "mergedAt": "2017-05-11T00:02:03Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NDY2NDU=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T18:21:02Z",
          "updatedAt": "2017-05-08T18:21:02Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I don't strictly need the nested array here: it could just be a list of alternating headers and bodies.",
              "createdAt": "2017-05-08T18:21:02Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NDY5MTU=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T18:22:13Z",
          "updatedAt": "2017-05-08T18:22:13Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I don't strictly need this array either, but it's a little more difficult to tease out where the next index entry starts with the optional length. (You'd use the bstr-ness of the resource-key.) I could require lengths, but that wastes some space when a package isn't expected to be downloaded using http range requests.",
              "createdAt": "2017-05-08T18:22:13Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzczNDY=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:32:25Z",
          "updatedAt": "2017-05-08T20:32:25Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Later the resource key is described with a particular order, should that be reflected here (or pulled out and referenced in both places)",
              "createdAt": "2017-05-08T20:32:25Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzc0MjU=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:32:44Z",
          "updatedAt": "2017-05-08T20:32:44Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I think it makes sense and will make parser simpler.",
              "createdAt": "2017-05-08T20:32:44Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzc0NDk=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:32:51Z",
          "updatedAt": "2017-05-08T20:32:51Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Same here.",
              "createdAt": "2017-05-08T20:32:51Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzc1MjQ=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "in general this lgtm",
          "createdAt": "2017-05-08T20:33:14Z",
          "updatedAt": "2017-05-08T20:33:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzc4MTQ=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:34:23Z",
          "updatedAt": "2017-05-08T20:34:23Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Having the array makes sense, or not-having it?",
              "createdAt": "2017-05-08T20:34:23Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODE1Njc=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:49:33Z",
          "updatedAt": "2017-05-08T20:49:33Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Done, thanks.",
              "createdAt": "2017-05-08T20:49:33Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODE3MzM=",
          "commit": {
            "abbreviatedOid": "ab14fdd"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:50:12Z",
          "updatedAt": "2017-05-08T20:50:12Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Having the array.",
              "createdAt": "2017-05-08T20:50:12Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODQyNzc=",
          "commit": {
            "abbreviatedOid": "ab14fdd"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T21:00:43Z",
          "updatedAt": "2017-05-08T21:00:43Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Could you add a comment explaining how the hashes are mapped to resources? Is it based on the order in the array?",
              "createdAt": "2017-05-08T21:00:43Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODQ5NDU=",
          "commit": {
            "abbreviatedOid": "ab14fdd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T21:03:56Z",
          "updatedAt": "2017-05-08T21:03:56Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "The idea is that we make a set of the allowed `hash-value`s, hash each resource, and then the resource is allowed if its hash appears in the set. I'll try to describe that more clearly.",
              "createdAt": "2017-05-08T21:03:56Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODYwMDM=",
          "commit": {
            "abbreviatedOid": "ab14fdd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T21:08:43Z",
          "updatedAt": "2017-05-08T21:08:43Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "How's this?",
              "createdAt": "2017-05-08T21:08:43Z",
              "updatedAt": "2017-05-08T21:08:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTk4OTc=",
          "commit": {
            "abbreviatedOid": "997f5db"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-09T00:42:35Z",
          "updatedAt": "2017-05-09T00:42:35Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Is the mapping resource->hash done here by using the same order of the hash-values as resources in indexed content? It's not explicitly said anywhere I think...",
              "createdAt": "2017-05-09T00:42:35Z",
              "updatedAt": "2017-05-09T00:42:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDE4NTg=",
          "commit": {
            "abbreviatedOid": "997f5db"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-09T05:12:50Z",
          "updatedAt": "2017-05-09T05:12:50Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "No, the list of hash values here is just a set. If the resource matches any of them, it's valid. I think https://github.com/dimich-g/webpackage/pull/46/files#diff-04c6e90faac2675aa89e2176d2eec7d8R316 says this.",
              "createdAt": "2017-05-09T05:12:50Z",
              "updatedAt": "2017-05-09T05:12:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE4NDU5MDUw",
      "title": "Update the packaging tool to generate CBOR packages from a text format.",
      "url": "https://github.com/WICG/webpackage/pull/49",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This doesn't yet support signed manifests, and it's not tested as thoroughly as\r\nI'd like, but it can generate packages for the first couple examples.\r\n\r\nIt assumes that #46 is accepted.",
      "createdAt": "2017-05-01T23:16:13Z",
      "updatedAt": "2017-05-11T00:04:29Z",
      "closedAt": "2017-05-11T00:04:26Z",
      "mergedAt": "2017-05-11T00:04:26Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDA1Mzc=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Hi, sorry for the extremely partial review, but this is a large PR :)  Will continue tomorrow.",
          "createdAt": "2017-05-03T21:14:01Z",
          "updatedAt": "2017-05-03T23:26:28Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Can you explicitly outline the major types in the comment? ",
              "createdAt": "2017-05-03T21:14:01Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 5,
              "body": "Do you just mean Additional information = 27 or something else?",
              "createdAt": "2017-05-03T21:18:34Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 12,
              "body": "Does this mean bignums?",
              "createdAt": "2017-05-03T21:45:41Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 12,
              "body": "Perhaps it should be better specified as we don't support tagging of items?",
              "createdAt": "2017-05-03T21:47:12Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 22,
              "body": "This is somewhat misleading since it's not a signed int but actually a negative one.",
              "createdAt": "2017-05-03T21:58:10Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjkzMTY=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-04T17:07:14Z",
          "updatedAt": "2017-05-04T17:07:14Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "No, not bignums. The Major Type 1 format supports numbers down to -2^64, but int64 only holds down to -2^63. I've clarified the comment.",
              "createdAt": "2017-05-04T17:07:14Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjkzNjY=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-04T17:07:26Z",
          "updatedAt": "2017-05-04T17:07:26Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Good point. Renamed to TypePosInt and TypeNegInt.",
              "createdAt": "2017-05-04T17:07:26Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjk0MjY=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-04T17:07:36Z",
          "updatedAt": "2017-05-04T17:07:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Just additional information=27.",
              "createdAt": "2017-05-04T17:07:36Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjk0NDI=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-04T17:07:39Z",
          "updatedAt": "2017-05-04T17:07:39Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2017-05-04T17:07:39Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MDYwMjU=",
          "commit": {
            "abbreviatedOid": "4516174"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "In general this lgtm, I'm not sure that I'm able to fully cope with 1300 line patches so I might have missed something :)\r\n\r\nThanks!",
          "createdAt": "2017-05-04T22:46:45Z",
          "updatedAt": "2017-05-09T16:57:07Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "The range of numbers we claim to support (std::numeric_limits<int64_t>::min() through std::numeric_limits<uint64_t>::max() is a bit unusual.  Would the client of the parser need to explicitly expect a signed or unsigned integer?",
              "createdAt": "2017-05-04T22:46:45Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "it might not be very future-proof to read potentially large packages into memory like this.",
              "createdAt": "2017-05-04T22:48:11Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "Same with writing cbor to an array of bytes rather than bytestream.",
              "createdAt": "2017-05-04T22:49:57Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 41,
              "body": "nit: comment explaining the magic numbr",
              "createdAt": "2017-05-04T22:50:32Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 105,
              "body": "so all headers are in the resource key now, not just vary-enabled ones?\r\n\r\n(also there is no definition of resource key in the README)",
              "createdAt": "2017-05-04T23:09:50Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "int here turns into uint on line 21?",
              "createdAt": "2017-05-04T23:17:32Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 42,
              "body": "can you document why offset is used in this operation?",
              "createdAt": "2017-05-08T20:35:07Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTE1MzE=",
          "commit": {
            "abbreviatedOid": "4516174"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-09T17:03:55Z",
          "updatedAt": "2017-05-09T19:09:16Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I have an `AppendUint64` and an `AppendInt64` function, which let the client say whether they have a signed or unsigned integer.",
              "createdAt": "2017-05-09T17:03:55Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "Yeah, it's like this because the only call is from len(x), which returns an int. I think my use of `int` vs `int64` vs `uint64` is probably unconventional for Go. `int` seems to be `ssize_t`, which meant that I started second-guessing lots of places I used uint64 for sizes of things in packages: even if we want a package larger than `int`, the buffer used to hold the package can't be that big, so there's no point in using `uint64`. Do you have suggestions or preferences?",
              "createdAt": "2017-05-09T17:11:07Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 42,
              "body": "Done.",
              "createdAt": "2017-05-09T18:05:36Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "Yep. I'd like to use mmap, but https://godoc.org/golang.org/x/exp/mmap is experimental and doesn't actually let me extract byte slices from the file without copying them. Should I use https://github.com/edsrzf/mmap-go? For large packages, I think we're going to wind up in C++ (or Rust) anyway, since that's where the browsers are, so maybe it doesn't matter for this implementation.\r\n\r\nBecause of the indexes, it's hard to write the package to a bytestream in one pass. It would be possible to write the `resources` section to a file, then compose the index and read that file back to generate the final package. That approach might also let me delete the complexity around PendingInts.",
              "createdAt": "2017-05-09T18:33:27Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 41,
              "body": "Done.",
              "createdAt": "2017-05-09T18:37:27Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 105,
              "body": "I'm blindly copying headers from `part`, but it's up to the package author to make sure they only put `Vary`-enabled headers there. I've now checked this in text_format.go, and we should check it in the CBOR parser once it's implemented.\r\n\r\nhttps://github.com/jyasskin/webpackage/blob/remove-redundant-resource-keys/README.md#main-content has the definition of `resource-key`.",
              "createdAt": "2017-05-09T18:41:33Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE4NDYzNTcy",
      "title": "Update the unsigned examples for the new format.",
      "url": "https://github.com/WICG/webpackage/pull/50",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This uses the tool from #49.",
      "createdAt": "2017-05-02T00:01:38Z",
      "updatedAt": "2017-05-17T18:50:39Z",
      "closedAt": "2017-05-17T18:50:35Z",
      "mergedAt": "2017-05-17T18:50:35Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTA1Mzk=",
          "commit": {
            "abbreviatedOid": "3aa18c2"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-05-17T18:25:11Z",
          "updatedAt": "2017-05-17T18:25:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE5NTQxOTA1",
      "title": "Split the Local Sharing use case into shapshots and signed apps.",
      "url": "https://github.com/WICG/webpackage/pull/51",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Is there a more official link to the Chrome MHTML work than http://www.techgainer.com/enable-single-file-mhtml-support-chrome/?",
      "createdAt": "2017-05-08T21:44:44Z",
      "updatedAt": "2017-05-24T00:16:03Z",
      "closedAt": "2017-05-24T00:16:01Z",
      "mergedAt": "2017-05-24T00:16:01Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTcyOTI=",
          "commit": {
            "abbreviatedOid": "1cabbfe"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-05-23T23:54:37Z",
          "updatedAt": "2017-05-23T23:54:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIwMDAzMTcy",
      "title": "Write a package in two passes, which lets me remove support for \"pending\" ints.",
      "url": "https://github.com/WICG/webpackage/pull/53",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It also removes the O(#parts^2) slowdown from inserting offsets one at a time, and makes it possible to build packages larger than fit in memory.\r\n\r\n@mrdewitt",
      "createdAt": "2017-05-11T00:06:12Z",
      "updatedAt": "2017-05-23T23:44:46Z",
      "closedAt": "2017-05-23T23:44:44Z",
      "mergedAt": "2017-05-23T23:44:44Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MTA4MzA=",
          "commit": {
            "abbreviatedOid": "f058b5d"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "No major problems with this patch, I think it does make the process a little more readable. \r\n\r\nNow that this repo is getting bigger, you may want someone with Go readability (or at least reasonable amounts of experience) to review this code.",
          "createdAt": "2017-05-16T20:58:58Z",
          "updatedAt": "2017-05-16T21:35:34Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Not a go expert, but any reason you have a block here?",
              "createdAt": "2017-05-16T20:58:58Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            },
            {
              "originalPosition": 9,
              "body": "nit: this would be clearer if the name reflected that it is temporary",
              "createdAt": "2017-05-16T21:00:39Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            },
            {
              "originalPosition": 24,
              "body": "nit: blank line above",
              "createdAt": "2017-05-16T21:32:14Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Mzc2NDg=",
          "commit": {
            "abbreviatedOid": "f058b5d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-18T03:52:54Z",
          "updatedAt": "2017-05-18T04:00:05Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Done.",
              "createdAt": "2017-05-18T03:52:54Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            },
            {
              "originalPosition": 73,
              "body": "It seemed easier to read. Maybe it's not because it makes readers wonder why there's a block?",
              "createdAt": "2017-05-18T03:57:16Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            },
            {
              "originalPosition": 24,
              "body": "Removed.",
              "createdAt": "2017-05-18T03:58:29Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIwMTgwMTgx",
      "title": "Add a function to parse the text format from an inline manifest.",
      "url": "https://github.com/WICG/webpackage/pull/54",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This lets me write tests without adding a new file for each test.",
      "createdAt": "2017-05-11T19:12:44Z",
      "updatedAt": "2017-05-24T00:11:47Z",
      "closedAt": "2017-05-24T00:11:44Z",
      "mergedAt": "2017-05-24T00:11:44Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTc1MjM=",
          "commit": {
            "abbreviatedOid": "8d021eb"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-05-23T23:56:22Z",
          "updatedAt": "2017-05-23T23:56:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIxNTg4MDAz",
      "title": "Parse manifests",
      "url": "https://github.com/WICG/webpackage/pull/55",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There's no support yet for serializing the text format including manifest data, or serializing and signing the CBOR format.",
      "createdAt": "2017-05-19T21:42:51Z",
      "updatedAt": "2017-06-26T15:47:04Z",
      "closedAt": "2017-06-26T15:47:01Z",
      "mergedAt": "2017-06-26T15:47:01Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this need a rebase?  It looks like the 2 pass commit is part of this pull request.",
          "createdAt": "2017-05-23T23:53:26Z",
          "updatedAt": "2017-05-23T23:53:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Rebased.",
          "createdAt": "2017-05-24T00:11:11Z",
          "updatedAt": "2017-05-24T00:11:11Z"
        },
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "Any reason you haven't merged this?",
          "createdAt": "2017-06-26T15:41:50Z",
          "updatedAt": "2017-06-26T15:41:50Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I was waiting for an LGTM, but I guess you approved it in your first review. I'll merge.",
          "createdAt": "2017-06-26T15:46:41Z",
          "updatedAt": "2017-06-26T15:46:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjQ0NDc=",
          "commit": {
            "abbreviatedOid": "d636b01"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks great in general!  Just a few comments.",
          "createdAt": "2017-06-08T21:54:46Z",
          "updatedAt": "2017-06-08T23:04:24Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Can this list be expanded?",
              "createdAt": "2017-06-08T21:54:46Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 73,
              "body": "Any reason you didn't just use crypto.Signer? https://golang.org/src/crypto/crypto.go?s=3217:4212#L97\r\n",
              "createdAt": "2017-06-08T22:22:18Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 16,
              "body": "nit: maybe LoadCertificatesFromFile?  Into reads more like into the file to me.",
              "createdAt": "2017-06-08T23:03:05Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTEzMzA=",
          "commit": {
            "abbreviatedOid": "85421cd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T15:47:12Z",
          "updatedAt": "2017-06-09T15:47:12Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Sure, done. I could also use just `LoadCertificates()`. I had `Into` to distinguish it from a function that I've since removed.",
              "createdAt": "2017-06-09T15:47:12Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTc5OTk=",
          "commit": {
            "abbreviatedOid": "d976a35"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T16:14:04Z",
          "updatedAt": "2017-06-09T16:19:39Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "want a new line at eof?",
              "createdAt": "2017-06-09T16:14:04Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 1,
              "body": "Can you please add tests for each type of private key that we support?",
              "createdAt": "2017-06-09T16:14:43Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 1,
              "body": "Can be in another patch.",
              "createdAt": "2017-06-09T16:14:50Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDk0MDA=",
          "commit": {
            "abbreviatedOid": "a841da4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T03:51:18Z",
          "updatedAt": "2017-06-14T03:57:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Whoops, added.",
              "createdAt": "2017-06-14T03:51:18Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 1,
              "body": "Yep, filed #72.",
              "createdAt": "2017-06-14T03:56:47Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIyMTIwODUx",
      "title": "Improve readability.",
      "url": "https://github.com/WICG/webpackage/pull/56",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I'll try to get some experienced Go programmers to review this and suggest other ways to improve readability, as requested in https://github.com/dimich-g/webpackage/pull/53#pullrequestreview-38510830.",
      "createdAt": "2017-05-24T00:09:34Z",
      "updatedAt": "2017-06-02T22:50:30Z",
      "closedAt": "2017-06-02T22:50:26Z",
      "mergedAt": "2017-06-02T22:50:26Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIzODEzNTA1",
      "title": "Store URL and status in HTTP2 pseudoheaders.",
      "url": "https://github.com/WICG/webpackage/pull/60",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-06-02T22:49:44Z",
      "updatedAt": "2017-06-26T16:10:57Z",
      "closedAt": "2017-06-26T16:10:54Z",
      "mergedAt": "2017-06-26T16:10:54Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that the requested changes have been factored out, so this should be good to go.",
          "createdAt": "2017-06-26T16:09:13Z",
          "updatedAt": "2017-06-26T16:09:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjc2OTc=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "",
          "createdAt": "2017-06-09T21:40:29Z",
          "updatedAt": "2017-06-26T16:10:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I feel I should have asked before, but what is potential purpose to keep 'method' here? It seems to add to confusion because it's unclear how would that be processed by UA and what the method would exactly mean.",
              "createdAt": "2017-06-09T21:40:29Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            },
            {
              "originalPosition": 14,
              "body": "Same question about 200 - do we need it as part of the format? If not, it's probably better to remove and add later if/when the need arises.",
              "createdAt": "2017-06-09T21:41:12Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTA4NjQ=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-10T05:27:32Z",
          "updatedAt": "2017-06-10T05:27:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'm not sure we need `:method`: it's here because it's in HTTP2, but I don't know of any methods besides GET that we'd want to support. I think this is something the folks at the IETF might be able to give us useful feedback about. I've filed #70 to track this.",
              "createdAt": "2017-06-10T05:27:32Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTA5NDI=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-10T05:32:44Z",
          "updatedAt": "2017-06-10T05:32:45Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think we *do* have uses for other `:status`es: specifically, we should be able to store 301 and 302 redirections in the package. We could make 200 the default if the `:status` is omitted, but in HPACK it's a 1-byte overhead, so I didn't think omitting it was worthwhile.",
              "createdAt": "2017-06-10T05:32:44Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTk2MzA=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T16:21:19Z",
          "updatedAt": "2017-06-13T22:25:43Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "requestHeaders[4:] is sprinkled around this pull request, can you refactor it a bit so it's clearer what you are referring to?",
              "createdAt": "2017-06-09T16:21:19Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            },
            {
              "originalPosition": 37,
              "body": "Same with responseHeaders[1:]",
              "createdAt": "2017-06-09T16:21:28Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDg4NTM=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T03:44:53Z",
          "updatedAt": "2017-06-14T03:44:53Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done.",
              "createdAt": "2017-06-14T03:44:53Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDkxNzY=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T03:48:30Z",
          "updatedAt": "2017-06-14T03:48:30Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Is it all right if I submit this PR and send a separate one to remove `:method`? I think that'll do better to focus discussion on whether it's a good idea to diverge from HTTP2 here.",
              "createdAt": "2017-06-14T03:48:30Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDg2Mzg=",
          "commit": {
            "abbreviatedOid": "3a8ab0d"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-26T16:08:49Z",
          "updatedAt": "2017-06-26T16:08:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIzODE4OTc0",
      "title": "Rearrange writing the resource body so it doesn't have to materialize in memory.",
      "url": "https://github.com/WICG/webpackage/pull/61",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Using a Writer makes it easier to hash the resource at the same time it's being written to the CBOR serialization.",
      "createdAt": "2017-06-02T23:55:40Z",
      "updatedAt": "2017-06-14T03:31:44Z",
      "closedAt": "2017-06-14T03:31:41Z",
      "mergedAt": "2017-06-14T03:31:41Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODA0Mzk=",
          "commit": {
            "abbreviatedOid": "1b764c4"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-13T23:19:15Z",
          "updatedAt": "2017-06-13T23:45:31Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "if bw.item.Write fails, is n negative?",
              "createdAt": "2017-06-13T23:19:15Z",
              "updatedAt": "2017-06-13T23:45:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDc2MzM=",
          "commit": {
            "abbreviatedOid": "1b764c4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T03:31:17Z",
          "updatedAt": "2017-06-14T03:31:17Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "According to https://golang.org/pkg/bufio/#Writer.Write and https://golang.org/pkg/io/#Writer, no: Go uses the err return instead of negative lengths to convey errors.",
              "createdAt": "2017-06-14T03:31:17Z",
              "updatedAt": "2017-06-14T03:31:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIzODIwMjkx",
      "title": "Write signed manifests to the CBOR format.",
      "url": "https://github.com/WICG/webpackage/pull/62",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This sits on top of #55, #60, #61, #63, #64, #65, and #66. Sorry that it's so long again.",
      "createdAt": "2017-06-03T00:16:13Z",
      "updatedAt": "2018-04-10T23:25:50Z",
      "closedAt": "2018-04-10T23:25:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjc5MDk=",
          "commit": {
            "abbreviatedOid": "51fd9d3"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-26T17:26:19Z",
          "updatedAt": "2017-06-26T17:48:25Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "micro nit: process \"date\" first to match the order in the spec",
              "createdAt": "2017-06-26T17:26:19Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            },
            {
              "originalPosition": 38,
              "body": "is it more canonical to name the return value than to declare one in the first line of the function?",
              "createdAt": "2017-06-26T17:33:58Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            },
            {
              "originalPosition": 216,
              "body": "Does this actually verify that signingCert corresponds to a DNSName of \"example.com\"?  Does it make sense to add a test for attempts to sign a package with no signatures corresponding to the origin?",
              "createdAt": "2017-06-26T17:47:48Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NjI2NzI=",
          "commit": {
            "abbreviatedOid": "51fd9d3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-02T23:41:52Z",
          "updatedAt": "2017-08-02T23:41:52Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "Done.",
              "createdAt": "2017-08-02T23:41:52Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NjI2NzM=",
          "commit": {
            "abbreviatedOid": "51fd9d3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-02T23:41:54Z",
          "updatedAt": "2017-08-02T23:41:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I don't know, but I can do that instead.",
              "createdAt": "2017-08-02T23:41:54Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NjI2NzY=",
          "commit": {
            "abbreviatedOid": "51fd9d3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-02T23:41:56Z",
          "updatedAt": "2017-08-02T23:41:56Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "Yes, and I've added an extra test with the wrong DNSName to check that.\r\n\r\nAnd I've added a check that at least one signature covers the package's origin.",
              "createdAt": "2017-08-02T23:41:56Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NDg5MDA4",
      "title": "Refine the algorithm for hashing a resource.",
      "url": "https://github.com/WICG/webpackage/pull/63",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Headers are decompressed before being hashed.",
      "createdAt": "2017-06-07T18:35:11Z",
      "updatedAt": "2017-06-14T03:33:42Z",
      "closedAt": "2017-06-14T03:33:39Z",
      "mergedAt": "2017-06-14T03:33:39Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to get these merged, and then send another PR to remove `:method`.",
          "createdAt": "2017-06-14T03:33:35Z",
          "updatedAt": "2017-06-14T03:33:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODQyMDM=",
          "commit": {
            "abbreviatedOid": "8f53788"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm pending the :method discussion.",
          "createdAt": "2017-06-13T23:46:30Z",
          "updatedAt": "2017-06-13T23:46:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NDkwNzI0",
      "title": "Define how to pick a signing algorithm based on a certificate's public key.",
      "url": "https://github.com/WICG/webpackage/pull/64",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And add some Go code to sign a message into a byte string.",
      "createdAt": "2017-06-07T18:43:49Z",
      "updatedAt": "2017-06-17T04:31:34Z",
      "closedAt": "2017-06-17T04:31:31Z",
      "mergedAt": "2017-06-17T04:31:31Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I checked with @sleevi, who thinks this set is ok. We may need to add RSA-4096 in the future, but because intermediates and roots tend to be 2048 bits, those don't actually add security.",
          "createdAt": "2017-06-17T04:30:36Z",
          "updatedAt": "2017-06-17T04:30:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODU4NzA=",
          "commit": {
            "abbreviatedOid": "33eef8b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T15:26:38Z",
          "updatedAt": "2017-06-09T15:28:30Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Moved @mrdewitt's comment from https://github.com/WICG/webpackage/pull/55#discussion_r121008410:\r\n\r\n> Can this list be expanded?",
              "createdAt": "2017-06-09T15:26:38Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 73,
              "body": "Moved @mrdewitt's comment from https://github.com/WICG/webpackage/pull/55#discussion_r121012844:\r\n\r\n> Any reason you didn't just use crypto.Signer? https://golang.org/src/crypto/crypto.go?s=3217:4212#L97",
              "createdAt": "2017-06-09T15:27:52Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODgxMDI=",
          "commit": {
            "abbreviatedOid": "33eef8b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T15:35:17Z",
          "updatedAt": "2017-06-09T15:35:17Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Yes, but the expansion can't be implemented in Go yet. e.g. ed25519 is an obvious extension, but it's missing from their crypto library. For now, it doesn't matter because there are no TLS certificates with public key types other than the ones here (except perhaps for really long RSA keys).",
              "createdAt": "2017-06-09T15:35:17Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODkzNDM=",
          "commit": {
            "abbreviatedOid": "33eef8b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T15:39:59Z",
          "updatedAt": "2017-06-09T15:39:59Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "crypto.Signer requires that the caller hash the message, while this file incorporates the hash into the Sign() function. I could replace the rsa.SignPSS call with s.privKey.Sign(..., & PSSOptions{Hash:s.Hash}), but that doesn't seem any clearer, and the [documentation](https://golang.org/pkg/crypto/rsa/#PrivateKey.Sign) says \"Common uses should use the Sign* functions in this package.\"",
              "createdAt": "2017-06-09T15:39:59Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODQ1MTQ=",
          "commit": {
            "abbreviatedOid": "33eef8b"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-13T23:49:12Z",
          "updatedAt": "2017-06-14T15:53:47Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "https://bugs.chromium.org/p/chromium/issues/detail?id=478225\r\n\r\nChrome doesn't appear to support secp521r1. Shall we omit this from this format as well?",
              "createdAt": "2017-06-13T23:49:13Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 12,
              "body": "Imports should probably be migrated to WICG",
              "createdAt": "2017-06-13T23:50:28Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 46,
              "body": "Is this actually inequality, or should we be listing explicit bit lengths that are accepted?",
              "createdAt": "2017-06-14T00:08:03Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 55,
              "body": "I wish these were pre-defined constants somewhere. But I didn't see that in a brief overview of crypto/elliptic",
              "createdAt": "2017-06-14T15:53:04Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 4,
              "body": "nit: link?",
              "createdAt": "2017-06-14T15:53:41Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjY1MjQ=",
          "commit": {
            "abbreviatedOid": "932f36b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "@sleevi, this patch now says the format only supports RSA2048, secp256r1, and secp384r1. Is that the right set, in order to capture nearly all existing TLS leaf certificates and avoid putting too much flexibility in the protocol?",
          "createdAt": "2017-06-14T16:01:39Z",
          "updatedAt": "2017-06-14T16:56:10Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Interesting. Sounds good, to reduce the amount of flexibility in the protocol.",
              "createdAt": "2017-06-14T16:01:39Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 46,
              "body": "Right now, it's actually inequality, but I think you're right that we should just list explicit lengths.",
              "createdAt": "2017-06-14T16:37:39Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 4,
              "body": "Added.",
              "createdAt": "2017-06-14T16:40:06Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 55,
              "body": "I could use elliptic.P256().Params().Name.",
              "createdAt": "2017-06-14T16:42:40Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 12,
              "body": "Thanks, done in b8ae7b5797550d28f94edcbf461e6d96ac9071eb.",
              "createdAt": "2017-06-14T16:44:39Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NDk2MzE3",
      "title": "Remove unused code from Package.",
      "url": "https://github.com/WICG/webpackage/pull/65",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-06-07T19:13:11Z",
      "updatedAt": "2017-06-14T15:58:32Z",
      "closedAt": "2017-06-14T15:58:29Z",
      "mergedAt": "2017-06-14T15:58:29Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjQyODg=",
          "commit": {
            "abbreviatedOid": "e2215ba"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-14T15:54:21Z",
          "updatedAt": "2017-06-14T15:54:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NDk4OTEw",
      "title": "Add a simple CBOR parser to make it easier to test the CBOR writer.",
      "url": "https://github.com/WICG/webpackage/pull/66",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-06-07T19:26:32Z",
      "updatedAt": "2017-06-14T16:59:27Z",
      "closedAt": "2017-06-14T16:59:24Z",
      "mergedAt": "2017-06-14T16:59:24Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjUxODc=",
          "commit": {
            "abbreviatedOid": "f79658a"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-14T15:57:20Z",
          "updatedAt": "2017-06-14T16:03:29Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: not clear what \"full\" is at first glance.",
              "createdAt": "2017-06-14T15:57:20Z",
              "updatedAt": "2017-06-14T16:58:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjk2Njc=",
          "commit": {
            "abbreviatedOid": "f79658a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T16:12:52Z",
          "updatedAt": "2017-06-14T16:12:52Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yeah, it's the full buffer that's being decoded. Does this just need a comment, or would you rather some other name?",
              "createdAt": "2017-06-14T16:12:52Z",
              "updatedAt": "2017-06-14T16:58:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNzExOTc=",
          "commit": {
            "abbreviatedOid": "f79658a"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T16:18:27Z",
          "updatedAt": "2017-06-14T16:18:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "probably prefer something like cborBytes or cborBuffer but that might just be my verbose C++ history. I leave it up to you.",
              "createdAt": "2017-06-14T16:18:27Z",
              "updatedAt": "2017-06-14T16:58:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwODE4OTk=",
          "commit": {
            "abbreviatedOid": "f79658a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T16:58:58Z",
          "updatedAt": "2017-06-14T16:58:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Sure, done.",
              "createdAt": "2017-06-14T16:58:58Z",
              "updatedAt": "2017-06-14T16:58:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NTQxMzk5",
      "title": "Add support for encrypted and missing keys to wpktext2cbor.",
      "url": "https://github.com/WICG/webpackage/pull/67",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This depends on #62.",
      "createdAt": "2017-06-07T23:49:55Z",
      "updatedAt": "2018-04-10T23:26:01Z",
      "closedAt": "2018-04-10T23:26:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NTQxNDU1",
      "title": "Update the signed one-origin example.",
      "url": "https://github.com/WICG/webpackage/pull/68",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This update was generated using #67, but we can commit it without all that code.",
      "createdAt": "2017-06-07T23:50:29Z",
      "updatedAt": "2017-06-26T16:23:04Z",
      "closedAt": "2017-06-08T23:46:43Z",
      "mergedAt": "2017-06-08T23:46:43Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "This looks good. Merging...",
          "createdAt": "2017-06-08T23:46:57Z",
          "updatedAt": "2017-06-08T23:46:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI4NDY0NDk3",
      "title": "Write an internet draft",
      "url": "https://github.com/WICG/webpackage/pull/76",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #71. I'm going to submit the draft to the IETF before this is reviewed in order to make their July 3 deadline, but I definitely want y'all to point out problems so I can fix them in the next draft.\r\n\r\nI've pre-emptively removed the :method header (#70) and changed the `sections` map into an array, and I'll backfill those into the explainer and implementation when I get a bit more time.",
      "createdAt": "2017-06-30T23:07:58Z",
      "updatedAt": "2017-08-14T23:58:07Z",
      "closedAt": "2017-08-14T23:58:02Z",
      "mergedAt": "2017-08-14T23:58:01Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this to make it easier for me to build on top of it. Feel free to send other comments or file bugs about what needs to change.",
          "createdAt": "2017-08-14T23:46:03Z",
          "updatedAt": "2017-08-14T23:46:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDQ0MTk=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-07-06T19:50:18Z",
          "updatedAt": "2017-07-06T23:52:52Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "is it normal to use Chromium or Google addresses here?",
              "createdAt": "2017-07-06T19:50:18Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 34,
              "body": "nit: remove \"then\"",
              "createdAt": "2017-07-06T19:50:56Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 62,
              "body": "is \"web application\" well defined?",
              "createdAt": "2017-07-06T19:52:10Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 63,
              "body": "What is TLS-type?  Cryptographic?  PKI-based?",
              "createdAt": "2017-07-06T20:41:23Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 96,
              "body": "Do we envision tools other than browsers using this?  I can think possibly an \"explode to filesystem\" tool would be necesary as well",
              "createdAt": "2017-07-06T20:43:15Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 135,
              "body": "any reason overlap is allowed?",
              "createdAt": "2017-07-06T20:48:36Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 252,
              "body": "perhaps clearer if this said \"the HPACK dynamic table\"",
              "createdAt": "2017-07-06T22:43:40Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 252,
              "body": "Also, this is the first reference to the dynamic table, and is confusingly terse.",
              "createdAt": "2017-07-06T22:54:04Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 281,
              "body": "Have you thought about the issue with how (in loading a package) the browsers will generate requests with headers in a particular order?",
              "createdAt": "2017-07-06T22:56:17Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 373,
              "body": "\"as a subset\" isn't very clear to me, perhaps this is mathematician lingo though?",
              "createdAt": "2017-07-06T23:01:05Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 399,
              "body": "\"Try to find\" is unclear, perhaps something like \"iterate through signing-certificates until one is found that has an identity matching ...",
              "createdAt": "2017-07-06T23:04:17Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 422,
              "body": "Perhaps reorder this paragraph after the cddl defining a subpackage?",
              "createdAt": "2017-07-06T23:05:42Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 463,
              "body": "nit: Could use an example.",
              "createdAt": "2017-07-06T23:06:46Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 575,
              "body": "Does this mean that packages become unusable after 7-30 days offline?",
              "createdAt": "2017-07-06T23:51:39Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODA1MzM=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:22:11Z",
          "updatedAt": "2017-08-04T21:22:12Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Folks seem to vary. Several people use @google, but https://tools.ietf.org/html/rfc6797 uses a personal address.",
              "createdAt": "2017-08-04T21:22:11Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODA5ODA=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:24:30Z",
          "updatedAt": "2017-08-04T21:24:30Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I don't know a well-defined term for this. \"Install\" doesn't work well with \"websites\", which also isn't particularly defined. \"Service workers\" have a defined install step, but it's not obvious that we want to insist on service workers for these packages. Any suggestions?",
              "createdAt": "2017-08-04T21:24:30Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODE1NjM=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:27:46Z",
          "updatedAt": "2017-08-04T21:27:46Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "That's true, but I'm not sure it addresses the need for standardization?",
              "createdAt": "2017-08-04T21:27:46Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODE2NTg=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:28:12Z",
          "updatedAt": "2017-08-04T21:28:12Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "We can't prohibit overlap without forcing extra work onto parsers. ",
              "createdAt": "2017-08-04T21:28:12Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODMzMDg=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:37:34Z",
          "updatedAt": "2017-08-04T21:37:35Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Yes! That'll appear in the W3C spec about browsers loading packages, but basically, we're not going to (can't) locate resources by looking for an exact match between the headers the browser would generate and the key in the index. Instead, the browser will have to use its request information to pick the best of the options provided by the package.",
              "createdAt": "2017-08-04T21:37:34Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY1OTc=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:58:24Z",
          "updatedAt": "2017-08-04T21:58:24Z",
          "comments": [
            {
              "originalPosition": 575,
              "body": "Yes, although there'll be a cheap way to update them and to distribute those updates offline. I can make an argument that we should let a package live forever on a given device as long as that device _never_ goes online, but I'm not sure it'll convince everyone.",
              "createdAt": "2017-08-04T21:58:24Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3ODA=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:28Z",
          "updatedAt": "2017-08-04T21:59:28Z",
          "comments": [
            {
              "originalPosition": 463,
              "body": "Done.",
              "createdAt": "2017-08-04T21:59:28Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3ODE=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:29Z",
          "updatedAt": "2017-08-04T21:59:29Z",
          "comments": [
            {
              "originalPosition": 422,
              "body": "Done.",
              "createdAt": "2017-08-04T21:59:29Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3ODU=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:31Z",
          "updatedAt": "2017-08-04T21:59:31Z",
          "comments": [
            {
              "originalPosition": 399,
              "body": "Great, thanks.",
              "createdAt": "2017-08-04T21:59:31Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3OTE=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:33Z",
          "updatedAt": "2017-08-04T21:59:33Z",
          "comments": [
            {
              "originalPosition": 373,
              "body": "Yes, derived from a function being a particular kind of [relation](https://en.wikipedia.org/wiki/Binary_relation), which is a set of pairs; but this document should be comprehensible to non-mathematicians, so I've changed it.",
              "createdAt": "2017-08-04T21:59:33Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3OTk=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:35Z",
          "updatedAt": "2017-08-04T21:59:35Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Yeah ... How about I delete this comment about the dynamic table and rely on the actual parsing described below.",
              "createdAt": "2017-08-04T21:59:35Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY4MDU=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:39Z",
          "updatedAt": "2017-08-04T21:59:39Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "How's this?",
              "createdAt": "2017-08-04T21:59:39Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY4MTI=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:42Z",
          "updatedAt": "2017-08-04T21:59:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Done.",
              "createdAt": "2017-08-04T21:59:42Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI4NDY3MDUw",
      "title": "Describe the TAG's draft as out-of-date.",
      "url": "https://github.com/WICG/webpackage/pull/77",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I've heard from at least two people who started reading the TAG's document instead of this one because of how prominently we highlight it.",
      "createdAt": "2017-06-30T23:41:37Z",
      "updatedAt": "2017-07-31T15:31:50Z",
      "closedAt": "2017-07-28T23:52:36Z",
      "mergedAt": "2017-07-28T23:52:36Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Can we also update the TAG document to point to this one? Their version is one of the top links when you search for \"web packaging\". \r\n\r\n/cc @triblondon",
          "createdAt": "2017-07-28T22:32:03Z",
          "updatedAt": "2017-07-28T22:32:03Z"
        },
        {
          "author": "triblondon",
          "authorAssociation": "NONE",
          "body": "That sounds like a sensible idea.  I'm happy to push that change.",
          "createdAt": "2017-07-28T22:35:05Z",
          "updatedAt": "2017-07-28T22:35:05Z"
        },
        {
          "author": "triblondon",
          "authorAssociation": "NONE",
          "body": "Oh, actually since the TAG version is also published in W3C TR space I think I will have to pass the buck to @ylafon",
          "createdAt": "2017-07-28T22:37:15Z",
          "updatedAt": "2017-07-28T22:37:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks @triblondon and @ylafon. And I've taken @KenjiBaheux's suggestion to strike out the link, although I'm not sure that's necessary.",
          "createdAt": "2017-07-28T22:58:46Z",
          "updatedAt": "2017-07-28T22:58:46Z"
        },
        {
          "author": "ylafon",
          "authorAssociation": "NONE",
          "body": "Yes, I already amended the README, and will fix both the old edcopy and in /TR/",
          "createdAt": "2017-07-31T12:35:54Z",
          "updatedAt": "2017-07-31T12:35:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks @ylafon!",
          "createdAt": "2017-07-31T15:31:50Z",
          "updatedAt": "2017-07-31T15:31:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NzkwODQ=",
          "commit": {
            "abbreviatedOid": "90b0e33"
          },
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "That's probably enough. If it's available, strike through or a footnote for the link, would make it more obvious or less prone to confusion.",
          "createdAt": "2017-07-06T22:19:32Z",
          "updatedAt": "2017-07-06T22:19:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM1ODY5NTU0",
      "title": "An initial use-cases document for the web packaging proposal.",
      "url": "https://github.com/WICG/webpackage/pull/80",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/draft-webpackage-use-cases/draft-yasskin-webpackage-use-cases.html\r\n\r\n@mnot, you seemed to have some use cases for signing individual request/response/body triples, but I don't remember what they were. Could you list a couple so I can add them to this document?",
      "createdAt": "2017-08-15T19:09:33Z",
      "updatedAt": "2017-08-25T23:35:58Z",
      "closedAt": "2017-08-25T23:35:55Z",
      "mergedAt": "2017-08-25T23:35:55Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0ODcwNzI=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "great doc!  Just a few comments.",
          "createdAt": "2017-08-15T22:21:33Z",
          "updatedAt": "2017-08-15T23:15:09Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "These requirements are associated but no explanation is given why they are associated.",
              "createdAt": "2017-08-15T22:21:33Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            },
            {
              "originalPosition": 344,
              "body": "Is this worth a little more enumeration?  Confidentiality comes up repeatedly in discussions and it'd be good to ensure that rehashing is minimized.",
              "createdAt": "2017-08-15T23:13:22Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            },
            {
              "originalPosition": 47,
              "body": "Is there some line in the list of priorities that we won't cross?  Is Http/2 push essential to this document? is offline browsing?",
              "createdAt": "2017-08-15T23:14:57Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3OTQxMDg=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-16T23:41:52Z",
          "updatedAt": "2017-08-16T23:41:52Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I'd say that everything below https://jyasskin.github.io/webpackage/draft-webpackage-use-cases/draft-yasskin-webpackage-use-cases.html#security-review is nice-to-have. Do you think I should split the use-cases into \"essential\" and \"nice-to-have\" buckets to reflect that?",
              "createdAt": "2017-08-16T23:41:52Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3OTQyMzM=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-16T23:42:47Z",
          "updatedAt": "2017-08-16T23:42:47Z",
          "comments": [
            {
              "originalPosition": 344,
              "body": "How's this?",
              "createdAt": "2017-08-16T23:42:47Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3OTQyNzU=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-16T23:43:06Z",
          "updatedAt": "2017-08-16T23:43:06Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I'll add a sentence to all the associated requirements. That's not done yet.",
              "createdAt": "2017-08-16T23:43:06Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMjAzNTE=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-17T18:49:19Z",
          "updatedAt": "2017-08-17T18:49:19Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Done.",
              "createdAt": "2017-08-17T18:49:19Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMjA4MDQ=",
          "commit": {
            "abbreviatedOid": "3c73dfe"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "still lgtm",
          "createdAt": "2017-08-17T18:50:55Z",
          "updatedAt": "2017-08-17T18:51:21Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Thanks!",
              "createdAt": "2017-08-17T18:50:55Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            },
            {
              "originalPosition": 344,
              "body": "thanks, looks good",
              "createdAt": "2017-08-17T18:51:13Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM3MzM5MTQy",
      "title": "Start an Internet Draft for signed single responses.",
      "url": "https://github.com/WICG/webpackage/pull/81",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/draft-yasskin-origin-signed-responses/draft-yasskin-http-origin-signed-responses.html\r\n\r\nThis doesn't yet have a design, just some use cases and constraints on the design. I also haven't yet worked out how this would fit into a bundling proposal. It's possible that it doesn't.\r\n\r\n@nyaxt @KenjiBaheux @mnot @mikewest",
      "createdAt": "2017-08-23T23:22:22Z",
      "updatedAt": "2017-08-31T19:40:29Z",
      "closedAt": "2017-08-31T19:40:26Z",
      "mergedAt": "2017-08-31T19:40:26Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to commit this so I can start discussion on the httpbis mailing list. Of course feel free to suggest more changes either here or there.",
          "createdAt": "2017-08-31T19:38:44Z",
          "updatedAt": "2017-08-31T19:38:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg3ODYxNzM=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-26T00:00:24Z",
          "updatedAt": "2017-08-26T00:00:24Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "@igrigorik, could you check that these performance-related use cases for signed **single** responses make sense? (https://jyasskin.github.io/webpackage/draft-yasskin-origin-signed-responses/draft-yasskin-http-origin-signed-responses.html#use-cases)\r\n\r\nI added some explicit text to the [packaging use cases](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html) to discourage folks from thinking of them as a performance tool, but with fewer use cases overall for non-bundled signed responses, I'm left with the performance ones here.",
              "createdAt": "2017-08-26T00:00:24Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjcyNjA=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-28T21:00:11Z",
          "updatedAt": "2017-08-28T21:00:11Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "The overall use case makes sense, but enumerating CDNs in markup is painful. Could this be elevated to a document-level opt-in (e.g. via response header or meta directive) that notifies UA that content on this origin can also be fetched from cdn.com? Specifically, say I detect that user is coming from Geo-region X, or mobile network Y, and I have edge caches optimized for each of those... I'd like to emit a header that notifies UA that it can fetch from X or Y; rewriting HTML is super painful.",
              "createdAt": "2017-08-28T21:00:11Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjc3Mzg=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-28T21:02:10Z",
          "updatedAt": "2017-08-28T21:02:10Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "This may be out of scope, but.. is content-addressable caching something to consider? You note that we want to sign headers+body, but what about cases where I only care about body -- e.g. I don't particularly care which CDN you fetch jquery.v.1.2.3.js from, as long as its content signature matches. ",
              "createdAt": "2017-08-28T21:02:10Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwOTY5NzM=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-28T23:32:59Z",
          "updatedAt": "2017-08-29T00:07:02Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "A custom element could certainly do that sort of dispatching. Following the Extensible Web Manifesto though, I'm inclined to let folks actually write some custom elements for this before baking a URL transformation into browsers.",
              "createdAt": "2017-08-28T23:32:59Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            },
            {
              "originalPosition": 102,
              "body": "There are two separable features here:\r\n\r\n1. Content-addressed caching where the resource original author is willing to vouch for the resource's actual URL. That is, if you have content with the same logical URL and a good signature, you can use it without contacting the CDN. (But this isn't actually content-addressing; it's URL-addressing again.) I think this is safe from a same-origin perspective, but I'm not sufficiently current with the SRI folks' discussion of content-addressing to know if it solves their privacy worries. @mikewest?\r\n2. Cases where you only care about the content, and not its URL. I think this doesn't make sense for signed content: the point of a public keypair is that you can sign more than one thing with it, but then which data signed with the provided public key are you actually trying to use?\r\n\r\nSo ... I'm happy to consider content-addressing, but I think I don't understand what you mean by it in this context.",
              "createdAt": "2017-08-29T00:06:41Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxMDc1MDQ=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-29T00:55:13Z",
          "updatedAt": "2017-08-29T00:55:13Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "FWIW, I'm skeptical that's a scalable way to do this, or even required one for this use case.. What I'm describing is another iteration on base tag.",
              "createdAt": "2017-08-29T00:55:13Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxMDc4NjU=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-29T00:58:18Z",
          "updatedAt": "2017-08-29T00:58:19Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "My question is mostly as an exercise to identify whether this is in or out of scope of this proposal. Specifically, you call out signing headers+body, but signing body only may have merit in context of sharing responses -- that said, you're right in this case you cant be signing with your key, so perhaps that's out of scope.",
              "createdAt": "2017-08-29T00:58:18Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3MjczMjQ=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-31T00:04:31Z",
          "updatedAt": "2017-08-31T00:04:31Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "I've added a link to https://github.com/mikewest/signature-based-sri/issues/5 arguing that it's unsafe to sign just-a-body, with any key. :smiling_imp: ",
              "createdAt": "2017-08-31T00:04:31Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM4MDMxOTE5",
      "title": "Add notes to requirements saying when they conflict with re-using MHTML or ZIP.",
      "url": "https://github.com/WICG/webpackage/pull/82",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview in https://jyasskin.github.io/webpackage/alex-changes/draft-yasskin-webpackage-use-cases.html.\r\n\r\nDid I miss anything obvious or say anything incorrect?\r\n\r\nThis also adds an explicit \"Implementations are hard to get wrong\" requirement.",
      "createdAt": "2017-08-28T20:36:47Z",
      "updatedAt": "2017-08-30T20:50:42Z",
      "closedAt": "2017-08-30T20:50:39Z",
      "mergedAt": "2017-08-30T20:50:39Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Hm, I omitted a date because I can't find a publication date in https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html. Its latest copyright is 2014, so maybe that's the right thing to use? Done.\r\n\r\nI don't see a way to write down a retrieval date in [`<reference>`](https://tools.ietf.org/html/rfc7749#section-2.30).",
          "createdAt": "2017-08-28T20:47:35Z",
          "updatedAt": "2017-08-28T21:03:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjE4OTg=",
          "commit": {
            "abbreviatedOid": "fe40308"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm, but do we need a date on the JAR spec retrieval?",
          "createdAt": "2017-08-28T20:40:49Z",
          "updatedAt": "2017-08-28T20:40:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM4MDMyMjA2",
      "title": "Add a distinct Web Publications use case.",
      "url": "https://github.com/WICG/webpackage/pull/83",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview in https://jyasskin.github.io/webpackage/alex-changes/draft-yasskin-webpackage-use-cases.html.\r\n\r\nThis also adds a \"Metadata\" requirement from https://www.w3.org/TR/pwp-ucr/#archmetadata, which is also used by the offline-installation use case.",
      "createdAt": "2017-08-28T20:38:14Z",
      "updatedAt": "2017-08-30T20:55:48Z",
      "closedAt": "2017-08-30T20:55:46Z",
      "mergedAt": "2017-08-30T20:55:46Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 84,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM5NjM2NDg5",
      "title": "Updates to the origin-signing draft in response to IETF comments.",
      "url": "https://github.com/WICG/webpackage/pull/84",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See the thread starting at https://lists.w3.org/Archives/Public/ietf-http-wg/2017JulSep/0385.html.\r\n\r\nPreview at https://jyasskin.github.io/webpackage/signed-responses-update/draft-yasskin-http-origin-signed-responses.html",
      "createdAt": "2017-09-06T18:43:46Z",
      "updatedAt": "2017-11-22T17:23:10Z",
      "closedAt": "2017-11-17T19:40:38Z",
      "mergedAt": "2017-11-17T19:40:38Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQwMTQ1Njcz",
      "title": "Add a status to the README, and separate the Explainer.",
      "url": "https://github.com/WICG/webpackage/pull/85",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I hope this'll make it a little easier to follow along as things move into formal standards bodies.",
      "createdAt": "2017-09-08T23:57:57Z",
      "updatedAt": "2017-09-11T15:56:55Z",
      "closedAt": "2017-09-11T15:56:52Z",
      "mergedAt": "2017-09-11T15:56:52Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUzNDExMzEx",
      "title": "Add a security consideration to revoke keys exposed by a signing oracle.",
      "url": "https://github.com/WICG/webpackage/pull/87",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "How's this, @agl, @sleevi?",
      "createdAt": "2017-11-17T22:48:27Z",
      "updatedAt": "2017-11-20T17:17:06Z",
      "closedAt": "2017-11-20T17:08:39Z",
      "mergedAt": "2017-11-20T17:08:39Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "agl",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense. Coincidentally, [here's](https://support.f5.com/csp/article/K21905460) a vulnerability from F5, published yesterday, that lets attackers get signatures from an online TLS key.",
          "createdAt": "2017-11-18T19:17:33Z",
          "updatedAt": "2017-11-18T19:17:33Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks. I would not have guessed that an \"Adaptive Chosen Ciphertext attack\" would lead to a signing oracle, which makes me worry that folks won't know to revoke their key after this sort of vulnerability.",
          "createdAt": "2017-11-20T17:17:05Z",
          "updatedAt": "2017-11-20T17:17:05Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 88,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0MDI2NzI2",
      "title": "A rough proposal for signing HTTP exchanges.",
      "url": "https://github.com/WICG/webpackage/pull/88",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There's a preview at https://jyasskin.github.io/webpackage/design-signatures/draft-yasskin-http-origin-signed-responses.html#proposal\r\n\r\nWhat's clearly broken about this? Is the complexity of allowing either plain responses or encapsulated request headers worth it?\r\n\r\nI updated the validity algorithm to handle raw public keys and to return exactly which headers are trustworthy, but I did it quickly, so there could be mistakes there.",
      "createdAt": "2017-11-21T23:22:49Z",
      "updatedAt": "2017-12-05T19:32:25Z",
      "closedAt": "2017-12-05T19:32:21Z",
      "mergedAt": "2017-12-05T19:32:21Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this and publish it as an IETF draft so we can start discussing on the httpbis mailing list. More comments are, of course, welcome, either here or there.",
          "createdAt": "2017-12-05T19:30:11Z",
          "updatedAt": "2017-12-05T19:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzgzMzQ2MDI=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-22T04:44:21Z",
          "updatedAt": "2017-11-22T04:44:21Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "@otherdaniel / @mikewest Does this look like it'll handle what https://github.com/mikewest/signature-based-sri needs? (The algorithm that uses it is at https://wicg.github.io/webpackage/design-signatures/draft-yasskin-http-origin-signed-responses.html#signature-validity)",
              "createdAt": "2017-11-22T04:44:21Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzgzNDkzMDE=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-22T06:59:54Z",
          "updatedAt": "2017-11-22T06:59:54Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "In broad strokes, I think this would support the SRI proposal. I'm not sure about some details, but if we were designing something _just_ for the SRI use case, I think we'd end up with something sufficiently similar to this that we should just squint at it until it's the same. I'm willing to live with some \"cruft\" (from my feature's perspective) in order to not invent a custom new thing just for my use case. :)\r\n\r\nThat said, https://github.com/mikewest/signature-based-sri/issues/5#issuecomment-345212824 suggested looking into https://tools.ietf.org/html/draft-cavage-http-signatures-08, which does similar things to this proposal, with a different spelling, and somewhat different characteristics (no certs, for instance). It does tack headers into the message to be signed, which is appealing (binding the resource to a `Content-Type`, for instance, might be valuable).\r\n\r\nI know you've thought about that use case. What do you think about supporting it in this way?",
              "createdAt": "2017-11-22T06:59:54Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg1MjA5MDY=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-22T17:15:35Z",
          "updatedAt": "2017-11-22T17:15:35Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "This is definitely still open for tweaking. For example, I could replace the `ed25519Key=*base64` field with a CSP-style `key=ed25519-base64` [label](https://mnot.github.io/I-D/structured-headers/#label). I didn't because that takes an extra level of parsing to actually check the signature in this spec, but it's certainly possible.\r\n\r\nIt's plausible that we should have totally separate headers for the \"give extra assurance when the physical and logical request are the same\" case from the \"assert a request/response pair that my normal certificate doesn't cover\" case. Even for the extra-assurance case, draft-cavage-http-signatures has some problems:\r\n1. Specifying the algorithm next to the key is bad practice nowadays because it leads to things like https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/.\r\n1. Using a keyId to have a higher-level protocol look up the key instead of having the header specify it leaves room for those protocols to shoot themselves in the foot. I assume SRI would make something like \"ed25519-base64\" the keyId, so you won't be affected, but it's a problem for adopting the header more broadly.\r\n1. Using the `Digest` header as the only way to sign the body seems risky: we'd have to make sure that every path through the browser notices the presence of a Digest header and avoids using the body until it's checked.\r\n1. I'm still pretty sure leaving the hostname out of the signed data is a mistake, even though it requires extra signatures for testing vs prod. This draft doesn't require people to specify the hostname either, but it doesn't hardcode omitting it.\r\n1. draft-cavage-http-signatures doesn't expire signatures, meaning a single signed resource with a vulnerability forces the server to rotate the key.\r\n1. New things should try to use mnot's structured headers, although that's probably easy to fix.",
              "createdAt": "2017-11-22T17:15:35Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg2NzY3OTI=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-23T10:36:46Z",
          "updatedAt": "2017-11-23T10:36:47Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "missing \"",
              "createdAt": "2017-11-23T10:36:46Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg2NzcyMDI=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-23T10:38:26Z",
          "updatedAt": "2017-11-23T10:38:26Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Also: why do we need to reinvent `cache-control` here? Or do those have a different purpose?",
              "createdAt": "2017-11-23T10:38:26Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODAzNzMxOTI=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-12-01T00:14:12Z",
          "updatedAt": "2017-12-01T00:14:13Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "0df5fe2 now describes why I'm reinventing cache-control.",
              "createdAt": "2017-12-01T00:14:12Z",
              "updatedAt": "2017-12-05T19:28:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0MjQwODI1",
      "title": "Avoid use of \"CDN\", which implies a CNAME to many people.",
      "url": "https://github.com/WICG/webpackage/pull/89",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Use \"content distributor\" instead, in the hope that it only implies\r\ndistribution without authority.\r\n\r\nHow's this, @yoavweiss?\r\n\r\nPreviews in https://jyasskin.github.io/webpackage/clarify-cdn/.",
      "createdAt": "2017-11-22T19:42:13Z",
      "updatedAt": "2017-11-23T19:09:24Z",
      "closedAt": "2017-11-23T19:09:21Z",
      "mergedAt": "2017-11-23T19:09:21Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg2OTc3OTg=",
          "commit": {
            "abbreviatedOid": "b9adf91"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM :)",
          "createdAt": "2017-11-23T12:04:51Z",
          "updatedAt": "2017-11-23T12:04:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0MjQ4NDU4",
      "title": "Turn the PUSH-replacement use case into a non-goal.",
      "url": "https://github.com/WICG/webpackage/pull/90",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/demote-push-ergonomics/draft-yasskin-webpackage-use-cases.html#push-replacement\r\n\r\n@slightlyoff @dglazkov: I included this as a goal because y'all keep talking about it, but the PUSH experts like @yoavweiss and @igrigorik think we should just stop talking about it and rely on the other benefits instead, so here's a PR to demote it.",
      "createdAt": "2017-11-22T20:25:23Z",
      "updatedAt": "2017-12-01T00:18:39Z",
      "closedAt": "2017-12-01T00:18:36Z",
      "mergedAt": "2017-12-01T00:18:36Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg2OTYzMTg=",
          "commit": {
            "abbreviatedOid": "4cad429"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2017-11-23T11:58:12Z",
          "updatedAt": "2017-11-23T11:58:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU2NjExMzQy",
      "title": "Remove the worry about not signing the whole cert chain.",
      "url": "https://github.com/WICG/webpackage/pull/91",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@sleevi says this is ok.\r\n\r\nPreview at https://jyasskin.github.io/webpackage/remove-chain-signing-question/draft-yasskin-http-origin-signed-responses.html#signature-validity.",
      "createdAt": "2017-12-06T00:30:22Z",
      "updatedAt": "2017-12-11T21:00:43Z",
      "closedAt": "2017-12-11T21:00:41Z",
      "mergedAt": "2017-12-11T21:00:41Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU2ODUxMDgz",
      "title": "Rewrite (X, section Y) to (Section Y of X).",
      "url": "https://github.com/WICG/webpackage/pull/92",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In the hopes of getting deep links.\r\n\r\nPointed out in https://lists.w3.org/Archives/Public/ietf-http-wg/2017OctDec/0399.html.\r\n\r\nHowever, https://tools.ietf.org/html/draft-ietf-httpbis-origin-frame-04#section-1 does have a deep link to <a href=\"./rfc7540#section-9.1.2\">[RFC7540], Section&nbsp;9.1.2</a>, so I don't think this ordering is the fundamental problem.\r\n\r\nI can't get any of these syntaxes to result in deep links from https://xml2rfc.tools.ietf.org/, so I'm not sure what the ietf-httpbis drafts are doing to get them. The httpsbis editors' drafts do *not* have deep links: http://httpwg.org/http-extensions/expect-ct.html#response-header-field-syntax\r\n\r\n@MikeBishop, halp! \ud83d\ude3a",
      "createdAt": "2017-12-06T22:00:38Z",
      "updatedAt": "2017-12-11T21:17:53Z",
      "closedAt": "2017-12-11T21:10:00Z",
      "mergedAt": "2017-12-11T21:10:00Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It turns out that https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-01 does have deep links because of magic from https://tools.ietf.org/tools/rfcmarkup/ that's not present in xml2rfc.\r\n\r\nThey're missing in https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-01#page-10's \"Section 4.2.3 of [I-D.ietf-tls-tls13]\", so I'll do a little digging to see what's broken there.",
          "createdAt": "2017-12-08T04:49:47Z",
          "updatedAt": "2017-12-08T04:49:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ah, it's probably the commented-out \"section x of draft-y markup\" in https://tools.ietf.org/tools/rfcmarkup/code, so deep links into drafts probably just won't work.",
          "createdAt": "2017-12-08T05:02:38Z",
          "updatedAt": "2017-12-08T05:02:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU2ODcxNTM5",
      "title": "Fix nits that Ilari found.",
      "url": "https://github.com/WICG/webpackage/pull/93",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/ilari-issues/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/ilari-issues/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2017-12-06T23:57:16Z",
      "updatedAt": "2017-12-15T19:22:29Z",
      "closedAt": "2017-12-15T19:22:12Z",
      "mergedAt": "2017-12-15T19:22:12Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3MzYxNzc3",
      "title": "Define an HTTP/2 extension for cross-origin Server Push.",
      "url": "https://github.com/WICG/webpackage/pull/94",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/http-extension/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/http-extension/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2017-12-09T00:31:48Z",
      "updatedAt": "2017-12-15T19:35:56Z",
      "closedAt": "2017-12-15T19:35:47Z",
      "mergedAt": "2017-12-15T19:35:47Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3NDI5MzM3",
      "title": "remove unneeded/misleading metadata",
      "url": "https://github.com/WICG/webpackage/pull/95",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(for instance, this is not a work item of the HTTP working group)",
      "createdAt": "2017-12-10T12:37:44Z",
      "updatedAt": "2017-12-11T05:04:48Z",
      "closedAt": "2017-12-11T04:33:47Z",
      "mergedAt": "2017-12-11T04:33:46Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Oh, that makes sense. Thanks! I wish I could remember what caused me to include those three elements so I could try to fix that documentation.\r\n\r\nI have the same mistake in `draft-yasskin-dispatch-web-packaging.md` and `draft-yasskin-webpackage-use-cases.md` except with Dispatch as the workgroup. There's nothing special about Dispatch that would mean it's right to use them as the workgroup, right?",
          "createdAt": "2017-12-11T04:33:29Z",
          "updatedAt": "2017-12-11T04:33:29Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the draft is not an official work item of the WG, it shouldn't say so on the first page.\r\n\r\n(FWIW, the related rule is a bit ambiguous as it only says what to put there if a draft *is* a WG draft -- but that's my interpretation...)",
          "createdAt": "2017-12-11T05:01:36Z",
          "updatedAt": "2017-12-11T05:01:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks, done.",
          "createdAt": "2017-12-11T05:04:48Z",
          "updatedAt": "2017-12-11T05:04:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 96,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3Njg4ODM5",
      "title": "Add EdDSA certificates to the set with defined signature algorithms.",
      "url": "https://github.com/WICG/webpackage/pull/96",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I used the pre-hashed variants for those and switched the raw ed25519\r\npublic key to use ed25519ph, with an Open Question for whether that's\r\nthe right choice.\r\n\r\nIlari Liusvaara pointed out that draft-ietf-curdle-pkix is nearly published, so it makes sense to include its public key types in this document now. \r\n\r\n@sleevi, is this the right choice?\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/define-ed25519-certs/draft-yasskin-http-origin-signed-responses.html#signature-validity), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/define-ed25519-certs/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2017-12-11T22:30:05Z",
      "updatedAt": "2017-12-12T00:00:41Z",
      "closedAt": "2017-12-12T00:00:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "There are no plans at this time to support such certificates in Chrome",
          "createdAt": "2017-12-11T23:11:53Z",
          "updatedAt": "2017-12-11T23:11:53Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks Ryan. I'll drop this until some client says they really want it.",
          "createdAt": "2017-12-12T00:00:40Z",
          "updatedAt": "2017-12-12T00:00:40Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU4NzExMjA3",
      "title": "Fix some comments from Yoav Weiss.",
      "url": "https://github.com/WICG/webpackage/pull/97",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@yoavweiss",
      "createdAt": "2017-12-15T23:03:42Z",
      "updatedAt": "2018-01-16T22:11:48Z",
      "closedAt": "2018-01-16T22:11:45Z",
      "mergedAt": "2018-01-16T22:11:45Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODU0OTUyMDU=",
          "commit": {
            "abbreviatedOid": "d9482fa"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-12-25T19:25:03Z",
          "updatedAt": "2017-12-25T19:25:08Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Maybe add a note that responses are encouraged to include `Cache-Control: no-transform`?",
              "createdAt": "2017-12-25T19:25:04Z",
              "updatedAt": "2018-01-16T21:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODc2OTkzMzI=",
          "commit": {
            "abbreviatedOid": "d9482fa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-10T00:11:43Z",
          "updatedAt": "2018-01-10T00:11:43Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "@yoavweiss I mentioned no-transform up here.",
              "createdAt": "2018-01-10T00:11:43Z",
              "updatedAt": "2018-01-16T21:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODc3NjY5MzE=",
          "commit": {
            "abbreviatedOid": "d9482fa"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-10T08:58:10Z",
          "updatedAt": "2018-01-10T08:58:10Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "oh, OK. missed it :/",
              "createdAt": "2018-01-10T08:58:10Z",
              "updatedAt": "2018-01-16T21:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODc3NjcxMDk=",
          "commit": {
            "abbreviatedOid": "d9482fa"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2018-01-10T08:58:51Z",
          "updatedAt": "2018-01-10T08:58:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU5NTUyODAx",
      "title": "Start writing the bundling spec.",
      "url": "https://github.com/WICG/webpackage/pull/98",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html)\r\n\r\nThis fills a similar niche as [MHTML](https://tools.ietf.org/html/rfc2557), but\r\n* is random access,\r\n* efficiently encodes 8-bit payloads,\r\n* can represent multiple top-level resources,\r\n* can represent content-negotiated resources,\r\n* and possibly other advantages.\r\n\r\nI believe that combined with [signed exchanges](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html), bundles fill all of the [web packaging use cases](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html) except that they'll need a subsequent change to work for \"Third-party security review\", which will need a signature to cover groups of resources to enforce that their versions are consistent.",
      "createdAt": "2017-12-21T00:58:41Z",
      "updatedAt": "2018-12-01T00:34:31Z",
      "closedAt": "2018-05-29T21:00:12Z",
      "mergedAt": "2018-05-29T21:00:12Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(Note that I replied even in the feedback GitHub considers \"outdated\".)",
          "createdAt": "2018-03-26T07:11:51Z",
          "updatedAt": "2018-03-26T07:11:51Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Are you going to leave it to Fetch to drop the response body for a `HEAD` request? Or will that be an error to codify? It seems to me that you'd want to forbid `HEAD` to be encoded and only support it on the retrieval side and do the appropriate translations to `GET` minus response body there.",
          "createdAt": "2018-03-26T07:14:01Z",
          "updatedAt": "2018-03-26T07:14:01Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(Another thought I had was to take inspiration from the Cache API, as sort of the API surface on top of this format. The Cache API only supports `GET` thus far, but it does have `Vary` support. Haven't fully explored whether it's a complete fit, but it's interesting to think about as a way to avoid introducing too many new primitives.)",
          "createdAt": "2018-03-27T07:09:31Z",
          "updatedAt": "2018-03-27T07:09:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I believe this is finally ready for a re-review. It's missing 3 things that are going to be important, but that I'd like to do in a subsequent patch:\r\n\r\n1. The algorithm to take the request a browser would generate, e.g. with multiple values in its `Accept` header, and find a matching request inside a bundle, where requests will generally only have 1 value in their `Accept` headers.\r\n1. Compression: the index can probably just be brotli-compressed, but response headers should be able to take advantage of a shared dictionary.\r\n1. Signatures covering multiple resources: this both saves on signature verification costs and ensures that resources have matching versions.",
          "createdAt": "2018-05-21T22:09:36Z",
          "updatedAt": "2018-05-21T22:09:36Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "> Do you think I should say that clients MAY reject bundles that aren't a valid CBOR item? Or something else?\r\n\r\n1. I think we want it to be fully deterministic across all conforming (browser) implementations how they would handle all possible sequences of bytes. I.e., at least as good as the HTML parser.\r\n2. I don't think we should use +cbor if that isn't always the case or required to be the case.\r\n\r\nRe: \"best available bundled response\" I'd prefer it as an open issue if you plan on addressing it rather than it saying it's implementation-defined.\r\n\r\n(Note that we might get rid of pairs still: https://github.com/whatwg/infra/issues/127.)",
          "createdAt": "2018-05-24T05:04:59Z",
          "updatedAt": "2018-05-24T05:04:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "1. I haven't added the MAY.\r\n1. I've removed the +cbor from the MIME type.\r\n1. I marked the \"best available bundled response\" as a TODO.\r\n\r\nThanks!",
          "createdAt": "2018-05-24T22:57:32Z",
          "updatedAt": "2018-05-24T22:57:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this so it's easier to refer to and so I can start sending PRs to modify it, but please feel free to keep commenting and filing issues against it.",
          "createdAt": "2018-05-29T20:56:25Z",
          "updatedAt": "2018-05-29T20:56:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NDY2NjE3",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "You state that \"parsing MUST fail\" in a bunch of cases, but there's also a lot of scanning and jumping going on. Are there multiple levels where things can fail? That is, if you happened to just parse this once without jumping around, you can't simply return failure for all errors but would instead have to throw away items? That's rather unclear.",
          "createdAt": "2018-03-23T12:01:52Z",
          "updatedAt": "2018-03-23T12:06:04Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "This is not really good enough for browsers I think. You need to have a safelist.",
              "createdAt": "2018-03-23T12:01:52Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 316,
              "body": "It's unclear how to validate this in browsers. There's no such primitive.",
              "createdAt": "2018-03-23T12:02:17Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 321,
              "body": "Those key/value pairs are suitably constrained somehow? What's the parsing for them?",
              "createdAt": "2018-03-23T12:03:01Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzA4NjI5",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-24T19:51:43Z",
          "updatedAt": "2018-03-24T23:26:07Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "I believe one identifies an [absolute-URL string](https://url.spec.whatwg.org/#absolute-url-string) by running the [URL parser](https://url.spec.whatwg.org/#concept-url-parser) with no base URL and then checking that it doesn't have a fragment.\r\n\r\nAre you complaining that I'm not linking to the URL spec, that this isn't phrased as a parsing algorithm, both, or something else?",
              "createdAt": "2018-03-24T19:51:43Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 315,
              "body": "https://www.iana.org/assignments/http-methods/http-methods.xhtml is precise about the safe methods, but you have to click through to get cacheability defined, and the WebDAV methods leave it out. In an IETF draft, I'm pretty sure I can list the current methods that satisfy this (GET and HEAD), and in the browser-side loading living spec I can just list those expecting the list to get updated if any new ones get added.\r\n\r\nI also note that [Fetch](https://fetch.spec.whatwg.org/#http-network-or-cache-fetch) uses \"unsafe\" without specifying it more precisely.",
              "createdAt": "2018-03-24T19:54:14Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 321,
              "body": "They're HTTP headers, so we should do whatever https://fetch.spec.whatwg.org/#http-network-fetch does.\r\n\r\nOr are you worried about how claimed request headers are matched against browser request headers? That's not written yet. I was hoping to use the matching rules for PUSH_PROMISEs, but those aren't written yet either.",
              "createdAt": "2018-03-24T23:24:10Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzkwNDQy",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-26T07:08:21Z",
          "updatedAt": "2018-03-26T07:08:21Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "In the cache section, which is somewhat optional in a way.",
              "createdAt": "2018-03-26T07:08:21Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzkwNzIx",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-26T07:09:39Z",
          "updatedAt": "2018-03-26T07:09:40Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "Can I go with all three? E.g., `http://example.com/%` is not an \"absolute URI\", but will parse per the URL parser.",
              "createdAt": "2018-03-26T07:09:40Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzkwOTcy",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-26T07:11:03Z",
          "updatedAt": "2018-03-26T07:11:04Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "Well they're not quite the same as ordinary HTTP headers, since they are delimited differently, right? E.g., can you have a 0x0A byte in the value?",
              "createdAt": "2018-03-26T07:11:04Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA3MTEyMTk4",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Sorry for skipping the \"Are there multiple levels where things can fail?\" question earlier. My plan is that there are 2 levels where things can fail: \r\n\r\n1. The browser parses the metadata (https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html#load-metadata), and if anything fails there, the whole bundle is invalid.\r\n2. Then for any response the browser actually wants to use, it parses that particular response (https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html#load-response). If that fails, only that particular response is invalid, but the bundle can still contain other responses.\r\n\r\nThanks for saying that's not adequately clear; I'll try to fix it.\r\n\r\nI hadn't thought about how exactly to constrain HEAD. If you think the right approach is to treat it as an automatic transformation from GET, I'll do that.\r\n\r\nNone of this is done yet. I'll comment again when it is.",
          "createdAt": "2018-03-26T23:51:44Z",
          "updatedAt": "2018-03-26T23:57:50Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "HTTP/2 headers are also delimited in a way that lets their values include a 0x0A byte. I wonder if browsers handle that correctly...\r\n\r\nI suspect the right thing to do here is to explicitly create a [header list](https://fetch.spec.whatwg.org/#concept-header-list) from this, but since that concept doesn't exist in the IETF, I'll have to give up on the idea of making this an IETF draft.\r\n\r\nI'm going to ping some folks to see if I'll hurt any feelings by doing that.",
              "createdAt": "2018-03-26T23:51:44Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA3MTY5MDc0",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-27T06:49:47Z",
          "updatedAt": "2018-03-27T06:49:47Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "Oooh wow, I didn't know that about H/2. That's another reason to get a web-platform-tests setup.",
              "createdAt": "2018-03-27T06:49:47Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyMDkzMDIw",
          "commit": {
            "abbreviatedOid": "f4523f2"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Just skimmed through, had some nit comments / questions (non blocking).",
          "createdAt": "2018-05-22T09:45:58Z",
          "updatedAt": "2018-05-22T10:19:26Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "nit: should bolding be applied to **available bytes** ?",
              "createdAt": "2018-05-22T09:45:58Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 232,
              "body": "nit: `sectionOffsetsLength` (missing the closing \\`)",
              "createdAt": "2018-05-22T09:46:03Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 329,
              "body": "nit: extra \\\\",
              "createdAt": "2018-05-22T10:01:44Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 361,
              "body": "Wasn't fully unsure what could come here?",
              "createdAt": "2018-05-22T10:04:29Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 375,
              "body": "nit: missing ) after {{parse-cbor}}",
              "createdAt": "2018-05-22T10:05:37Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 473,
              "body": "\"Parsing the index section\" seems to say request has one url, do you mean it could have a list / redirect chain?",
              "createdAt": "2018-05-22T10:13:14Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyMjUzNDMw",
          "commit": {
            "abbreviatedOid": "f4523f2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-22T16:36:46Z",
          "updatedAt": "2018-05-22T16:49:42Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Sure.",
              "createdAt": "2018-05-22T16:36:46Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 232,
              "body": "Thanks.",
              "createdAt": "2018-05-22T16:38:33Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 329,
              "body": "Thanks.",
              "createdAt": "2018-05-22T16:39:10Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 375,
              "body": "Thanks.",
              "createdAt": "2018-05-22T16:39:58Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 361,
              "body": "If we add more sections in the future, and the publisher wants to make sure parsers don't just ignore one of those sections because they don't understand it, this section points out the ones not to skip.\r\n\r\nI'm not certain this is the right way to do this. PNG does it with a particular capitalization in the section names: https://tools.ietf.org/html/rfc2083#page-13",
              "createdAt": "2018-05-22T16:43:21Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 473,
              "body": "This is just an asymmetry in how requests and responses default their values: https://fetch.spec.whatwg.org/#concept-request-url-list defaults from the request's url, while https://fetch.spec.whatwg.org/#concept-response-url is hard-coded to point to the response's url list. I believe both URL lists should always have 1 value for exchanges in the bundle.\r\n\r\nI suspect Fetch will actually wind up copying or extending this response when serving browser-generated requests from bundles, so that a redirect into a bundle can work correctly.",
              "createdAt": "2018-05-22T16:48:26Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyMjkxMjQ3",
          "commit": {
            "abbreviatedOid": "ae24147"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-22T18:16:11Z",
          "updatedAt": "2018-05-22T18:16:12Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "@domenic, [here's the use of streams](https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html#stream-operations) I mentioned on #whatwg. I'm thinking about re-doing it in terms of [`ReadableStream`](https://fetch.spec.whatwg.org/#readablestream) despite your advice because https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html#load-response needs to create a [body's stream](https://fetch.spec.whatwg.org/#concept-body), which is defined as a `ReadableStream`. The stream a bundle's parsed from is likely to be a response body anyway, so it'll probably be a ReadableStream even if I pretend it isn't.\r\n\r\nWhat do you think?",
              "createdAt": "2018-05-22T18:16:11Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyNTIxMDM2",
          "commit": {
            "abbreviatedOid": "ae24147"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I still find it a little hard to digest how the whole thing fits together, but I tried to review regardless.",
          "createdAt": "2018-05-23T10:21:48Z",
          "updatedAt": "2018-05-23T10:37:48Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "request-response?",
              "createdAt": "2018-05-23T10:21:48Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 46,
              "body": "I'd leave this out, since the signing is controversial and not required.",
              "createdAt": "2018-05-23T10:22:25Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 52,
              "body": "It seems discussion also takes place on GitHub?",
              "createdAt": "2018-05-23T10:22:45Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 70,
              "body": "I'd pick one separator and stick with it.",
              "createdAt": "2018-05-23T10:23:39Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 120,
              "body": "\"error in this specification\" doesn't appear to mean anything. Wouldn't it be better to say that seek or read can return an error and that callers of them need to account for that?",
              "createdAt": "2018-05-23T10:26:16Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 132,
              "body": "What Fetch defines as \"requests\" are not necessarily HTTP requests. They're more broad.",
              "createdAt": "2018-05-23T10:26:47Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 174,
              "body": "Why not? We define this for the Cache API, I think ideally we use the same algorithm here.",
              "createdAt": "2018-05-23T10:28:39Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 186,
              "body": "Is there still use in CBOR then? Doesn't the MIME type lie with +cbor if you cannot actually use a CBOR parser?",
              "createdAt": "2018-05-23T10:29:36Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 258,
              "body": "The idea with structs is that they are immutable.",
              "createdAt": "2018-05-23T10:31:09Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 570,
              "body": "You cannot have multiple headers of the same name? Might be worth calling out you cannot encode cookies.",
              "createdAt": "2018-05-23T10:35:41Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyNzQ4MzIz",
          "commit": {
            "abbreviatedOid": "ae24147"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-23T20:12:13Z",
          "updatedAt": "2018-05-24T00:02:43Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I was trying to emphasize that it's both. A hyphen doesn't feel quite right because \"request\" doesn't modify \"response\". A slash feels like it might be alternation, although https://infra.spec.whatwg.org/#pair uses it the way I intend here.",
              "createdAt": "2018-05-23T20:12:13Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 46,
              "body": "I don't intend to shy away from the controversial bits, but you're right that it's not required, so maybe it doesn't belong in the abstract.\r\n\r\nI do expect to add a section to bundles to efficiently encode multi-resource signatures with the same semantics as multiple signed-exchanges, at which point it'll come back to the abstract.",
              "createdAt": "2018-05-23T20:13:30Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 52,
              "body": "I think that's covered by the \"issues list\" comment in the next paragraph. HTTPWG drafts have similar text, and also discuss on GitHub issues.",
              "createdAt": "2018-05-23T20:14:19Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 70,
              "body": "Indeed, thanks.",
              "createdAt": "2018-05-23T20:14:39Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 120,
              "body": "I intended the same meaning as in https://infra.spec.whatwg.org/#assertions, but looking at the uses of \"wait\", \"seek\", and \"read\", every seek and read except the ones to the start of the stream was immediately preceded by a wait, so I may as well incorporate the wait into the other operations.",
              "createdAt": "2018-05-23T20:33:46Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 132,
              "body": "What's the best way to say that the keys here come from the subset of Fetch \"requests\" that are HTTP requests? I don't think it makes sense to include the other schemes mentioned in https://fetch.spec.whatwg.org/#url.",
              "createdAt": "2018-05-23T21:07:09Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 174,
              "body": "Clearly we're going to have to define that algorithm somewhere. I don't have a strong opinion between here and the WICG/Fetch side, but I was leaning toward WICG/Fetch, and would definitely prefer to do it in a separate PR even if you prefer this spec.\r\n\r\nUnfortunately, https://w3c.github.io/ServiceWorker/#query-cache-algorithm assumes that varied headers will be identical between the cached request and the queried request, which isn't plausible for a bundle intended to be used by more than one UA.\r\n\r\nFor example, imagine that Greta's UA sends `Accept-Language: de-DE,de,en;q=0.9`. In the Cache API, that's exactly the request header that'll be cached since the Cache API uses https://fetch.spec.whatwg.org/#concept-fetch to fill it in. Similarly, if Hilda's UA sends `Accept-Language: de-AT,de;q=0.9`, that's what her cache will contain. If the server wants to put a `de` resource in a bundle to serve both users, what `Accept-Language` header should they write? There isn't one that Query-Cache will find for both people. The same problem shows up for `Accept` across browsers instead of people. So we need a new algorithm.",
              "createdAt": "2018-05-23T21:37:18Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 186,
              "body": "I'm primarily using CBOR instead of a totally custom binary format because 1) ASCII/UTF-8 formats like JSON are nice because you can read them without custom parsers, and 2) we need a binary format for this, but there are likely to be generic tools to dump CBOR to a readable format, so that preserves as much of the ASCII benefit as possible.\r\n\r\nI would actually like to say that bundles must be well-formed CBOR items, but because most parsers won't actually work that way, I expect non-CBOR bundles to wind up existing in the wild. Do you think I should say that clients MAY reject bundles that aren't a valid CBOR item? Or something else?",
              "createdAt": "2018-05-23T21:49:39Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 570,
              "body": "I believe multiple `Cookie` headers would be encoded by joining them with semicolons (not that you'd generally put cookies in bundled requests), but yeah, `Set-Cookie` has no single-field form. Noted.\r\n\r\n(This line is actually redundant with the fact that CBOR maps exclude duplicate keys, so I've replaced it with an Assert.)",
              "createdAt": "2018-05-23T21:59:33Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 258,
              "body": "I think you mean that the set of item names is immutable. It's simple to change this to a map, so I've done that. The set of keys is only not-fixed because I wanted to let other specifications add section names that might define new metadata, but I'm not totally sure that's a good idea, so this might go back to a struct later.",
              "createdAt": "2018-05-23T23:08:29Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyODQ1NTA3",
          "commit": {
            "abbreviatedOid": "80d01b9"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-24T04:56:05Z",
          "updatedAt": "2018-05-24T04:56:05Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Even those are more broad as they carry fields HTTP requests don't have. I guess you could say requests whose url list contains a single URL whose scheme is an HTTP(S) scheme (unless this is restricted to secure contexts?).",
              "createdAt": "2018-05-24T04:56:05Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMjAzNzMw",
          "commit": {
            "abbreviatedOid": "69a0512"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-24T23:18:30Z",
          "updatedAt": "2018-05-24T23:18:30Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "I've removed the attempt to subset the kinds of Fetch requests this operation can return. If it would noticeably simplify the request-matching function I need to write, I might add the subsetting back later, but I don't really expect that.",
              "createdAt": "2018-05-24T23:18:30Z",
              "updatedAt": "2018-05-24T23:18:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU5OTExMzAy",
      "title": "Use CBOR maps in signed exchanges.",
      "url": "https://github.com/WICG/webpackage/pull/99",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Instead of arrays with alternating keys and values, which side-steps the\r\ndisagreement about CBOR canonical map ordering rules, I now specify one\r\nof the ordering rules and use maps where they make sense.\r\n\r\nThe one place I'm still not using a map is in the top level of the\r\nexchange representation, where the request/response/payload ordering\r\nseems useful and where we might someday want to add, for example, the\r\nrequest payload between the request and response.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/use-maps/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/use-maps/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@MikeBishop",
      "createdAt": "2017-12-22T18:03:58Z",
      "updatedAt": "2018-01-16T22:28:15Z",
      "closedAt": "2018-01-16T22:28:12Z",
      "mergedAt": "2018-01-16T22:28:12Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYyMDEyNzky",
      "title": "remove stray period",
      "url": "https://github.com/WICG/webpackage/pull/106",
      "state": "MERGED",
      "author": "evmar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-01-10T00:53:17Z",
      "updatedAt": "2018-01-10T03:59:12Z",
      "closedAt": "2018-01-10T03:59:12Z",
      "mergedAt": "2018-01-10T03:59:12Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYzMzI2NDgx",
      "title": "Sign just the headers and identify a header to guard the payload.",
      "url": "https://github.com/WICG/webpackage/pull/108",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/incremental-validity/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/incremental-validity/draft-yasskin-http-origin-signed-responses.txt) (When TravisCI recovers.)\r\n\r\nThis limits the length of the signed data, which helps validation\r\nroutines use the non-prehashed variant of ed25519, and if the MI header\r\nfield is used, it allows clients to incrementally trust the beginning\r\nchunks of the payload as they are received instead of needing to wait\r\nfor the whole thing. ",
      "createdAt": "2018-01-17T01:00:05Z",
      "updatedAt": "2018-01-19T18:29:28Z",
      "closedAt": "2018-01-19T18:29:25Z",
      "mergedAt": "2018-01-19T18:29:25Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk0NjY1MjU=",
          "commit": {
            "abbreviatedOid": "814c43b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Reviewed to L300",
          "createdAt": "2018-01-17T14:53:11Z",
          "updatedAt": "2018-01-17T15:01:13Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Not for this commit, but this line was a bit hard for me to understand. Can we split to something like:\r\n```\r\nEach parameterised label MUST have parameters named \"sig\", \"integrity\", \"validityUrl\", \"date\", and \"expires\".\r\nIn addition, each parameterised label MUST have either \"certUrl\" and \"certSha256\" parameters, or an \"ed25519Key\" parameter.\r\n```",
              "createdAt": "2018-01-17T14:53:11Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            },
            {
              "originalPosition": 156,
              "body": "I assume the keys need to be sorted?\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#canonical-cbor",
              "createdAt": "2018-01-17T15:00:35Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            },
            {
              "originalPosition": 161,
              "body": "this too?",
              "createdAt": "2018-01-17T15:00:43Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk0NzAzMDI=",
          "commit": {
            "abbreviatedOid": "814c43b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-17T15:03:25Z",
          "updatedAt": "2018-01-17T15:03:25Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "sorry maybe this is already sorted in \"the bytewise lexicographic order\"",
              "createdAt": "2018-01-17T15:03:25Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk1Mzg0MDI=",
          "commit": {
            "abbreviatedOid": "814c43b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-17T18:12:30Z",
          "updatedAt": "2018-01-17T18:44:49Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Exactly: because the encoding of a string starts with its length, shorter strings sort before longer ones. This isn't obvious from the definition, but I do have the example of \"z\" sorting before \"aa\".\r\n\r\nThere's no actual need for the diagnostic form to appear in sorted order anyway, since canonicalization happens when encoding a semantic CBOR item to bytes, but I did sort it just to demonstrate the order.",
              "createdAt": "2018-01-17T18:12:30Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            },
            {
              "originalPosition": 33,
              "body": "Done.",
              "createdAt": "2018-01-17T18:44:22Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk2MzIyODQ=",
          "commit": {
            "abbreviatedOid": "7094753"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-17T23:46:38Z",
          "updatedAt": "2018-01-17T23:46:38Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "[Not for this commit] Should this be a http://www.ietf.org/rfc/rfc2616.txt http-date?",
              "createdAt": "2018-01-17T23:46:38Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk2MzM1OTQ=",
          "commit": {
            "abbreviatedOid": "7094753"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-17T23:53:33Z",
          "updatedAt": "2018-01-17T23:53:48Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "> as soon as they are validated\r\n\r\nWould you clarify if this means \"potentially-validated\" from Section 3.6 algorithm, or \"valid\" from the full cert chain authority check in Section 4.3.1?",
              "createdAt": "2018-01-17T23:53:33Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAxOTYzMDY=",
          "commit": {
            "abbreviatedOid": "7094753"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-19T18:06:18Z",
          "updatedAt": "2018-01-19T18:06:18Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "It's possible the HTTPWG will tell me to use text dates, but I'd rather avoid the change until then: text dates are longer, take more code to parse and generate, and we can provide the human readability in devtools if we want. ",
              "createdAt": "2018-01-19T18:06:18Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAyMDI0MDM=",
          "commit": {
            "abbreviatedOid": "7094753"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-19T18:28:39Z",
          "updatedAt": "2018-01-19T18:28:39Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "This turns out to be hard to word. It's actually both: there's a stack of standards here, and the next layer up mustn't process past the potentially-valid point when determining actual validity, and the layer above that mustn't process past the actually-valid point when using the data for some other purpose. It's totally plausible that a protocol might need to see the end of a message body to determine whether any of it is valid, but still take advantage of the incremental validity we're providing here to give that answer faster.\r\n\r\nI've updated the wording to try to capture that. I'm going to merge this to master to make my next PR easier to review, but please let me know if I need to change it more.",
              "createdAt": "2018-01-19T18:28:39Z",
              "updatedAt": "2018-01-19T18:28:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 109,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0MDcyNjkz",
      "title": "Specifying the Accept-Signature header to ask for signatures.",
      "url": "https://github.com/WICG/webpackage/pull/109",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/want-signature/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/want-signature/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n[RFC3230](https://tools.ietf.org/html/rfc3230#section-4.3.1) uses `Want-Digest` for a similar purpose, but `Accept-*` seems more common.\r\n\r\n@cramforce, does this look sensible? Have I over- or under-complicated it?",
      "createdAt": "2018-01-19T21:30:23Z",
      "updatedAt": "2018-01-30T17:05:38Z",
      "closedAt": "2018-01-26T21:14:28Z",
      "mergedAt": "2018-01-26T21:14:28Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@yoavweiss Here's your content negotiation mechanism.",
          "createdAt": "2018-01-24T18:31:46Z",
          "updatedAt": "2018-01-24T18:31:46Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "> @yoavweiss Here's your content negotiation mechanism.\r\n\r\nIndeed! missed that PR. Will go over it soonish",
          "createdAt": "2018-01-24T22:32:34Z",
          "updatedAt": "2018-01-24T22:32:34Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm merging this to unblock publishing the next IETF draft, but please keep commenting and filing issues as you notice problems.",
          "createdAt": "2018-01-26T21:13:47Z",
          "updatedAt": "2018-01-26T21:13:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAyODk1NzE=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-20T01:48:25Z",
          "updatedAt": "2018-01-20T01:48:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "When would a client send this? Would you expect a UA to always send this header?",
              "createdAt": "2018-01-20T01:48:25Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAyOTM0ODA=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-20T04:01:23Z",
          "updatedAt": "2018-01-20T04:01:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I would expect the AMP crawler to always send it. A browser might omit it on normal requests, but send it when there's an [`integrity=\"ed25519-xyz\"` attribute](https://github.com/mikewest/signature-based-sri#the-proposal), and, when the user says \"save page as\", it might try re-requesting all the resources with the header to see if it can include proofs that the resources aren't modified. Or if cross-signatures become a thing, the browser might always send a version of the header that asks for the cross-signature it cares about.",
              "createdAt": "2018-01-20T04:01:23Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzMDcyNDI=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-01-20T16:02:37Z",
          "updatedAt": "2018-01-20T16:02:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzMjU0NTc=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-21T09:10:14Z",
          "updatedAt": "2018-01-21T09:10:14Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'd expect UA implementing pre-fetch mechanisms (incl. Chromium) to always send this header.\r\nLINK rel={prefetch,preload} primitives may prefetch the resources that are later meant to be integrity checked. While re-sending the request on <script integrity> usage is theoretically possible, it would incur additional latency which was the whole point of the prefetch.",
              "createdAt": "2018-01-21T09:10:14Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzMjU1MjQ=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-21T09:14:45Z",
          "updatedAt": "2018-01-21T09:14:46Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Would it be possible for the client (Chromium) to request ed25519key signature response, while not specifying the ed25519 public key (or its prefix)?\r\nI'm not sure if the UA knows which key its going to use at the request time (similar to the prefetch argument above).",
              "createdAt": "2018-01-21T09:14:46Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTA2MzI1MjY=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-22T21:28:54Z",
          "updatedAt": "2018-01-22T21:28:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "We wouldn't need to pass the header for [`as`](https://html.spec.whatwg.org/multipage/semantics.html#attr-link-as) types that don't support [`integrity` attributes](https://w3c.github.io/webappsec-subresource-integrity/#interface-extensions), but yeah, that's a good point for preloaded scripts and stylesheets. @otherdaniel, would it make sense to put `integrity` attributes on prefetch links? [`<link>` already supports the attribute](https://html.spec.whatwg.org/multipage/semantics.html#attr-link-integrity) for the benefit of stylesheets.\r\n\r\nServers can also opt to send a Signature unconditionally when they expect it to be needed by their SRI directives, although we probably don't want to risk that performance footgun.",
              "createdAt": "2018-01-22T21:28:54Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTA2MzMyMjY=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-22T21:31:11Z",
          "updatedAt": "2018-01-22T21:31:11Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Right now, no, although we could specify a way to say that. For example, `ed25519key; *`. I *think* that for the https://github.com/mikewest/signature-based-sri use case, the `integrity=ed25519-...` attribute is always available next to the `src`, so the browser could include the public key.\r\n@otherdaniel",
              "createdAt": "2018-01-22T21:31:11Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyNjgyNjE=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": null,
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T17:48:09Z",
          "updatedAt": "2018-01-24T17:48:09Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Regarding _integrity attributes on prefetch links_: We've been [discussing this](https://bugs.chromium.org/p/chromium/issues/detail?id=677022) in a different context, and the consensus then was that from a web developer's perspective it makes little sense to require integrity attributes on prefetches. The present Chrome/Chromium implementation doesn't deal super well with this, but we thought our implementation choices shouldn't be the deciding factor.\r\n\r\nI think one can argue this either way, but my gut feeling is that the prefetch shouldn't be burdened with this.",
              "createdAt": "2018-01-24T17:48:09Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyNzA4Mjg=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": null,
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T17:56:33Z",
          "updatedAt": "2018-01-24T17:56:33Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "According to Mike's proposal, this would always be the case.\r\n\r\nI can imagine use cases where this wouldn't be the case. Particularly if [Origin Policy](https://wicg.github.io/origin-policy/) happens, it'd be very convenient if the origin could declare its supported keys, without requiring them to be duplicated within each page. That would then break this.\r\n\r\nA related, but somewhat incomplete thought: Mike has been pushing around the idea that maybe each resource should carry its own integrity assertions (that is, the resource declares it's own hash, or maybe signature, etc.), which would make it somewhat self-contained. Then, much of the work could happen as each resource is downloaded, independently of where/how it's being used. That's a somewhat incomplete plan, but IMHO rather attractive since it offers a path to bring the cost of (additional) security down to near-zero, and predictably so. Much of what we discuss here isn't directly contradicting this, but does go in the opposite direction, in that a resource could only be integrity-checked if requested in specific ways. \r\n",
              "createdAt": "2018-01-24T17:56:33Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyODA1NTE=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T18:27:43Z",
          "updatedAt": "2018-01-24T18:30:23Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "'k, I realized that `ed25519key; *` already matches all keys, so the browser can use that on prefetches if we don't want those to include `integrity` attributes. I've added an example for this. Or servers can send their `Signature` headers unconditionally for those resources.",
              "createdAt": "2018-01-24T18:27:43Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            },
            {
              "originalPosition": 69,
              "body": "Yep, I wouldn't want to get in the way of putting keys in the Origin Policy. Servers can definitely send the `Signature` even if the browser didn't explicitly request it, which fits the second half. If that becomes policy, we can drop the `ed25519key; ...` stuff entirely.",
              "createdAt": "2018-01-24T18:30:12Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTI1NDU2NDU=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": null,
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-30T12:48:17Z",
          "updatedAt": "2018-01-30T12:48:17Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This is a bit of a nitpick, but: As I read draft-ietf-httpbis-header-structure-02, a lone asterisk wouldn't match the grammar given there. It specifies \r\n\r\n>  binary = \"*\" 1\\*21846(base64)\r\n\r\nwhich I read as at least 1 and at most 21846 base64 characters. I guess there should be some way to specifiy an empty binary string, but I can't figure out how.\r\n",
              "createdAt": "2018-01-30T12:48:17Z",
              "updatedAt": "2018-01-30T12:48:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTI2NDE5ODA=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-30T17:05:38Z",
          "updatedAt": "2018-01-30T17:05:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Good point, thanks. I've filed https://github.com/httpwg/http-extensions/issues/474.",
              "createdAt": "2018-01-30T17:05:38Z",
              "updatedAt": "2018-01-30T17:05:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 110,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0MDk5Mzg0",
      "title": "Define application/http-exchange+cbor.",
      "url": "https://github.com/WICG/webpackage/pull/110",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/envelope-format/draft-yasskin-http-origin-signed-responses.html#application-http-exchange)\r\n\r\nThis format wraps an HTTP exchange, which allows an HTTP/1 connection to\r\ntransfer cross-origin signed exchanges, and which may have other uses.\r\n\r\n@kinu @yoavweiss Does this look reasonable?",
      "createdAt": "2018-01-20T00:41:32Z",
      "updatedAt": "2018-01-26T21:26:51Z",
      "closedAt": "2018-01-26T21:26:48Z",
      "mergedAt": "2018-01-26T21:26:48Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Just read through the texts, LGTM\r\n\r\n/cc @horo-t",
          "createdAt": "2018-01-22T02:21:19Z",
          "updatedAt": "2018-01-22T02:21:19Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm merging this to unblock publishing the next IETF draft, but please keep commenting and filing issues as you notice problems.",
          "createdAt": "2018-01-26T21:23:24Z",
          "updatedAt": "2018-01-26T21:23:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzMjU3MDA=",
          "commit": {
            "abbreviatedOid": "f8a6833"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-01-21T09:25:11Z",
          "updatedAt": "2018-01-21T09:25:31Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Would it be possible to standardize one?",
              "createdAt": "2018-01-21T09:25:11Z",
              "updatedAt": "2018-01-26T21:22:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzNTg1MTQ=",
          "commit": {
            "abbreviatedOid": "f8a6833"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-22T02:23:05Z",
          "updatedAt": "2018-01-22T02:23:05Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Reg: impl side concerns I think we're also fine with leaving it as N/A",
              "createdAt": "2018-01-22T02:23:05Z",
              "updatedAt": "2018-01-26T21:22:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTA2MjIxMTg=",
          "commit": {
            "abbreviatedOid": "f8a6833"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-22T20:53:54Z",
          "updatedAt": "2018-01-22T20:53:54Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "I'll grab `htxg` which matches the magic number that I pulled out of my hat, but I'm going to invite the HTTPWG to propose other names for the mime type, which could easily change the extension.",
              "createdAt": "2018-01-22T20:53:54Z",
              "updatedAt": "2018-01-26T21:22:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0NjMyNDky",
      "title": "Changes inspired by Ryan's comments",
      "url": "https://github.com/WICG/webpackage/pull/111",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@sleevi, how's this look?\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/sleevi-comments/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/sleevi-comments/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-01-23T16:57:33Z",
      "updatedAt": "2018-01-26T20:44:49Z",
      "closedAt": "2018-01-26T20:44:45Z",
      "mergedAt": "2018-01-26T20:44:45Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEwMTE1NzE=",
          "commit": {
            "abbreviatedOid": "376a8d9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-23T22:51:13Z",
          "updatedAt": "2018-01-23T22:51:13Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "@jschuh, here's your suggestion that clients can check for validity more often.",
              "createdAt": "2018-01-23T22:51:13Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyOTU1ODY=",
          "commit": {
            "abbreviatedOid": "2ab9cb3"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T19:12:50Z",
          "updatedAt": "2018-01-24T19:20:45Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Readability wise, this is very subtle and tripped me up during review here, that we're talking thirdparty.example.com versus example.com\r\n\r\nIt might make sense to use a different suffix here on the resource.validity, so that the visual pattern matching can more easily notice the difference in origins?",
              "createdAt": "2018-01-24T19:12:50Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 73,
              "body": "As a further comment re: examples, it's unclear what the implications of the overlap are between the expires on sig1 and the date on sig2. That is, it's not clear the use case for the overlapping set of signatures with the same validityURL, versus discrete (non-overlapping)\r\n\r\nThis is not specific to this PR, but was within the set of concerns with the examples being relatively opaque. It may be that an 'explainer' type document is better suited to capture this nuance, but as an example, it's a bit confusing :)",
              "createdAt": "2018-01-24T19:15:19Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 197,
              "body": "This guarantee is provided iff you have the same-origin assertion from line 647. The open question (in line 674) makes it unclear whether this would be true, but if that's removed, then it could be that validityUrl is served by a different entity, and thus does not provide a TLS guarantee.",
              "createdAt": "2018-01-24T19:16:43Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 197,
              "body": "Also, given validityUrls are unsigned and don't *seem* to be restricted to https:// in any of the normative requirements, I'm not sure that is inherently true, so much as assumed true?",
              "createdAt": "2018-01-24T19:19:32Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 219,
              "body": "1) Why not MUST?\r\n2) How do you determine \"as secure as\". What is the guidance meant to be provided to implementations in determining that assessment? Is HTTP on a local network 'at least as secure as' HTTPS, if it's over a VPN?",
              "createdAt": "2018-01-24T19:20:26Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEzMTUxMjQ=",
          "commit": {
            "abbreviatedOid": "5fa68ba"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T20:13:44Z",
          "updatedAt": "2018-01-24T20:14:01Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ahhh, I don't think we'd want to use anything other than the IANA-reserved domains, especially in a draft, so I think you were doing great with thirdparty.example.com, which is why I mentioned the suffix part :)\r\n\r\nPut more precise: I do not think we should deviate from https://tools.ietf.org/html/rfc6761#section-6.5",
              "createdAt": "2018-01-24T20:13:44Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEzNDUzOTQ=",
          "commit": {
            "abbreviatedOid": "2ab9cb3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T21:55:46Z",
          "updatedAt": "2018-01-26T18:44:48Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "My thought is that you'd sign with two different signatures if you have different clients with incompatible constraints, for example one has Symantec but no newer roots, and another refuses to trust Symantec. The date ranges aren't exactly equal because there's no technical need for it: each signature is valid or expired independently. However, there's probably also no need for the author to use different date ranges, so I'll make them the same in my next update.",
              "createdAt": "2018-01-24T21:55:46Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 78,
              "body": "I've kept the same suffix pattern, and just varying the timestamp digits isn't particularly noticeable, but I've now abbreviated the signature so the longer origin now sticks out a lot more.",
              "createdAt": "2018-01-24T22:49:56Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 197,
              "body": "I've added a note that this guarantee only works if we keep the same-origin restriction. I'm going to argue for allowing a list of URLs, but that'll take a change to [draft-ietf-httpbis-header-structure](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-02).\r\n\r\nI wasn't sure whether to require validityUrls to be HTTPS or to reason that, if you care about this, your main resource is HTTPS, and since the validityUrl must be same-origin with the main URL, it's also HTTPS.\r\n\r\nI've now also signed the validityUrl, since if it has to be same-origin with the resource, there's not much point in caching it. If we change it to a list, I'll probably just sign the first member.",
              "createdAt": "2018-01-24T22:56:20Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 219,
              "body": "Blast your precision. \ud83d\ude09  So, I used SHOULD because the client might be loading an exchange from local disk with no indication of the transport that put it there. There might also be non-TLS transports that are actually as secure as TLS? I am happy to ban plain HTTP.\r\n\r\nHow's this?",
              "createdAt": "2018-01-24T23:01:54Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 23,
              "body": "Thanks for expressing that opinion. Fixed.",
              "createdAt": "2018-01-26T18:43:57Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTE5MzcwOTQ=",
          "commit": {
            "abbreviatedOid": "7fd5e2a"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I think the question I raise here is beyond the scope of this PR, so I'm going to mark Approve for purposes of continuing the discussion, either async or in subsequent issues.",
          "createdAt": "2018-01-26T19:04:01Z",
          "updatedAt": "2018-01-26T19:07:06Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Could you explain what you mean by 'cross-signing certificate' here?\r\n\r\nThat is, 'normally' cross-signing refers to the same subject entity being validated by two different issuers - e.g., a given intermediate \"Intermediate Foo\" can be signed by both \"CA A\" and \"CA B\".\r\n\r\nThis makes me think that the use case here is `thirdparty.example.com` asserting that the content is truly from `example.com`, rather than being `example.com` proving that the `thirdpartysig` covers the resources from `thirdparty.example.com`.\r\n\r\nIf it's the latter (`thirdparty.example.com` certifying the content on `example.com`), then it seems we're introducing yet another Trusted Third Party into Web Packaging, beyond the CA model. That seems a radical departure from the TLS guarantees, and perhaps a subtle aspect I failed to realize - that this would allow non-CA entities to certify certificates.",
              "createdAt": "2018-01-26T19:04:01Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTE5NTE4NTQ=",
          "commit": {
            "abbreviatedOid": "7fd5e2a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-26T19:54:56Z",
          "updatedAt": "2018-01-26T19:54:56Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I mean for all four of these signatures to sign the resource, not any other certificates. (Remember, this is currently about a single exchange, not for a bundle of exchanges that might contain resources from several origins.) One use case might be for `thirdparty.example.com` to be a binary transparency log whose signature certifies that the resource is contained in the log. I'm adding a more explicit statement of the cross-signing use cases in https://github.com/WICG/webpackage/pull/112/files#diff-a2197f2cbc199dc1463dc10213fa40d9R862.\r\n\r\nI'm going to remove the use of \"cross-signing\" lest it imply signing certificates to anyone else, and then merge so that I can publish a new I-D.",
              "createdAt": "2018-01-26T19:54:56Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 112,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0NzI1NjUz",
      "title": "Cleanup and introduction improvements",
      "url": "https://github.com/WICG/webpackage/pull/112",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/cleanup/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/cleanup/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@KenjiBaheux, the introduction here should be usable as a simple explainer. Please check that it's readable and explains enough.",
      "createdAt": "2018-01-24T00:18:37Z",
      "updatedAt": "2018-01-26T23:45:34Z",
      "closedAt": "2018-01-26T23:45:27Z",
      "mergedAt": "2018-01-26T23:45:27Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm merging so I can publish a new I-D, but feel free to comment later.",
          "createdAt": "2018-01-26T23:45:20Z",
          "updatedAt": "2018-01-26T23:45:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1NDc3NTIx",
      "title": "Update to the -23 TLS1.3 draft.",
      "url": "https://github.com/WICG/webpackage/pull/116",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "That draft splits the rsa_pss signature algorithm names to depend on the key's OID. I suspect all RSA keys in the wild use the rsaEncryption OID, so banning that (to avoid Bleichenbacher attacks) would be equivalent to banning RSA keys, but if not, maybe we could allow the RSASSA-PSS ones.\r\n\r\n@sleevi @davidben",
      "createdAt": "2018-01-26T22:41:52Z",
      "updatedAt": "2018-02-28T22:07:35Z",
      "closedAt": "2018-02-28T22:07:31Z",
      "mergedAt": "2018-02-28T22:07:31Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0MjE0MjU=",
          "commit": {
            "abbreviatedOid": "bf53491"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-22T01:20:45Z",
          "updatedAt": "2018-02-22T01:20:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 118,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODEzOTg2",
      "title": "Update the README.",
      "url": "https://github.com/WICG/webpackage/pull/118",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "A quick update to the README that fixes #115. This doesn't update the explainer, which is still aimed at the pre-layered format.",
      "createdAt": "2018-01-29T20:50:21Z",
      "updatedAt": "2018-01-30T00:46:22Z",
      "closedAt": "2018-01-30T00:46:19Z",
      "mergedAt": "2018-01-30T00:46:19Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTIzNTIzMjA=",
          "commit": {
            "abbreviatedOid": "8e15f7f"
          },
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-01-29T20:52:57Z",
          "updatedAt": "2018-01-29T20:52:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3MDYwNDMx",
      "title": "\"Signed Exchange\" Generator implementation",
      "url": "https://github.com/WICG/webpackage/pull/119",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces a generator tool which implements the \"Signed HTTP Exchange\" proposed as in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html\r\n\r\nThe code is written by @hajimehoshi, @nyaxt, @irori (all Googlers, thus can skip CLA) with adopted code from https://github.com/WICG/webpackage/tree/master/go/webpack.\r\n",
      "createdAt": "2018-02-05T05:28:11Z",
      "updatedAt": "2018-02-14T02:04:08Z",
      "closedAt": "2018-02-14T02:04:08Z",
      "mergedAt": "2018-02-14T02:04:08Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think all the current problems are solved (except for testing format in cert_url?) Sorry for the very huge PR, and thank you for taking a look!",
          "createdAt": "2018-02-08T08:16:30Z",
          "updatedAt": "2018-02-08T08:16:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxNDM0ODA=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I've reviewed through go/signedexchange/mice/mice.go.",
          "createdAt": "2018-02-05T21:10:53Z",
          "updatedAt": "2018-02-05T21:58:18Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I assume you gave `w` a name to avoid exporting it?",
              "createdAt": "2018-02-05T21:10:53Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 213,
              "body": "This could be more efficient, but for the data sizes that are likely in signed-exchange maps, it probably doesn't matter. Maybe just comment that?",
              "createdAt": "2018-02-05T21:14:03Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 89,
              "body": "Please also test a non-UTF-8 string.",
              "createdAt": "2018-02-05T21:16:15Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 12,
              "body": "Comment why you can't use https://golang.org/pkg/encoding/binary/#Write (size isn't necessarily a power of 2).",
              "createdAt": "2018-02-05T21:28:43Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 19,
              "body": "I'd expect a function called `ParsePEM` to only parse the PEM format, and not also serialize it to the TLS 1.3 Certificate message format. Call it `CertificateMessageFromPEM` or similar, or split it into two functions?",
              "createdAt": "2018-02-05T21:31:36Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 47,
              "body": "Could you paste the Certificate format from https://tools.ietf.org/html/draft-ietf-tls-tls13-23#section-4.4.2 here?\r\n\r\n```\r\nenum {\r\n    X509(0),\r\n    RawPublicKey(2),\r\n    (255)\r\n} CertificateType;\r\n\r\nstruct {\r\n    select (certificate_type) {\r\n        case RawPublicKey:\r\n          /* From RFC 7250 ASN.1_subjectPublicKeyInfo */\r\n          opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;\r\n\r\n        case X509:\r\n          opaque cert_data<1..2^24-1>;\r\n    };\r\n    Extension extensions<0..2^16-1>;\r\n} CertificateEntry;\r\n\r\nstruct {\r\n    opaque certificate_request_context<0..2^8-1>;\r\n    CertificateEntry certificate_list<0..2^24-1>;\r\n} Certificate;\r\n```",
              "createdAt": "2018-02-05T21:34:27Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 71,
              "body": "I'm happy for this to be a TODO, but we'll also need to include the OCSP Status SignedCertificateTimestamps extensions.",
              "createdAt": "2018-02-05T21:35:40Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 75,
              "body": "This isn't a particularly useful test, but I also don't want to make you write a TLS parser just to test the code. `CertificateBody.Unmarshal` in https://github.com/bifurcation/mint/blob/master/handshake-messages.go#L295 might be helpful.",
              "createdAt": "2018-02-05T21:41:28Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 14,
              "body": "Add `> certurlfile`?",
              "createdAt": "2018-02-05T21:42:27Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 32,
              "body": "`%q` will avoid the need for quotes around `\"%s\"`. https://golang.org/pkg/fmt/#hdr-Printing",
              "createdAt": "2018-02-05T21:44:57Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 82,
              "body": "Give `i` a more explanatory name.",
              "createdAt": "2018-02-05T21:48:06Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 13,
              "body": "\"if one exists\" or \"the error if any\", I think.",
              "createdAt": "2018-02-05T21:49:30Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 24,
              "body": "Please comment what you're doing in this loop.",
              "createdAt": "2018-02-05T21:56:32Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxODQ2Nzc=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-05T23:50:09Z",
          "updatedAt": "2018-02-06T00:22:24Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I recommend use of the assert package, to avoid having to repeat error messages. https://godoc.org/github.com/stretchr/testify/assert. The Google style guide disapproves, but they're wrong.",
              "createdAt": "2018-02-05T23:50:09Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 16,
              "body": "I think this is just an `Exchange`.",
              "createdAt": "2018-02-05T23:55:31Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 60,
              "body": "Would it make sense for this tool to assume that all headers are signed? We support signing a subset to allow the signatures to survive intermediate proxies, and this tool doesn't need to be a proxy. Then you could remove this function, and have AddSignatureHeader also add the Signed-Headers header.",
              "createdAt": "2018-02-06T00:00:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 103,
              "body": "Be consistent about whether the HTTP header fields are one \"header\" or a list of \"headers\". I tend to prefer making it plural, but one can argue that that's not literally correct.",
              "createdAt": "2018-02-06T00:03:49Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 140,
              "body": "Be consistent about whether you include \"canonical\" in these function names.",
              "createdAt": "2018-02-06T00:05:08Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 162,
              "body": "Checking against a base64-encoded version of the CBOR data won't make it easy to diagnose test failures. You might instead use https://godoc.org/github.com/ugorji/go/codec#Decoder.Decode to decode to an interface and then `fmt` that with `%v` to get a text representation of the cbor, which will have comprehensible assertion failures.",
              "createdAt": "2018-02-06T00:13:01Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 69,
              "body": "I've added the `validityUrl` into this map: https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity.\r\n\r\nThis is likely to change again, slightly: I think the validityUrl should be a list of URLs, only one of which must be same-origin with the request URL and included in the signature.",
              "createdAt": "2018-02-06T00:16:02Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 98,
              "body": "Comment why you allow the caller to pass in a random number generator.",
              "createdAt": "2018-02-06T00:17:46Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 27,
              "body": "@nyaxt pointed out that the last `nil` here is a bug: RSA-PSS requires that the salt length equals the hash length, so you need `&PSSOptions{SaltLength:rsa.PSSSaltLengthEqualsHash}`.",
              "createdAt": "2018-02-06T00:19:42Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxOTY2MjA=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T00:58:48Z",
          "updatedAt": "2018-02-06T01:00:59Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Would you elaborate on this? I feel like keeping the code easier to understand without assert pkg knowledge is more valuable here. Golang docs also mentions this.\r\nhttps://golang.org/doc/faq#assertions\r\nhttps://golang.org/doc/faq#testing_framework\r\n\r\nAlthough, I do feel its a bit repetitive. How about introducing a one-off bytes compare helper function in this file and using it throughout the test?\r\nSomething like:\r\n```\r\nfunc assertBytesEqal(t *testing.T, desc string, expected, actual []byte) {\r\n  t.Helper()\r\n  if !bytes.Equal(expected, actual) {\r\n    t.Errorf(\"%s: got %v, want %v\", msg, expected, actual)\r\n  }\r\n}\r\n```",
              "createdAt": "2018-02-06T00:58:48Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 27,
              "body": "I'm preparing a separate PR to address this. Will follow up shortly.",
              "createdAt": "2018-02-06T00:59:52Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 60,
              "body": "I'm preparing a separate PR to address this. Will follow up shortly.",
              "createdAt": "2018-02-06T01:00:54Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMTQ5ODU=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T03:11:01Z",
          "updatedAt": "2018-02-06T03:27:47Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "https://github.com/hajimehoshi/webpackage/pull/2",
              "createdAt": "2018-02-06T03:11:01Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 60,
              "body": "https://github.com/hajimehoshi/webpackage/pull/3",
              "createdAt": "2018-02-06T03:27:44Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMjQ2Njg=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T04:43:57Z",
          "updatedAt": "2018-02-06T04:43:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Right. ",
              "createdAt": "2018-02-06T04:43:57Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMjQ4MzE=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T04:45:03Z",
          "updatedAt": "2018-02-06T04:45:03Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "I agree: sorting keys with a new array is not very effective but is the most direct way. I'll comment this later.",
              "createdAt": "2018-02-06T04:45:03Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMjYwMTI=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T04:57:48Z",
          "updatedAt": "2018-02-06T04:57:48Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "https://github.com/hajimehoshi/webpackage/pull/4",
              "createdAt": "2018-02-06T04:57:48Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMjY4MDQ=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you! I fixed the PR addressing on part of your comments. I'll be working on the rest later.",
          "createdAt": "2018-02-06T05:06:02Z",
          "updatedAt": "2018-02-06T05:57:39Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "Done.",
              "createdAt": "2018-02-06T05:06:02Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 89,
              "body": "Done",
              "createdAt": "2018-02-06T05:09:04Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2018-02-06T05:18:36Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 14,
              "body": "Done.",
              "createdAt": "2018-02-06T05:21:31Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2018-02-06T05:23:41Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 13,
              "body": "Done.",
              "createdAt": "2018-02-06T05:26:37Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 25,
              "body": "Hmm, I tend not to want to use assertions. This is just because I'd want to follow Go's standard convention, not only Google's convention.",
              "createdAt": "2018-02-06T05:34:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 16,
              "body": "Done.",
              "createdAt": "2018-02-06T05:38:50Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMzczMjE=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T06:37:53Z",
          "updatedAt": "2018-02-06T06:37:57Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "Done by https://github.com/WICG/webpackage/pull/119/commits/38c496415ca945dd369fcf3576f2a5416d63f9fb",
              "createdAt": "2018-02-06T06:37:53Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMzkxOTc=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T06:51:04Z",
          "updatedAt": "2018-02-06T07:47:10Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done.",
              "createdAt": "2018-02-06T06:51:04Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 19,
              "body": "Done. As this function is in `certurl` package, I thought `ParsePEM` was not so confusing IMHO. However, `CertificateMessageFromPEM` might be a better name.",
              "createdAt": "2018-02-06T06:56:42Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 71,
              "body": "Done.",
              "createdAt": "2018-02-06T07:00:40Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 69,
              "body": "Merged.",
              "createdAt": "2018-02-06T07:12:51Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 24,
              "body": "Done.",
              "createdAt": "2018-02-06T07:15:37Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 75,
              "body": "Thanks, but different from `codec.CborHandle`, this can't be passed to `%q` format?",
              "createdAt": "2018-02-06T07:45:36Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ0MjI3NDY=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T16:58:32Z",
          "updatedAt": "2018-02-06T18:39:08Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "s/effective/efficient/ It's very effective. :)",
              "createdAt": "2018-02-06T16:58:32Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 102,
              "body": "Instead of adding a third field to the test list, whose meaning isn't obvious from looking at the `{..., false}`, I'd probably write an independent assertion for the failure case:\r\n\r\n```go\r\nif err:=NewEncoder(&bytes.Buffer{}).EncodeTextString(\"\\x80 <- invalid UTF-8\"); err==nil {\r\n  t.Errorf(\"Expected an error for malformed UTF-8\")\r\n}\r\n```",
              "createdAt": "2018-02-06T17:04:20Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 97,
              "body": "Whoops, I forgot an \"and\" in my review comment, which you faithfully reproduced here. \"OCSP Status\" and \"SignedCertificateTimestamps\" are two separate extensions.",
              "createdAt": "2018-02-06T17:07:30Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 75,
              "body": "I don't really understand the question. [`codec.CborHandle`](http://ugorji.net/blog/go-codec-primer#decoding) isn't the object that's filled in when decoding cbor with codec, and I'd expect to format objects with `%v` instead of `%q` anyway.",
              "createdAt": "2018-02-06T18:39:07Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ0NTgwNTY=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T18:40:14Z",
          "updatedAt": "2018-02-06T19:31:03Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "In a usage string `[]` usually surrounds optional things, but here the pem-file isn't optional, and if the certurlFile is omitted the `>` needs to be absent too.",
              "createdAt": "2018-02-06T18:40:14Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 25,
              "body": "You don't have to use assertions, but to elaborate a bit:\r\n\r\nIt's a choice between \r\n```go\r\nfunc TestSingleRecord(t *testing.T) {\r\n\tvar buf bytes.Buffer\r\n\tmessage := []byte(\"When I grow up, I want to be a watermelon\")\r\n\tmi, err := Encode(&buf, message, 0x29)\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\tgotBytes := buf.Bytes()\r\n\twantBytes := append([]byte{0, 0, 0, 0, 0, 0, 0, 0x29}, message...)\r\n\tif !bytes.Equal(gotBytes, wantBytes) {\r\n\t\tt.Errorf(\"buf.Bytes(): got %v, want %v\", gotBytes, wantBytes)\r\n\t}\r\n\r\n\twantMI := \"mi-sha256=dcRDgR2GM35DluAV13PzgnG6-pvQwPywfFvAu1UeFrs\"\r\n\tif mi != wantMI {\r\n\t\tt.Errorf(\"e.MI(); got %v, want %v\", mi, wantMI)\r\n\t}\r\n}\r\n```\r\nvs\r\n```go\r\nfunc TestSingleRecord(t *testing.T) {\r\n\tvar buf bytes.Buffer\r\n\tmessage := []byte(\"When I grow up, I want to be a watermelon\")\r\n\tmi, err := Encode(&buf, message, 0x29)\r\n\trequire.NoError(t, err)\r\n\tassert.Equal(t, buf.Bytes(), append([]byte{0, 0, 0, 0, 0, 0, 0, 0x29}, message...), \"buf.Bytes()\")\r\n\tassert.Equal(t, mi, \"mi-sha256=dcRDgR2GM35DluAV13PzgnG6-pvQwPywfFvAu1UeFrs\", \"e.MI\")\r\n}\r\n```\r\n\r\nThere's fewer extraneous lines of code that get in the way when reading the test. It's also clearer whether you want the `Encode` call to succeed or fail where \"if error is not nil, fail\" has a double-negative. For the cases where the lack of an assertion library forces you to use a table, which is clearer to read?\r\n\r\n```go\r\n{\r\n\tbegin: 8,\r\n\tend:   24,\r\n\twant:  message[0:16],\r\n},\r\n```\r\nor\r\n```go\r\nassert.Equal(t, b[8:24], message[0:16])\r\n```\r\n\r\nI'm still not insisting that you diverge from the Go's authors' preference here, but it does harm test readability.",
              "createdAt": "2018-02-06T19:31:02Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ0NzYyMTg=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-06T19:32:00Z",
          "updatedAt": "2018-02-06T19:38:41Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Be consistent about whether the HTTP header fields are one \"header\" or a list of \"headers\". I tend to prefer making it plural, but one can argue that that's not literally correct.",
              "createdAt": "2018-02-06T19:32:00Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 140,
              "body": "Be consistent about whether you include \"canonical\" in these function names.",
              "createdAt": "2018-02-06T19:32:21Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ1OTU1NDE=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-07T05:29:39Z",
          "updatedAt": "2018-02-07T06:56:11Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "Oops, done :-)",
              "createdAt": "2018-02-07T05:29:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 102,
              "body": "Done.",
              "createdAt": "2018-02-07T05:37:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 97,
              "body": "Done.",
              "createdAt": "2018-02-07T05:40:49Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 14,
              "body": "Done.",
              "createdAt": "2018-02-07T05:41:25Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 25,
              "body": "Thank you for elaboration! Well, to be honest, I agree that assertion is clearer and concise, but I was wondering if using assertions is worth being against the conventions (Especially in Go culture, it looks like following the conventions is important than adopting a 'better' local way).\r\n\r\nAs for readability, the current non-assertion way is less readable but it is not critical IMHO.",
              "createdAt": "2018-02-07T06:03:21Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 103,
              "body": "Done (I don't have a strong opinion. I adopted plurals).",
              "createdAt": "2018-02-07T06:07:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 177,
              "body": "Found that comparing `%q` strings is fragile since the order of map keys is not deterministic. I'll fix this later.",
              "createdAt": "2018-02-07T06:41:22Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 75,
              "body": "Ah sorry, I meant a decoded object by `codec.CborHandle` like what we did in singedexchange_test.go My question was, we could compare the formatted strings with `%q` but we couldn't do it with `CertificateBody`. \r\n\r\nAs for `%v`, this just shows the addresses of member pointers like `{[] [{0xc420194b00 []} {0xc420195080 []}]}`, so this doesn't work as we expected?",
              "createdAt": "2018-02-07T06:48:32Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ2MjMzMzg=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-07T08:29:40Z",
          "updatedAt": "2018-02-07T08:29:40Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "Done.",
              "createdAt": "2018-02-07T08:29:40Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ3OTIyMTc=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-07T17:13:38Z",
          "updatedAt": "2018-02-07T17:18:25Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Ah, good point. It looks like you'd need https://github.com/davecgh/go-spew, or an extension to your `readableString()` function, to format through pointer values. Using that might still be worth it to make the test readable.",
              "createdAt": "2018-02-07T17:13:38Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 25,
              "body": "If you look at http://go-search.org/tops, assert is the 4th most imported package in all of Go, so, it basically is a convention even if the language designers don't like it.",
              "createdAt": "2018-02-07T17:18:25Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ3OTU4ODU=",
          "commit": {
            "abbreviatedOid": "9800a9e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-07T17:23:37Z",
          "updatedAt": "2018-02-07T17:23:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5MjYxMDA=",
          "commit": {
            "abbreviatedOid": "9800a9e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T00:54:24Z",
          "updatedAt": "2018-02-08T00:54:24Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "FYI, @sleevi tells me that using the TLS Certificate format is likely to cause problems for implementers, since its parser isn't actually exposed by TLS validation libraries. He suggests I just do a CBOR structure holding an array of certificates, an ocsp response, and an sct response. That's also easier for you to test, so don't spend too much time getting the Certificate message right in this change.",
              "createdAt": "2018-02-08T00:54:24Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5NjM2Nzg=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T05:57:36Z",
          "updatedAt": "2018-02-08T05:57:36Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Thank you!\r\n\r\nAs my `readableString` is only for fundamental types like a map or a slice of `interface{}`, this doesn't have a capability of analyzing struct members. It's possible to extend this to do that, but it'd be tough work.\r\n\r\nI tried `go-spew`, but both `spew.Sprintf(\"%v\", ...)` and `spew.Dump(...)` generates a lot of huge sequences of binary numbers, so I don't think spew has a lot of advantage compared to the current way...",
              "createdAt": "2018-02-08T05:57:36Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5NjY0OTI=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T06:20:50Z",
          "updatedAt": "2018-02-08T06:20:51Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Done: Used `github.com/kylelemons/godebug/pretty.Compare` to make the 'binary' diff much more readable.\r\n\r\nAnother concern of such pretty printing of struct values is that the order of map keys and/or struct members are not assured. Probably I'd be able to create an expected `mint.CertificateBody` and compare them by `pretty.Compare`, but as I mentioned, this struct includes a lot of binary sequences, so this might not be very helpful very much?",
              "createdAt": "2018-02-08T06:20:51Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5NzA2NTg=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T06:52:56Z",
          "updatedAt": "2018-02-08T06:52:56Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Done.",
              "createdAt": "2018-02-08T06:52:56Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5ODI3NTI=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T08:06:52Z",
          "updatedAt": "2018-02-08T08:06:52Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Done.",
              "createdAt": "2018-02-08T08:06:52Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTU2MTM4NjY=",
          "commit": {
            "abbreviatedOid": "04fa384"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm myside.\r\n@jyasskin Would you merge once you are happy?",
          "createdAt": "2018-02-10T05:51:57Z",
          "updatedAt": "2018-02-10T05:52:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3NzkyOTgy",
      "title": "Let certUrl and validityUrl contain lists",
      "url": "https://github.com/WICG/webpackage/pull/120",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/validity-url-lists/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/validity-url-lists/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-02-07T19:55:55Z",
      "updatedAt": "2018-03-05T20:31:02Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3ODMxMjc0",
      "title": "Sign over the OCSP response to make signing oracles temporary.",
      "url": "https://github.com/WICG/webpackage/pull/121",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/sign-ocsp/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/sign-ocsp/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@davidben @sleevi, how's this look?",
      "createdAt": "2018-02-07T22:49:20Z",
      "updatedAt": "2018-08-20T06:19:55Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@hajimehoshi @nyaxt FYI, this will need a change to the signature generator.",
          "createdAt": "2018-02-07T22:53:10Z",
          "updatedAt": "2018-02-07T22:53:10Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben friendly ping. I'm trying to make b2 cut (which we'd like to target Origin-Trial), and is wondering if this PR is good enough to go in to the cut",
          "createdAt": "2018-08-20T01:37:29Z",
          "updatedAt": "2018-08-20T01:37:29Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, given the timeline, I'd like to punt this to b3 if possible if you are comfortable.",
          "createdAt": "2018-08-20T06:19:55Z",
          "updatedAt": "2018-08-20T06:19:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyOTY4NzA=",
          "commit": {
            "abbreviatedOid": "bf6158e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:49:43Z",
          "updatedAt": "2018-02-16T19:57:55Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Signing oracles may also arise from implementation flaws like Bleichbacher attack or DROWN.",
              "createdAt": "2018-02-16T19:49:43Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 80,
              "body": "SHOULD NOT is weak here. Because this is not the opt-in X.509 extension (which is much more straightforward and strongly preferable), any client which deploys this instantly makes *all* sites vulnerable. That places the bar much higher. This specification dramatically upgrades the consequences of any site under a CA that pre-signs OCSP responses.",
              "createdAt": "2018-02-16T19:52:14Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 88,
              "body": "Not sure what \"yet\" means in this context. Going from opt-in X.509 extension to this weaker OCSP trick is a meaningful direction, but we can't switch from this weaker option to an X.509 extension because the mere existence of the other option is what introduces the vulnerability.\r\n\r\n(Or did you mean this as more a TODO-like comment rather than final specification text?)",
              "createdAt": "2018-02-16T19:53:32Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 43,
              "body": "s/can/SHOULD/ maybe? It seems, in general, that `certUrl`s should change whenever their contents change, otherwise old signed extensions would fail to validate.",
              "createdAt": "2018-02-16T19:55:46Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 23,
              "body": "I don't see `parsed-chain` used anywhere here, or am I missing something?",
              "createdAt": "2018-02-16T19:56:48Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMjMyMTU=",
          "commit": {
            "abbreviatedOid": "bf6158e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I've fixed your comments, but this whole change might get superseded by another PR to use an X.509 certificate extension instead.",
          "createdAt": "2018-02-16T21:34:20Z",
          "updatedAt": "2018-02-17T00:32:17Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Nope, I failed to use it. I've switched to the variable names from #122, although this is also going to interact with that refactoring..",
              "createdAt": "2018-02-16T21:34:20Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 43,
              "body": "Sure.",
              "createdAt": "2018-02-16T21:35:41Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 73,
              "body": "I've now mentioned those too.",
              "createdAt": "2018-02-16T21:47:00Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 80,
              "body": "Is there a useful distinction between the CA pre-signing OCSP responses but keeping them internal, vs releasing those responses to the certificate owner?\r\n\r\nI may as well say MUST here until someone complains.",
              "createdAt": "2018-02-16T21:49:16Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 88,
              "body": "It's something like a TODO, yeah. I've changed it.",
              "createdAt": "2018-02-17T00:30:47Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4MzUyNTU0",
      "title": "Avoid the TLS 1.3 Certificate message.",
      "url": "https://github.com/WICG/webpackage/pull/122",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Use a custom CBOR certificate chain format instead.\r\n\r\nAlso register this format with IANA.\r\n\r\n@sleevi, better?\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/avoid-tls-messages/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/avoid-tls-messages/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-02-09T22:00:44Z",
      "updatedAt": "2018-03-02T18:24:14Z",
      "closedAt": "2018-02-28T23:16:46Z",
      "mergedAt": "2018-02-28T23:16:46Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@davidben should also look at this.\r\n\r\nDavid: The concern was that at present, no TLS library exposes its Certificate parsing or generating functions (Modulo Boring\u2019s CBS), and that, more generally speaking, the TLS libraries are maintained at separate cadences and release structures than UAs.\r\n\r\nThere\u2019s also the separable concern about semantics of or to the TLS layer and their interaction with Web Packaging, and thus the suggestion to make it an explicit format.",
          "createdAt": "2018-02-09T22:05:55Z",
          "updatedAt": "2018-02-09T22:05:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Haven't looked closely at the PR text yet, but I agree avoiding the TLS message makes sense. That was one of the comments I had in my queue. :-) Even with BoringSSL's `CBS` stuff, we don't expose the message itself, just the low-level length-prefix bits.\r\n\r\nYou needed different parsing rules from TLS anyway. TLS doesn't allow unsolicited extensions, so you actually reject, not ignore, unknown extensions. (SCTs, OCSP stapling, etc., are advertised in ClientHello or CertificateRequest, so the other side knows whether to include them.) Your signing rules are also slightly different, with the `certSha256` stuff.",
          "createdAt": "2018-02-09T23:22:01Z",
          "updatedAt": "2018-02-09T23:22:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTU1Nzg4OTQ=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-09T22:11:32Z",
          "updatedAt": "2018-02-09T22:13:18Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Is this right, or should it only be the leaf certificate that holds an SCT?",
              "createdAt": "2018-02-09T22:11:32Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            },
            {
              "originalPosition": 15,
              "body": "Oh, also, this is a simplification of the `status_request` TLS extension that omits the layer containing a `CertificateStatusType`. Is that the right choice?",
              "createdAt": "2018-02-09T22:12:48Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            },
            {
              "originalPosition": 16,
              "body": "A `SignedCertificateTimestampList` appears to be a serialized TLS message, but I guess because other systems have to generate this, it's ok?",
              "createdAt": "2018-02-09T22:13:15Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMDY0MDk=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T21:27:56Z",
          "updatedAt": "2018-02-13T21:27:56Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Under RFC 6962, only the leaf has (additional) SCTs provided by the TLS extension\r\n\r\nUnder 6962-bis, this can change, but there are no implementations of 6962-bis (nor announced) that I know of.",
              "createdAt": "2018-02-13T21:27:56Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMDc1MzM=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T21:31:21Z",
          "updatedAt": "2018-02-13T21:31:21Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I believe so, at least as we discussed. This might be an area of future change.\r\n\r\nThe practical reality is that OCSP multi-stapling is rather inefficient for the browser case, given that \"Every Modern Browser\" (tm) effectively has an out-of-bands mechanism for dealing with intermediate revocation, treating it akin to root revocation, as well as heavily caching intermediate results (e.g. in the case of macOS, via an out-of-band datafile containing the revocation status of all intermediates, in the case of Windows, through background-fetching CRLs that cover CAs)\r\n\r\nFrom a PKI pursist standpoint, however, you could try and argue that such systems don't handle nested sets of name-constrained subordinate CAs, and for those cases (and, effectively, those cases alone), it makes sense to allow OCSP responses for intermediates to be stapled.",
              "createdAt": "2018-02-13T21:31:21Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMDc2Nzc=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T21:31:47Z",
          "updatedAt": "2018-02-13T21:31:47Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Right, this is passed as (effectively) opaque input, much like the OCSP response, into the certificate validation system, which contains a minimal subset of the TLS decoder for this case.",
              "createdAt": "2018-02-13T21:31:47Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMjIzMTQ=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T22:18:52Z",
          "updatedAt": "2018-02-13T22:18:52Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "I've changed it to just the leaf certificate. Thanks.",
              "createdAt": "2018-02-13T22:18:52Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMjI3NDY=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T22:20:16Z",
          "updatedAt": "2018-02-13T22:20:16Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'm going to omit the \"nested sets of name-constrained subordinate CAs\" case from this draft, and if someone tells me to add it, I'm going to make them write the wording that distinguishes certificates that need OCSPs from ones that don't.",
              "createdAt": "2018-02-13T22:20:16Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0MjA1MzQ=",
          "commit": {
            "abbreviatedOid": "308c428"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-22T01:15:13Z",
          "updatedAt": "2018-02-22T01:19:50Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Nit: There can be more than one valid signature for a given public key and message. I would say perhaps:\r\n\r\nIf `signature` is a valid signature of `message` by `publicKey` using `signing-alg` [...]",
              "createdAt": "2018-02-22T01:15:13Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            },
            {
              "originalPosition": 32,
              "body": "Re \"subsequent certificates\", I suspect this may end up being a bit controversial since the TLSWG intentionally went the other way with TLS 1.3 and made it easy to encode OCSP staples on intermediates. But I'll leave that for @sleevi and others to wrestle out later. :-)\r\n\r\n(In our TLS 1.3 implementation, we tolerate metadata on intermediates but ignore them for now. We'll start processing them if we have something useful to do with them.)",
              "createdAt": "2018-02-22T01:18:43Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            },
            {
              "originalPosition": 197,
              "body": "(Also the TLS 1.3 message has different parsing rules than what you want anyway.)",
              "createdAt": "2018-02-22T01:19:29Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMjY2NDE5",
          "commit": {
            "abbreviatedOid": "308c428"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T23:12:20Z",
          "updatedAt": "2018-03-02T18:24:14Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I'll look forward to when folks are objecting to this kind of detail.",
              "createdAt": "2018-02-28T23:12:20Z",
              "updatedAt": "2018-03-02T18:24:14Z"
            },
            {
              "originalPosition": 112,
              "body": "Thanks, fixed.",
              "createdAt": "2018-02-28T23:12:29Z",
              "updatedAt": "2018-03-02T18:24:14Z"
            },
            {
              "originalPosition": 197,
              "body": "Noted.",
              "createdAt": "2018-02-28T23:12:36Z",
              "updatedAt": "2018-03-02T18:24:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4NTgwNjE3",
      "title": "Add a use-case for subresource bundling",
      "url": "https://github.com/WICG/webpackage/pull/123",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes https://github.com/WICG/webpackage/issues/101",
      "createdAt": "2018-02-12T13:38:49Z",
      "updatedAt": "2018-02-13T06:06:33Z",
      "closedAt": "2018-02-13T06:06:33Z",
      "mergedAt": "2018-02-13T06:06:33Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Your update LGTM",
          "createdAt": "2018-02-13T06:06:11Z",
          "updatedAt": "2018-02-13T06:06:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTU4NjcxMTI=",
          "commit": {
            "abbreviatedOid": "cd7afc4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I've pushed an update to your text. Let me know if I've said anything wrong, and then we can merge it.",
          "createdAt": "2018-02-12T17:06:44Z",
          "updatedAt": "2018-02-12T17:06:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNDA1MDQ3",
      "title": "signedexchange: Add flags 'requestHeader' and 'responseHeader'",
      "url": "https://github.com/WICG/webpackage/pull/125",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#124 \r\n\r\nThis is WIP: I have no idea how to treat the passed request headers.",
      "createdAt": "2018-02-21T08:38:28Z",
      "updatedAt": "2018-02-27T07:37:16Z",
      "closedAt": "2018-02-26T04:18:26Z",
      "mergedAt": "2018-02-26T04:18:26Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Right now, the spec says not to sign request headers, which would imply that the tool shouldn't actually take a `--requestHeader` argument. If we want to sign request headers (which is plausible, especially inside `application/http-exchange+cbor` objects instead of plain HTTP responses), I think the natural thing is to include them in the map created by `encodeRequest()`.",
          "createdAt": "2018-02-21T18:27:14Z",
          "updatedAt": "2018-02-21T18:27:14Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think the natural thing is to include them in the map created by encodeRequest().\r\n\r\nThank you, done.",
          "createdAt": "2018-02-22T06:48:13Z",
          "updatedAt": "2018-02-22T06:48:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0NjI1NDY=",
          "commit": {
            "abbreviatedOid": "e44a80d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-22T06:56:37Z",
          "updatedAt": "2018-02-22T06:57:04Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "encodeRequest from L172 should include requestHeaders, while L149 should not",
              "createdAt": "2018-02-22T06:56:37Z",
              "updatedAt": "2018-02-22T07:35:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0NjM0MDc=",
          "commit": {
            "abbreviatedOid": "e44a80d"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you!",
          "createdAt": "2018-02-22T07:02:34Z",
          "updatedAt": "2018-02-22T07:02:39Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Done.",
              "createdAt": "2018-02-22T07:02:34Z",
              "updatedAt": "2018-02-22T07:35:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTkxODE5MzM=",
          "commit": {
            "abbreviatedOid": "164698e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-26T04:18:18Z",
          "updatedAt": "2018-02-26T04:18:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNjY2NjU5",
      "title": "signedexchange: Update tests",
      "url": "https://github.com/WICG/webpackage/pull/126",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The test results was changed at https://github.com/WICG/webpackage/commit/d989c1be0e6e717476f4291cea2edd2adbd867ac and this PR updates the test results.",
      "createdAt": "2018-02-22T06:25:15Z",
      "updatedAt": "2018-02-22T06:40:20Z",
      "closedAt": "2018-02-22T06:34:58Z",
      "mergedAt": "2018-02-22T06:34:58Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nyaxt PTAL",
          "createdAt": "2018-02-22T06:30:10Z",
          "updatedAt": "2018-02-22T06:30:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0NTk2NjA=",
          "commit": {
            "abbreviatedOid": "a30ef3b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-22T06:34:52Z",
          "updatedAt": "2018-02-22T06:34:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNjc2NjYz",
      "title": "signedexchange: Sort signed-headers value to make tests deterministic",
      "url": "https://github.com/WICG/webpackage/pull/127",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PTAL @nyaxt ",
      "createdAt": "2018-02-22T07:41:08Z",
      "updatedAt": "2018-02-27T07:36:59Z",
      "closedAt": "2018-02-26T04:19:18Z",
      "mergedAt": "2018-02-26T04:19:18Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTkxODIwMDY=",
          "commit": {
            "abbreviatedOid": "4929ec0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-26T04:19:13Z",
          "updatedAt": "2018-02-26T04:19:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNTk1ODM2",
      "title": "signedexchange: Follow the new (tantative) format",
      "url": "https://github.com/WICG/webpackage/pull/130",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T08:44:05Z",
      "updatedAt": "2018-05-21T15:48:31Z",
      "closedAt": "2018-05-21T07:23:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to wait until the spec text is updated, but will merge this to nyaxt/webpackage.",
          "createdAt": "2018-03-01T17:37:32Z",
          "updatedAt": "2018-03-01T17:37:32Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Should I close this? ",
          "createdAt": "2018-03-12T09:44:29Z",
          "updatedAt": "2018-03-12T09:44:29Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "not yet.",
          "createdAt": "2018-03-12T10:15:05Z",
          "updatedAt": "2018-03-12T10:15:05Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this now, since this is no longer the latest format",
          "createdAt": "2018-05-21T07:23:13Z",
          "updatedAt": "2018-05-21T07:23:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTIzNjE2",
          "commit": {
            "abbreviatedOid": "5a83fa7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-01T17:36:04Z",
          "updatedAt": "2018-03-01T17:37:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This comment is obsolete. Remove the line",
              "createdAt": "2018-03-01T17:36:04Z",
              "updatedAt": "2018-03-02T06:07:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNjgyNzUx",
          "commit": {
            "abbreviatedOid": "5a83fa7"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-02T06:07:55Z",
          "updatedAt": "2018-03-02T06:07:55Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done.",
              "createdAt": "2018-03-02T06:07:55Z",
              "updatedAt": "2018-03-02T06:07:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyMDYwODI0",
      "title": "Rewrite the explainer, and update the use-cases document.",
      "url": "https://github.com/WICG/webpackage/pull/131",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@KenjiBaheux @thinkpanzer, is this clear as an entry-point to the packaging specs? Have I missed anything folks will want to see?",
      "createdAt": "2018-02-28T20:16:24Z",
      "updatedAt": "2018-03-02T01:14:35Z",
      "closedAt": "2018-03-02T01:14:31Z",
      "mergedAt": "2018-03-02T01:14:31Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 132,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyNjE4OTU0",
      "title": "Remove allResponseHeaders; handle signed request headers.",
      "url": "https://github.com/WICG/webpackage/pull/132",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@davidben, you'll probably like this one. It refactors the rules for trusting cross-origin exchanges so that they can be shared by Push and the application/http-exchange format. This let me cover all headers from those two transfer methods unconditionally, with only same-origin exchanges able to use `Signed-Headers` to select a subset.\r\n\r\nThere's a bunch of text motion, but sections id'ed `signed-headers` and `significant-headers` are basically unchanged in their new locations, and `authority-chain-validation` became the algorithm in `cross-origin-trust`.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/unify-cross-origin/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/unify-cross-origin/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-03-02T22:20:23Z",
      "updatedAt": "2018-03-05T20:37:42Z",
      "closedAt": "2018-03-05T20:37:39Z",
      "mergedAt": "2018-03-05T20:37:39Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAxMjg3NTY3",
          "commit": {
            "abbreviatedOid": "feb016a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-05T19:07:48Z",
          "updatedAt": "2018-03-05T19:09:10Z",
          "comments": [
            {
              "originalPosition": 326,
              "body": "@nyaxt pointed out that this needs to exclude the `Signature` header from the exchange passed to {{cross-origin-trust}} (since you can't cover a signature with itself), so I'm working on that.",
              "createdAt": "2018-03-05T19:07:48Z",
              "updatedAt": "2018-03-05T19:30:24Z"
            },
            {
              "originalPosition": 400,
              "body": "I'm excluding the `Signature` header from this too.",
              "createdAt": "2018-03-05T19:08:16Z",
              "updatedAt": "2018-03-05T19:30:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAxMjk1NjQ2",
          "commit": {
            "abbreviatedOid": "feb016a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-05T19:30:36Z",
          "updatedAt": "2018-03-05T19:30:37Z",
          "comments": [
            {
              "originalPosition": 326,
              "body": "Ok, fixed, I think.",
              "createdAt": "2018-03-05T19:30:37Z",
              "updatedAt": "2018-03-05T19:30:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 133,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyNjI2MjU4",
      "title": "Mitigate publishers that accidentally sign private information",
      "url": "https://github.com/WICG/webpackage/pull/133",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This builds on #132, so probably review that one first.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/block-set-cookie/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/block-set-cookie/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@davidben",
      "createdAt": "2018-03-02T23:04:31Z",
      "updatedAt": "2018-03-05T20:45:11Z",
      "closedAt": "2018-03-05T20:45:01Z",
      "mergedAt": "2018-03-05T20:45:01Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 134,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyNjM3ODEw",
      "title": "Require a new certificate extension for packages",
      "url": "https://github.com/WICG/webpackage/pull/134",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This builds on #132, so probably review that one first.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/cert-extension/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/cert-extension/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@davidben @sleevi",
      "createdAt": "2018-03-03T00:43:08Z",
      "updatedAt": "2018-03-05T20:58:02Z",
      "closedAt": "2018-03-05T20:57:51Z",
      "mergedAt": "2018-03-05T20:57:51Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAxMzIzNjQx",
          "commit": {
            "abbreviatedOid": "1cbb6b1"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I'm going to merge this so I can make the IETF deadline, but I'm still happy to fix comments.",
          "createdAt": "2018-03-05T20:55:22Z",
          "updatedAt": "2018-03-05T20:56:13Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Note that because these certificates can't be used for TLS servers anymore, I'm diverging from the TLS format. IIUC, the initial 64 spaces are only needed in TLS because the attacker controls the initial content of the message, but since the attacker doesn't control that for packages, it doesn't seem to be needed here. I've added an open question to check that my guess is right.",
              "createdAt": "2018-03-05T20:55:22Z",
              "updatedAt": "2018-03-05T20:56:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczMDA3NDM1",
      "title": "Update use cases",
      "url": "https://github.com/WICG/webpackage/pull/136",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/update-use-cases/draft-yasskin-webpackage-use-cases.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.txt&url2=https://jyasskin.github.io/webpackage/update-use-cases/draft-yasskin-webpackage-use-cases.txt)\r\n\r\nI'm probably going to merge this without review to get it in time for the IETF deadline, but I'll definitely fix any comments that show up after that.",
      "createdAt": "2018-03-05T22:37:52Z",
      "updatedAt": "2018-03-05T23:48:47Z",
      "closedAt": "2018-03-05T23:27:19Z",
      "mergedAt": "2018-03-05T23:27:19Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczMDExMzk0",
      "title": "Add an archival use case.",
      "url": "https://github.com/WICG/webpackage/pull/137",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/archival-use-case/draft-yasskin-webpackage-use-cases.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.txt&url2=https://jyasskin.github.io/webpackage/archival-use-case/draft-yasskin-webpackage-use-cases.txt)\r\n\r\n@ibnesayeed @craigfrancis @TzviyaSiegman, you've been interested in this topic in issues like #105. What should I write in this section? I don't know enough about the topic to even describe the use case well.\r\n\r\nI'm probably going to merge this without review to get it in time for the IETF deadline, but I'll definitely fix any comments that show up after that.",
      "createdAt": "2018-03-05T22:57:15Z",
      "updatedAt": "2018-03-06T20:57:42Z",
      "closedAt": "2018-03-05T23:28:11Z",
      "mergedAt": "2018-03-05T23:28:11Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "Thanks for adding these notes @jyasskin \r\n\r\nI'm not sure how much I can add at the moment, as you have noted that packages could be used for archival purposes (actual implementation will probably be for the browsers to decide), and the only other point I have is the suggestion/concerns about JavaScript basing the date/time off the timestamp of the package (which is already covered).",
          "createdAt": "2018-03-06T11:33:25Z",
          "updatedAt": "2018-03-06T11:33:25Z"
        },
        {
          "author": "ibnesayeed",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @jyasskin for this. The language used seems a little too informal. That said, I think we need to invite more people from the web arching community to give their input on the archival aspect here or in #105. In case of WARC file-based replay, certificates of the archive host are used in TLS communication rather than the original ones. I am CCing @anjackson, @hvdsomp, @phonedude, @ikreymer, @galsondor, and @machawk1 here for any comments on it.",
          "createdAt": "2018-03-06T13:07:56Z",
          "updatedAt": "2018-03-06T13:07:56Z"
        },
        {
          "author": "jmulliken",
          "authorAssociation": "NONE",
          "body": "I have some limited experience creating WARCs. Without knowing too much about the back-end, I can add that this approach would work for many html/css/javascript publications. We are currently using it for amenable web-based publications at Stanford University Press. Here, for example, is a web archive of our latest web publication: https://webrecorder.io/sup/enchanting-the-desert I think you could generalize a use case from this, but the type of publication is not the typical kind this group has looked at so far. That said I would LOVE for it to become part of the conversation.",
          "createdAt": "2018-03-06T20:45:45Z",
          "updatedAt": "2018-03-06T20:45:45Z"
        },
        {
          "author": "BigBlueHat",
          "authorAssociation": "NONE",
          "body": "From a Web Publication WG perspective, we'll want Packaged Web Publications (PWP) to live well beyond the rental of a domain name or certificate. Reducing the contents to a sandbox-ed experience may be fine if the contents are primarily (or exclusively) descriptive (i.e. little to no JS involved).\r\n\r\nIdeally, one could still experience a PWP they'd downloaded (or purchased) even if the domain or cert expired just days prior. Essentially, we don't want a reader's experience of a publication dependent on a rent-based architecture.\r\n\r\nAnd huge \ud83d\udc4d to involving a wider audience (i.e. WARC and friends) in the development of this potentially very valuable addition to the Web platform.",
          "createdAt": "2018-03-06T20:57:42Z",
          "updatedAt": "2018-03-06T20:57:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczNTM1NDIy",
      "title": "Start an implementation draft",
      "url": "https://github.com/WICG/webpackage/pull/139",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/implementation-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/implementation-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)\r\n\r\nThis shows the state we expect to synchronize on for May.",
      "createdAt": "2018-03-07T18:25:53Z",
      "updatedAt": "2018-03-18T04:41:50Z",
      "closedAt": "2018-03-18T04:41:46Z",
      "mergedAt": "2018-03-18T04:41:46Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for starting on this. Please ping me when it's ready for review.\r\n\r\n- Chrome currently implements the old TLS certURl format.\r\n- ECDSA not supported\r\n- new envelope format",
          "createdAt": "2018-03-07T21:12:23Z",
          "updatedAt": "2018-03-07T21:12:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@twifkak",
          "createdAt": "2018-03-07T22:32:38Z",
          "updatedAt": "2018-03-07T22:32:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, I think this is ready to review.",
          "createdAt": "2018-03-08T23:03:31Z",
          "updatedAt": "2018-03-08T23:03:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyOTIyOTQw",
          "commit": {
            "abbreviatedOid": "9fbef88"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-12T04:47:09Z",
          "updatedAt": "2018-03-12T04:55:07Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "Somehow this formatting is broken on the preview HTML version",
              "createdAt": "2018-03-12T04:47:09Z",
              "updatedAt": "2018-03-17T08:23:27Z"
            },
            {
              "originalPosition": 504,
              "body": "Chrome snapshot only allows 1 signature",
              "createdAt": "2018-03-12T04:50:04Z",
              "updatedAt": "2018-03-17T08:23:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NzYwNTM4",
          "commit": {
            "abbreviatedOid": "9fbef88"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-17T08:35:37Z",
          "updatedAt": "2018-03-17T08:35:37Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "Whoops, thanks for catching that.",
              "createdAt": "2018-03-17T08:35:37Z",
              "updatedAt": "2018-03-17T08:35:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NzYwNTQx",
          "commit": {
            "abbreviatedOid": "9fbef88"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-17T08:35:51Z",
          "updatedAt": "2018-03-17T08:35:51Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "Fixed. The parser expects a blank line before lists.",
              "createdAt": "2018-03-17T08:35:51Z",
              "updatedAt": "2018-03-17T08:35:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 140,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczNTM2ODQ0",
      "title": "gen-signedexchange: Remove 32 spaces from signed message",
      "url": "https://github.com/WICG/webpackage/pull/140",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-07T18:31:50Z",
      "updatedAt": "2018-03-12T06:28:22Z",
      "closedAt": "2018-03-12T06:28:22Z",
      "mergedAt": "2018-03-12T06:28:22Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyNTQ3MTIx",
          "commit": {
            "abbreviatedOid": "07f3c27"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-03-09T05:20:27Z",
          "updatedAt": "2018-03-09T05:20:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczODM2ODYw",
      "title": "gen-se: Remove \"Signed-Headers\" header",
      "url": "https://github.com/WICG/webpackage/pull/143",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "Updates gen-signedexchange to match spec text changes in 3cae5496a86cafde2ab59f95bb62d6d47202445b",
      "createdAt": "2018-03-08T20:06:30Z",
      "updatedAt": "2018-03-12T06:59:00Z",
      "closedAt": "2018-03-12T06:59:00Z",
      "mergedAt": "2018-03-12T06:59:00Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm",
          "createdAt": "2018-03-09T05:19:34Z",
          "updatedAt": "2018-03-09T05:19:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyNTQ3MDQ3",
          "commit": {
            "abbreviatedOid": "9e9ded2"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-09T05:19:45Z",
          "updatedAt": "2018-03-09T05:19:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 144,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc0MzExMjUx",
      "title": "gen-signedexchange: Limit num of chunks when splitting headers by colon",
      "url": "https://github.com/WICG/webpackage/pull/144",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes the bug that colons were not usable in request/response headers.\r\n",
      "createdAt": "2018-03-12T09:27:49Z",
      "updatedAt": "2018-03-12T10:52:08Z",
      "closedAt": "2018-03-12T10:38:25Z",
      "mergedAt": "2018-03-12T10:38:25Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyOTgzMDY2",
          "commit": {
            "abbreviatedOid": "b163e6c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-12T10:15:38Z",
          "updatedAt": "2018-03-12T10:15:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 145,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc0MzE1NDU5",
      "title": "signedexchange: Remove signed-header usages",
      "url": "https://github.com/WICG/webpackage/pull/145",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PTAL",
      "createdAt": "2018-03-12T09:46:02Z",
      "updatedAt": "2018-03-13T02:21:42Z",
      "closedAt": "2018-03-13T01:47:25Z",
      "mergedAt": "2018-03-13T01:47:25Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAzMjQ3MjQw",
          "commit": {
            "abbreviatedOid": "8f3d711"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-12T22:47:19Z",
          "updatedAt": "2018-03-12T22:47:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc0NTY0Mjg3",
      "title": "gen-signedexchange: Add expire flag",
      "url": "https://github.com/WICG/webpackage/pull/146",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PTAL",
      "createdAt": "2018-03-13T05:52:58Z",
      "updatedAt": "2018-03-13T06:11:30Z",
      "closedAt": "2018-03-13T06:11:27Z",
      "mergedAt": "2018-03-13T06:11:27Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAzMzA1MTk2",
          "commit": {
            "abbreviatedOid": "3049183"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-13T06:01:24Z",
          "updatedAt": "2018-03-13T06:01:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1MTU0OTUz",
      "title": "Replace the application/http-exchange+cbor format with a simpler format.",
      "url": "https://github.com/WICG/webpackage/pull/148",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This format:\r\n* Doesn't require a streaming CBOR parser parse it from a network stream.\r\n* Doesn't allow request payloads or response trailers, which don't fit into\r\n  the signature model.\r\n* Allows checking the signature before parsing the exchange headers.\r\n\r\nThis is similar to, but not exactly the same as the format @davidben proposed for #139: it pulls out the `Signature` header into bytestring before the other headers so that the second map can be literally the bytes in the signed string. This isn't extensible if we ever want to add new non-signed values, so I added a format version number into the format's magic number.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/no-streaming/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/no-streaming/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nFixes #135.",
      "createdAt": "2018-03-15T05:53:41Z",
      "updatedAt": "2018-04-04T22:51:56Z",
      "closedAt": "2018-04-04T22:51:53Z",
      "mergedAt": "2018-04-04T22:51:52Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MDk5ODk3",
          "commit": {
            "abbreviatedOid": "1985843"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-03T20:13:55Z",
          "updatedAt": "2018-04-03T20:27:52Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Yay!",
              "createdAt": "2018-04-03T20:13:55Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 25,
              "body": "WDYT about putting the two lengths first? (I.e. swap this one and the one above.) One less state in your parsing state machine. (First you read a fixed 5 + 3 + 3 bytes, then you check lengths, then you read additional `sigLength + headerLength` bytes.)",
              "createdAt": "2018-04-03T20:15:10Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 38,
              "body": "Nit: Specifically the `Transfer-Encoding` header inside the header block has no effect, whereas the outer `Transfer-Encoding` header which transfers the overall `application/signed-exchange` blob does. Dunno if that's worth clarifying.",
              "createdAt": "2018-04-03T20:16:40Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 167,
              "body": "(I like the current mix, of course. :-) )",
              "createdAt": "2018-04-03T20:17:54Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 15,
              "body": "Does the receiver need to check this value?",
              "createdAt": "2018-04-03T20:20:05Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 20,
              "body": "I might suggest instead saying that draft impls not use the final MIME type instead/additionally. Consider if this format changes a bit. Probably someone will end up in a situation where they need to support two iterations at the same time. That means you first need to read enough to dispatch on the type (which isn't even fixed-width), then parse the rest out. Or you cleverly meld the state machines.\r\n\r\nWhereas, if it's in the content type, the HTTP stack has already given you the headers as one atomic thing, so you can go ahead and dispatch there.\r\n\r\nEdit: Ah, I see you've put the parameter in the MIME type registration. Maybe make it clearer here that that's going on?",
              "createdAt": "2018-04-03T20:21:10Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 212,
              "body": "That seems a lot of complexity to put on the receiver. Why not just define application/signed-exchange-v1, application/signed-exchange-v2, etc. You don't need to parse out all this complex versioning information. We use a lot more bytes but header compression is nice, and is this format really going to have to change that much?\r\n\r\nYou might be able to make this extensible by saying the headers block is allowed to have unknown keys that you just ignore. This is how TLS does a lot of things. Though then you need to be sure that extensions are all safe for unknowing receivers to ignore.",
              "createdAt": "2018-04-03T20:25:26Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MTA2Nzgw",
          "commit": {
            "abbreviatedOid": "1985843"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-03T20:35:08Z",
          "updatedAt": "2018-04-03T23:30:57Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think the receiver can trust the mime type, and now I've said so. If they don't match, the signature will fail to validate.",
              "createdAt": "2018-04-03T20:35:08Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 20,
              "body": "I think the version identifier has to go in both because people will store these as files, and their servers need to be able to pick the right mime type. But yeah, I've now said the client needs to trust the mime type.",
              "createdAt": "2018-04-03T23:02:29Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 25,
              "body": "Sure.",
              "createdAt": "2018-04-03T23:02:37Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 38,
              "body": "Clarified.",
              "createdAt": "2018-04-03T23:05:31Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 212,
              "body": "Hopefully the format won't change much once it's an RFC, but it is going to change until then. I think I talked to @sleevi about whether to make the headers block (especially the non-signed block) extensible, and he liked making it really simple, hence 21692e13a3b505292fbb248883ba368c4a2f178c.\r\n\r\nI think I can remove ranges from the version numbers, since most likely a client will only support 2 versions at a time.",
              "createdAt": "2018-04-03T23:14:49Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTA3MjA4",
          "commit": {
            "abbreviatedOid": "b95e497"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-04T21:28:28Z",
          "updatedAt": "2018-04-04T21:31:15Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I would probably suggest checking it, rather than ignoring it, just to make sure folks get it right. https://tools.ietf.org/html/draft-thomson-postel-was-wrong-02 and stuff.",
              "createdAt": "2018-04-04T21:28:28Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 220,
              "body": "Nit: That then suggests that versions aren't digits but opaque strings, right?",
              "createdAt": "2018-04-04T21:29:30Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTA5MjM4",
          "commit": {
            "abbreviatedOid": "b95e497"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks!",
          "createdAt": "2018-04-04T21:35:31Z",
          "updatedAt": "2018-04-04T21:40:15Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "Yep, I believe I included that change in b95e497dd2bfb780504220ccd4ebe85fe64baf56 (especially `v: A string denoting the version`), but if you see a word I missed, let me know.",
              "createdAt": "2018-04-04T21:35:31Z",
              "updatedAt": "2018-04-04T21:40:15Z"
            },
            {
              "originalPosition": 16,
              "body": "Done.",
              "createdAt": "2018-04-04T21:35:41Z",
              "updatedAt": "2018-04-04T21:40:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NDM1Njcy",
      "title": "gen-se: Allow override of content-type response header",
      "url": "https://github.com/WICG/webpackage/pull/150",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "Found by @irori",
      "createdAt": "2018-03-16T04:04:16Z",
      "updatedAt": "2018-03-20T00:24:05Z",
      "closedAt": "2018-03-20T00:23:22Z",
      "mergedAt": "2018-03-20T00:23:22Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "So the problem was that `Add` could be called multiple times for the same header `content-type`, which was problematic?",
          "createdAt": "2018-03-16T04:39:57Z",
          "updatedAt": "2018-03-16T04:39:57Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "`Add` can be called multiple times for the same header, but `encodeResponseHeaders` uses only the first one (`value[0]` here:\r\nhttps://github.com/WICG/webpackage/blob/master/go/signedexchange/signedexchange.go#L104)",
          "createdAt": "2018-03-16T05:03:29Z",
          "updatedAt": "2018-03-16T05:03:29Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm",
          "createdAt": "2018-03-16T05:11:21Z",
          "updatedAt": "2018-03-16T05:11:21Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> encodeResponseHeaders uses only the first one (value[0] here:\r\n\r\nThis sounds like an another bug.",
          "createdAt": "2018-03-16T05:12:24Z",
          "updatedAt": "2018-03-16T05:12:24Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@twifkak FYI, while this shouldn't affect \"library\" usage of gen-se.",
          "createdAt": "2018-03-20T00:24:05Z",
          "updatedAt": "2018-03-20T00:24:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NDU4NzQz",
          "commit": {
            "abbreviatedOid": "124de3c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-16T05:36:20Z",
          "updatedAt": "2018-03-16T05:36:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NjE1NjYz",
      "title": "Talk about publishers rather than authors.",
      "url": "https://github.com/WICG/webpackage/pull/153",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is just an editorial change rather than a behavior change.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/publisher-author/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/publisher-author/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-03-16T18:41:42Z",
      "updatedAt": "2018-03-17T08:04:58Z",
      "closedAt": "2018-03-17T08:04:55Z",
      "mergedAt": "2018-03-17T08:04:55Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NzM4NDA5",
          "commit": {
            "abbreviatedOid": "989c6fa"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-16T22:51:43Z",
          "updatedAt": "2018-03-16T22:51:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 155,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzM1MDcw",
      "title": "Insulate against changes in later versions of draft-thomson-http-mice-02.",
      "url": "https://github.com/WICG/webpackage/pull/155",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/draft-mice/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/draft-mice/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-03-18T04:44:28Z",
      "updatedAt": "2018-04-10T23:22:01Z",
      "closedAt": "2018-04-10T23:21:58Z",
      "mergedAt": "2018-04-10T23:21:58Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the change totally makes sense to go in `draft-yasskin-http-origin-signed-responses.md`, but I'd like to avoid changing the impl snapshot `draft-yasskin-httpbis-origin-signed-exchanges-impl.md` at this point if there is no security concern.\r\n\r\nChromium has already implemented the current `draft-yasskin-httpbis-origin-signed-exchanges-impl.md` under flag, so any further changes will confuse the users who are currently experimenting with the feature.",
          "createdAt": "2018-03-19T06:11:07Z",
          "updatedAt": "2018-03-19T06:11:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, now that https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-00 is published, this is updated and ready for the -01 implementation draft.\r\n\r\nAnd I should check with @martinthomson whether this is a sensible way to handle changes in his MI draft. I've added a -draft2 suffix to all of the identifiers.",
          "createdAt": "2018-04-06T18:11:28Z",
          "updatedAt": "2018-04-06T18:11:28Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "We kinda screwed up the drafts leading to RFC 8188 by not including a draft-version in the name that we used for deployments.  That's a hard thing to reverse.  If you are serious about changing the mechanism to handle empty bodies properly, then there is a risk that things will change.",
          "createdAt": "2018-04-09T02:10:38Z",
          "updatedAt": "2018-04-09T02:10:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I follow you. RFC 8188 and draft-thomson-http-mice-02 don't cover the same thing.",
          "createdAt": "2018-04-09T02:27:04Z",
          "updatedAt": "2018-04-09T02:27:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "In 8188 we made a few (minor) changes over time.  Each time, we had to deploy a new name.  Given that the chances of changes here are non-trivial, maybe prepare for those changes by adding a draft-number suffix.",
          "createdAt": "2018-04-09T04:13:30Z",
          "updatedAt": "2018-04-09T04:13:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'll take that as an endorsement of this change, where I'm adding a draft number suffix to the header and content type. Thanks!",
          "createdAt": "2018-04-09T15:58:50Z",
          "updatedAt": "2018-04-09T15:58:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwMzEwODk1",
          "commit": {
            "abbreviatedOid": "be67b99"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM for draft ver2",
          "createdAt": "2018-04-09T01:38:02Z",
          "updatedAt": "2018-04-09T01:38:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 157,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1ODYwMjU1",
      "title": "gen-signedexchange: Encode multiple values for the same header",
      "url": "https://github.com/WICG/webpackage/pull/157",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #151\r\n\r\nCC @twifkak \r\n\r\nPTAL",
      "createdAt": "2018-03-19T10:39:19Z",
      "updatedAt": "2018-03-20T06:55:25Z",
      "closedAt": "2018-03-19T12:16:01Z",
      "mergedAt": "2018-03-19T12:16:01Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "cherry-picked into nyaxt/master",
          "createdAt": "2018-03-20T00:43:24Z",
          "updatedAt": "2018-03-20T00:43:24Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that https://tools.ietf.org/html/rfc7230#section-3.2.2 calls out an exception for Set-Cookie. Obviously, Set-Cookie shouldn't appear in web packages, but I'm wondering if we can avoid the potential for semantic change (e.g. in any other non-standard headers) by instead looping over `value` and emitting several key/value pairs.",
          "createdAt": "2018-03-20T05:50:54Z",
          "updatedAt": "2018-03-20T05:50:54Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "@twifkak Good point. I feel like we should eliminate `Set-Cookie` explicitly. Did you mean we should have a kind of whitelist for standard headers?",
          "createdAt": "2018-03-20T06:21:44Z",
          "updatedAt": "2018-03-20T06:21:44Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry! My comment was based on a mistaken understanding of CBOR. I see now that it supports only one value per key. In that case, we should probably eliminate `Set-Cookie` here, or return an error if more than one `Set-Cookie` is present.\r\n\r\nFWIW, my packager tool currently strips all response headers in this list: https://jyasskin.github.io/webpackage/implementation-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#stateful-headers\r\n\r\nThis could be a useful thing to do at the library level, too, or you may want to keep it generic (e.g. allow users to generate stateful htxg's for testing). Both options seem reasonable to me.",
          "createdAt": "2018-03-20T06:52:39Z",
          "updatedAt": "2018-03-20T06:52:39Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I think stripping the stateful header fields should be done on the library side. I'll create an issue for this and PR soon.",
          "createdAt": "2018-03-20T06:55:25Z",
          "updatedAt": "2018-03-20T06:55:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0OTI5NTM0",
          "commit": {
            "abbreviatedOid": "3c8bef0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-19T11:49:10Z",
          "updatedAt": "2018-03-19T11:49:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2MDkzMDg4",
      "title": "gofmt -s -w",
      "url": "https://github.com/WICG/webpackage/pull/158",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-20T05:33:57Z",
      "updatedAt": "2018-04-11T01:00:34Z",
      "closedAt": "2018-04-11T01:00:34Z",
      "mergedAt": "2018-04-11T01:00:34Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "ping?",
          "createdAt": "2018-04-10T08:34:50Z",
          "updatedAt": "2018-04-10T08:34:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwOTA1Mzc1",
          "commit": {
            "abbreviatedOid": "9009da7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-10T16:06:13Z",
          "updatedAt": "2018-04-10T16:06:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDU5MjE0",
          "commit": {
            "abbreviatedOid": "9009da7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-11T01:00:24Z",
          "updatedAt": "2018-04-11T01:00:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 159,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2MDk1NjQ2",
      "title": "cmd/gen-signedexchange: Add date flag",
      "url": "https://github.com/WICG/webpackage/pull/159",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#152 \r\n\r\nPTAL",
      "createdAt": "2018-03-20T05:57:17Z",
      "updatedAt": "2018-03-23T00:23:59Z",
      "closedAt": "2018-03-20T07:00:27Z",
      "mergedAt": "2018-03-20T07:00:27Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @hajimehoshi!\r\n\r\n@nyaxt would you cherry-pick this into nyaxt/master?",
          "createdAt": "2018-03-22T04:59:32Z",
          "updatedAt": "2018-03-22T04:59:32Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Done: https://github.com/nyaxt/webpackage/commit/8c727969402bce9f4bd86b1c530696a72aea0384",
          "createdAt": "2018-03-23T00:23:59Z",
          "updatedAt": "2018-03-23T00:23:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA1MjI4Nzk1",
          "commit": {
            "abbreviatedOid": "899f414"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-20T06:23:44Z",
          "updatedAt": "2018-03-20T06:23:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2MTA5NDMy",
      "title": "gen-signedexchange: Error with stateful request/response header fields",
      "url": "https://github.com/WICG/webpackage/pull/162",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#160 \r\n\r\nPTAL",
      "createdAt": "2018-03-20T07:38:42Z",
      "updatedAt": "2018-03-26T05:59:02Z",
      "closedAt": "2018-03-26T05:59:02Z",
      "mergedAt": "2018-03-26T05:59:02Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Should these rather error out than ignore? (No need to take my comment authoritative / you can wait for nyaxt's response)",
          "createdAt": "2018-03-20T07:51:06Z",
          "updatedAt": "2018-03-20T07:51:06Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "First I thought that, but now I am not sure since gen-singnedexchange would not accept any response header including stateful headers, and this would not be useful. I'm fine with either.",
          "createdAt": "2018-03-20T08:00:25Z",
          "updatedAt": "2018-03-20T08:00:25Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Commented on #160, but +1 on kinu. This should be an error",
          "createdAt": "2018-03-20T08:11:09Z",
          "updatedAt": "2018-03-20T08:11:09Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Done.",
          "createdAt": "2018-03-22T06:12:49Z",
          "updatedAt": "2018-03-22T06:12:49Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nyaxt Are you happy with this PR? Thanks!",
          "createdAt": "2018-03-22T12:20:32Z",
          "updatedAt": "2018-03-22T12:20:32Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "ping @nyaxt ",
          "createdAt": "2018-03-26T05:42:20Z",
          "updatedAt": "2018-03-26T05:42:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA1OTk3MzYy",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-22T06:18:59Z",
          "updatedAt": "2018-03-22T06:18:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Consider exporting these two sets. I'd like to offer packager users the option to remove these headers rather than error, as I imagine some web servers probably Set-Cookie automatically. (Let me know if you think that's a bad idea.)",
              "createdAt": "2018-03-22T06:18:59Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA1OTk3NTMx",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sorry for the delay!",
          "createdAt": "2018-03-22T06:20:22Z",
          "updatedAt": "2018-03-22T06:20:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2MDAzMTgz",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-22T06:59:11Z",
          "updatedAt": "2018-03-22T06:59:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good point. I'd add a new API to strip (probably in another PR). I'd like to keep `NewExchange` as it is. gen-signedexchange users would be able to choose to strip such headers by specifying flag. Does this make sense to you?",
              "createdAt": "2018-03-22T06:59:11Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2MDk0NjY0",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-03-22T12:27:01Z",
          "updatedAt": "2018-03-22T12:27:30Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "stateful response header %q can't be captured inside signed exchange",
              "createdAt": "2018-03-22T12:27:01Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            },
            {
              "originalPosition": 30,
              "body": "stateful request header %q can't be captured inside signed exchange\r\n\r\n",
              "createdAt": "2018-03-22T12:27:24Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2MTg1OTMw",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-22T16:00:13Z",
          "updatedAt": "2018-03-22T16:00:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yep, that works for me.",
              "createdAt": "2018-03-22T16:00:13Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2MzgwMTQ5",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-23T05:12:59Z",
          "updatedAt": "2018-03-23T05:13:06Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Done.",
              "createdAt": "2018-03-23T05:12:59Z",
              "updatedAt": "2018-03-23T05:13:06Z"
            },
            {
              "originalPosition": 35,
              "body": "Done.",
              "createdAt": "2018-03-23T05:13:03Z",
              "updatedAt": "2018-03-23T05:13:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2Nzc5NzEw",
          "commit": {
            "abbreviatedOid": "82a15bc"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-26T05:57:28Z",
          "updatedAt": "2018-03-26T05:57:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2NDkzMDYx",
      "title": "Fix #161: All HTTP header names should be lowercase.",
      "url": "https://github.com/WICG/webpackage/pull/163",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @irori. Please double-check that I fixed everywhere that failed to specify that HTTP headers are named in lowercase.\r\n\r\nSpec: [Preview](https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nImpl draft: [Preview](https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-03-21T14:26:12Z",
      "updatedAt": "2018-03-27T20:27:17Z",
      "closedAt": "2018-03-27T20:27:14Z",
      "mergedAt": "2018-03-27T20:27:14Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "It might be worth spelling out what the receiver should do if it sees an uppercase header. (Otherwise LGTM.)",
          "createdAt": "2018-03-21T15:54:17Z",
          "updatedAt": "2018-03-21T15:54:17Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you also update the \"implementation checkpoint\" and the envelope format there?",
          "createdAt": "2018-03-22T00:57:43Z",
          "updatedAt": "2018-03-22T00:57:43Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you also update [Section 5.3](https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.3)?",
          "createdAt": "2018-03-22T02:00:59Z",
          "updatedAt": "2018-03-22T02:00:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks, done.",
          "createdAt": "2018-03-24T12:23:37Z",
          "updatedAt": "2018-03-24T12:23:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzE2Mjg0",
          "commit": {
            "abbreviatedOid": "def9b44"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-25T01:43:02Z",
          "updatedAt": "2018-03-25T01:43:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2Nzc2Mjkx",
          "commit": {
            "abbreviatedOid": "def9b44"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-26T05:26:08Z",
          "updatedAt": "2018-03-26T05:26:30Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Nit: lowercase",
              "createdAt": "2018-03-26T05:26:08Z",
              "updatedAt": "2018-03-27T20:23:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA3NDUzNDE3",
          "commit": {
            "abbreviatedOid": "def9b44"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-27T20:24:07Z",
          "updatedAt": "2018-03-27T20:24:08Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Thanks.",
              "createdAt": "2018-03-27T20:24:08Z",
              "updatedAt": "2018-03-27T20:24:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc3MjQ5Njky",
      "title": "Update to draft-04 of structured headers.",
      "url": "https://github.com/WICG/webpackage/pull/166",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "But pin the implementation draft to -02.\r\n\r\nSpec: [Preview](https://jyasskin.github.io/webpackage/update-header-structure-draft/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/update-header-structure-draft/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nImpl draft: [Preview](https://jyasskin.github.io/webpackage/update-header-structure-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/update-header-structure-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-03-24T17:49:18Z",
      "updatedAt": "2018-03-27T20:18:51Z",
      "closedAt": "2018-03-27T20:18:47Z",
      "mergedAt": "2018-03-27T20:18:47Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@mnot, FYI in case you like watching changes to drafts using structured headers.\r\n\r\n@hajimehoshi @nyaxt The encoding of binary content will need to change in the implementations, but only *after* we move to the next implementation draft.",
          "createdAt": "2018-03-24T17:52:56Z",
          "updatedAt": "2018-03-24T17:52:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzU3NDk0",
          "commit": {
            "abbreviatedOid": "538aa69"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-26T02:13:20Z",
          "updatedAt": "2018-03-26T02:13:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2Nzg1ODUx",
          "commit": {
            "abbreviatedOid": "538aa69"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-26T06:41:40Z",
          "updatedAt": "2018-03-26T06:41:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc3MzI2MzI5",
      "title": "Make ecdsaSigValue fields visible so it can be asn1.Marshaled",
      "url": "https://github.com/WICG/webpackage/pull/167",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-26T01:54:00Z",
      "updatedAt": "2018-03-26T05:17:53Z",
      "closedAt": "2018-03-26T05:17:53Z",
      "mergedAt": "2018-03-26T05:17:53Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2Nzc1MzUz",
          "commit": {
            "abbreviatedOid": "9963ed1"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-03-26T05:17:44Z",
          "updatedAt": "2018-03-26T05:17:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc5MTY0OTQy",
      "title": "Finalize impl snapshot",
      "url": "https://github.com/WICG/webpackage/pull/168",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Impl draft: [Preview](https://jyasskin.github.io/webpackage/finalize-impl-snapshot/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/finalize-impl-snapshot/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)\r\n\r\n@nyaxt @twifkak, I think this is the final set of changes needed before I publish this snapshot. Do you see anything that'll change before we want to move to the next snapshot?",
      "createdAt": "2018-04-03T17:18:25Z",
      "updatedAt": "2018-04-05T03:26:03Z",
      "closedAt": "2018-04-05T03:26:00Z",
      "mergedAt": "2018-04-05T03:26:00Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MDY3MDM2",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I'll defer to @nyaxt for approval.",
          "createdAt": "2018-04-03T18:32:45Z",
          "updatedAt": "2018-04-03T18:39:51Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "nit: Specify an upper bound on `<positive-integer>`? Otherwise, it'll be an unspecified upper bound, as I'm sure nobody will use bignum for this. :)",
              "createdAt": "2018-04-03T18:32:45Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            },
            {
              "originalPosition": 76,
              "body": "Oh, I had missed the removal of tls-cert-chain earlier. Do you advise a content-type to use for certUrls when implementing against this snapshot?",
              "createdAt": "2018-04-03T18:36:35Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MDgzNjMx",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-03T19:22:41Z",
          "updatedAt": "2018-04-03T20:17:25Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I added it for the impl draft (https://github.com/WICG/webpackage/pull/139/commits/2bc9a298b5686d22027164e36b3537ae654fd2a2), but Chrome just doesn't enforce it (https://cs.chromium.org/search/?q=tls-cert-chain&sq=package:chromium&type=cs), so I may as well not specify a new thing for just one version of the draft.\r\n\r\nI don't have a strong feeling for what the server should use. I could put this back if it makes you more comfortable, or you could use `application/octet-stream`.",
              "createdAt": "2018-04-03T19:22:41Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            },
            {
              "originalPosition": 93,
              "body": "'k. 10000 versions should be enough for anyone.",
              "createdAt": "2018-04-03T20:16:44Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MTAxNjkz",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-03T20:19:44Z",
          "updatedAt": "2018-04-03T20:19:44Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Meh, `octet-stream` works for me.",
              "createdAt": "2018-04-03T20:19:44Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTM2MDUy",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-04T23:34:07Z",
          "updatedAt": "2018-04-04T23:34:07Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "After a review of the main spec, I wound up removing numeric ranges from there, so I'll also remove them from here.",
              "createdAt": "2018-04-04T23:34:07Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTQxOTg5",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-05T00:08:49Z",
          "updatedAt": "2018-04-05T00:08:49Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Works for me. Thanks for the heads up.",
              "createdAt": "2018-04-05T00:08:49Z",
              "updatedAt": "2018-04-05T00:08:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTQ4NDAw",
          "commit": {
            "abbreviatedOid": "1b1b333"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-04-05T00:54:26Z",
          "updatedAt": "2018-04-05T00:54:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc5NzczOTUw",
      "title": "Fix #147: Require URLs to be absolute.",
      "url": "https://github.com/WICG/webpackage/pull/170",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I realized this should probably also go in before I publish the implementation draft.\r\n\r\nSpec: [Preview](https://jyasskin.github.io/webpackage/absolute-urls/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/absolute-urls/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nImpl draft: [Preview](https://jyasskin.github.io/webpackage/absolute-urls/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/absolute-urls/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-04-05T19:30:07Z",
      "updatedAt": "2018-04-09T01:38:55Z",
      "closedAt": "2018-04-06T17:34:07Z",
      "mergedAt": "2018-04-06T17:34:07Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me, assuming the allowance of all schemes (incl `file:`) is intentional (and it's safe to ignore fragments).",
          "createdAt": "2018-04-05T20:22:49Z",
          "updatedAt": "2018-04-05T20:22:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I suspect we're going to need to restrict the schemes some, but I'm not sure to what (https only? [potentially-trustworthy](https://www.w3.org/TR/secure-contexts/#is-origin-trustworthy) only?), so I was going to leave that open for now.",
          "createdAt": "2018-04-06T03:16:28Z",
          "updatedAt": "2018-04-06T03:16:28Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm",
          "createdAt": "2018-04-09T01:38:55Z",
          "updatedAt": "2018-04-09T01:38:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 171,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwMDYwMDk4",
      "title": "Fix #169: Explicitly accept SCTs in X.509 and OCSP extensions.",
      "url": "https://github.com/WICG/webpackage/pull/171",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @irori.\r\n\r\n@davidben @sleevi, is this the right thing to do? Or should I match [RFC6962](https://tools.ietf.org/html/rfc6962#section-3.3) by requiring clients to look in all three places?",
      "createdAt": "2018-04-06T21:38:01Z",
      "updatedAt": "2018-04-09T18:19:21Z",
      "closedAt": "2018-04-09T18:19:18Z",
      "mergedAt": "2018-04-09T18:19:18Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm confused. What's the motivation for ignoring them? That seems inconsistent, especially considering that SCTs will often be embedded in the certificate.\r\n\r\nIt also seems more complicated to ignore them for the implementer too. Implementation-wise, that wants to be thoroughly abstracted away from the web packaging logic anyway. If not, something is probably structured wrong.",
          "createdAt": "2018-04-06T21:51:36Z",
          "updatedAt": "2018-04-06T21:51:52Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin I think we can close as WontFix.\r\n\r\nAll three sources (certificate, OCSP, extension) should be acceptable. The most likely workflow is that all of the necessary SCTs will be within the certificate itself. However, we need an additional channel to supply SCTs (in the event the cert or OCSP response does not contain them), hence the need for the CBOR side (to match the TLS extension).\r\n\r\nSo... They should all work :) This is more about mirroring the TLS channels' set of authority expressions",
          "createdAt": "2018-04-06T21:54:14Z",
          "updatedAt": "2018-04-06T21:54:14Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "My argument for ignoring the other two methods is that it's simpler to have only one way to do things. However, if y'all think it's actually simpler to accept them from anywhere, I'll do that instead.\r\n\r\nIt's definitely not WontFix if we want to accept them from anywhere: the current text says that the SCT has to appear by itself. I have to fix that.\r\n\r\n@irori, are you the person implementing this, and were you asking because it's less code to accept them from any of the three places?",
          "createdAt": "2018-04-06T21:55:33Z",
          "updatedAt": "2018-04-06T21:55:33Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Yeah, from a CT ecosystem point of view, it's highly desirable that the CA is responsible for ensuring the compliance of the certificate with various CT policies, either via embedding SCTs in the certificate or via the OCSP response. That ensures a more consistent approach less likely to break due to changes in the CT ecosystem. The availability for the TLS extension (or, in this case, the dictionary) is meant to address scenarios in which the CA does not manage that effectively/at all, or the validity period of the certificate is so great that it exceeds the normal log ecosystem stability range. The former is increasingly less likely as CT deployment rolls out, while the latter has not yet happened and is only theoretical.\r\n\r\nThe ideal outcome is that Web Packagers do not have to 'think' about CT when packaging/updating signatures, and that it just works. This is a mechanism to allow for explicit control (as some large CDNs prefer, in order to keep certificates and OCSP responses small for clients that don't use CT) or rapid response.",
          "createdAt": "2018-04-06T21:59:17Z",
          "updatedAt": "2018-04-06T21:59:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "CT has a bunch of ways to deliver SCTs because it needed to slot into an existing and complex CA and TLS server ecosystem. You may have CAs that haven't gotten SCT support yet, you may have TLS servers that don't support the extension, you may have server operators that don't know to configure CT, etc. In a vacuum, yes, having only one mechanism would be by far the most preferable, but there were other considerations for it to succeed.\r\n\r\nGiven that CT thus looks like this, it should be consistent across uses, so that we *don't* need to make the implementation more complex. Chromium's implementation already bundles together the three sources. If the in-progress web packaging implementation isn't using that abstraction, we should fix that, and not the spec.",
          "createdAt": "2018-04-06T22:00:56Z",
          "updatedAt": "2018-04-06T22:00:56Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Done: https://jyasskin.github.io/webpackage/fix-169/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust",
          "createdAt": "2018-04-06T22:03:56Z",
          "updatedAt": "2018-04-06T22:03:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "In hindsight, I suspect CT could have managed with just the in-cert mechanism and the TLS extension, without leeching off of OCSP, but so it goes. :-)",
          "createdAt": "2018-04-06T22:06:53Z",
          "updatedAt": "2018-04-06T22:06:53Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, accepting them is simpler from the implementer's point of view.\r\nThanks!\r\n",
          "createdAt": "2018-04-09T01:34:38Z",
          "updatedAt": "2018-04-09T01:34:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwMjIxODc3",
          "commit": {
            "abbreviatedOid": "c5fc489"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-04-06T22:05:35Z",
          "updatedAt": "2018-04-06T22:05:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 173,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwNDM5MzMx",
      "title": "Sketch loading and caching in the explainer based on Kinuko's description",
      "url": "https://github.com/WICG/webpackage/pull/173",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @kinu! This is a subset of your document that I think will give folks like the TAG enough to go on. The rest of your doc is most of the specification.\r\n\r\nhttps://github.com/jyasskin/webpackage/blob/sketch-loading/explainer.md#signed-exchange-loading-sketch",
      "createdAt": "2018-04-09T22:01:03Z",
      "updatedAt": "2018-05-08T22:00:47Z",
      "closedAt": "2018-05-08T22:00:39Z",
      "mergedAt": "2018-05-08T22:00:39Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've now made the layering more explicit and removed the claim that we'll put the inner exchange in the HTTP cache. There's still a section saying to explore that later.\r\n\r\nHow's it look now?",
          "createdAt": "2018-05-05T00:02:38Z",
          "updatedAt": "2018-05-05T00:02:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this is pretty much stable now, so I'll merge it. Comments and bugs are still welcome.",
          "createdAt": "2018-05-08T21:57:29Z",
          "updatedAt": "2018-05-08T21:57:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwNzQ4MTQx",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for starting this! I have some comments/questions (probably more, but here're initial ones)",
          "createdAt": "2018-04-10T09:03:04Z",
          "updatedAt": "2018-04-10T09:55:24Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "nit: would it be better to say it depends on if the request is for a navigation or not? (Not sure how this text is confusing or not to the readers)",
              "createdAt": "2018-04-10T09:03:04Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 105,
              "body": "'only if the Service Worker responds with...' part felt a bit confusing (in this paragraph it's not clear if we're talking about fetching the physical URL in general or the case that with the embedder's SW).",
              "createdAt": "2018-04-10T09:28:43Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 138,
              "body": "Should it be clearer if we say 'If it fails to validate the signature' given that this talks about general validation failure cases (e.g. clock skew etc)?  (While I also found that we're using the text 'find a valid signature' throughout this change, so this is probably intentional?)\r\n",
              "createdAt": "2018-04-10T09:40:45Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 173,
              "body": "Do you have some example scenarios?",
              "createdAt": "2018-04-10T09:49:13Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 164,
              "body": "Let me clarify... at this point we start talking about caching the response(s) in the signed exchange, is that right?",
              "createdAt": "2018-04-10T09:52:24Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 182,
              "body": "I don't feel super comfortable having this text yet, UA should respect the cache headers but not sure if it should cache the response in the signed exchange.  Also: mentioning 'preload cache' here feels a bit confusing, it should come into play only when the signed exchange is 'preloaded', right?",
              "createdAt": "2018-04-10T09:53:29Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDAzNjkw",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-10T20:44:34Z",
          "updatedAt": "2018-04-10T21:50:41Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Yeah, probably. Done.",
              "createdAt": "2018-04-10T20:44:34Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 105,
              "body": "I was worrying about either the physical URL's or the embedder's SW receiving the `application/signed-exchange` response but calling `e.respondWith(somethingElse)`. I can probably just ignore that subtlety for the explainer and let folks assume that SWs will return the real resource.",
              "createdAt": "2018-04-10T20:53:24Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 138,
              "body": "My idea here is that signed exchanges can have several signatures, some of which are invalid for this client (but might be valid for some other client), some of which are valid but not origin-trusted, and some of which are both valid and origin-trusted. The basic verification process is a search through those signatures for one that's both valid and origin-trusted. Does that make sense? I definitely want to avoid implying that there's exactly one signature, but I'm happy to reword to make this clearer.",
              "createdAt": "2018-04-10T21:00:59Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 164,
              "body": "Heh, yes, that wasn't clear at all. Is this new wording better?",
              "createdAt": "2018-04-10T21:16:00Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 173,
              "body": "1. The Accept header includes `image/newformat`, the response is actually in that format and so Chrome can't display it, and this winds up in the cache, preventing Chrome from doing a later request with our actual Accept headers, which would content-negotiate for an image we could actually display.\r\n2. The Accept-Language header doesn't match the user's language preferences, and the response is something they can't read. If we dropped the exchange with mis-matched request headers, we might negotiate the right response.\r\n\r\nI don't have an example of confusing the client beyond just caching an unusable resource that could have been content-negotiated using a connection to the real server. I guess that any real confusion could also be caused by a server that served a malicious response, so Chrome's already hardened against that.\r\n\r\nWe could put mismatched request headers in the preload cache and just exclude them from the HTTP cache, so a malicious or buggy intermediate would only hurt itself? It seems simpler to skip all caching, but you'd know better what's easier to implement.",
              "createdAt": "2018-04-10T21:39:00Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 182,
              "body": "Ah, I hadn't caught that whether to HTTP-cache it was still up in the air. I'll mention that.\r\n\r\nI could be misunderstanding the preload cache in general, but my impression was that (whatever we call it) it's the place that stores prefetches, preloads, the thing https://w3c.github.io/ServiceWorker/#navigation-preload-manager manages, and anything else where we want to use an already-stale response \"once\". ",
              "createdAt": "2018-04-10T21:47:02Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMTAzODQx",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-11T06:46:50Z",
          "updatedAt": "2018-04-11T06:46:51Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I see. Since the issue (https://github.com/whatwg/fetch/issues/590) isn't closed yet I added a question to ask for the clarification there, that would probably give you some additional context too. For now I just assume this is talking about 'a cache' for preload/prefetch or whatever.",
              "createdAt": "2018-04-11T06:46:50Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMTE2MjUw",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks! Added some more comments. (Let me know if you want to land this earlier than later, we can keep discussing even after committing this if you prefer)",
          "createdAt": "2018-04-11T07:38:15Z",
          "updatedAt": "2018-04-11T08:58:14Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "Loos a lot clearer, thanks!",
              "createdAt": "2018-04-11T08:08:05Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 182,
              "body": "Reading this further I started to worry that we say a lot about the HTTP cache here.\r\n\r\nDoes it make sense to have this part (putting it in HTTP cache) as an optional behavior, or could the spec leave which cache to put the resource up to UA?  Say, we can define a conceptual `signed response cache` and note that the behavior can be implemented in the HTTP cache if UA wants?\r\n\r\nMy concern is layering, efficiency and complexity: The signed exchange itself is cacheable, which seems to mean that the signed exchange layer sits on top of HTTP cache, therefore populating HTTP cache with the contents extracted from the signed exchange could mean:\r\n\r\n1. we may waste disk space by caching the data in dup'ed way (signed and non-signed ones)\r\n2. we may need to populate HTTP cache from the layer above it, which is probably unprecedented\r\n3. we need to make the HTTP cache understand the signed exchange logic and associate each entry with the corresponding signature in order to process the revalidation logic stated below",
              "createdAt": "2018-04-11T08:09:04Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 185,
              "body": "Does this imply that the signature's expiration has somewhat sticky effect on the resources that are installed from the signed exchange / bundle?  For some use cases like offline PWA installation this may not make a lot sense, or may have some inconsistency?  E.g. I think we'd want to keep the PWA's SW and assets installed from a bundle/exchange valid even after the signature expires, is that right?",
              "createdAt": "2018-04-11T08:29:45Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 214,
              "body": "I don't think the `FetchEvent` *needs* to include the notification, but if SW wants to know about that we can do that by utilizing navigation preload (only for the SWs that have enabled the feature), is the argument.",
              "createdAt": "2018-04-11T08:54:35Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMzQwMjcy",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-11T18:01:34Z",
          "updatedAt": "2018-04-11T18:01:34Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Blargh. https://github.com/whatwg/fetch/issues/590#issuecomment-357995100 makes me realize that this is definitely *not* the preload cache. The preload cache has a bit of behavior that I want, but it sits after the Service Worker (i.e. caches SW responses), while we're currently thinking of this thing as sitting before the SW and providing input to it.\r\n\r\nYou mentioned prefetch \"basically just puts things in HTTP cache\": does that mean that when the subsequent page requests the prefetched thing, the request goes through the subsequent page's Service Worker, and the SW finds the prefetched thing if the it calls down to the network?",
              "createdAt": "2018-04-11T18:01:34Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMzU0NzE1",
          "commit": {
            "abbreviatedOid": "910fcec"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Let's see if we converge in the next couple rounds instead of committing early.",
          "createdAt": "2018-04-11T18:40:51Z",
          "updatedAt": "2018-04-11T20:40:49Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "Yes, I'm currently thinking that the signature's expiration sticks to the resources it guarded. We could argue the opposite based on the fact that we don't expire resources after their certificate or OCSP response expires, but I haven't been arguing that so far because those uses at least have a liveness guarantee at the point when the resource arrived.\r\n\r\nFor offline use, I'm going to argue (https://github.com/WICG/webpackage/issues/117) that we should extend signature expiration times by O(a month) as long as the client is continuously offline and can't fetch updates, rather than that we should just ignore signature expiration.",
              "createdAt": "2018-04-11T18:40:51Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 182,
              "body": "I don't think we can leave it entirely up to the UA, because developers will be able to see the differences, and our experience with the HTTP/2 Push cache makes me worried about introducing any visibly-different cache.\r\n\r\nIf we say that this all goes into the HTTP cache, but we also say that signed exchanges can't contain other signed exchanges or redirects, does that allow you to implement the specified behavior using two layers, to avoid your concerns?\r\n\r\nI played with the idea of not caching at all, but that'll break the case where we prefetch the .sxg and try to use its logical URL directly, which hurts non-AMP users, so I don't think it's realistic.\r\n",
              "createdAt": "2018-04-11T19:43:46Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 214,
              "body": "I agree that we can probably ship without this notification, but I think people will want it sooner or later. I'll downgrade my language here.\r\n\r\nThe existing navigation preload only applies to navigations, while signed exchanges also offer a response for subresources, so I think we'll need to extend its current spec. I also don't think we need opt-in to expose this: navigation preload needs opt-in because it adds an extra maybe-useless request, but this just exposes something that's happening anyway.",
              "createdAt": "2018-04-11T20:03:20Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDgzMjc0",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T05:26:44Z",
          "updatedAt": "2018-04-12T05:26:44Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "> You mentioned prefetch \"basically just puts things in HTTP cache\": does that mean that when the subsequent page requests the prefetched thing, the request goes through the subsequent page's Service Worker, and the SW finds the prefetched thing if the it calls down to the network?\r\n\r\nYeah that what happens.",
              "createdAt": "2018-04-12T05:26:44Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDg0MzY1",
          "commit": {
            "abbreviatedOid": "910fcec"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T05:35:16Z",
          "updatedAt": "2018-04-12T05:35:16Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I see reg: offline use case.  What do you think about the following two cases:\r\n\r\n* UA populates HTTP cache with resources extracted from the signed exchange, and they expire when the signature of them expire\r\n* SW populates Cache Storage with resources come from the signed exchange (and SW may know the fact or not), and they will be around even after the signature of the original exchange expires\r\n\r\nMy mental model has been that the expiration matters when we process the signed exchange, but once if it's processed the resources that come from the signed exchange could just look similar to others. I think I'm fine with the current text, but wanted to note that (partly because not sticking the signature info is easier to implement).",
              "createdAt": "2018-04-12T05:35:16Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDg0NDc2",
          "commit": {
            "abbreviatedOid": "910fcec"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T05:36:13Z",
          "updatedAt": "2018-04-12T05:36:13Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I still think having the signed responses only in so-called `preload cache` (or undefined memory cache thing) could make sense, at least from impl pov.  We sill cache the signed exchange, so having a layer that processes it and potentially caches it up to a certain period seems to be fairly natural to me (this is what we do for images, scripts etc), and that resolves your perf concern?  That model fits well with the expiration model too.",
              "createdAt": "2018-04-12T05:36:13Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDg0Mjg1",
          "commit": {
            "abbreviatedOid": "910fcec"
          },
          "author": "mnot",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T05:34:43Z",
          "updatedAt": "2018-04-12T05:44:18Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "HTTP freshness can't be modified like this; any upstream caches (e.g., CDN) won't be aware of these special semantics. \r\n\r\nI think the two approaches you have are:\r\n1. Don't do that -- i.e., make sure HTTP cache lifetime is always shorter than the signature expiration.\r\n2. If a client encounters a fresh cached response with an expired signature, it can force-refresh using things like `Cache-Control: max-age` in requests. Be aware, though, that request cache directives are ignored by many...",
              "createdAt": "2018-04-12T05:38:13Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 207,
              "body": "As above, if the response is still fresh, upstream caches will consider it so, so you'll need to cache-bust.",
              "createdAt": "2018-04-12T05:39:43Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 215,
              "body": "I feel like I'm missing something here -- what does \"first update the signature and then check for a 304\" mean?",
              "createdAt": "2018-04-12T05:40:48Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 53,
              "body": "Until their interaction with Push is specified, I wonder if it's better to just leave this out.",
              "createdAt": "2018-04-12T05:41:31Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 22,
              "body": "This terminology feels a bit generic; could we come up with something a bit more specific?\r\n\r\n",
              "createdAt": "2018-04-12T05:44:07Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDkwNTk1",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Some more lightweight comments (before think more about HTTP cache ones)",
          "createdAt": "2018-04-12T06:17:26Z",
          "updatedAt": "2018-04-12T06:24:06Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "It feels this should be allowed.",
              "createdAt": "2018-04-12T06:17:26Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 250,
              "body": "This seems questionable, given the text above says we stop prefetch steps before populating HTTP cache with the signed responses",
              "createdAt": "2018-04-12T06:18:28Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 252,
              "body": "I think yes.",
              "createdAt": "2018-04-12T06:18:42Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 254,
              "body": "No, for the same reason?",
              "createdAt": "2018-04-12T06:19:06Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzQwODI1",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I'll update the content tomorrow, but some quick responses today:",
          "createdAt": "2018-04-12T18:28:37Z",
          "updatedAt": "2018-04-12T18:46:16Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I don't have any better terms offhand, but I'll look for some.",
              "createdAt": "2018-04-12T18:28:37Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 53,
              "body": "In the explainer, I think it makes sense to lay out the goal, even though we haven't written down exactly how we're getting there yet. In the loading specification, I think you're right that I should only add the PUSH route when I can actually write down how the browser processes it.\r\n\r\nDoes that make sense? If you're not convinced, I'm not dead set on keeping this entry.\r\n\r\nThere's also a question of whether it makes sense to target Push in any new feature...",
              "createdAt": "2018-04-12T18:33:22Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 192,
              "body": "If I rewrite this sentence as \"If we put the *content* of the signed exchange in the HTTP cache\", does that fix things for you? I definitely don't mean that the envelope needs to have different cache behavior, just the signed bits we pull out of the envelope. (I'm looking for clearer words about this; distinguishing the envelope format from the logical HTTP exchange inside it has been tricky.)\r\n\r\nI *think* that's ok because the upstream caches like CDNs can only put the contents of a signed exchange into their cache if they understand signed exchanges, which means they're modifying code anyway and can also modify it in this way. I could even be wrong about that because it'd be code owned by two different groups?",
              "createdAt": "2018-04-12T18:37:53Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 215,
              "body": "To update the signature, the client follows https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.6. Then \"check for a 304\" is probably equivalent to \"makes a conditional request\". It's intended to be the two bullets above.",
              "createdAt": "2018-04-12T18:42:15Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 207,
              "body": "Here, the client would make an unconditional request to the `validity-url`, as described by https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#updating-validity, and it's fine for intermediates to cache that with normal HTTP semantics, and if the caching headers are set wrong, the client will probably wind up re-fetching the resource with a normal TLS request to its logical URL (the original publisher's origin), at which point any CDNs are welcome to serve their cached copy if they have one.",
              "createdAt": "2018-04-12T18:44:58Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 254,
              "body": "I need to think through how this affects how authors need to write their content, using more time than I have today, but thanks for also thinking about it.",
              "createdAt": "2018-04-12T18:46:00Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExOTA1MjU5",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-13T07:13:56Z",
          "updatedAt": "2018-04-13T07:13:56Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Looking at the comments by mnot, it seems intermediates may just go on and can cache the responses in the signed exchanges regardless of the request was for prefetches or not. Is that right, and if so should we note something here?",
              "createdAt": "2018-04-13T07:13:56Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyNTQ0MjY1",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-16T18:53:20Z",
          "updatedAt": "2018-04-16T18:53:20Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "I _think_ @mnot is talking about proxies caching the enveloped signed exchange instead of proxies unwrapping the signed exchange and caching its contents (https://github.com/WICG/webpackage/pull/173#discussion_r181182126), but if he does think they'll blindly unwrap things, I need to think about the implications.",
              "createdAt": "2018-04-16T18:53:20Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyNjc4MjI3",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "mnot",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-17T06:23:10Z",
          "updatedAt": "2018-04-17T06:23:10Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Proxies today won't do anything to the body -- they'll just cache things according to the various HTTP caching rules, just like wiht everything else. ",
              "createdAt": "2018-04-17T06:23:10Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4MTY4NjA5",
          "commit": {
            "abbreviatedOid": "3c7b9c7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-07T21:59:46Z",
          "updatedAt": "2018-05-07T21:59:47Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Does the preload cache might look equivalent to the memory/image cache to developers? If so, I should probably merge them in this list.",
              "createdAt": "2018-05-07T21:59:47Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4MTgwMDEz",
          "commit": {
            "abbreviatedOid": "3c7b9c7"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, this looks good / the layering part looks a lot clearer to me!  Left a few nit comments + some questions.",
          "createdAt": "2018-05-07T22:51:44Z",
          "updatedAt": "2018-05-07T23:16:04Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "This part can be in a different PR?",
              "createdAt": "2018-05-07T22:51:44Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 95,
              "body": "Having them separately looks good to me (Blink has separated preload cache out of memory cache, and it looks Yoav's trying to sketch preload cache roughly following the way",
              "createdAt": "2018-05-07T22:55:30Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 94,
              "body": "(HTTP cache and prefetch cache are not really different things in chrome impl, but that's probably fine)",
              "createdAt": "2018-05-07T22:58:08Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 24,
              "body": "'the outer exchange that fetches the outer resource' this sentence was unclear to me, what 'fetches' means here?",
              "createdAt": "2018-05-07T22:59:09Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 194,
              "body": "Does this extra check run only when the fetch comes from/via the Service Worker?  We also say the response is not really distinguishable between inner responses as a part of signed exchange vs regular resources from SW for now, they feel slightly inconsistent to me.",
              "createdAt": "2018-05-07T23:07:28Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 256,
              "body": "Yeah +1 to keep this as an open discussion for now",
              "createdAt": "2018-05-07T23:12:20Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 199,
              "body": "nit: annotate this as (TBD) too?",
              "createdAt": "2018-05-07T23:13:46Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4MTg3NjY2",
          "commit": {
            "abbreviatedOid": "3c7b9c7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-07T23:32:49Z",
          "updatedAt": "2018-05-08T00:00:28Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Hm, yeah, that's unclear. How about \"whose response's payload is the outer resource\"?",
              "createdAt": "2018-05-07T23:32:49Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 35,
              "body": "I can avoid moving it in this PR.",
              "createdAt": "2018-05-07T23:33:47Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 194,
              "body": "The extra check should happen even when there's no SW or no `fetch` handler in the SW. I tend to think of a page without a SW as equivalent to a page whose SW does nothing in its `fetch` handler, so if it looks like I'm deviating from that, or if that's the wrong model for me to have, let me know. :)",
              "createdAt": "2018-05-07T23:52:13Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 199,
              "body": "Done.",
              "createdAt": "2018-05-07T23:52:18Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 174,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwNTQ5MzEx",
      "title": "gen-certurl: Follow the latest specification of certurl (OCSP and SCT)",
      "url": "https://github.com/WICG/webpackage/pull/174",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #165 \r\n\r\nOriginal author: @irori\r\n\r\nThis PR fixes gen-certurl to follow the latest specification.\r\n\r\nThis PR also adds internal/testhelper package for testing to show readable strings of CBOR binary.",
      "createdAt": "2018-04-10T09:59:28Z",
      "updatedAt": "2018-04-11T05:38:30Z",
      "closedAt": "2018-04-11T05:38:27Z",
      "mergedAt": "2018-04-11T05:38:26Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori Would you follow up on instructions/scripts on generating sct/ocsp files?",
          "createdAt": "2018-04-11T01:23:15Z",
          "updatedAt": "2018-04-11T01:23:15Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "> @irori Would you follow up on instructions/scripts on generating sct/ocsp files?\r\n\r\nSee here: https://docs.google.com/document/d/1gl_t8MmULHaEFT9Yny2bkNGjtTuB4K-ugvM44E0kXnM/edit#",
          "createdAt": "2018-04-11T04:19:18Z",
          "updatedAt": "2018-04-11T04:19:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDYyMDE5",
          "commit": {
            "abbreviatedOid": "508edba"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-11T01:22:51Z",
          "updatedAt": "2018-04-11T01:22:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDg1OTQy",
          "commit": {
            "abbreviatedOid": "508edba"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks.",
          "createdAt": "2018-04-11T04:39:29Z",
          "updatedAt": "2018-04-11T04:39:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxMDI2MzI1",
      "title": "Make all Structured Header identifiers lower-case.",
      "url": "https://github.com/WICG/webpackage/pull/178",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @twifkak for noticing the violation of\r\n[draft-ietf-httpbis-header-structure-04 Section 4.8](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-4.8).\r\n\r\nNote that this will affect the next implementation draft but doesn't affect the [current one](https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-00).",
      "createdAt": "2018-04-11T20:58:31Z",
      "updatedAt": "2018-04-13T19:52:46Z",
      "closedAt": "2018-04-13T19:52:37Z",
      "mergedAt": "2018-04-13T19:52:37Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDAyNjg4",
          "commit": {
            "abbreviatedOid": "f801f93"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-11T21:05:36Z",
          "updatedAt": "2018-04-11T21:05:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDg5ODUy",
          "commit": {
            "abbreviatedOid": "f801f93"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-04-12T06:13:09Z",
          "updatedAt": "2018-04-12T06:13:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxMDYyMjA1",
      "title": "Allow certificate re-use for TLS.",
      "url": "https://github.com/WICG/webpackage/pull/179",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See discussion in\r\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0041.html.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/remove-rsa/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/remove-rsa/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-04-12T00:30:47Z",
      "updatedAt": "2018-11-14T21:44:05Z",
      "closedAt": "2018-05-09T19:53:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "So, I am not convinced that this is a positive change we should make. While I can understand the proposal to restrict the signature algorithms, the reuse with TLS is something that I believe is a net-negative for the practical deployment scenario. While I realize that some providers, particularly those BYOC, may have difficulty managing two certificates, the separation requirement was mitigating both operational and cryptographic concerns.\r\n\r\nThat is, in a forced-separation model, there is no direct advantage or incentive to promoting online signing, while that is fundamentally necessary for TLS certificates. The same discussion can be seen regarding the key protections for Secondary Certificates. This is critically important when considering \"key compromise\" scenarios. While the current separation does not absolutely guarantee any operational security, it ensures the design does not incentivize insecurity. This is the same consideration as when thinking about forward-dating signatures, and just as in that case, there may be future operational or protocol restrictions (e.g. needing to cover an OCSP response), one can imagine that Web Packages may have future requirements similar to code signing certificates in the Microsoft ecosystem - namely, can only be issued to hardware-backed keys (as an example)\r\n\r\nAt this time, I do not think allowing the reuse with TLS is good for clients or for servers, despite the challenges some have raised.",
          "createdAt": "2018-04-12T13:29:50Z",
          "updatedAt": "2018-04-12T13:29:50Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "@sleevi I think you are missing at least one part of the ecosystem incentive that I know you would usually care about:\r\n\r\n1. Allowing reuse with TLS is good for decentralization because it allows parties to reuse their cert to participate in package generation with minimal added effort.\r\n2. Forbidding reuse incentivizes outsourcing of package generation to specialized and naturally more centralized entities who generate the special certificates on behalf of the origin and generate packages for them.\r\n",
          "createdAt": "2018-04-12T13:42:32Z",
          "updatedAt": "2018-04-12T13:42:32Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@cramforce No, I'm not missing those from the considerations. I think the cross-protocol and key compromise risks are significantly greater through the introduction of Web Packaging (or Secondary Certificates), and thus deserve serious mitigations if clients are to consider implementing and shipping them. I do not think it is a positive step forward to ship without such mitigations.\r\n\r\nYour first argument is not consistent with the efforts that Google or the Chrome team have encouraged or the statements made regarding the automation of certificates. An alternative phrasing is that Web Packaging's practical deployment encourages greater automation through certificate issuance - which we already see widespread. Thus, the concerns about getting a second certificate are merely a misdirect and not applicable.\r\n\r\nRegarding your second argument, this is true already for CDNs, which can offer greater key protection for nodes than those afforded to clients. This is fundamentally no different than existing solutions such as Cloudflare, Amazon, or Google, all of which take steps to secure client keys from compromise. My concern would be if the use of a particular CDN or provider was functionally required or incentivized, but that is separate from an argument against CDNs.\r\n\r\nIn light of the security risks that clients would be faced with, I do not think this change is good, and I worry that it would make Web Packaging more difficult to reason about and accept from a security perspective. But I wonder whether we should be continuing this conversation on the list instead - I'm not sure @jyasskin's desired workmode, but since the conversation started there, it's probably best to continue it there.",
          "createdAt": "2018-04-12T13:49:51Z",
          "updatedAt": "2018-04-12T13:51:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Additionally this PR forgets to restore those 64 spaces in the context string.\r\n\r\nRegardless of which way this goes, as I mentioned when removing those spaces came up, I think removing them in the first place was a bad idea. It was only a matter of time before someone tries to remove the restriction and then forgets to fix the context string to match.\r\n\r\nEdit: Sorry, 64 spaces, not 32.",
          "createdAt": "2018-04-12T17:51:08Z",
          "updatedAt": "2018-04-12T17:54:52Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that, by requiring P-256 keys, most sites will already have to manage multiple certificates anyway. There are enough RSA-only TLS clients out there that, in practice, most folks need to have an RSA certificate. ECDSA certificates are primarily deployed in *addition* to RSA certificates, to reduce server resource usage (ECDSA signing is much faster than RSA signing).",
          "createdAt": "2018-04-12T18:01:34Z",
          "updatedAt": "2018-04-12T18:01:34Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks for having the main discussion on the list; I think more people can participate there.\r\n\r\n@davidben Your bug is now fixed; thanks for pointing it out.",
          "createdAt": "2018-04-16T18:16:02Z",
          "updatedAt": "2018-04-16T18:16:02Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Most of this change was merged in #181, and Ryan's objections in https://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0070.html seem to have convinced everyone to stop pushing for certificate re-use, so I'm closing this PR.",
          "createdAt": "2018-05-09T19:53:56Z",
          "updatedAt": "2018-05-09T19:53:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDUyOTQ4",
          "commit": {
            "abbreviatedOid": "218faaa"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T01:17:03Z",
          "updatedAt": "2018-04-12T01:17:08Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Would it be possible to pin the TLS version/draft in the signedexchange spec?",
              "createdAt": "2018-04-12T01:17:03Z",
              "updatedAt": "2018-05-09T19:51:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDczMDM0",
          "commit": {
            "abbreviatedOid": "218faaa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T03:58:12Z",
          "updatedAt": "2018-04-12T03:58:12Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Do you mean to the -28 draft or to exactly TLS 1.3? The TLS draft is [\"Submitted to IESG for Publication\"](https://datatracker.ietf.org/doc/draft-ietf-tls-tls13/), so it's unlikely that -28 will change significantly before it's published as an RFC.\r\n\r\nIt's possible to pin to 1.3, but [Ilari's post](https://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0050.html) seems to say that he wants this RFC to allow for future expansion in the set of algorithms without needing to revise this RFC. Other security folks might speak up and disagree, of course.\r\n\r\nNote that the WHATWG-side spec will be a living spec that'll follow the current version of TLS and specify exactly which algorithms browsers are using, even if this spec is less precise.",
              "createdAt": "2018-04-12T03:58:12Z",
              "updatedAt": "2018-05-09T19:51:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 180,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxNTc5OTMx",
      "title": "Re-add the 64-byte TLS signature padding.",
      "url": "https://github.com/WICG/webpackage/pull/180",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Per davidben's advice, it's safer to make all similar signature formats\r\nthe same.\r\n\r\nSeparate from #179 since it sounds like you're advising this even if that doesn't go in.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/re-add-tls-padding/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/re-add-tls-padding/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-04-13T19:45:07Z",
      "updatedAt": "2018-04-16T18:14:04Z",
      "closedAt": "2018-04-16T18:14:01Z",
      "mergedAt": "2018-04-16T18:14:01Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyMTM4MTU1",
          "commit": {
            "abbreviatedOid": "8824c27"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-13T19:46:41Z",
          "updatedAt": "2018-04-13T19:46:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 181,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyNTEwODc1",
      "title": "Forbid RSA and only require secp256r1.",
      "url": "https://github.com/WICG/webpackage/pull/181",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See discussion in\r\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0041.html.\r\n\r\nThis is #179 without the change to allow exchange-signing certificates to be used for TLS.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/remove-rsa-no-tls/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/remove-rsa-no-tls/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-04-18T15:06:24Z",
      "updatedAt": "2018-05-09T19:47:17Z",
      "closedAt": "2018-05-09T19:45:07Z",
      "mergedAt": "2018-05-09T19:45:07Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4ODM2OTQ5",
          "commit": {
            "abbreviatedOid": "1e540d7"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-09T17:44:22Z",
          "updatedAt": "2018-05-09T17:45:29Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Nit: You don't want the ecdsa/secp384r1 here, right?",
              "createdAt": "2018-05-09T17:44:22Z",
              "updatedAt": "2018-05-09T17:45:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4ODM4MTU2",
          "commit": {
            "abbreviatedOid": "1e540d7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-09T17:47:42Z",
          "updatedAt": "2018-05-09T17:47:43Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "It was an intentional part of the example, showing how an odd client, that changed which curve is supported, would announce that fact to servers. Let me know if you think I'm wrong to have an example like that.\r\n\r\n(I'm not certain my `Accept-Signature` thing is a good idea overall, but that's a discussion for another PR.)",
              "createdAt": "2018-05-09T17:47:42Z",
              "updatedAt": "2018-05-09T17:47:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4ODc2ODY5",
          "commit": {
            "abbreviatedOid": "1e540d7"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-09T19:41:20Z",
          "updatedAt": "2018-05-09T19:41:20Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Oh! Sorry, I got confused and read the text above as describing this example rather than the text below. Ignore me.",
              "createdAt": "2018-05-09T19:41:20Z",
              "updatedAt": "2018-05-09T19:41:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 182,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyNTE0MTU5",
      "title": "Remove the \"Digest\" integrity header and bound MI record size.",
      "url": "https://github.com/WICG/webpackage/pull/182",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Digests require buffering the whole response body before determining that it's\r\nvalid, which unnecessarily increases the complexity in the verifier.\r\n\r\nThis change also puts a bound on the MI record size, also to limit the needed buffering.\r\n\r\n@davidben, have I explained the right reasons for doing this?\r\n\r\nFixes #138\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/remove-digest/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/remove-digest/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-04-18T15:16:40Z",
      "updatedAt": "2018-05-01T23:45:23Z",
      "closedAt": "2018-05-01T23:45:19Z",
      "mergedAt": "2018-05-01T23:45:18Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've now mentioned that motivation too.",
          "createdAt": "2018-05-01T23:43:42Z",
          "updatedAt": "2018-05-01T23:43:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMzc1OTU4",
          "commit": {
            "abbreviatedOid": "e5b955d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Yup. Thanks!\r\n\r\nAnother motivation is just not having unnecessary options. Adding the digest option means the receiver needs to implement two modes, all so the sender has an option to save a for loop in their signer?",
          "createdAt": "2018-04-18T20:18:08Z",
          "updatedAt": "2018-04-18T20:18:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg2NTEzOTI1",
      "title": "add signedexchange redirect README",
      "url": "https://github.com/WICG/webpackage/pull/184",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-08T02:52:42Z",
      "updatedAt": "2018-05-08T03:22:12Z",
      "closedAt": "2018-05-08T03:22:12Z",
      "mergedAt": "2018-05-08T03:22:11Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4MjE1MjMy",
          "commit": {
            "abbreviatedOid": "6484667"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-08T02:55:46Z",
          "updatedAt": "2018-05-08T02:55:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 189,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjY5NTQ5",
      "title": "Support latest envelope format",
      "url": "https://github.com/WICG/webpackage/pull/189",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #135 \r\nCorresponding spec change at f4ca17d1377bed966fdba85c03adbd798cfb5a96\r\n\r\n@jyasskin FYI",
      "createdAt": "2018-05-21T02:29:14Z",
      "updatedAt": "2018-05-22T01:49:38Z",
      "closedAt": "2018-05-22T01:49:38Z",
      "mergedAt": "2018-05-22T01:49:38Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxODQzMjI3",
          "commit": {
            "abbreviatedOid": "f55cc1c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-21T15:37:20Z",
          "updatedAt": "2018-05-21T15:47:45Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "`if _, err = signedexchange.Encode3BytesBigEndianUint(0x12345678); err != ...`",
              "createdAt": "2018-05-21T15:37:21Z",
              "updatedAt": "2018-05-22T01:47:34Z"
            },
            {
              "originalPosition": 29,
              "body": "Showing the got value and want value would be better",
              "createdAt": "2018-05-21T15:37:43Z",
              "updatedAt": "2018-05-22T01:47:34Z"
            },
            {
              "originalPosition": 83,
              "body": "`io.Copy` is better since `io.Copy` doesn't require successive memory region of `headerBuf.Length()`",
              "createdAt": "2018-05-21T15:40:43Z",
              "updatedAt": "2018-05-22T01:47:34Z"
            },
            {
              "originalPosition": 32,
              "body": "const?",
              "createdAt": "2018-05-21T15:47:27Z",
              "updatedAt": "2018-05-22T01:47:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 190,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjcyMzY1",
      "title": "Update structured header identifiers to lower-case",
      "url": "https://github.com/WICG/webpackage/pull/190",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Follow spec changes after #178 and 3fc67e270b4a89bed9a46732c985fd984c2a66d3\r\n\r\nFYI: @jyasskin ",
      "createdAt": "2018-05-21T03:01:31Z",
      "updatedAt": "2018-05-22T01:21:28Z",
      "closedAt": "2018-05-22T01:21:28Z",
      "mergedAt": "2018-05-22T01:21:28Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxODQyODQ2",
          "commit": {
            "abbreviatedOid": "0c51f3c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-21T15:36:12Z",
          "updatedAt": "2018-05-21T15:36:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 192,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjkyMzc1",
      "title": "Pad magic string to 8 bytes",
      "url": "https://github.com/WICG/webpackage/pull/192",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #191 ",
      "createdAt": "2018-05-21T06:21:37Z",
      "updatedAt": "2018-05-24T23:19:40Z",
      "closedAt": "2018-05-24T23:19:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Per discussion in #191, I think this isn't needed anymore.",
          "createdAt": "2018-05-24T23:19:40Z",
          "updatedAt": "2018-05-24T23:19:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxOTczNDU3",
          "commit": {
            "abbreviatedOid": "e81185d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-21T22:56:23Z",
          "updatedAt": "2018-05-21T22:56:23Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Especially since this already only leaves 3 bytes anyway, probably better to simply write:\r\n> and MUST use another 8-byte implementation-specific string beginning with \"sxg1-\".\r\n\r\nI.e. no sense in talking about padding schemes and such.",
              "createdAt": "2018-05-21T22:56:23Z",
              "updatedAt": "2018-05-21T22:56:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5NjA5NDI2",
      "title": "Update key strings in serializeSignedMessage to lower-case",
      "url": "https://github.com/WICG/webpackage/pull/193",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a follow-up to #190.\r\n\r\n#178 also changed the key strings in the canonical CBOR map.",
      "createdAt": "2018-05-22T10:04:29Z",
      "updatedAt": "2018-05-22T10:17:05Z",
      "closedAt": "2018-05-22T10:17:05Z",
      "mergedAt": "2018-05-22T10:17:05Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm. Thanks for the catch",
          "createdAt": "2018-05-22T10:16:31Z",
          "updatedAt": "2018-05-22T10:16:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyMTAzNzQ4",
          "commit": {
            "abbreviatedOid": "bdd4625"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-22T10:16:39Z",
          "updatedAt": "2018-05-22T10:16:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5ODIwNjA2",
      "title": "Fix the HTTP/1.1 exchanges to use Host headers instead of full URLs in the GET line.",
      "url": "https://github.com/WICG/webpackage/pull/194",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @triblondon for noticing in\r\nhttps://github.com/w3ctag/design-reviews/issues/235#issuecomment-379424440.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/fix-http1-samples/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/fix-http1-samples/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-05-22T23:37:49Z",
      "updatedAt": "2018-05-25T03:22:08Z",
      "closedAt": "2018-05-25T03:22:05Z",
      "mergedAt": "2018-05-25T03:22:05Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "How about `:path` + `:host` to deduplicate host?",
          "createdAt": "2018-05-23T02:25:36Z",
          "updatedAt": "2018-05-23T02:25:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It's more that the `Host` header isn't ever going to actually appear in the encoding. https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#same-origin-response doesn't allow it, and https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#application-signed-exchange lets the publisher pick their headers, and there's no reason for a publisher to include `Host` redundantly with the `:url`.\r\n\r\nDo you think it's ok to show the misleading mapping, or should I switch it to an HTTP/2 representation that doesn't have the Host header in the first place, or something else?",
          "createdAt": "2018-05-23T04:31:17Z",
          "updatedAt": "2018-05-23T04:31:17Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to check my understanding first.\r\nAm I correct that:\r\n- The modified `3.2.1` example is only focused on how the http text format maps to CBOR representation\r\n  - It is out-of-scope of the section that the CBOR representation in the signature message may have filtered it out.\r\n  - It is possible but should be very rare for a signature message have `Host` request header in practice, since:\r\n     - application/signed-exchange packagers can choose to only include `:url` \r\n     - When transferring the exchange via H2, most servers would have no reason to include it in the list of Signed-Headers ",
          "createdAt": "2018-05-24T01:28:08Z",
          "updatedAt": "2018-05-24T01:28:08Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "(Question from @horo-t)\r\nDo you have any recommendation on how browsers should react if it received a signed exchange with conflicting `:url` and `Host` in its request headers?",
          "createdAt": "2018-05-24T01:29:20Z",
          "updatedAt": "2018-05-24T01:29:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "That all sounds correct. How does it sound to say that a signed exchange with conflicting `:url` and `Host` will never [be sufficiently similar to the browser's request](https://github.com/WICG/webpackage/blob/master/explainer.md#navigations-and-subresources-redirect)?",
          "createdAt": "2018-05-24T03:12:40Z",
          "updatedAt": "2018-05-24T03:12:40Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM",
          "createdAt": "2018-05-24T05:09:57Z",
          "updatedAt": "2018-05-24T05:09:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I felt bad about including the misleading `Host` headers, so I've now excluded them explicitly.",
          "createdAt": "2018-05-24T22:12:33Z",
          "updatedAt": "2018-05-24T22:12:33Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "still lgtm. I like the latest change better.",
          "createdAt": "2018-05-25T00:39:02Z",
          "updatedAt": "2018-05-25T00:39:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyODQ3MTQ3",
          "commit": {
            "abbreviatedOid": "3e7fffc"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-24T05:10:08Z",
          "updatedAt": "2018-05-24T05:10:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwMDMxNDIy",
      "title": "Use the signature context string to distinguish draft versions.",
      "url": "https://github.com/WICG/webpackage/pull/195",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @sleevi for noticing the problem.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/include-version-in-sig-context/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/include-version-in-sig-context/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-05-23T16:15:34Z",
      "updatedAt": "2018-05-24T20:38:13Z",
      "closedAt": "2018-05-24T20:38:10Z",
      "mergedAt": "2018-05-24T20:38:10Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Happy to explain. This is about mitigation version rollback attacks. Right now, the version of the envelope is outside of the signed data. This creates the opportunity for an attacker to alter the version number, causing the signed data to be interpreted differently.\r\n\r\nIn Chromium, it came up in exploring the b0 to b1 transition, in which b0 ignores the OCSP response, but b1 requires it. An attacker could take a signed b1 response, mark it as b0, and bypass those security checks.\r\n\r\nSimilar to how X.509 certificates include the signature algorithm within the inner (signed) context, in addition to the outer envelope, or how TLS includes the version number as part of the session transcript, the goal is to ensure that the externally-negotiated properties (such as version) are also bound within the internal, signed content, to prevent any confusion issues. These are functionally the same as cross-protocol attacks, it just happens that its different versions of the same protocol (but functionally different protocols).\r\n\r\nThe general method of mitigating these cross-protocol attacks is using the context string, to ensure that distinct signatures are created for distinct protocols. This change is necessary, but I'm not entirely sure it's sufficient - if the Web Packaging protocol evolves over time / additional versions, the context string of those subsequent versions will still need to migrate.\r\n\r\nThus, it may make sense to explicitly include both versioning and draft numbers, of which the latter is more applicable here, and formalize that as an inherent part of the protocol. That's the sufficient part :)",
          "createdAt": "2018-05-23T18:31:01Z",
          "updatedAt": "2018-05-23T18:31:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm curious about the motivation\r\n\r\nAll signature payloads with the same key be distinguishable, otherwise an attacker can cause the verifier to misinterpret a signature made in one protocol as something else in a different protocol. This includes differences between different versions of the same protocol.\r\n\r\nAs a toy example, consider if one version signed request headers followed by response headers, and then another version switched the order. Without baking the version into the signature, I can trick the receiver into accepting a signed exchange different from what the origin actually signed.",
          "createdAt": "2018-05-23T18:31:34Z",
          "updatedAt": "2018-05-23T18:31:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ooops, I see Ryan and I crossed mid-stream! Hopefully some combination of the two is enlightening. :-)",
          "createdAt": "2018-05-23T18:32:01Z",
          "updatedAt": "2018-05-23T18:32:01Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm also happy to use \"HTTP Exchange 1\" as the standard context string with \"HTTP Exchange 1 b1\" as the pattern for draft strings, if y'all prefer. I don't think that changes anything substantively here: in either case, version 2 will use \"HTTP Exchange 2\" as its context string, and that'll be different from any of the options for v1.",
          "createdAt": "2018-05-23T18:44:39Z",
          "updatedAt": "2018-05-23T18:44:39Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin That sounds good, as it makes sure the expectation is setup in the base spec and so we remember to rev on any semantically-relevant change (overall) and on drafts :)",
          "createdAt": "2018-05-23T18:46:26Z",
          "updatedAt": "2018-05-23T18:46:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Done.",
          "createdAt": "2018-05-23T18:49:51Z",
          "updatedAt": "2018-05-23T18:49:51Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanations!",
          "createdAt": "2018-05-24T01:13:10Z",
          "updatedAt": "2018-05-24T01:13:10Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you add a ChangeLog entry too?",
          "createdAt": "2018-05-24T01:38:41Z",
          "updatedAt": "2018-05-24T01:38:41Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "> Would you add a ChangeLog entry too? \u2014 @nyaxt \r\n\r\nWhoops, thanks, done.",
          "createdAt": "2018-05-24T20:36:28Z",
          "updatedAt": "2018-05-24T20:36:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyNzEwMDMw",
          "commit": {
            "abbreviatedOid": "12fde52"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm curious about the motivation, but LGTM; thanks for the heads up!",
          "createdAt": "2018-05-23T18:23:41Z",
          "updatedAt": "2018-05-23T18:23:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyNzIwMDk4",
          "commit": {
            "abbreviatedOid": "b5caaa8"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-23T18:50:33Z",
          "updatedAt": "2018-05-23T18:50:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyODE0NDIz",
          "commit": {
            "abbreviatedOid": "b5caaa8"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-24T00:46:58Z",
          "updatedAt": "2018-05-24T00:46:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwMTYwNjcz",
      "title": "gen-certurl: Make -sct flag optional",
      "url": "https://github.com/WICG/webpackage/pull/196",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #171, the sct field of the cbor cert chain should be optional. (See also #175)\r\n\r\ncc: @jyasskin @horo-t",
      "createdAt": "2018-05-24T03:31:54Z",
      "updatedAt": "2018-07-17T05:18:22Z",
      "closedAt": "2018-05-24T05:08:24Z",
      "mergedAt": "2018-05-24T05:08:24Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyODQ2ODg1",
          "commit": {
            "abbreviatedOid": "6f313c1"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-24T05:08:05Z",
          "updatedAt": "2018-05-24T05:08:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxMDUzNzQy",
      "title": "Update magic string to sxg1-b1",
      "url": "https://github.com/WICG/webpackage/pull/198",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-29T07:22:33Z",
      "updatedAt": "2018-05-29T07:25:47Z",
      "closedAt": "2018-05-29T07:25:47Z",
      "mergedAt": "2018-05-29T07:25:47Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODcyODE0",
          "commit": {
            "abbreviatedOid": "c8d6d07"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-29T07:25:02Z",
          "updatedAt": "2018-05-29T07:25:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxMDU0OTgy",
      "title": "Update context string to follow #195",
      "url": "https://github.com/WICG/webpackage/pull/199",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-29T07:28:47Z",
      "updatedAt": "2018-05-29T09:29:31Z",
      "closedAt": "2018-05-29T09:29:31Z",
      "mergedAt": "2018-05-29T09:29:31Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should use a draft-specific string as noted in the spec, such as `\"HTTP Exchange 1 b1\"`.",
          "createdAt": "2018-05-29T07:48:44Z",
          "updatedAt": "2018-05-29T07:48:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODgzMjE0",
          "commit": {
            "abbreviatedOid": "ac9ccb8"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-29T08:01:48Z",
          "updatedAt": "2018-05-29T08:01:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODgzMzg4",
          "commit": {
            "abbreviatedOid": "ac9ccb8"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T08:02:22Z",
          "updatedAt": "2018-05-29T08:02:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Following the convention of Go, comments should start with `ContextString is...`.",
              "createdAt": "2018-05-29T08:02:23Z",
              "updatedAt": "2018-05-29T08:34:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODgzNTM4",
          "commit": {
            "abbreviatedOid": "ac9ccb8"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T08:02:54Z",
          "updatedAt": "2018-05-29T08:02:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do we need to export this const? If not, this should be `contextString`",
              "createdAt": "2018-05-29T08:02:54Z",
              "updatedAt": "2018-05-29T08:34:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODkzNzQz",
          "commit": {
            "abbreviatedOid": "5e67631"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T08:33:55Z",
          "updatedAt": "2018-05-29T08:33:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done",
              "createdAt": "2018-05-29T08:33:55Z",
              "updatedAt": "2018-05-29T08:34:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODk1NDgx",
          "commit": {
            "abbreviatedOid": "658001b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-29T08:38:35Z",
          "updatedAt": "2018-05-29T08:38:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxNjI0OTA0",
      "title": "gen-signedexchange: Re-add the 64-byte signature padding",
      "url": "https://github.com/WICG/webpackage/pull/200",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Follows spec change after #180.",
      "createdAt": "2018-05-31T02:01:23Z",
      "updatedAt": "2018-05-31T03:30:25Z",
      "closedAt": "2018-05-31T03:30:18Z",
      "mergedAt": "2018-05-31T03:30:18Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0NjU3NDU4",
          "commit": {
            "abbreviatedOid": "6bb712e"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-31T02:57:08Z",
          "updatedAt": "2018-05-31T02:57:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0NjYxMTI0",
          "commit": {
            "abbreviatedOid": "6bb712e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2018-05-31T03:30:25Z",
          "updatedAt": "2018-05-31T03:30:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkyNjE2MTAx",
      "title": "Fix the formatting in #index-section Step 3.7",
      "url": "https://github.com/WICG/webpackage/pull/203",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The leading `+` in L336 caused the markdown parser to interpret it as a new unordered list. This PR fixes it by moving the `+` to the end of previous line.",
      "createdAt": "2018-06-05T07:41:38Z",
      "updatedAt": "2018-06-06T08:04:17Z",
      "closedAt": "2018-06-06T08:04:17Z",
      "mergedAt": "2018-06-06T08:04:17Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI2MjcwNjA1",
          "commit": {
            "abbreviatedOid": "6740958"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Lol. Thank you.",
          "createdAt": "2018-06-06T08:03:51Z",
          "updatedAt": "2018-06-06T08:03:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 204,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzMTQ0NjIx",
      "title": "Add a test OID to the signed exchanges draft.",
      "url": "https://github.com/WICG/webpackage/pull/204",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Also change the content of the extension to an ASN.1 NULL.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/test-oid/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/test-oid/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@sleevi Is this right? Would you approve when the OID is actually allocated?",
      "createdAt": "2018-06-06T21:23:03Z",
      "updatedAt": "2018-06-08T11:54:32Z",
      "closedAt": "2018-06-08T11:54:24Z",
      "mergedAt": "2018-06-08T11:54:23Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MDU1OTQ0",
          "commit": {
            "abbreviatedOid": "17a3d16"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-08T07:24:30Z",
          "updatedAt": "2018-06-08T07:24:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Would this mean we can make this with `openssl x509` by specifying `1.3.6.1.4.1.11129.2.1.22=DER:0500` in conf file?",
              "createdAt": "2018-06-08T07:24:30Z",
              "updatedAt": "2018-06-08T07:24:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MDkwODYw",
          "commit": {
            "abbreviatedOid": "17a3d16"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-08T09:23:56Z",
          "updatedAt": "2018-06-08T09:23:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "You can also use \r\n`1.3.6.1.4.1.11129.2.1.22=ASN1:NULL` (as per https://www.openssl.org/docs/man1.0.2/crypto/ASN1_generate_nconf.html )",
              "createdAt": "2018-06-08T09:23:56Z",
              "updatedAt": "2018-06-08T09:23:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MDkyMzQ1",
          "commit": {
            "abbreviatedOid": "17a3d16"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "The OID is now assigned.",
          "createdAt": "2018-06-08T09:28:35Z",
          "updatedAt": "2018-06-08T09:28:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzMjI5OTM0",
      "title": "Expose stateful header sets and make the check case-insensitive",
      "url": "https://github.com/WICG/webpackage/pull/205",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HTTP Header names are case-insensitive.",
      "createdAt": "2018-06-07T07:41:32Z",
      "updatedAt": "2018-06-12T03:29:31Z",
      "closedAt": "2018-06-12T03:29:31Z",
      "mergedAt": "2018-06-12T03:29:31Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "PTAL",
          "createdAt": "2018-06-11T06:59:39Z",
          "updatedAt": "2018-06-11T06:59:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDQ1ODE4",
          "commit": {
            "abbreviatedOid": "d9a6281"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-11T06:32:42Z",
          "updatedAt": "2018-06-11T06:34:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "`if _, err = NewExchange(...); err == nil {`",
              "createdAt": "2018-06-11T06:32:42Z",
              "updatedAt": "2018-06-11T07:08:42Z"
            },
            {
              "originalPosition": 40,
              "body": "As we discussed offline, let's have functions instead of exposing variables.",
              "createdAt": "2018-06-11T06:34:35Z",
              "updatedAt": "2018-06-11T07:08:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDUwNTg1",
          "commit": {
            "abbreviatedOid": "c2e8c9b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with nits",
          "createdAt": "2018-06-11T06:59:54Z",
          "updatedAt": "2018-06-11T07:00:14Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "`for name := range requestHeaders {`",
              "createdAt": "2018-06-11T06:59:54Z",
              "updatedAt": "2018-06-11T07:08:42Z"
            },
            {
              "originalPosition": 39,
              "body": "ditto",
              "createdAt": "2018-06-11T07:00:01Z",
              "updatedAt": "2018-06-11T07:08:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDUyNDY2",
          "commit": {
            "abbreviatedOid": "368d65b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-11T07:09:00Z",
          "updatedAt": "2018-06-11T07:09:00Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "done",
              "createdAt": "2018-06-11T07:09:00Z",
              "updatedAt": "2018-06-11T07:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDUyNDc3",
          "commit": {
            "abbreviatedOid": "368d65b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-11T07:09:01Z",
          "updatedAt": "2018-06-11T07:09:01Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "done",
              "createdAt": "2018-06-11T07:09:01Z",
              "updatedAt": "2018-06-11T07:09:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 207,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzODYwNjc3",
      "title": "Small fixes for README.md to add/update some links",
      "url": "https://github.com/WICG/webpackage/pull/207",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add/update following links:\r\n* Bundled exchanges draft html\r\n* Loading sketch explainer\r\n* An additional link to chromium's testing repo that could be helpful for people who want to try out signed exchange tools",
      "createdAt": "2018-06-11T02:15:55Z",
      "updatedAt": "2018-06-12T18:33:52Z",
      "closedAt": "2018-06-11T03:01:01Z",
      "mergedAt": "2018-06-11T03:01:01Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-06-12T18:33:52Z",
          "updatedAt": "2018-06-12T18:33:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDIxNzIw",
          "commit": {
            "abbreviatedOid": "63f179e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-11T02:17:54Z",
          "updatedAt": "2018-06-11T02:17:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzODg3NTQ3",
      "title": "cmd: introduce dump-signedexchange tool",
      "url": "https://github.com/WICG/webpackage/pull/208",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces dump-exchange tool to pretty-print an signedexchange file.",
      "createdAt": "2018-06-11T06:48:29Z",
      "updatedAt": "2018-06-11T07:02:36Z",
      "closedAt": "2018-06-11T07:02:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you split the PR to only commit go/signedexchange/cbor/decoder* for now?\r\nPlease update the dump-signedexchange tool so that it can actually decode the file generated by gen-signedexchange",
          "createdAt": "2018-06-11T06:50:06Z",
          "updatedAt": "2018-06-11T06:50:06Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, let me close this.",
          "createdAt": "2018-06-11T07:02:33Z",
          "updatedAt": "2018-06-11T07:02:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzODkwMTU4",
      "title": "cbor: Add decoder",
      "url": "https://github.com/WICG/webpackage/pull/209",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-11T07:04:41Z",
      "updatedAt": "2018-06-11T07:14:56Z",
      "closedAt": "2018-06-11T07:14:53Z",
      "mergedAt": "2018-06-11T07:14:53Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDUyNjM3",
          "commit": {
            "abbreviatedOid": "8fd857d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-11T07:09:43Z",
          "updatedAt": "2018-06-11T07:09:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0MTU5MDUw",
      "title": "Make MI encoding optional",
      "url": "https://github.com/WICG/webpackage/pull/210",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "WebBundling format doesn't require the payload to be MI encoded. This PR splits the encoding of the payload, so that it is possible to create an exchange without MI encoding.",
      "createdAt": "2018-06-12T03:48:08Z",
      "updatedAt": "2018-06-12T04:57:26Z",
      "closedAt": "2018-06-12T04:57:26Z",
      "mergedAt": "2018-06-12T04:57:26Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODE2NzU1",
          "commit": {
            "abbreviatedOid": "cdc2739"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T04:40:22Z",
          "updatedAt": "2018-06-12T04:40:45Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This function no longer needs to return error?",
              "createdAt": "2018-06-12T04:40:22Z",
              "updatedAt": "2018-06-12T04:40:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODE4NTkx",
          "commit": {
            "abbreviatedOid": "cdc2739"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-12T04:57:11Z",
          "updatedAt": "2018-06-12T04:57:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0MTc0Mzc0",
      "title": "Introduce gen-bundle tool to emit \"Bundled HTTP Exchanges\" [1]",
      "url": "https://github.com/WICG/webpackage/pull/211",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[1] https://wicg.github.io/webpackage/draft-yasskin-dispatch-bundled-exchanges.html",
      "createdAt": "2018-06-12T06:05:51Z",
      "updatedAt": "2018-06-13T05:46:05Z",
      "closedAt": "2018-06-13T05:46:04Z",
      "mergedAt": "2018-06-13T05:46:04Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "PTAL",
          "createdAt": "2018-06-13T05:24:05Z",
          "updatedAt": "2018-06-13T05:24:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODU2ODk4",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T08:07:13Z",
          "updatedAt": "2018-06-12T08:14:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "`headerMagicBytes` to be unexported?\r\n\r\nIf this is used only in `WriteBundle`, I'd move there.",
              "createdAt": "2018-06-12T08:07:13Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            },
            {
              "originalPosition": 15,
              "body": "`footerLength` in `writeFooter`",
              "createdAt": "2018-06-12T08:08:07Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            },
            {
              "originalPosition": 18,
              "body": "Do you have a plan to add members to the input? If no, just using slice would be enough.",
              "createdAt": "2018-06-12T08:08:54Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            },
            {
              "originalPosition": 4,
              "body": "Hmm, this sounds unsafe since payload can be modified on the caller side. At least we should have comments.",
              "createdAt": "2018-06-12T08:11:42Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            },
            {
              "originalPosition": 47,
              "body": "Where is error gone?",
              "createdAt": "2018-06-12T08:12:06Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTY5NzYx",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T22:19:25Z",
          "updatedAt": "2018-06-12T22:19:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "The magic bytes are useful by itself. The clients can see if a given binary is a bundle or not.",
              "createdAt": "2018-06-12T22:19:25Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTY5OTQ5",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T22:20:15Z",
          "updatedAt": "2018-06-12T22:20:15Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Yes. The implementation only encodes \"index\",\"responses\" sections atm, but there are other sections (such as manifest)",
              "createdAt": "2018-06-12T22:20:15Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTcwMjc3",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T22:21:39Z",
          "updatedAt": "2018-06-12T22:21:39Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "The func uses named return vars",
              "createdAt": "2018-06-12T22:21:39Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTk3MjQy",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T00:55:23Z",
          "updatedAt": "2018-06-13T00:55:23Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Ack",
              "createdAt": "2018-06-13T00:55:23Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjI5OTA2",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T05:23:02Z",
          "updatedAt": "2018-06-13T05:23:02Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2018-06-13T05:23:02Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjI5OTg4",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T05:23:35Z",
          "updatedAt": "2018-06-13T05:23:36Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Done.",
              "createdAt": "2018-06-13T05:23:35Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjMxMDYz",
          "commit": {
            "abbreviatedOid": "bc30d4f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T05:31:30Z",
          "updatedAt": "2018-06-13T05:31:34Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'm against exposing a `[]byte`.\r\n\r\n> The clients can see if a given binary is a bundle or not.\r\n\r\nWould it be possible to add a function to do that?",
              "createdAt": "2018-06-13T05:31:31Z",
              "updatedAt": "2018-06-13T05:31:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjMyOTky",
          "commit": {
            "abbreviatedOid": "bc30d4f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-13T05:43:27Z",
          "updatedAt": "2018-06-13T05:43:38Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Discussed offline, and we compromised this since there is no good substitution.",
              "createdAt": "2018-06-13T05:43:28Z",
              "updatedAt": "2018-06-13T05:43:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NDc2NTg0",
      "title": "Rename bundle.{Input => Bundle}, and bundle.{WriteBundle => Write}",
      "url": "https://github.com/WICG/webpackage/pull/213",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To prepare for bundle.Read",
      "createdAt": "2018-06-13T05:46:19Z",
      "updatedAt": "2018-06-13T06:07:20Z",
      "closedAt": "2018-06-13T06:07:19Z",
      "mergedAt": "2018-06-13T06:07:19Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjMzNzU0",
          "commit": {
            "abbreviatedOid": "10a75a0"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-13T05:48:46Z",
          "updatedAt": "2018-06-13T05:48:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "optional: How about implementing `WriteTo`?\r\n\r\nhttps://golang.org/pkg/io/#WriterTo",
              "createdAt": "2018-06-13T05:48:46Z",
              "updatedAt": "2018-06-13T05:59:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjM1NDIx",
          "commit": {
            "abbreviatedOid": "baa5726"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T05:59:51Z",
          "updatedAt": "2018-06-13T05:59:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Done",
              "createdAt": "2018-06-13T05:59:51Z",
              "updatedAt": "2018-06-13T05:59:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjM1OTc3",
          "commit": {
            "abbreviatedOid": "f0d7ade"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "still lgtm",
          "createdAt": "2018-06-13T06:03:56Z",
          "updatedAt": "2018-06-13T06:03:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 215,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NzQ0OTM4",
      "title": "Update to draft-ietf-httpbis-header-structure-06.",
      "url": "https://github.com/WICG/webpackage/pull/215",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I believe this is just updates to section numbers, and the addition of ABNF for the headers.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/update-structured-headers/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/update-structured-headers/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-06-13T23:45:31Z",
      "updatedAt": "2018-06-14T03:09:52Z",
      "closedAt": "2018-06-14T03:09:48Z",
      "mergedAt": "2018-06-14T03:09:48Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori Would you check this?",
          "createdAt": "2018-06-14T01:29:55Z",
          "updatedAt": "2018-06-14T01:29:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NjIwNDAw",
          "commit": {
            "abbreviatedOid": "e3712f9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-14T01:55:49Z",
          "updatedAt": "2018-06-14T01:55:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NjIxMTY4",
          "commit": {
            "abbreviatedOid": "e3712f9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-14T02:01:35Z",
          "updatedAt": "2018-06-14T02:01:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 216,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NzQ1NzE5",
      "title": "Add IANA registrations for Accept-Signature and Signed-Headers headers.",
      "url": "https://github.com/WICG/webpackage/pull/216",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/register-headers/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/register-headers/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-06-13T23:51:33Z",
      "updatedAt": "2018-06-14T03:10:21Z",
      "closedAt": "2018-06-14T03:10:17Z",
      "mergedAt": "2018-06-14T03:10:17Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "LGTM",
          "createdAt": "2018-06-14T00:36:08Z",
          "updatedAt": "2018-06-14T00:36:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 217,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MDQ3MzUz",
      "title": "Editorial: double quote all section names",
      "url": "https://github.com/WICG/webpackage/pull/217",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-14T23:54:58Z",
      "updatedAt": "2018-06-15T00:03:14Z",
      "closedAt": "2018-06-15T00:03:14Z",
      "mergedAt": "2018-06-15T00:03:14Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MDA5NTQ1",
          "commit": {
            "abbreviatedOid": "54526c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Oops, thanks.",
          "createdAt": "2018-06-15T00:02:59Z",
          "updatedAt": "2018-06-15T00:02:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 218,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MDQ4MzU3",
      "title": "Add note about `ignoredSections`",
      "url": "https://github.com/WICG/webpackage/pull/218",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There doesn't seem to be a section that \"says not to process other sections\" as of now. Can we omit the steps until we have one?",
      "createdAt": "2018-06-15T00:03:32Z",
      "updatedAt": "2018-06-18T18:35:50Z",
      "closedAt": "2018-06-18T18:35:50Z",
      "mergedAt": "2018-06-18T18:35:50Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is here so that a future specification can define a section that replaces another one without needing to re-release this specification. This step definitely doesn't need to appear in an implementation until it implements a section that says to ignore another one, but to remove it from the specification, I'd want an argument that this kind of section is fundamentally a bad idea.",
          "createdAt": "2018-06-15T00:06:54Z",
          "updatedAt": "2018-06-15T00:06:54Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it.\r\n\r\nI was a bit confused when I was implementing the steps line-by-line. Would it be able to add a note how this is going to be used in future?",
          "createdAt": "2018-06-15T00:13:41Z",
          "updatedAt": "2018-06-15T00:13:41Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "If you were confused, it probably deserves a note. Do you want to try to word it, or should I try next week?",
          "createdAt": "2018-06-15T00:46:01Z",
          "updatedAt": "2018-06-15T00:46:01Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Tried something. PTAL",
          "createdAt": "2018-06-15T03:34:18Z",
          "updatedAt": "2018-06-15T03:34:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MjM3Njk1",
          "commit": {
            "abbreviatedOid": "bdfc665"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-15T16:29:47Z",
          "updatedAt": "2018-06-15T16:38:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "s/supercedes/supercede/",
              "createdAt": "2018-06-15T16:29:47Z",
              "updatedAt": "2018-06-18T00:41:41Z"
            },
            {
              "originalPosition": 5,
              "body": "How about\r\n\r\n> Implementations that don't implement any such sections are free to omit the relevant steps.\r\n\r\nsince even after we add such a section to the registry, implementations that don't implement it will still be able to skip the `ignoredSections` steps.\r\n\r\nI expect to get some pushback based on the fact that implementations are [always allowed to differ from the specified steps as long as they get the same answer](https://infra.spec.whatwg.org/#algorithms).",
              "createdAt": "2018-06-15T16:38:26Z",
              "updatedAt": "2018-06-18T00:41:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NDA2OTUz",
          "commit": {
            "abbreviatedOid": "bdfc665"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T00:26:21Z",
          "updatedAt": "2018-06-18T00:26:54Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2018-06-18T00:26:21Z",
              "updatedAt": "2018-06-18T00:41:41Z"
            },
            {
              "originalPosition": 5,
              "body": "That sounds much better! Applied.",
              "createdAt": "2018-06-18T00:26:24Z",
              "updatedAt": "2018-06-18T00:41:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 219,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MDc2OTMz",
      "title": "Editorial: the map variable should be sectionOffsets",
      "url": "https://github.com/WICG/webpackage/pull/219",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-15T04:49:06Z",
      "updatedAt": "2018-06-15T16:40:22Z",
      "closedAt": "2018-06-15T16:40:22Z",
      "mergedAt": "2018-06-15T16:40:22Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MjQwNzI4",
          "commit": {
            "abbreviatedOid": "854ddb7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-06-15T16:40:12Z",
          "updatedAt": "2018-06-15T16:40:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 220,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1NDA0ODI5",
      "title": "Fix reference to headerCbor",
      "url": "https://github.com/WICG/webpackage/pull/220",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-18T01:06:18Z",
      "updatedAt": "2018-06-18T18:53:21Z",
      "closedAt": "2018-06-18T18:53:21Z",
      "mergedAt": "2018-06-18T18:53:21Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NjkyNjA4",
          "commit": {
            "abbreviatedOid": "f0ecbbd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-06-18T18:52:34Z",
          "updatedAt": "2018-06-18T18:52:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 223,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1NDE3NzA3",
      "title": "dump-bundle: Introduce dump-bundle tool which implements bundled",
      "url": "https://github.com/WICG/webpackage/pull/223",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "exchange semantics",
      "createdAt": "2018-06-18T04:06:18Z",
      "updatedAt": "2018-06-22T01:33:30Z",
      "closedAt": "2018-06-22T01:33:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this. Please review #230 instead",
          "createdAt": "2018-06-22T01:33:29Z",
          "updatedAt": "2018-06-22T01:33:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NDI0ODA3",
          "commit": {
            "abbreviatedOid": "c570cd9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sounds fine, but I'll take a deeper look at this later",
          "createdAt": "2018-06-18T04:26:53Z",
          "updatedAt": "2018-06-18T04:28:20Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Why isn't this fixed now?",
              "createdAt": "2018-06-18T04:26:54Z",
              "updatedAt": "2018-06-18T04:28:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1Njc2MDI5",
      "title": "Update readme",
      "url": "https://github.com/WICG/webpackage/pull/224",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Feel free to land via rebase if everything looks good.",
      "createdAt": "2018-06-18T23:31:18Z",
      "updatedAt": "2018-06-19T05:50:59Z",
      "closedAt": "2018-06-19T05:50:31Z",
      "mergedAt": "2018-06-19T05:50:31Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5ODE4Mzkw",
          "commit": {
            "abbreviatedOid": "b957f8f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-19T05:04:29Z",
          "updatedAt": "2018-06-19T05:04:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 225,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1Njc2NjI2",
      "title": "Fix #202: Link to the Metadata field's definition.",
      "url": "https://github.com/WICG/webpackage/pull/225",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "[Preview](https://jyasskin.github.io/webpackage/link-metadata/draft-yasskin-wpack-bundled-exchanges.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.txt&url2=https://jyasskin.github.io/webpackage/link-metadata/draft-yasskin-wpack-bundled-exchanges.txt)\r\n\r\n@nyaxt How's this?",
      "createdAt": "2018-06-18T23:35:40Z",
      "updatedAt": "2018-06-19T05:50:50Z",
      "closedAt": "2018-06-19T05:50:46Z",
      "mergedAt": "2018-06-19T05:50:46Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5ODE4NDI4",
          "commit": {
            "abbreviatedOid": "9af7827"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-19T05:04:51Z",
          "updatedAt": "2018-06-19T05:04:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 226,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1OTkwNDAw",
      "title": "In both random-access maps, store the index and contents in the same order.",
      "url": "https://github.com/WICG/webpackage/pull/226",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "[Preview](https://jyasskin.github.io/webpackage/ordered-responses/draft-yasskin-wpack-bundled-exchanges.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.txt&url2=https://jyasskin.github.io/webpackage/ordered-responses/draft-yasskin-wpack-bundled-exchanges.txt)\r\n\r\nThis lets us store only lengths in the index, and compute offsets from\r\nthem, which in turn enforces that the contents don't overlap and don't\r\nhave gaps, making the content array well-formed CBOR.\r\n\r\nThis applies to both the section index and the request index.\r\n\r\nFixes #212.\r\n\r\nLet me know if you see any places that the parser still isn't checking that the bundle is well-formed CBOR.",
      "createdAt": "2018-06-20T00:08:17Z",
      "updatedAt": "2018-06-22T19:33:29Z",
      "closedAt": "2018-06-22T18:51:37Z",
      "mergedAt": "2018-06-22T18:51:36Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I love this change. Looks great on a first pass. I'll take a closer look later today.",
          "createdAt": "2018-06-20T00:28:28Z",
          "updatedAt": "2018-06-20T00:28:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMjM2MDY3",
          "commit": {
            "abbreviatedOid": "a389864"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T04:24:52Z",
          "updatedAt": "2018-06-20T04:29:22Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "Should we remove the sentence \"That is, offsets in the index are relative to the start of the \"responses\" section.\"?",
              "createdAt": "2018-06-20T04:24:52Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            },
            {
              "originalPosition": 165,
              "body": "Should we scope this step (+its substeps) to parsing the responses array header?",
              "createdAt": "2018-06-20T04:27:46Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            },
            {
              "originalPosition": 176,
              "body": "Then, we can have this say:\r\nLet `currentOffset` be the ...\r\n\r\nwithout Step 2.",
              "createdAt": "2018-06-20T04:28:10Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNTY1NDgw",
          "commit": {
            "abbreviatedOid": "a389864"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T20:00:34Z",
          "updatedAt": "2018-06-20T20:46:13Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Sure.",
              "createdAt": "2018-06-20T20:00:34Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            },
            {
              "originalPosition": 205,
              "body": "Whoops, done.",
              "createdAt": "2018-06-20T20:41:41Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNjM2MTMx",
          "commit": {
            "abbreviatedOid": "e1a382e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-21T00:50:37Z",
          "updatedAt": "2018-06-21T00:50:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2MjA0NzU4",
      "title": "Fix typo",
      "url": "https://github.com/WICG/webpackage/pull/227",
      "state": "MERGED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Two instances of receipient => recipient",
      "createdAt": "2018-06-20T16:38:53Z",
      "updatedAt": "2018-06-20T16:44:55Z",
      "closedAt": "2018-06-20T16:44:55Z",
      "mergedAt": "2018-06-20T16:44:55Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDkwNDMw",
          "commit": {
            "abbreviatedOid": "926ba81"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-06-20T16:44:47Z",
          "updatedAt": "2018-06-20T16:44:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2MzA0OTQ0",
      "title": "Limit the allowed schemes for URLs.",
      "url": "https://github.com/WICG/webpackage/pull/228",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And clarify the definition of \"absolute URL\".\r\n\r\nFixes #222.\r\n\r\n@kinu \r\n\r\n[Preview](https://jyasskin.github.io/webpackage/filter-schemes/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/filter-schemes/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-06-21T00:14:30Z",
      "updatedAt": "2018-06-21T04:03:14Z",
      "closedAt": "2018-06-21T02:30:43Z",
      "mergedAt": "2018-06-21T02:30:43Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! lgtm.",
          "createdAt": "2018-06-21T00:56:37Z",
          "updatedAt": "2018-06-21T00:56:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@twifkak I should have double-checked with you before merging this. Let me know if I've gotten the right set of schemes in each location.",
          "createdAt": "2018-06-21T02:32:10Z",
          "updatedAt": "2018-06-21T02:32:10Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "No worries; this LGTM.",
          "createdAt": "2018-06-21T04:03:14Z",
          "updatedAt": "2018-06-21T04:03:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNjM1ODkx",
          "commit": {
            "abbreviatedOid": "283cc4f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-21T00:48:37Z",
          "updatedAt": "2018-06-21T00:48:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2NjE3MDM0",
      "title": "Introduce dump-bundle tool and follow #226 format",
      "url": "https://github.com/WICG/webpackage/pull/230",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-22T01:32:53Z",
      "updatedAt": "2018-06-28T07:36:14Z",
      "closedAt": "2018-06-28T07:36:14Z",
      "mergedAt": "2018-06-28T07:36:14Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMDUwNzcw",
          "commit": {
            "abbreviatedOid": "8928763"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-22T02:33:10Z",
          "updatedAt": "2018-06-22T02:37:16Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "`if err := ... ; err {`",
              "createdAt": "2018-06-22T02:33:11Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            },
            {
              "originalPosition": 26,
              "body": "Why do we need to introduce a struct for a option? Isn't just an argument enough so far? My expectation is `Dump`'s signature is changeable though `Dump` is exported.",
              "createdAt": "2018-06-22T02:34:07Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNTA4MjY0",
          "commit": {
            "abbreviatedOid": "8928763"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-06-25T08:20:56Z",
          "updatedAt": "2018-06-25T08:26:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'd name `DeocdeUint` (small i) or `DeocdeUint64`.",
              "createdAt": "2018-06-25T08:20:56Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            },
            {
              "originalPosition": 6,
              "body": "I was wondering where this method is called. As this exposes a mutable value, I'd want to avoid this.",
              "createdAt": "2018-06-25T08:26:22Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            },
            {
              "originalPosition": 12,
              "body": "ditto",
              "createdAt": "2018-06-25T08:26:52Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxODY2NTA4",
          "commit": {
            "abbreviatedOid": "8928763"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T05:11:59Z",
          "updatedAt": "2018-06-26T05:11:59Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done",
              "createdAt": "2018-06-26T05:11:59Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxODY2NzMy",
          "commit": {
            "abbreviatedOid": "8928763"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "PTAL",
          "createdAt": "2018-06-26T05:13:48Z",
          "updatedAt": "2018-06-28T05:04:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done",
              "createdAt": "2018-06-26T05:13:49Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            },
            {
              "originalPosition": 26,
              "body": "Done",
              "createdAt": "2018-06-26T05:20:56Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjkxNjI2",
          "commit": {
            "abbreviatedOid": "7735a91"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-28T05:36:38Z",
          "updatedAt": "2018-06-28T05:48:15Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "As HTTP status is represented as an integer in `net/http` package, let's use an integer here.",
              "createdAt": "2018-06-28T05:36:39Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2Nzg0Mjg1",
      "title": "Rename id-ce-testCanSignHttpExchanges to id-ce-canSignHttpExchangesDraft",
      "url": "https://github.com/WICG/webpackage/pull/231",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Per @sleevi's suggestion.\r\n\r\nFixes #229.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/rename-test-oid/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/rename-test-oid/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-06-22T16:19:05Z",
      "updatedAt": "2018-12-01T00:34:29Z",
      "closedAt": "2018-06-25T01:47:11Z",
      "mergedAt": "2018-06-25T01:47:11Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQzMjY4",
          "commit": {
            "abbreviatedOid": "689d7da"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-25T00:36:10Z",
          "updatedAt": "2018-06-25T00:36:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQ0MzY3",
          "commit": {
            "abbreviatedOid": "689d7da"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-25T00:54:27Z",
          "updatedAt": "2018-06-25T00:54:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 232,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2ODY4Njcy",
      "title": "Start the -impl-01 draft.",
      "url": "https://github.com/WICG/webpackage/pull/232",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I think this catches everything that we're expecting to be different or missing in the Chrome 69 implementation vs the main spec. Let me know if I've missed anything.\r\n\r\nFixes #186.",
      "createdAt": "2018-06-23T00:04:28Z",
      "updatedAt": "2018-07-09T18:41:40Z",
      "closedAt": "2018-07-09T18:41:36Z",
      "mergedAt": "2018-07-09T18:41:36Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM.\r\n\r\nShould we put tentative values on TBD size limits?",
          "createdAt": "2018-06-25T01:46:54Z",
          "updatedAt": "2018-06-25T01:46:54Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2018-07-06T22:11:12Z",
          "updatedAt": "2018-07-06T22:11:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQ4MDQw",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-25T01:46:04Z",
          "updatedAt": "2018-06-25T01:46:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQ4MjUz",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T01:48:31Z",
          "updatedAt": "2018-06-25T01:48:32Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "For M69, we currently plan to support only single signature for an exchange.",
              "createdAt": "2018-06-25T01:48:32Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDY3MzEz",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T04:53:02Z",
          "updatedAt": "2018-06-25T05:18:35Z",
          "comments": [
            {
              "originalPosition": 703,
              "body": "Should we use \"mi-sha256\" or \"mi-sha256-draft2\" here?\r\n(@kinu and I can go with either, but want to clarify your decision on this)\r\n\r\nFor more context, I was wondering if this should be \"mi-sha256-draft2\", but noticed that https://github.com/martinthomson/http-mice/pull/8 isn't merged yet and mice draft02 expired in May.",
              "createdAt": "2018-06-25T04:53:03Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1201,
              "body": "Looks like this actually went away in draft-01?",
              "createdAt": "2018-06-25T04:53:59Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 107,
              "body": "[tangentially related]\r\nWhile the header-structure spec's 04->06 diff doesn't affect signed exchange much, we were wondering if the header spec would also apply to \"Content-Type\" header someday, since it disallows identifier being an `item`.\r\nWith the change, `v=b1` is invalid and it has to be `v=\"b1\"`.\r\n\r\nWhen parsing signed exchange, Chrome Canary currently allows both `v=b1` and `v=\"b1\"` so we are good here.\r\nHowever, we might want to change the Accept header to say `v=\"b1\"`",
              "createdAt": "2018-06-25T05:18:30Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNDA2MzQz",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM; only nits and naive questions.",
          "createdAt": "2018-06-30T00:09:19Z",
          "updatedAt": "2018-06-30T01:51:00Z",
          "comments": [
            {
              "originalPosition": 347,
              "body": "s/first item/first map/ (or s/first/second/)",
              "createdAt": "2018-06-30T00:09:19Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 355,
              "body": "Is this optional to allow for the possibility of an intermediate fetching and attaching it?",
              "createdAt": "2018-06-30T00:18:46Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 359,
              "body": "Should this be s/Each/The first/?",
              "createdAt": "2018-06-30T00:22:28Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 359,
              "body": "Also, s/value/value if any/ per {#cross-origin-trust}?",
              "createdAt": "2018-06-30T00:24:07Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 462,
              "body": "1. Does this mean the choice cannot depend on the signature_algorithms_cert extension?\r\n2. Can the choice be \"always return invalid\"? (That appears to be [what chromium does](https://cs.chromium.org/chromium/src/content/browser/web_package/signed_exchange_signature_verifier.cc?l=183&rcl=b7527b9711e28030e03ad438ba323af7142ce43b) IIUC.)\r\n\r\n(Pardon my naivety!)",
              "createdAt": "2018-06-30T01:00:00Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 607,
              "body": "s/to/if it wishes to/? (i.e. A client may use `thirdpartysig` without updating the others if it validates and meets its needs?)",
              "createdAt": "2018-06-30T01:06:04Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 699,
              "body": "s/digest/mi/",
              "createdAt": "2018-06-30T01:08:31Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1002,
              "body": "Should this be updated to remove the reference to the \"non-signed header section\", or perhaps the above \"`sigLength` bytes\" item clarified to be named that?",
              "createdAt": "2018-06-30T01:37:46Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1022,
              "body": "IIUC, the 3-byte header length should precede the signature value.",
              "createdAt": "2018-06-30T01:44:42Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1141,
              "body": "Should there be an implementation draft note for this, too?",
              "createdAt": "2018-06-30T01:48:10Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM0MTk4NDkz",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-03T23:21:28Z",
          "updatedAt": "2018-07-06T21:22:50Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "The Structured Headers proposal doesn't intend to change existing headers' definitions, and practically I don't think it could change them in backward-incompatible ways like that.",
              "createdAt": "2018-07-03T23:21:28Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 347,
              "body": "Good catch. This needs to change in the main spec too.",
              "createdAt": "2018-07-03T23:22:13Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 359,
              "body": "Yep, SCTs might be embedded elsewhere.",
              "createdAt": "2018-07-03T23:23:48Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 355,
              "body": "I'm not sure why that says \"if any\"... It might date from when I thought intermediate certs could have OCSP responses.",
              "createdAt": "2018-07-03T23:24:23Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 462,
              "body": "1. I think so. Note that [signature_algorithms_cert](https://tlswg.github.io/tls13-spec/draft-ietf-tls-tls13.html#signature-algorithms) is a TLS option, which isn't really in effect when parsing a signed exchange.\r\n\r\n2. Yep. Supporting just one kind of public key is reasonable.",
              "createdAt": "2018-07-03T23:28:35Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 607,
              "body": "Yeah.",
              "createdAt": "2018-07-03T23:29:25Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 699,
              "body": "Oops.",
              "createdAt": "2018-07-03T23:29:37Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 703,
              "body": "I think \"mi-draft2/mi-sha256-draft2\" since we don't want to opt into the final RFC by mistake. (And I'm mostly ignoring expirations of Internet-Drafts.)",
              "createdAt": "2018-07-03T23:30:50Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1002,
              "body": "Yep, I'll refer to the signature instead of the non-signed headers.",
              "createdAt": "2018-07-03T23:31:47Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1022,
              "body": "Yep.",
              "createdAt": "2018-07-03T23:32:32Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1201,
              "body": "It's coming back. The change wasn't totally finished.",
              "createdAt": "2018-07-03T23:33:15Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1141,
              "body": "Yes.",
              "createdAt": "2018-07-03T23:34:03Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 90,
              "body": "Thanks.",
              "createdAt": "2018-07-03T23:51:16Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTcxMTY4",
          "commit": {
            "abbreviatedOid": "d19cde6"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-06T22:12:34Z",
          "updatedAt": "2018-07-06T22:12:35Z",
          "comments": [
            {
              "originalPosition": 462,
              "body": "Out of curiosity, is there a specific \"other context\" that this language intends to prevent?",
              "createdAt": "2018-07-06T22:12:35Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTcyNDA3",
          "commit": {
            "abbreviatedOid": "35f0e3a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-06T22:20:29Z",
          "updatedAt": "2018-07-06T22:20:29Z",
          "comments": [
            {
              "originalPosition": 462,
              "body": "For example, lots of signature formats, like [JWS](https://tools.ietf.org/html/rfc7515#section-5.2), include an algorithm name in the signature in addition to a public key identifier. This allows some silly things like https://www.sjoerdlangkemper.nl/2016/09/28/attacking-jwt-authentication/.",
              "createdAt": "2018-07-06T22:20:29Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3MDA5NDQ1",
      "title": "gen-signedexchange: Follow changes in #228",
      "url": "https://github.com/WICG/webpackage/pull/233",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-25T06:03:51Z",
      "updatedAt": "2018-06-25T06:52:56Z",
      "closedAt": "2018-06-25T06:52:56Z",
      "mergedAt": "2018-06-25T06:52:56Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDgxMDI1",
          "commit": {
            "abbreviatedOid": "e811c46"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-25T06:33:05Z",
          "updatedAt": "2018-06-25T06:33:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3NzkxNjI2",
      "title": "Fixes #234: mi-sha256 should be base64 encoded",
      "url": "https://github.com/WICG/webpackage/pull/235",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The examples show a mi-sha256 hexdigest instead of bas64 encoding,\r\n\r\nsee https://github.com/martinthomson/http-mice/blob/master/draft-thomson-http-mice.md",
      "createdAt": "2018-06-27T16:45:45Z",
      "updatedAt": "2018-07-02T22:41:29Z",
      "closedAt": "2018-07-02T22:41:01Z",
      "mergedAt": "2018-07-02T22:41:01Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjU3OTk2",
          "commit": {
            "abbreviatedOid": "c8ca724"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T01:00:42Z",
          "updatedAt": "2018-06-28T01:12:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I was wondering if this should be\r\n```\r\nMI: mi-sha256=*dcRDgR2GM35DluAV13PzgnG6-pvQwPywfFvAu1UeFrs==*\r\n```\r\n\r\nbut it looks like https://martinthomson.github.io/http-mice/draft-thomson-http-mice.html#header refers to RFC7230 and RFC7231, not https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-06 yet.",
              "createdAt": "2018-06-28T01:00:42Z",
              "updatedAt": "2018-06-28T09:22:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNzI5NjY2",
          "commit": {
            "abbreviatedOid": "c8ca724"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T08:14:00Z",
          "updatedAt": "2018-06-28T08:14:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@nyaxt right, MICE doesn't use structured headers.\r\n\r\nOT: where can I ask questions/discuss on other parts of this proposal?",
              "createdAt": "2018-06-28T08:14:00Z",
              "updatedAt": "2018-06-28T09:22:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNzQxMjg5",
          "commit": {
            "abbreviatedOid": "c8ca724"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T08:41:10Z",
          "updatedAt": "2018-06-28T08:41:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "https://martinthomson.github.io/http-mice/draft-thomson-http-mice.html#mi-header-field-parameters says that the value is base64url encoding [[RFC7515](https://tools.ietf.org/html/rfc7515)], which does not have padding '=' characters.",
              "createdAt": "2018-06-28T08:41:10Z",
              "updatedAt": "2018-06-28T09:22:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNzYwMjQ2",
          "commit": {
            "abbreviatedOid": "d5a65e2"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T09:23:08Z",
          "updatedAt": "2018-06-28T09:23:08Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "@irori thx++ :D",
              "createdAt": "2018-06-28T09:23:08Z",
              "updatedAt": "2018-06-28T09:23:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNzk5NzIw",
          "commit": {
            "abbreviatedOid": "d5a65e2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks for catching this!",
          "createdAt": "2018-07-02T22:39:29Z",
          "updatedAt": "2018-07-02T22:39:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzODAwMDgx",
          "commit": {
            "abbreviatedOid": "d5a65e2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-02T22:41:28Z",
          "updatedAt": "2018-07-02T22:41:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "OT: Filing issues here is great. :)",
              "createdAt": "2018-07-02T22:41:29Z",
              "updatedAt": "2018-07-02T22:41:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4MjMzNDAw",
      "title": "go/bundle: add README.md",
      "url": "https://github.com/WICG/webpackage/pull/239",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-29T07:13:03Z",
      "updatedAt": "2018-06-29T11:18:27Z",
      "closedAt": "2018-06-29T11:18:27Z",
      "mergedAt": "2018-06-29T11:18:27Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm, thanks!",
          "createdAt": "2018-06-29T09:23:21Z",
          "updatedAt": "2018-06-29T09:23:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIxNDk1",
          "commit": {
            "abbreviatedOid": "6c8178b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:19:41Z",
          "updatedAt": "2018-06-29T07:20:17Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "`go get -u github.com/WICG/webpackage/go/bundle/cmd/...` would work to install all the binaries.",
              "createdAt": "2018-06-29T07:19:42Z",
              "updatedAt": "2018-06-29T08:55:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTI1OTM0",
          "commit": {
            "abbreviatedOid": "6c8178b"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:38:44Z",
          "updatedAt": "2018-06-29T07:38:51Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Should `foo.webbundle` be `foo.wbn` per https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.6.1 ?",
              "createdAt": "2018-06-29T07:38:44Z",
              "updatedAt": "2018-06-29T08:55:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTQ4MTE5",
          "commit": {
            "abbreviatedOid": "6c8178b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T08:55:40Z",
          "updatedAt": "2018-06-29T08:55:50Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2018-06-29T08:55:40Z",
              "updatedAt": "2018-06-29T08:55:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTc1MTUy",
          "commit": {
            "abbreviatedOid": "0775728"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-29T10:26:24Z",
          "updatedAt": "2018-06-29T10:26:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 240,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODM4ODIz",
      "title": "gen-certurl: Fix usage messages",
      "url": "https://github.com/WICG/webpackage/pull/240",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-03T03:12:40Z",
      "updatedAt": "2018-07-03T07:20:18Z",
      "closedAt": "2018-07-03T07:20:18Z",
      "mergedAt": "2018-07-03T07:20:18Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzODY3Njcy",
          "commit": {
            "abbreviatedOid": "4f27c6a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-03T06:52:46Z",
          "updatedAt": "2018-07-03T06:52:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODUxODAz",
      "title": "gen-signedexchange: Add detailed README.md",
      "url": "https://github.com/WICG/webpackage/pull/241",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc: @kinu ",
      "createdAt": "2018-07-03T05:15:19Z",
      "updatedAt": "2018-07-04T03:23:18Z",
      "closedAt": "2018-07-04T03:23:18Z",
      "mergedAt": "2018-07-04T03:23:18Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the review UI is getting difficult and @irori and @davidben are OOO, I'll tentatively merge this and open an issue asking for post-merge review.",
          "createdAt": "2018-07-04T03:23:13Z",
          "updatedAt": "2018-07-04T03:23:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzODUxMDY2",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-03T05:15:54Z",
          "updatedAt": "2018-07-03T05:15:54Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "@irori I'm not sure if this is good. Do you have any suggestion here?",
              "createdAt": "2018-07-03T05:15:54Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzOTUyMTky",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-03T11:18:37Z",
          "updatedAt": "2018-07-03T11:51:30Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "go/signedexchange?",
              "createdAt": "2018-07-03T11:18:37Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 52,
              "body": "As long as you use Chrome with `--ignore-certificate-errors-spki-list`, this is fine.\r\n\r\n`-sct` should be optional (if not, we should fix `gen-certurl`), so we can omit it.\r\n\r\nFor OCSP, we should be able to use `openssl ocsp` to set up an OCSP responder and generate an OCSP response, but it would complicate this instructions even further.",
              "createdAt": "2018-07-03T11:50:37Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzOTc0MzEw",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looking pretty good, thanks! (Made bunch of comments but all cosmetic)",
          "createdAt": "2018-07-03T12:31:52Z",
          "updatedAt": "2018-07-03T12:47:17Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "nit: constructs HTTP request ... -> constructs an HTTP request and response pair\r\n\r\nattach a -> attaches the\r\n\r\nto output file -> to an output file, or to the given output file",
              "createdAt": "2018-07-03T12:31:52Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 11,
              "body": "nit: a X.509 -> an X.509",
              "createdAt": "2018-07-03T12:33:54Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 13,
              "body": "nit: as a golang lib",
              "createdAt": "2018-07-03T12:34:23Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 28,
              "body": "nit: a signed exchange file that is signed using a self-signed certificate pair.",
              "createdAt": "2018-07-03T12:36:05Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 30,
              "body": "an HTTPS server\r\n\r\nstatic content -> static contents",
              "createdAt": "2018-07-03T12:36:13Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 37,
              "body": "nit: use a self signed certificate\r\n\r\nthere are no CA that issues -> there are no CAs that issue\r\n\r\n'signed exchange compatible' -> 'signed-exchange compatible' might be easier to read (optional)",
              "createdAt": "2018-07-03T12:37:48Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 74,
              "body": "Might be useful to note the version numbers too?",
              "createdAt": "2018-07-03T12:46:29Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM0MTYyNjYx",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-07-03T20:42:43Z",
          "updatedAt": "2018-07-03T21:04:58Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "I believe it's only a reference implementation to generate signed exchanges, rather than the whole spec?",
              "createdAt": "2018-07-03T20:42:43Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 11,
              "body": "Since `gen-certurl` accepts an OCSP response and SCT, I'd say \r\n\r\n> ... converts an X.509 certificate chain, an OCSP response, and an SCT (if one isn't already included in the certificate or OCSP response) to `application/cert-chain+cbor` ...",
              "createdAt": "2018-07-03T20:44:15Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 18,
              "body": "s/golang environment/The golang environment/\r\ns/on latest golang/on the latest golang/ or \"on the latest version of Go\"\r\ns/to [Go/to the [Go/\r\nMaybe s/golang/Go/g: I don't think the Go docs ever talk about \"golang\".",
              "createdAt": "2018-07-03T20:45:39Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 30,
              "body": "I would keep \"static content\". I think that's because \"content\" is used as a [mass noun](https://en.wikipedia.org/wiki/Mass_noun) for internet content, even though it can turn into \"contents\" when describing the contents of a box (but the content of a box would be fine too ... if you're thinking of all of the content as one notional thing ...). Sorry about English.",
              "createdAt": "2018-07-03T20:51:11Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 32,
              "body": "Maybe s/content/payload/ here, to match the HTTP term.",
              "createdAt": "2018-07-03T20:55:18Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 37,
              "body": "Or 'signed-exchange-compatible': https://en.wikipedia.org/wiki/Hyphen#Compound_modifiers",
              "createdAt": "2018-07-03T20:57:10Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 42,
              "body": "@davidben Could you double-check this series of commands?",
              "createdAt": "2018-07-03T20:59:36Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 73,
              "body": "s/supporting signed exchange/supporting signed exchanges/",
              "createdAt": "2018-07-03T21:02:06Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM0MjEzNzk2",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for your review",
          "createdAt": "2018-07-04T01:22:39Z",
          "updatedAt": "2018-07-04T01:48:20Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Done",
              "createdAt": "2018-07-04T01:22:39Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 3,
              "body": "We plan to add the envelope parser later, but yes. Corrected.",
              "createdAt": "2018-07-04T01:23:19Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 9,
              "body": "Done",
              "createdAt": "2018-07-04T01:24:03Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 11,
              "body": "Done.",
              "createdAt": "2018-07-04T01:24:12Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 11,
              "body": "Taken",
              "createdAt": "2018-07-04T01:24:41Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 13,
              "body": "Done",
              "createdAt": "2018-07-04T01:24:50Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2018-07-04T01:25:32Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 28,
              "body": "Done",
              "createdAt": "2018-07-04T01:26:01Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 30,
              "body": "Did s/a/an",
              "createdAt": "2018-07-04T01:27:17Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2018-07-04T01:27:27Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 37,
              "body": "Took signed-exchange-compatible",
              "createdAt": "2018-07-04T01:27:56Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 52,
              "body": "Hmm. Leaving this as is for now. @irori would you mind updating here next week?",
              "createdAt": "2018-07-04T01:32:43Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 73,
              "body": "Done",
              "createdAt": "2018-07-04T01:33:09Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 74,
              "body": "Done",
              "createdAt": "2018-07-04T01:47:38Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5MTMwMzU5",
      "title": "Remove test headers from example firebase.json",
      "url": "https://github.com/WICG/webpackage/pull/244",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-04T03:25:44Z",
      "updatedAt": "2018-07-23T16:49:13Z",
      "closedAt": "2018-07-04T07:20:36Z",
      "mergedAt": "2018-07-04T07:20:36Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM0MjQ1Nzkw",
          "commit": {
            "abbreviatedOid": "6ae38d1"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-04T06:02:10Z",
          "updatedAt": "2018-07-04T06:02:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 246,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5ODQ3ODMz",
      "title": "Several small fixes noticed by twifkak",
      "url": "https://github.com/WICG/webpackage/pull/246",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* Certificate chains have an array item before the first certificate.\r\n* The first certificate's OCSP response was described as optional when\r\n  it's not.\r\n* The first certificate's SCT was *not* described as optional, but it\r\n  can appear in the certificate itself or the OCSP response.\r\n* \"digest/mi-sha256\" doesn't make sense.\r\n* There's no longer a non-signed headers section in SXG files.\r\n* An example had lengths in the wrong order.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/devin-cleanups/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/devin-cleanups/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-07-06T21:08:16Z",
      "updatedAt": "2018-07-10T03:38:37Z",
      "closedAt": "2018-07-10T03:38:33Z",
      "mergedAt": "2018-07-10T03:38:33Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTU3MDA2",
          "commit": {
            "abbreviatedOid": "853f04d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-06T21:10:20Z",
          "updatedAt": "2018-07-06T21:10:21Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "@davidben I think this matches what we actually want (OCSP is required on 1st cert & forbidden on later ones; SCT is optional everywhere), but I want to double-check with you in case I'm forgetting something. https://github.com/WICG/webpackage/pull/122/files#r169830552 has our previous discussion on the topic.",
              "createdAt": "2018-07-06T21:10:20Z",
              "updatedAt": "2018-07-06T21:20:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTY3MDcy",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for backporting the nits! I think you also intended to add an implementation draft note at https://github.com/WICG/webpackage/pull/246/files#diff-a2197f2cbc199dc1463dc10213fa40d9R1380 to change the magic number, per https://github.com/WICG/webpackage/pull/232#discussion-diff-199309577R1146.",
          "createdAt": "2018-07-06T21:52:47Z",
          "updatedAt": "2018-07-06T21:52:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MjcwMzY0",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-09T03:56:05Z",
          "updatedAt": "2018-07-09T03:56:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTgxOTkx",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T20:35:30Z",
          "updatedAt": "2018-07-09T20:35:30Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "@sleevi, David deferred to you on this. I'm finding myself a little uncomfortable having a different rule for SCTs on intermediate certs vs OCSP responses on intermediates, but I don't have a strong preference for which policy we have. I suspect it'll be easier to relax a rule that they're all forbidden on intermediates than to tighten a rule that they're allowed. Even if they're allowed in the format, of course, Chrome wouldn't need to process them.",
              "createdAt": "2018-07-09T20:35:30Z",
              "updatedAt": "2018-07-09T20:35:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NjEwMTcw",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T22:05:35Z",
          "updatedAt": "2018-07-09T22:05:35Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I'm not sure I understand the question. Are you asking whether it's ok to MUST NOT SCTs in subsequent certs, similar to OCSP? Or whether it's OK to relax the MUST NOT for OCSP? Or something different?",
              "createdAt": "2018-07-09T22:05:35Z",
              "updatedAt": "2018-07-09T22:05:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NjEwNTM1",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T22:07:00Z",
          "updatedAt": "2018-07-09T22:07:00Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "The question is basically, \"Is the new text right, and if not, what should I say instead?\"",
              "createdAt": "2018-07-09T22:07:00Z",
              "updatedAt": "2018-07-09T22:07:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NjEyOTA1",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T22:16:57Z",
          "updatedAt": "2018-07-09T22:16:57Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "So, for the normative changes:\r\n* OCSP now required, at least for the first cert (if any -> MUST)\r\n* CT now optional (MUST -> if any)\r\n\r\nIf so, that's correct.\r\n\r\nAs to any asymmetry between the two:\r\nOCSP on every cert is similar to OCSP Multi-stapling ( https://tools.ietf.org/html/rfc6961 ) in <= TLS 1.2 or the TLS 1.3 Certificate frame ( https://tools.ietf.org/html/draft-ietf-tls-tls13-28#section-4.4.2 ), for which the Extensions structure allows an OCSP response or an SCT for each individual certificate presented in the handshake. In those cases, both are optional (e.g. a TLS1.2 server could only support status_request extension), but allowed for every cert.\r\n\r\nThis is slightly different - OCSP is required by policy for the first cert, and forbidden for subsequent certs. I could see the MUST NOT be reduced to a SHOULD NOT in the cases where a browser's whitelist might not handle it (e.g. technically constrained sub-CA certs), but, meh.\r\n\r\nSo... Yes, the change and motivation look good. I could also see explicitly forbidding SCTs on subsequent certs to parallel the OCSP case, for the same reasons and motivations.",
              "createdAt": "2018-07-09T22:16:57Z",
              "updatedAt": "2018-07-09T22:16:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NjEzODc4",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T22:21:23Z",
          "updatedAt": "2018-07-09T22:21:23Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Ok, thanks. I'll leave the new text as I have it since you don't say it's important for the two to be symmetric.",
              "createdAt": "2018-07-09T22:21:23Z",
              "updatedAt": "2018-07-09T22:21:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 247,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5ODY4NTM2",
      "title": "Make the CanSignHttpExchanges extension non-critical.",
      "url": "https://github.com/WICG/webpackage/pull/247",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "But warn servers away from using it in TLS servers.\r\n\r\nFixes #238.\r\n\r\n@sleevi and any CA folks who see this, do you think I'm right to say \"Conforming CAs MUST NOT mark this extension as critical.\", or should I leave them without a requirement here?\r\n\r\nSpec: [Preview](https://jyasskin.github.io/webpackage/non-critical-extension/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/non-critical-extension/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nImpl draft: [Preview](https://jyasskin.github.io/webpackage/non-critical-extension/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/non-critical-extension/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-07-06T23:54:04Z",
      "updatedAt": "2018-07-18T15:49:10Z",
      "closedAt": "2018-07-18T15:49:04Z",
      "mergedAt": "2018-07-18T15:49:04Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, @sleevi, I've moved the whole rationale to the security considerations. That section is a bit awkward: I could try to move some bits into 6.2 or 6.4, or decide that we don't need the full explanation at all, or just keep what I have.",
          "createdAt": "2018-07-09T20:27:22Z",
          "updatedAt": "2018-07-09T20:27:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTg1NjUw",
          "commit": {
            "abbreviatedOid": "226f4ef"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "A few nits, but overall looking good :)",
          "createdAt": "2018-07-07T00:12:31Z",
          "updatedAt": "2018-07-07T00:16:17Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I don't think we'd want to include the second sentence in the spec. That is, it presumes that new clients use the OS verifier, or that they even have an OS verifier, which... isn't going to hold :)",
              "createdAt": "2018-07-07T00:12:31Z",
              "updatedAt": "2018-07-09T20:28:24Z"
            },
            {
              "originalPosition": 15,
              "body": "I think the motivation might be better detailed in security considerations.\r\n\r\nThe reason this is a bit tricky is that by virtue of non-critical, clients that don't recognize this extension WILL accept this extension in TLS connections. So we don't have a hard security boundary. Because of this motivation, it seems like it makes sense to be discussed in the security section, calling out that this is not a security boundary itself, but simply an ecosystem health thing.",
              "createdAt": "2018-07-07T00:14:16Z",
              "updatedAt": "2018-07-09T20:28:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTIxMDQ3",
          "commit": {
            "abbreviatedOid": "3ffea7c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2018-07-13T06:43:48Z",
          "updatedAt": "2018-07-13T06:43:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 249,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5OTg2NTM1",
      "title": "Address review comments from #245",
      "url": "https://github.com/WICG/webpackage/pull/249",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-09T04:03:30Z",
      "updatedAt": "2018-07-13T05:05:34Z",
      "closedAt": "2018-07-13T05:05:33Z",
      "mergedAt": "2018-07-13T05:05:33Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTA5ODk2",
          "commit": {
            "abbreviatedOid": "511a2a4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-09T17:07:37Z",
          "updatedAt": "2018-07-09T17:07:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Maybe \"to the domain you own and want to sign the exchange for\" or \"to the domain for which you want to sign the exchange\". I'm not sure how much we want to emphasize domain ownership vs just assuming that people can only get certs for their own domains.",
              "createdAt": "2018-07-09T17:07:37Z",
              "updatedAt": "2018-07-13T03:48:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2ODk4MjIy",
          "commit": {
            "abbreviatedOid": "511a2a4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-13T03:48:29Z",
          "updatedAt": "2018-07-13T03:48:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks. Suggestion taken.",
              "createdAt": "2018-07-13T03:48:29Z",
              "updatedAt": "2018-07-13T03:48:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 250,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMDEzNjE1",
      "title": "gen-certurl: make sct command-line flag optional",
      "url": "https://github.com/WICG/webpackage/pull/250",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address #243 ",
      "createdAt": "2018-07-09T07:32:03Z",
      "updatedAt": "2018-07-09T07:47:27Z",
      "closedAt": "2018-07-09T07:47:27Z",
      "mergedAt": "2018-07-09T07:47:27Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MzA0OTEw",
          "commit": {
            "abbreviatedOid": "a19db34"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Ah I missed this, thanks. LGTM",
          "createdAt": "2018-07-09T07:40:03Z",
          "updatedAt": "2018-07-09T07:40:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 251,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMzEwNjUz",
      "title": "signedexchange: Expose struct members",
      "url": "https://github.com/WICG/webpackage/pull/251",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR exposes all the members of `Exchange` for consistency.",
      "createdAt": "2018-07-10T07:56:17Z",
      "updatedAt": "2018-07-10T14:40:41Z",
      "closedAt": "2018-07-10T14:40:37Z",
      "mergedAt": "2018-07-10T14:40:36Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODQ4Nzk4",
          "commit": {
            "abbreviatedOid": "1d83ab0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-10T14:24:01Z",
          "updatedAt": "2018-07-10T14:24:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 252,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMzY4MDU5",
      "title": "signedexchange: Implement dump-signedexchange command",
      "url": "https://github.com/WICG/webpackage/pull/252",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-10T11:42:55Z",
      "updatedAt": "2018-07-13T06:24:40Z",
      "closedAt": "2018-07-13T06:24:36Z",
      "mergedAt": "2018-07-13T06:24:36Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODQ5MzIy",
          "commit": {
            "abbreviatedOid": "ca93c1b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-10T14:25:05Z",
          "updatedAt": "2018-07-10T14:27:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Out of curiosity, what's the rationale for the change?",
              "createdAt": "2018-07-10T14:25:05Z",
              "updatedAt": "2018-07-13T06:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODU2NDE0",
          "commit": {
            "abbreviatedOid": "ca93c1b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-10T14:39:09Z",
          "updatedAt": "2018-07-10T14:39:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "No strong reason. I'd want to avoid copying arrays and pass slices instead. Perhaps `Encode3Byte...` should be fixed in the same way for consistency, or we should keep `[3]byte` here for consistency. I prefer slices, but both are fine to me.",
              "createdAt": "2018-07-10T14:39:09Z",
              "updatedAt": "2018-07-13T06:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2ODk2ODQx",
          "commit": {
            "abbreviatedOid": "ca93c1b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-13T03:37:10Z",
          "updatedAt": "2018-07-13T03:37:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Let's keep it `[3]byte` then, or please provide reference to coding standards, etc. ",
              "createdAt": "2018-07-13T03:37:10Z",
              "updatedAt": "2018-07-13T06:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTEwOTE2",
          "commit": {
            "abbreviatedOid": "130c475"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-13T05:40:08Z",
          "updatedAt": "2018-07-13T05:40:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2018-07-13T05:40:08Z",
              "updatedAt": "2018-07-13T06:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTE2Njgx",
          "commit": {
            "abbreviatedOid": "130c475"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-13T06:18:42Z",
          "updatedAt": "2018-07-13T06:18:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 254,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxMTcyMTU3",
      "title": "gen-certurl: Fetch OCSP response from network if -ocsp is omitted",
      "url": "https://github.com/WICG/webpackage/pull/254",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-13T02:28:19Z",
      "updatedAt": "2018-07-13T06:03:31Z",
      "closedAt": "2018-07-13T06:03:01Z",
      "mergedAt": "2018-07-13T06:03:01Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "- Would you add test for this? (separate PR is fine)\r\n- Can we dedupe pem parsing? (separate PR is fine)",
          "createdAt": "2018-07-13T03:35:38Z",
          "updatedAt": "2018-07-13T03:35:38Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "PTAL\r\n\r\nTest added. Let me do pem cleanup in a separate PR.",
          "createdAt": "2018-07-13T05:02:40Z",
          "updatedAt": "2018-07-13T05:02:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2ODkzOTkx",
          "commit": {
            "abbreviatedOid": "3889ddb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-13T03:11:53Z",
          "updatedAt": "2018-07-13T03:11:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTA3MTcx",
          "commit": {
            "abbreviatedOid": "9c582d6"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-13T05:07:40Z",
          "updatedAt": "2018-07-13T05:07:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxMTk4OTM5",
      "title": "signedexchange: Add dump-singedexchange explanation to README",
      "url": "https://github.com/WICG/webpackage/pull/255",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-13T06:30:50Z",
      "updatedAt": "2018-07-15T10:17:28Z",
      "closedAt": "2018-07-15T10:13:11Z",
      "mergedAt": "2018-07-15T10:13:11Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3MjYxMjM1",
          "commit": {
            "abbreviatedOid": "8e72000"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-15T10:13:06Z",
          "updatedAt": "2018-07-15T10:13:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 256,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxMjAwNTg2",
      "title": "gen-certurl: do not parse input certificates twice",
      "url": "https://github.com/WICG/webpackage/pull/256",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now FetchOCSPResponse and CreateCertChainCBOR (renamed from\r\nCertificateMessageFromPEM) take parsed x509.Certificates.",
      "createdAt": "2018-07-13T06:41:31Z",
      "updatedAt": "2018-07-13T07:00:44Z",
      "closedAt": "2018-07-13T07:00:40Z",
      "mergedAt": "2018-07-13T07:00:40Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTIxMzUx",
          "commit": {
            "abbreviatedOid": "04c50d0"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-13T06:45:22Z",
          "updatedAt": "2018-07-13T06:45:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTIyNDI3",
          "commit": {
            "abbreviatedOid": "04c50d0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-13T06:50:56Z",
          "updatedAt": "2018-07-13T06:50:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNzgwODMz",
      "title": "Try all PEM blocks in private key file.",
      "url": "https://github.com/WICG/webpackage/pull/257",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Change gen-signedexchange to try parsing all blocks in the key file as a\r\nprivate key. On OpenSSL 1.1.0h, the instructions at README.md result in\r\na key file that has two blocks, where the first is an EC PARAMETERS\r\nblock and the second is the EC PRIVATE KEY. This allows that file to be\r\nread.",
      "createdAt": "2018-07-16T22:48:29Z",
      "updatedAt": "2018-07-18T03:55:42Z",
      "closedAt": "2018-07-18T03:55:42Z",
      "mergedAt": "2018-07-18T03:55:42Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me know if you prefer this to be pulled inside ParsePrivateKey.",
          "createdAt": "2018-07-16T22:49:00Z",
          "updatedAt": "2018-07-16T22:49:00Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for catching this!",
          "createdAt": "2018-07-17T02:20:59Z",
          "updatedAt": "2018-07-17T02:20:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NjU3NDAx",
          "commit": {
            "abbreviatedOid": "2f1c37f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-17T02:19:21Z",
          "updatedAt": "2018-07-17T02:20:40Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "%s/parsedPrivKey/derKey/g",
              "createdAt": "2018-07-17T02:19:21Z",
              "updatedAt": "2018-07-17T17:11:47Z"
            },
            {
              "originalPosition": 20,
              "body": "`fmt.Errorf(\"Invalid PEM block in private key file %q.\", *flagPrivateKey)`",
              "createdAt": "2018-07-17T02:20:33Z",
              "updatedAt": "2018-07-17T17:11:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3OTMxMjE1",
          "commit": {
            "abbreviatedOid": "baf507f"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T17:15:19Z",
          "updatedAt": "2018-07-17T17:15:19Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Renamed to pemBlock, since it's not necessarily a key.",
              "createdAt": "2018-07-17T17:15:19Z",
              "updatedAt": "2018-07-17T17:15:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3OTMxMjU2",
          "commit": {
            "abbreviatedOid": "baf507f"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T17:15:24Z",
          "updatedAt": "2018-07-17T17:15:24Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done.",
              "createdAt": "2018-07-17T17:15:24Z",
              "updatedAt": "2018-07-17T17:15:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDkwOTc0",
          "commit": {
            "abbreviatedOid": "baf507f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-18T03:17:34Z",
          "updatedAt": "2018-07-18T03:17:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 258,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxODI5MDA0",
      "title": "signedexchange: Hide Encode/Decode3BytesBigEndianUint",
      "url": "https://github.com/WICG/webpackage/pull/258",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR hides some functions that are not needed to be exposed.",
      "createdAt": "2018-07-17T05:37:03Z",
      "updatedAt": "2018-07-23T16:49:20Z",
      "closedAt": "2018-07-18T03:55:29Z",
      "mergedAt": "2018-07-18T03:55:29Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about renaming the funcs to {En,De}code3BytesUint since bigendian is now the package name\r\n\r\nDone!",
          "createdAt": "2018-07-17T09:27:45Z",
          "updatedAt": "2018-07-17T09:27:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NzA2NzUw",
          "commit": {
            "abbreviatedOid": "479ad1b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "How about renaming the funcs to {En,De}code3BytesUint since `bigendian` is now the package name",
          "createdAt": "2018-07-17T07:38:49Z",
          "updatedAt": "2018-07-17T07:38:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyMTE4NjEy",
      "title": "gen-certurl: Read SCT files from directory specified with -sctDir",
      "url": "https://github.com/WICG/webpackage/pull/259",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of reading a serialized SignedCertificateTimestampList from a\r\nfile, read all `*.sct` files in a directory given by the `-sctDir` flag\r\nand serialize them into SignedCertificateTimestampList.\r\n\r\nThis matches the way how [nginx-ct](https://github.com/grahamedgecombe/nginx-ct) and Apache's [mod_ssl_ct](https://httpd.apache.org/docs/trunk/mod/mod_ssl_ct.html) module work,\r\nand allows users to use existing SCT generation tools.",
      "createdAt": "2018-07-18T01:58:28Z",
      "updatedAt": "2018-07-18T03:57:15Z",
      "closedAt": "2018-07-18T03:55:52Z",
      "mergedAt": "2018-07-18T03:55:52Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDgxMjg1",
          "commit": {
            "abbreviatedOid": "d41f9f7"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-18T02:03:00Z",
          "updatedAt": "2018-07-18T02:03:01Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I removed `-sct` here since SCT is not necessary for self-signed certs.\r\n\r\nI plan to add a separate section for instructions to create signed exchanges with trusted certificates, and will explain the usage of `-sctDir` there.",
              "createdAt": "2018-07-18T02:03:00Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDkxMDIy",
          "commit": {
            "abbreviatedOid": "d41f9f7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-18T03:17:55Z",
          "updatedAt": "2018-07-18T03:22:28Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "sgtm",
              "createdAt": "2018-07-18T03:17:55Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            },
            {
              "originalPosition": 26,
              "body": "Is this line necessary?",
              "createdAt": "2018-07-18T03:20:45Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            },
            {
              "originalPosition": 27,
              "body": "please catch err:\r\n```\r\nif err := binary.Write(...); err != nil {\r\n  panic(err) or return nil, err\r\n}\r\n```",
              "createdAt": "2018-07-18T03:21:56Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            },
            {
              "originalPosition": 29,
              "body": "ditto",
              "createdAt": "2018-07-18T03:22:04Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            },
            {
              "originalPosition": 30,
              "body": "ditto",
              "createdAt": "2018-07-18T03:22:11Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDk1MzM0",
          "commit": {
            "abbreviatedOid": "c0504a2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-18T03:52:40Z",
          "updatedAt": "2018-07-18T03:52:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDk1NDc0",
          "commit": {
            "abbreviatedOid": "c0504a2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-18T03:54:15Z",
          "updatedAt": "2018-07-18T03:54:15Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Removed.",
              "createdAt": "2018-07-18T03:54:15Z",
              "updatedAt": "2018-07-18T03:54:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDk1NDky",
          "commit": {
            "abbreviatedOid": "c0504a2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-18T03:54:24Z",
          "updatedAt": "2018-07-18T03:54:24Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Done (here and elsewhere).",
              "createdAt": "2018-07-18T03:54:24Z",
              "updatedAt": "2018-07-18T03:54:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 260,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyMTkwNjUz",
      "title": "gen-signedexchange: Add -draft2 suffix on MI and mi-sha256",
      "url": "https://github.com/WICG/webpackage/pull/260",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-18T09:28:21Z",
      "updatedAt": "2018-07-18T22:45:06Z",
      "closedAt": "2018-07-18T22:45:06Z",
      "mergedAt": "2018-07-18T22:45:06Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MTc0ODkz",
          "commit": {
            "abbreviatedOid": "19ed9ad"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-18T09:36:49Z",
          "updatedAt": "2018-07-18T09:36:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 261,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDA2Njc4",
      "title": "Increase the header size limit to 512kB.",
      "url": "https://github.com/WICG/webpackage/pull/261",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is twice Chromium's limit for the request or response headers,\r\nsince both are included in the signed exchange headers block.",
      "createdAt": "2018-07-18T23:25:43Z",
      "updatedAt": "2018-07-20T16:57:00Z",
      "closedAt": "2018-07-19T15:35:52Z",
      "mergedAt": "2018-07-19T15:35:52Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. This matches M69 now.",
          "createdAt": "2018-07-19T15:35:46Z",
          "updatedAt": "2018-07-19T15:35:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzMxMTU1",
          "commit": {
            "abbreviatedOid": "b3e7c9e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-19T15:35:34Z",
          "updatedAt": "2018-07-19T15:35:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 262,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDUwMDQ4",
      "title": "dump-signedexchange: dump signature header value too",
      "url": "https://github.com/WICG/webpackage/pull/262",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-19T05:39:57Z",
      "updatedAt": "2018-07-19T06:41:51Z",
      "closedAt": "2018-07-19T06:41:25Z",
      "mergedAt": "2018-07-19T06:41:24Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NTM4NjIz",
          "commit": {
            "abbreviatedOid": "5e7abe5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-19T06:39:07Z",
          "updatedAt": "2018-07-19T06:39:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 263,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDU4NzE3",
      "title": "signedexchange: Remove EncodeRequestWithHeaders",
      "url": "https://github.com/WICG/webpackage/pull/263",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "That function is not used anywhere.",
      "createdAt": "2018-07-19T06:39:30Z",
      "updatedAt": "2018-07-19T16:24:29Z",
      "closedAt": "2018-07-19T15:36:17Z",
      "mergedAt": "2018-07-19T15:36:17Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzMxNDQ0",
          "commit": {
            "abbreviatedOid": "d2d8386"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-19T15:36:11Z",
          "updatedAt": "2018-07-19T15:36:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 264,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDYzNzcx",
      "title": "signedexchange: Rename some functions",
      "url": "https://github.com/WICG/webpackage/pull/264",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Change the function to a method to follow the same way as net/http.Request.Write.",
      "createdAt": "2018-07-19T07:07:26Z",
      "updatedAt": "2018-07-21T04:11:45Z",
      "closedAt": "2018-07-21T04:11:42Z",
      "mergedAt": "2018-07-21T04:11:42Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzMyMTU3",
          "commit": {
            "abbreviatedOid": "8235052"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-19T15:37:39Z",
          "updatedAt": "2018-07-19T15:39:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@twifkak wdyt?\r\n\r\nPlease also rename `ReadExchangeFile` if we are going to proceed.",
              "createdAt": "2018-07-19T15:37:39Z",
              "updatedAt": "2018-07-20T05:49:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzUyMjIx",
          "commit": {
            "abbreviatedOid": "8235052"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-19T16:25:29Z",
          "updatedAt": "2018-07-19T16:25:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we can keep the reading function as it is\r\n\r\nhttps://golang.org/pkg/net/http/#ReadRequest",
              "createdAt": "2018-07-19T16:25:29Z",
              "updatedAt": "2018-07-20T05:49:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzUyNTM5",
          "commit": {
            "abbreviatedOid": "8235052"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-19T16:26:19Z",
          "updatedAt": "2018-07-19T16:26:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ah, `ReadExchangeFile` should be `ReadExchange`, right? I'll do this later.",
              "createdAt": "2018-07-19T16:26:19Z",
              "updatedAt": "2018-07-20T05:49:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzgyMDI3",
          "commit": {
            "abbreviatedOid": "8235052"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-19T17:46:51Z",
          "updatedAt": "2018-07-19T17:47:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "LGTM. I'm not well-acquainted with idiomatic Go style, so I'll defer to your judgment there. \r\n\r\nThanks for the heads up! ampproject/amppackager still depends on nyaxt/webpackage, so there's no breakage by this change, but I'll keep it in mind for when I fix that.",
              "createdAt": "2018-07-19T17:46:52Z",
              "updatedAt": "2018-07-20T05:49:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTM1MzAz",
          "commit": {
            "abbreviatedOid": "4a615ae"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-20T05:50:18Z",
          "updatedAt": "2018-07-20T05:50:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.\r\n\r\n> ampproject/amppackager still depends on nyaxt/webpackage, so there's no breakage by this change, but I'll keep it in mind for when I fix that.\r\n\r\nSure!",
              "createdAt": "2018-07-20T05:50:18Z",
              "updatedAt": "2018-07-20T05:50:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI3MDIz",
          "commit": {
            "abbreviatedOid": "4a615ae"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T22:22:38Z",
          "updatedAt": "2018-07-20T22:22:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 265,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDY4MjQ1",
      "title": "signedexchange: Unexport SigningAlgorithm",
      "url": "https://github.com/WICG/webpackage/pull/265",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-19T07:28:48Z",
      "updatedAt": "2018-07-19T16:27:06Z",
      "closedAt": "2018-07-19T16:27:03Z",
      "mergedAt": "2018-07-19T16:27:03Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzMxNzU4",
          "commit": {
            "abbreviatedOid": "8b5bb1a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-19T15:36:47Z",
          "updatedAt": "2018-07-19T15:36:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 266,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNzQ2ODE4",
      "title": "gen-certurl: Show warnings on possibly invalid input",
      "url": "https://github.com/WICG/webpackage/pull/266",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Prints warning message when:\r\n- OCSP data cannot be parsed as a DER-encoded OCSP response\r\n- Cert and OCSP do not have embedded SCT, and `-sctDir` is not specified\r\n\r\nDidn't make them error since these are OK if generated cert-chain is used for testing, with the `--ignore-certificate-errors-spki-list` Chromium flag.",
      "createdAt": "2018-07-20T04:58:15Z",
      "updatedAt": "2018-07-23T01:35:41Z",
      "closedAt": "2018-07-23T01:35:35Z",
      "mergedAt": "2018-07-23T01:35:35Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTMzNjU0",
          "commit": {
            "abbreviatedOid": "8d93efb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-20T05:41:18Z",
          "updatedAt": "2018-07-20T05:43:46Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "`HasEmbeddedSCT returns true ...`",
              "createdAt": "2018-07-20T05:41:18Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            },
            {
              "originalPosition": 40,
              "body": "For warnings, I think `fmt.Fprintf(os.Stderr)` should be fine.\r\n\r\nExample usage in Go command: https://golang.org/src/cmd/go/main.go",
              "createdAt": "2018-07-20T05:43:37Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTM2Njg0",
          "commit": {
            "abbreviatedOid": "0c06eb9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-20T06:00:20Z",
          "updatedAt": "2018-07-20T06:00:20Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done",
              "createdAt": "2018-07-20T06:00:20Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTM2Njk5",
          "commit": {
            "abbreviatedOid": "0c06eb9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-20T06:00:23Z",
          "updatedAt": "2018-07-20T06:00:23Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Done",
              "createdAt": "2018-07-20T06:00:23Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTM3NTY1",
          "commit": {
            "abbreviatedOid": "0c06eb9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-20T06:05:52Z",
          "updatedAt": "2018-07-20T06:05:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI2NjEx",
          "commit": {
            "abbreviatedOid": "0c06eb9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm % comments",
          "createdAt": "2018-07-20T22:20:08Z",
          "updatedAt": "2018-07-20T22:21:18Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Nit: use camelCase `ocspDer` https://golang.org/doc/effective_go.html#mixed-caps",
              "createdAt": "2018-07-20T22:20:08Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            },
            {
              "originalPosition": 28,
              "body": "ditto `parsedOcsp`",
              "createdAt": "2018-07-20T22:20:31Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MzEyMjkx",
          "commit": {
            "abbreviatedOid": "44cd3cb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-23T01:34:42Z",
          "updatedAt": "2018-07-23T01:34:42Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "done",
              "createdAt": "2018-07-23T01:34:42Z",
              "updatedAt": "2018-07-23T01:34:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MzEyMjk4",
          "commit": {
            "abbreviatedOid": "44cd3cb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-23T01:34:45Z",
          "updatedAt": "2018-07-23T01:34:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "done",
              "createdAt": "2018-07-23T01:34:45Z",
              "updatedAt": "2018-07-23T01:34:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 267,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNzk0Nzcz",
      "title": "Add instructions to create a signed exchange with a trusted certificate",
      "url": "https://github.com/WICG/webpackage/pull/267",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-20T09:31:09Z",
      "updatedAt": "2018-07-23T01:40:44Z",
      "closedAt": "2018-07-23T01:40:41Z",
      "mergedAt": "2018-07-23T01:40:41Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MTM2MDYx",
          "commit": {
            "abbreviatedOid": "2ecb963"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T17:00:15Z",
          "updatedAt": "2018-07-20T17:00:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI1NDY3",
          "commit": {
            "abbreviatedOid": "2ecb963"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T22:13:24Z",
          "updatedAt": "2018-07-20T22:13:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 269,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyOTY2MzQw",
      "title": "Fix the magic number of a signed-exchange example in -impl.",
      "url": "https://github.com/WICG/webpackage/pull/269",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-20T22:03:48Z",
      "updatedAt": "2018-07-20T22:12:07Z",
      "closedAt": "2018-07-20T22:11:45Z",
      "mergedAt": "2018-07-20T22:11:45Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI0MTMw",
          "commit": {
            "abbreviatedOid": "298e0ce"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T22:05:59Z",
          "updatedAt": "2018-07-20T22:05:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI0ODQy",
          "commit": {
            "abbreviatedOid": "295cd22"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T22:09:58Z",
          "updatedAt": "2018-07-20T22:09:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 271,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAzOTQ0OTYw",
      "title": "Always embed manifest in the bundle",
      "url": "https://github.com/WICG/webpackage/pull/271",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #270\r\n\r\nAfter giving more thought, I couldn't think of a use-case where we want to refer to a external manifest.\r\n\r\nOn the other hand, I also want to make the manifest URL optional, for use-cases where a bundle contains a part of a page resources (for example, common assets across multiple webpages, a ES module tree, etc.)",
      "createdAt": "2018-07-25T19:53:04Z",
      "updatedAt": "2018-07-27T04:06:59Z",
      "closedAt": "2018-07-27T04:06:59Z",
      "mergedAt": "2018-07-27T04:06:59Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I made the manifest mandatory so that a start_url would be available for when someone navigated to a bundle. Once we move the fallback URL out of the manifest, it serves that purpose, and I think it makes sense to make the manifest optional.",
          "createdAt": "2018-07-25T20:11:04Z",
          "updatedAt": "2018-07-25T20:11:04Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> Once we move the fallback URL out of the manifest, it serves that purpose, and I think it makes sense to make the manifest optional.\r\n\r\nSGTM\r\n",
          "createdAt": "2018-07-25T21:01:45Z",
          "updatedAt": "2018-07-25T21:01:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQwNDc5NTAz",
          "commit": {
            "abbreviatedOid": "6c7c6f8"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-25T20:09:48Z",
          "updatedAt": "2018-07-25T20:09:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"MUST\" should be capitalized per https://tools.ietf.org/html/rfc8174.",
              "createdAt": "2018-07-25T20:09:48Z",
              "updatedAt": "2018-07-25T21:01:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQwNDk3OTY5",
          "commit": {
            "abbreviatedOid": "83108eb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-25T21:00:18Z",
          "updatedAt": "2018-07-25T21:00:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2018-07-25T21:00:18Z",
              "updatedAt": "2018-07-25T21:01:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 272,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0MDI4MDQy",
      "title": "Update the extensions of default output file",
      "url": "https://github.com/WICG/webpackage/pull/272",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Use `.sxg` and `.wbn` instead of `.htxg` and `.webbundle`.",
      "createdAt": "2018-07-26T04:53:10Z",
      "updatedAt": "2018-07-26T07:17:53Z",
      "closedAt": "2018-07-26T07:17:53Z",
      "mergedAt": "2018-07-26T07:17:53Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQwNjAyNDQy",
          "commit": {
            "abbreviatedOid": "25bc56c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-26T07:12:15Z",
          "updatedAt": "2018-07-26T07:12:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 273,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0MzM2NzI5",
      "title": "gen-bundle: Add options to create a bundle from local directory",
      "url": "https://github.com/WICG/webpackage/pull/273",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@nyaxt Do you think this is worth merging?",
      "createdAt": "2018-07-27T05:59:44Z",
      "updatedAt": "2018-07-31T09:30:59Z",
      "closedAt": "2018-07-31T09:30:56Z",
      "mergedAt": "2018-07-31T09:30:56Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is definitely worth merging, while need polishing up. @hajimehoshi PTAL",
          "createdAt": "2018-07-27T06:26:14Z",
          "updatedAt": "2018-07-27T06:26:38Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "All comments addressed. PTAL",
          "createdAt": "2018-07-31T05:31:00Z",
          "updatedAt": "2018-07-31T05:31:00Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review!",
          "createdAt": "2018-07-31T09:30:36Z",
          "updatedAt": "2018-07-31T09:30:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQwOTk1NTM2",
          "commit": {
            "abbreviatedOid": "62bc9ea"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-27T06:16:22Z",
          "updatedAt": "2018-07-27T06:25:41Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "b.Exchanges[0], b.Exchanges[i] = b.Exchanges[i], b.Exchanges[0]",
              "createdAt": "2018-07-27T06:16:22Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 53,
              "body": "Maybe https://golang.org/pkg/path/filepath/#Glob ?",
              "createdAt": "2018-07-27T06:22:54Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 113,
              "body": "oh wow. Please add a comment about this trick of using ResponseWriter->ServeFile to generate realistic response",
              "createdAt": "2018-07-27T06:24:19Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 31,
              "body": "Should we warn if *flagBaseUrl, *flagStartUrl is specified?",
              "createdAt": "2018-07-27T06:25:33Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxMDE5OTEw",
          "commit": {
            "abbreviatedOid": "62bc9ea"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-27T08:09:47Z",
          "updatedAt": "2018-07-27T08:11:27Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "or https://golang.org/pkg/path/filepath/#Walk :-)",
              "createdAt": "2018-07-27T08:09:47Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxMzE5Nzg1",
          "commit": {
            "abbreviatedOid": "62bc9ea"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-28T15:29:20Z",
          "updatedAt": "2018-07-28T16:22:11Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "For Go convention, `b` should be the first argument, which represents an output.",
              "createdAt": "2018-07-28T15:29:20Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 106,
              "body": "ditto.",
              "createdAt": "2018-07-28T16:21:48Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA0NDYy",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:28:18Z",
          "updatedAt": "2018-07-31T05:28:18Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Done.",
              "createdAt": "2018-07-31T05:28:18Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA0NTEy",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:28:38Z",
          "updatedAt": "2018-07-31T05:28:38Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Done.",
              "createdAt": "2018-07-31T05:28:38Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA0NTIz",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:28:42Z",
          "updatedAt": "2018-07-31T05:28:42Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Done.",
              "createdAt": "2018-07-31T05:28:42Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA0ODQ3",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:30:40Z",
          "updatedAt": "2018-07-31T05:30:41Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Now it returns exchanges as a return value.",
              "createdAt": "2018-07-31T05:30:40Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA1NTky",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:35:39Z",
          "updatedAt": "2018-07-31T05:37:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "`flagBaseURL` for Go convention https://stackoverflow.com/questions/38616687/which-way-to-name-a-function-in-go-camelcase-or-semi-camelcase",
              "createdAt": "2018-07-31T05:35:39Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 6,
              "body": "ditto",
              "createdAt": "2018-07-31T05:35:45Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODExMTIy",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-31T06:10:30Z",
          "updatedAt": "2018-07-31T06:10:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODQ3MTcz",
          "commit": {
            "abbreviatedOid": "de6ef10"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T08:24:41Z",
          "updatedAt": "2018-07-31T08:24:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "done",
              "createdAt": "2018-07-31T08:24:41Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODQ3MjQ5",
          "commit": {
            "abbreviatedOid": "de6ef10"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T08:24:53Z",
          "updatedAt": "2018-07-31T08:24:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "done",
              "createdAt": "2018-07-31T08:24:53Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODU0NDA5",
          "commit": {
            "abbreviatedOid": "de6ef10"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-31T08:45:15Z",
          "updatedAt": "2018-07-31T08:45:27Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "nit: The comment should start with `responseWriter` for Go convention.",
              "createdAt": "2018-07-31T08:45:16Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 274,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0NDk3NDI1",
      "title": "Fix typo in README",
      "url": "https://github.com/WICG/webpackage/pull/274",
      "state": "CLOSED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-27T17:47:57Z",
      "updatedAt": "2018-07-27T17:50:16Z",
      "closedAt": "2018-07-27T17:50:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 275,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0NDk4MDI2",
      "title": "Fix typo in README",
      "url": "https://github.com/WICG/webpackage/pull/275",
      "state": "MERGED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #268",
      "createdAt": "2018-07-27T17:50:33Z",
      "updatedAt": "2018-07-29T00:26:59Z",
      "closedAt": "2018-07-28T02:51:22Z",
      "mergedAt": "2018-07-28T02:51:22Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you!",
          "createdAt": "2018-07-28T02:51:29Z",
          "updatedAt": "2018-07-28T02:51:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxMzA1MjIy",
          "commit": {
            "abbreviatedOid": "4bbf449"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-28T02:51:17Z",
          "updatedAt": "2018-07-28T02:51:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 277,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0NzA5Mjc5",
      "title": "gen-signedexchange: Add flag to optionally dump signature message for\u2026",
      "url": "https://github.com/WICG/webpackage/pull/277",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 debugging",
      "createdAt": "2018-07-30T06:50:29Z",
      "updatedAt": "2018-08-03T01:46:59Z",
      "closedAt": "2018-08-03T01:46:59Z",
      "mergedAt": "2018-08-03T01:46:59Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDE3MTQx",
          "commit": {
            "abbreviatedOid": "d762b86"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-30T07:29:41Z",
          "updatedAt": "2018-07-30T07:30:01Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "`os.Create`?",
              "createdAt": "2018-07-30T07:29:41Z",
              "updatedAt": "2018-08-01T08:20:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQyMjUyNzAw",
          "commit": {
            "abbreviatedOid": "d762b86"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-01T07:18:09Z",
          "updatedAt": "2018-08-01T07:18:09Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Done",
              "createdAt": "2018-08-01T07:18:09Z",
              "updatedAt": "2018-08-01T08:20:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQyMjUzNjc1",
          "commit": {
            "abbreviatedOid": "8d625cc"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with nits",
          "createdAt": "2018-08-01T07:21:26Z",
          "updatedAt": "2018-08-01T07:22:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "`w` should be first for convention: as far as I know there is no explicit rule, but for standard libs, output streams tend to be the first argument.",
              "createdAt": "2018-08-01T07:21:26Z",
              "updatedAt": "2018-08-01T08:20:41Z"
            },
            {
              "originalPosition": 41,
              "body": "BTW, I think this code is not reachable?",
              "createdAt": "2018-08-01T07:22:01Z",
              "updatedAt": "2018-08-01T08:20:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQyMjk0OTQ5",
          "commit": {
            "abbreviatedOid": "2138780"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-01T09:28:24Z",
          "updatedAt": "2018-08-01T09:28:24Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I realized that this should be `flagCertificateUrl` and `flagValidityURL` for Go convention. Let's address on this later.",
              "createdAt": "2018-08-01T09:28:24Z",
              "updatedAt": "2018-08-01T09:28:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 278,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0NzI3NDEw",
      "title": "gen-bundle: Drop pseudo headers in HAR",
      "url": "https://github.com/WICG/webpackage/pull/278",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Chromium generates HAR that includes HTTP/2 pseudo headers in the\r\n`request.headers` field. Drop them so that they don't conflict with\r\nBundled Exchanges' pseudo headers.",
      "createdAt": "2018-07-30T08:19:17Z",
      "updatedAt": "2018-07-30T11:32:01Z",
      "closedAt": "2018-07-30T11:32:01Z",
      "mergedAt": "2018-07-30T11:32:01Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDU2MTY4",
          "commit": {
            "abbreviatedOid": "ee2cde6"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-30T09:32:40Z",
          "updatedAt": "2018-07-30T09:32:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "if strings.HasPrefix(nvp.Name, \":\")",
              "createdAt": "2018-07-30T09:32:40Z",
              "updatedAt": "2018-07-30T10:01:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDY2MzU5",
          "commit": {
            "abbreviatedOid": "b698b1e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-30T10:02:23Z",
          "updatedAt": "2018-07-30T10:02:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2018-07-30T10:02:23Z",
              "updatedAt": "2018-07-30T10:02:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDc3NDg5",
          "commit": {
            "abbreviatedOid": "b698b1e"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-30T10:39:16Z",
          "updatedAt": "2018-07-30T10:39:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDkyNzEw",
          "commit": {
            "abbreviatedOid": "b698b1e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-30T11:31:33Z",
          "updatedAt": "2018-07-30T11:31:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 279,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0OTg2OTAz",
      "title": "Move headers out of the CBOR map when constructing signed message bytes.",
      "url": "https://github.com/WICG/webpackage/pull/279",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To address #276 ",
      "createdAt": "2018-07-31T03:34:39Z",
      "updatedAt": "2018-08-20T01:38:16Z",
      "closedAt": "2018-08-20T01:38:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'd like to get @davidben's thoughts on any rework we do here, with reference to the [draft loading spec](http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#signed-message) that specifies how to check this.\r\n\r\nHe's out until mid-next-week, at which point I might be on leave, but if he's happy with a change while I'm out, go ahead and make it.",
          "createdAt": "2018-07-31T03:45:01Z",
          "updatedAt": "2018-07-31T03:45:01Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have a strong preference on how we should fix this.\r\n@davidben Please also take a look at options being discussed at https://github.com/WICG/webpackage/issues/276 . We are happy to hear other serialization method ideas too.",
          "createdAt": "2018-07-31T03:47:49Z",
          "updatedAt": "2018-07-31T03:47:49Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "We will go forward with #287 instead.",
          "createdAt": "2018-08-20T01:38:16Z",
          "updatedAt": "2018-08-20T01:38:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 280,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA1MzAyMDg2",
      "title": "Update go/bundle/README.md",
      "url": "https://github.com/WICG/webpackage/pull/280",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-01T03:54:12Z",
      "updatedAt": "2018-08-01T06:55:21Z",
      "closedAt": "2018-08-01T06:55:17Z",
      "mergedAt": "2018-08-01T06:55:17Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Added a note about the current behavior of `-startURL`.",
          "createdAt": "2018-08-01T06:22:26Z",
          "updatedAt": "2018-08-01T06:22:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQyMjQ0NjU3",
          "commit": {
            "abbreviatedOid": "0616f5c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-01T06:43:14Z",
          "updatedAt": "2018-08-01T06:43:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 281,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2NTIxMjA3",
      "title": "Integrate b1 signed exchanges with Fetch",
      "url": "https://github.com/WICG/webpackage/pull/281",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/loading-spec/loading.html)",
      "createdAt": "2018-08-06T21:26:25Z",
      "updatedAt": "2018-08-20T21:42:03Z",
      "closedAt": "2018-08-20T07:09:32Z",
      "mergedAt": "2018-08-20T07:09:32Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Hooking into [HTTP fetch](https://jyasskin.github.io/webpackage/loading-spec/loading.html#mp-http-fetch) gives me an easy way to inject a redirect, but it means that signed exchanges loaded from the filesystem, from blobs, etc. don't work. In the long run, I think we'll want them to work, so we'll want to either move the attachment point up to [main fetch](https://fetch.spec.whatwg.org/#concept-main-fetch), or manually go through some of the redirect steps in the other branches of [scheme fetch](https://fetch.spec.whatwg.org/#concept-scheme-fetch).\r\n\r\nI still think this PR is the right place to start: it'll be easier to see what that extension changes with this as a baseline.",
          "createdAt": "2018-08-13T22:26:23Z",
          "updatedAt": "2018-08-13T22:26:23Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that other @jyasskin PRs build on top of this PR, I'd like to proceed with this and then revise the bits later. @kinu Are you cool with this?",
          "createdAt": "2018-08-20T01:48:45Z",
          "updatedAt": "2018-08-20T01:48:45Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, let's merge it and consider separate PRs if we find any modifications are needed.",
          "createdAt": "2018-08-20T06:36:30Z",
          "updatedAt": "2018-08-20T06:36:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzNzkxMTY1",
          "commit": {
            "abbreviatedOid": "2cdb79d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-06T23:11:49Z",
          "updatedAt": "2018-08-06T23:51:50Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "@kinu Have y'all looked into the Service Worker side? I believe Fetch's https://fetch.spec.whatwg.org/#concept-http-fetch step 4.2\r\n\r\n> If request\u2019s redirect mode is \"follow\", then set request\u2019s service-workers mode to \"none\".\r\n\r\nprevents all redirects from hitting a service worker, so even if distributor.example.org just served a 302 to publisher.example.org, publisher.example.org's SW wouldn't get to handle the navigation. Am I misreading anything?",
              "createdAt": "2018-08-06T23:11:49Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 585,
              "body": "@sleevi @davidben The fact that the [certificate](http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#augmented-certificate-certificate) is stored un-parsed means that the spec winds up saying to parse out a public key twice, which feels like a security risk. How much can systems actually parse these structures ahead of time, vs when they're validating origin-trust?",
              "createdAt": "2018-08-06T23:19:17Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 242,
              "body": "Right now, I'm ignoring all of the [cache modes](https://fetch.spec.whatwg.org/#concept-request-cache-mode) in deciding to accept a signed exchange's content. They may be useful in controlling how to fetch the `.sxg` itself, and applying them to the content would probably just have the effect of forcing that to the network, which would defeat the point.\r\n\r\nDoes that sound right to y'all, or do you see any of the modes I should apply here?",
              "createdAt": "2018-08-06T23:23:07Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 610,
              "body": "I check the length of the validity window in cross-origin trust rather than while parsing the signature so that other uses of signatures can define their own maximum validities. e.g. maybe the Play store wants to sign that it's audited an app and have that be valid for more than a week.",
              "createdAt": "2018-08-06T23:43:57Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 640,
              "body": "@sleevi Is this a reasonable way to phrase the requirement?",
              "createdAt": "2018-08-06T23:45:10Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 766,
              "body": "@domenic This [whole section](http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#stream-algs) could migrate to either Fetch or Streams if you think it'll be useful to other specs.",
              "createdAt": "2018-08-06T23:49:38Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 542,
              "body": "@davidben How do you feel about this message algorithm? I think we can simplify it for b2, since I only made it this complicated to avoid confusion between multiple versions of the message, and that's now handled by the `HTTP Exchange 1 b1` context string, but it'll inform whether we can go to Origin Trial with b1 or have to go to b2 first.",
              "createdAt": "2018-08-06T23:51:30Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODM3NzY1",
          "commit": {
            "abbreviatedOid": "c3fab22"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T04:37:00Z",
          "updatedAt": "2018-08-07T04:37:01Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "For navigation the default redirect mode is \"manual\", therefore every time a request's redirected corresponding SW has a chance to see it.",
              "createdAt": "2018-08-07T04:37:00Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODM4ODc1",
          "commit": {
            "abbreviatedOid": "c3fab22"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T04:46:51Z",
          "updatedAt": "2018-08-07T04:46:51Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "This means that whenever UA loads things from a Signed Exchange UA also needs to check HTTP cache. Can you clarify what situation we are trying to deal with by this? If we don't cache the stashed exchange it feels it's just fine, or a site should probably set a short expiration date?",
              "createdAt": "2018-08-07T04:46:51Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTA0NDUz",
          "commit": {
            "abbreviatedOid": "c3fab22"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T17:32:47Z",
          "updatedAt": "2018-08-07T17:42:00Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Aha! Thanks! \r\n\r\nI think both @cramforce's idea to use the `preloadResponse` and asking people to call `fetch()` with cache==\"only-if-cached\" will work, but to use \"only-if-cached\" we'll have to tell people to modify the original request or its clone, instead of creating a new request with the same URL. A new request with the same URL won't have the stashed exchange attached, and wiring those up will require an extra global map in the SW itself, which could also get confused by interleaved requests to different signed exchanges holding the same publication URL.",
              "createdAt": "2018-08-07T17:32:47Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 141,
              "body": "Imagine that Vashti visits https://app.com/ regularly, and app.com also publishes a signed exchange valid for a week to allow offline distribution. Now app.com discovers a vulnerability and patches it, but the vulnerable signed exchange is still out there.\r\n\r\nIf Vashti visits the site after the update and gets the new version into her cache, even stale, then even if an attacker manages to serve her the vulnerable signed exchange, she won't use it.\r\n\r\nThis isn't an absolute defense against anything, but it lowers the probability of a successful attack on frequent users of a site.",
              "createdAt": "2018-08-07T17:41:25Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTI5OTcy",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:36:12Z",
          "updatedAt": "2018-08-07T18:36:12Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "@davidben @sleevi How many hives does this bit give you?",
              "createdAt": "2018-08-07T18:36:12Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTMyNTk2",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:42:54Z",
          "updatedAt": "2018-08-07T18:42:54Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "I'm not going to have bandwidth to review this this week, in part because I need to go get treated for hives. It quite concerns me, and I can tell it's going to take time and focus that I don't yet have to adequately review :/",
              "createdAt": "2018-08-07T18:42:54Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTMzMjM4",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:44:27Z",
          "updatedAt": "2018-08-07T18:44:27Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "Can you explain why it feels like a security risk? I'm not sure I fully understand the question. Extracting an SPKI from a certificate is something easy on virtually all systems - the question is whether or not it's \"trusted\" data yet.",
              "createdAt": "2018-08-07T18:44:27Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTM0NjQz",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:47:46Z",
          "updatedAt": "2018-08-07T18:47:47Z",
          "comments": [
            {
              "originalPosition": 640,
              "body": "No. There's no such thing as \"trusted logs\", and this also isn't how clients evaluate whether a certificate complies with a given CT policy.\r\n\r\nI think much of this algorithm can be replaced by waving into the blackbox and saying that the OCSP response, the SCTs, and the certificates are inputs, for the host, and determine the response. I suspect you may want an added requirement on the OCSP responses freshness, or that the validating client MUST support Certificate Transparency (or is it optional for UAs that don't support CT but still support SXG?)",
              "createdAt": "2018-08-07T18:47:47Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTM0MTg0",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:46:53Z",
          "updatedAt": "2018-08-07T19:24:16Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "I've been conditioned that any time we parse something twice, security bugs appear in the differences between the two parsers. However, if you're comfortable with this case (e.g. that nobody will actually write separate parsers), I'm also happy with it.",
              "createdAt": "2018-08-07T18:46:53Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 640,
              "body": "So put this all in the \"Attempt to build a trustworthy path\" step? Sounds good; how's this [new wording](http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#trusting-certificate)?\r\n\r\nI don't think CT should be optional for signed exchanges even for UAs that don't use it for TLS connections. Knowing that a certificate was mis-issued has been an important part of our security analysis.",
              "createdAt": "2018-08-07T18:50:47Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 585,
              "body": "SG. I've added a pointer to #141 so that anyone implementing this knows to check with security folks.",
              "createdAt": "2018-08-07T19:22:18Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTY1NzMz",
          "commit": {
            "abbreviatedOid": "4fc7650"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T20:14:13Z",
          "updatedAt": "2018-08-07T20:14:13Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "I presume they're going to be using the same parser - is there reason to believe they may be different?",
              "createdAt": "2018-08-07T20:14:13Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTY2Mzgw",
          "commit": {
            "abbreviatedOid": "4fc7650"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T20:16:03Z",
          "updatedAt": "2018-08-07T20:16:03Z",
          "comments": [
            {
              "originalPosition": 640,
              "body": "You realize this means that only Chrome will implement SXGs for the foreseeable future? Coupling to CT in this way is going to either explicitly preclude certain UAs, or encourage them to adopt patterns that they've been reticent to do for TLS, precisely because they know it will harm the CT ecosystem. We should sync up on that. I realize the intersection between CT relates to SXG, but I think we need to be careful about MUSTing certain policy bits, compared to highlighting the tradeoffs.",
              "createdAt": "2018-08-07T20:16:03Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0NjE1NjMx",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-08T21:26:22Z",
          "updatedAt": "2018-08-08T21:26:22Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "No particular reason.",
              "createdAt": "2018-08-08T21:26:22Z",
              "updatedAt": "2018-08-08T21:26:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0NjE1NzM2",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-08T21:26:40Z",
          "updatedAt": "2018-08-08T21:26:41Z",
          "comments": [
            {
              "originalPosition": 640,
              "body": "This is now a SHOULD with a link to a new Security Considerations section.",
              "createdAt": "2018-08-08T21:26:41Z",
              "updatedAt": "2018-08-08T21:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NDgyNTkw",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-20T01:48:54Z",
          "updatedAt": "2018-08-20T01:48:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTA5MDA0",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T06:02:28Z",
          "updatedAt": "2018-08-20T06:02:28Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Chrome's current impl is not following this, which is the biggest concern, but that part probably needs a separate discussion anyways to proceed. (I'll file an impl bug and take a closer look if this needs to block our further milestones)",
              "createdAt": "2018-08-20T06:02:28Z",
              "updatedAt": "2018-08-20T06:02:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTEyNjk1",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T06:25:37Z",
          "updatedAt": "2018-08-20T06:25:37Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "This sg to me.",
              "createdAt": "2018-08-20T06:25:37Z",
              "updatedAt": "2018-08-20T06:25:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTE1MTYy",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-20T06:38:25Z",
          "updatedAt": "2018-08-20T06:38:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NjE5ODgw",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "rwlbuis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T12:25:52Z",
          "updatedAt": "2018-08-20T12:25:52Z",
          "comments": [
            {
              "originalPosition": 787,
              "body": "Note that the way this is rendered in Safari looks a bit weird, I only see step 1. and 3. with a big ISSUE section in between. But I guess once Step 2 has been fleshed out, it will look ok.",
              "createdAt": "2018-08-20T12:25:52Z",
              "updatedAt": "2018-08-20T12:25:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2NTYxODU0",
      "title": "gen-bundle: Add checks to prevent creating invalid bundles",
      "url": "https://github.com/WICG/webpackage/pull/282",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Drop the HAR entry if:\r\n- Request method is not GET.\r\n- Status code is not valid. Chromium puts status code 0 if the request\r\n  failed with a network error.",
      "createdAt": "2018-08-07T02:16:11Z",
      "updatedAt": "2018-08-07T07:07:17Z",
      "closedAt": "2018-08-07T07:06:46Z",
      "mergedAt": "2018-08-07T07:06:46Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODMzMTA5",
          "commit": {
            "abbreviatedOid": "e5bc177"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-07T03:58:02Z",
          "updatedAt": "2018-08-07T03:58:08Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'm not sure on this change. Would you provide more context?",
              "createdAt": "2018-08-07T03:58:02Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODMzMjAy",
          "commit": {
            "abbreviatedOid": "e5bc177"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T03:58:42Z",
          "updatedAt": "2018-08-07T03:58:42Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Ah, how about simple check `Status != 0`?",
              "createdAt": "2018-08-07T03:58:42Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODMzMjQ4",
          "commit": {
            "abbreviatedOid": "e5bc177"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T03:59:04Z",
          "updatedAt": "2018-08-07T03:59:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "or >=100 <=999",
              "createdAt": "2018-08-07T03:59:05Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODQyMTcx",
          "commit": {
            "abbreviatedOid": "5d69637"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T05:13:04Z",
          "updatedAt": "2018-08-07T05:13:04Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Changed to check that status code is within [100, 999].",
              "createdAt": "2018-08-07T05:13:04Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODU4MTU2",
          "commit": {
            "abbreviatedOid": "5d69637"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T06:42:38Z",
          "updatedAt": "2018-08-07T06:42:38Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "optional: `http.MethodGet`",
              "createdAt": "2018-08-07T06:42:38Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODU4ODI0",
          "commit": {
            "abbreviatedOid": "5d69637"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-07T06:45:34Z",
          "updatedAt": "2018-08-07T06:45:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODYxNDIz",
          "commit": {
            "abbreviatedOid": "adbbb0b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T06:56:22Z",
          "updatedAt": "2018-08-07T06:56:23Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2018-08-07T06:56:23Z",
              "updatedAt": "2018-08-07T06:56:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 283,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2ODk1MDcy",
      "title": "README.md: Link to go/signedexchange",
      "url": "https://github.com/WICG/webpackage/pull/283",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now go/signedexchange/README.md would be more useful than Chromium's README.",
      "createdAt": "2018-08-08T05:18:50Z",
      "updatedAt": "2018-11-07T08:00:50Z",
      "closedAt": "2018-08-08T07:29:25Z",
      "mergedAt": "2018-08-08T07:29:25Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0Mjk2NzY0",
          "commit": {
            "abbreviatedOid": "cd9347a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-08T07:29:16Z",
          "updatedAt": "2018-08-08T07:29:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 284,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA3MTQwMTMy",
      "title": "Update the README and explainer to match the new loading spec.",
      "url": "https://github.com/WICG/webpackage/pull/284",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We should merge this after #281.",
      "createdAt": "2018-08-08T21:16:30Z",
      "updatedAt": "2018-08-20T21:41:30Z",
      "closedAt": "2018-08-20T07:10:10Z",
      "mergedAt": "2018-08-20T07:10:10Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "There will be things to be considered further, but this one lgtm/2. Thanks!",
          "createdAt": "2018-08-14T09:50:36Z",
          "updatedAt": "2018-08-14T09:50:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0NjY5MDYy",
          "commit": {
            "abbreviatedOid": "cf01a90"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@kinu Would you review this?",
          "createdAt": "2018-08-09T01:59:27Z",
          "updatedAt": "2018-08-09T02:00:19Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "should we clarify `sufficiently similar`?\r\n```\r\nThe inner request doesn't [match](https://wicg.github.io/webpackage/loading.html#request-matching) the Request the Service Worker sent.\r\n```",
              "createdAt": "2018-08-09T01:59:28Z",
              "updatedAt": "2018-08-13T18:37:54Z"
            },
            {
              "originalPosition": 69,
              "body": "Should we expand SW -> Service Worker?",
              "createdAt": "2018-08-09T01:59:44Z",
              "updatedAt": "2018-08-13T18:37:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ1NzgyMDUz",
          "commit": {
            "abbreviatedOid": "cf01a90"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-13T18:36:10Z",
          "updatedAt": "2018-08-13T18:38:02Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Sure.",
              "createdAt": "2018-08-13T18:36:11Z",
              "updatedAt": "2018-08-13T18:38:02Z"
            },
            {
              "originalPosition": 69,
              "body": "Sure.",
              "createdAt": "2018-08-13T18:36:14Z",
              "updatedAt": "2018-08-13T18:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ1OTA4NDgx",
          "commit": {
            "abbreviatedOid": "4a99757"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-14T03:49:44Z",
          "updatedAt": "2018-08-14T03:49:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 285,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA3MTU0Mzgw",
      "title": "Define request matching in terms of draft-ietf-httpbis-variants.",
      "url": "https://github.com/WICG/webpackage/pull/285",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See https://docs.google.com/document/d/1JdJkdY7cK2rD9JXbK75sSn069c0rhF9UnLQACBZ1OtY/edit for more analysis and options, but building on @mnot's Variants seems like a good plan here.\n\nIf we go this way, it probably makes sense to move away from storing arbitrary request headers in both signed exchanges and bundles, and toward storing something like the [Variants + Variant-Key headers](https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#variants) directly.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/285.html\" title=\"Last updated on Dec 7, 2018, 11:35 PM GMT (d1d5c8c)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/285/f603e91...jyasskin:d1d5c8c.html\" title=\"Last updated on Dec 7, 2018, 11:35 PM GMT (d1d5c8c)\">Diff</a>",
      "createdAt": "2018-08-08T22:22:19Z",
      "updatedAt": "2018-12-08T00:01:28Z",
      "closedAt": "2018-12-08T00:01:24Z",
      "mergedAt": "2018-12-08T00:01:24Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4NTMzODA4",
          "commit": {
            "abbreviatedOid": "e585628"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Per your PR-level comment: The Variants header specifies the list of all available variants, not which one this is. That would be the Variant-Key. AFAICT, there is no specified automated way for generating a Variant-Key from existing request headers (i.e. an algorithm to reproduce existing RFC723? behavior). It should be easy to construct one of those, but it seems like a good idea to standardize one. Otherwise, it makes it harder for publishers to generate SXGs. ",
          "createdAt": "2018-11-26T22:33:50Z",
          "updatedAt": "2018-11-26T22:53:52Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Maybe reword as e.g. [=header field specified to be content-negotiable with Variants=].",
              "createdAt": "2018-11-26T22:33:50Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 46,
              "body": "Also, it seems a bit up in the air as to where the UA implementor should look for specifications of Variant content negotiation mechanisms. Appendix A is one place, but presumably new or experimental HTTP headers will define them as part of their own spec? Or maybe it's OK to leave this a bit up in the air for now?",
              "createdAt": "2018-11-26T22:37:31Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 50,
              "body": "I think this is wrong, but I may be misreading this. e.g. If the cached response is `Accept-Language: foo` and the browser doesn't specify an `Accept-Language`, this would match, per the [specified content-negotiation mechanism](https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#content-language).",
              "createdAt": "2018-11-26T22:41:15Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 53,
              "body": "Ditto.",
              "createdAt": "2018-11-26T22:42:56Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNDczMzUy",
          "commit": {
            "abbreviatedOid": "8d60b58"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T22:23:12Z",
          "updatedAt": "2018-12-01T01:04:38Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "https://github.com/httpwg/http-extensions/issues/681 suggests a wiki page but doesn't actually create one.",
              "createdAt": "2018-11-30T22:23:12Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 45,
              "body": "How's \"the request header field of a content negotiation mechanism specified to be usable with Variants\"? https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#define talks about the content negotiation mechanism as the primary thing, with the request header being a piece of it.",
              "createdAt": "2018-12-01T00:50:42Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 50,
              "body": "It was out of date, now that Fetch has removed \"combined value\".\r\n\r\nVariants doesn't seem to handle the case where a request header is just missing: https://github.com/httpwg/http-extensions/issues/731.",
              "createdAt": "2018-12-01T01:02:58Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgxMDYzMTYz",
          "commit": {
            "abbreviatedOid": "df60799"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-04T01:55:42Z",
          "updatedAt": "2018-12-04T01:55:43Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yeah, works for me.",
              "createdAt": "2018-12-04T01:55:42Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgxMDY0MDk0",
          "commit": {
            "abbreviatedOid": "df60799"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-04T02:00:34Z",
          "updatedAt": "2018-12-04T02:10:53Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Ah, okay, sounds good. I guess the effect of this is that SXG generators should choose the \"greatest common subset\" of variable headers that are supported by the UAs they're targeting. As long as UAs tend to add support for headers over time rather than remove, this should be fine.",
              "createdAt": "2018-12-04T02:00:34Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 50,
              "body": "I think support for null values of negotiable request headers (here and in the content negotiation algorithms) is a necessity, though. Otherwise, if 3 different UAs support 3 different sets of content negotiation algorithms, then it would be impossible to generate an SXG that could be used by all of them. The union of all supported headers would fail because of the first item above, and the intersection of all supported headers would fail because of this item.\r\n\r\nEven for a single UA, one would have to tailor the header list to the particular version of the UA.\r\n\r\nMaybe this isn't a problem in practice because the set of content-negotiable headers doesn't change that much. But it'd be nice to avoid some spooky-action-at-a-distance here that may lead to calcification of that list.\r\n\r\n(I hope I'm not misunderstanding; I haven't spent a lot of time thinking about this, so I may be.)",
              "createdAt": "2018-12-04T02:10:08Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyOTExMjEy",
          "commit": {
            "abbreviatedOid": "d1d5c8c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-07T23:33:41Z",
          "updatedAt": "2018-12-07T23:33:41Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I agree. Now I just delegate to the content-negotiation algorithms, which I'm fixing in https://github.com/httpwg/http-extensions/pull/735.",
              "createdAt": "2018-12-07T23:33:41Z",
              "updatedAt": "2018-12-07T23:33:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyOTE0MTM5",
          "commit": {
            "abbreviatedOid": "d1d5c8c"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-07T23:51:42Z",
          "updatedAt": "2018-12-07T23:51:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 286,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4MDY0NjQz",
      "title": "Remove longlived impl diffs",
      "url": "https://github.com/WICG/webpackage/pull/286",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fix #197. \r\n\r\n@kinu, does this look good enough? [mice-03](https://tools.ietf.org/html/draft-thomson-http-mice-03) is now published.\r\n\r\nsigned-responses: [Preview](https://jyasskin.github.io/webpackage/remove-longlived-impl-diffs/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/remove-longlived-impl-diffs/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nbundled-exchanges: [Preview](https://jyasskin.github.io/webpackage/remove-longlived-impl-diffs/draft-yasskin-wpack-bundled-exchanges.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.txt&url2=https://jyasskin.github.io/webpackage/remove-longlived-impl-diffs/draft-yasskin-wpack-bundled-exchanges.txt)",
      "createdAt": "2018-08-13T18:32:31Z",
      "updatedAt": "2018-08-14T18:25:31Z",
      "closedAt": "2018-08-14T18:25:27Z",
      "mergedAt": "2018-08-14T18:25:27Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ1OTA3NTIx",
          "commit": {
            "abbreviatedOid": "52c8af8"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-14T03:41:02Z",
          "updatedAt": "2018-08-14T03:41:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4NDEwOTA5",
      "title": "Operate over header bytes instead of logical exchanges.",
      "url": "https://github.com/WICG/webpackage/pull/287",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #276 and makes it clearer that implementations shouldn't reserialize things per https://crbug.com/863499.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/fix-276-clearly-reuse-header-bytes/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/fix-276-clearly-reuse-header-bytes/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nThe change to the signed-message format can only take effect in b2, of course.",
      "createdAt": "2018-08-14T21:07:45Z",
      "updatedAt": "2018-08-20T21:41:01Z",
      "closedAt": "2018-08-17T05:42:04Z",
      "mergedAt": "2018-08-17T05:42:03Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Took a look, this looks good and am fine with either cherry-picking the format change only (nyaxt@ have a concern as the change included more) or landing this as is.",
          "createdAt": "2018-08-15T04:36:40Z",
          "updatedAt": "2018-08-15T04:36:40Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC, the commit has 2 goals:\r\n- Change the signature message format to not use CBOR\r\n- Explicitly pass CBOR header bytes to `{{ signature-validity }}` algorithm\r\n\r\nI'm not 100% confident from 30min review if all `exchange` concept change and `{{ signature-validity }}` procedure arguments change are consistent across all spec text.\r\nI think I'm fairly confident about the cross-origin path but I feel like there is subtlety with same-origin path.\r\n\r\nSince we are getting close to branch point, we discussed this with @kinu and decided to proceed with the PR and then follow up with fix-ups if needed. I was wondering if we could cherry-pick just the message format change for now but the lack of active implementation on the same-origin path atm may justify it a bit. That being said, I'd appreciate any help on reviewing cross-origin path.",
          "createdAt": "2018-08-15T04:45:05Z",
          "updatedAt": "2018-08-15T04:45:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MzI0NTU5",
          "commit": {
            "abbreviatedOid": "0840264"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-15T04:02:09Z",
          "updatedAt": "2018-08-15T04:34:39Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "Since we removed `{{significant-headers}}` concept, we might want to be pedantic here:\r\n\r\nIf the client relies on signature validity for any aspect of its behavior, it MUST ignore any header fields whose name are not listed in the `Signed-Headers` header field.",
              "createdAt": "2018-08-15T04:02:10Z",
              "updatedAt": "2018-08-15T04:34:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3MDI1NzY0",
          "commit": {
            "abbreviatedOid": "0840264"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-16T21:11:34Z",
          "updatedAt": "2018-08-16T21:11:35Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "tl;dr: I think it's fine for this part to be CBOR if you all want it to be CBOR. Sorry, I think I was unclear. It's more about re-encoding the headers than avoiding CBOR. :-)\r\n\r\nThis format's fine too, though if you do that, I suggest using BoringSSL's `CBB` functions in the implementation (we don't currently have `CBB_add_u64{,_length_prefixed}` since TLS doesn't use those, but they'd be easy to add). TLS also has a struct syntax you could borrow. (An 8 byte length prefix is also kind of impressively large for both URL and headers. :-) I don't think any implementation would tolerate either field to exceed, say, a 3 byte length. But 8 bytes is cool too if you prefer.)\r\n\r\nTo the CBOR point, I think I didn't express the concern clearly. My bad. It's not that you shouldn't trust the CBOR encoder itself. Rather, let's look at the pipeline of conversions we've got here.\r\n\r\nWe convert the byte representation of the signed exchange, to a CBOR AST (CBORValue), to some parsed signed exchange struct (SignedExchangeEnvelope), to the net/loading stack's representation (HttpResponseHeaders). Along the way, to verify the signature, we convert the SignedExchangeEnvelope *back* to the CBOR AST, then *back* to bytes, and *then* verify it.\r\n\r\nThat is:\r\n\r\n```\r\nbytes -> CBORValue -> SignedExchangeEnvelope -> HttpResponseHeaders -...-> web stack\r\n                                 |\r\n                                 v\r\n                             CBORValue\r\n                                 |\r\n                                 v\r\n                               bytes\r\n                                 |\r\n                                 v\r\n                         (verify signature)\r\n```\r\n\r\nWe want the \"verify signature\" step to cover what was ultimately sent to the rest of the stack. That's the point of this whole process. We wish to know that everything downstream of the verification only sees content attested by the signature.\r\n\r\nSuppose there's a logic bug in one of the right arrows. Maybe on certain malformed or weird input, we output something that can be massaged into an XSS. That's bad, but the signature mitigates a lot of potential attack vectors. The origin isn't going to sign the bad input, so as long as the verify step covered everything, an attacker can't use that bug to inject bad input into the origin. *The requirement on right arrows is they depend only on their inputs.*\r\n\r\nHowever, suppose there is a logic bug in one of the down arrows. Maybe we forgot to copy some new field from the SignedExchangeEnvelope into the CBORValue. That's a problem. An attacker can put the new field in, the signature would check out, and all the right arrows would think this new field was covered, when it really wasn't. *The requirement on down arrows is they preserve all information.*\r\n\r\nNote that, of these two requirements, one is much more straightforward than the other. It's hard to accidentally check a random global variable somewhere. :-) It's much easier to accidentally forget to encode something, or have some escaping bug in the encode somewhere.\r\n\r\nThus the goal is to minimize the complexity in the verify step. The trick I like most is to find the simplest representation and verify that. An array of bytes is a good candidate. No one is going to extend that. All the complex structure is carried within, and the verify step is blind to it all.\r\n\r\nNow, you can't always manage this. In the case of this logic, you are not just bytes. It's bytes plus some metadata decoded out of headers (cert-sha256, validity-url, etc). And, yeah, that means you need to go encode that metadata in some way. Maybe CBOR, maybe DER, or maybe something ad hoc. And, yeah, that's more down arrows. It would be more robust if you didn't have to do that, but there are also benefits to having the signature metadata outside of the payload, so the tradeoff is probably to leave those as is. Hopefully we don't have to extend those very often and the right arrows probably discard that information pretty quickly.\r\n\r\nThe rest of the payload, on the other hand, seems preferable to keep as bytes. Maybe someone will try to put trailers in there someday, I dunno.",
              "createdAt": "2018-08-16T21:11:35Z",
              "updatedAt": "2018-08-16T22:14:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3MDM0MTUw",
          "commit": {
            "abbreviatedOid": "0840264"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Some drive-by comments. They apply to the baseline of this PR, too; should I file a bug for them instead?",
          "createdAt": "2018-08-16T21:39:24Z",
          "updatedAt": "2018-08-16T21:52:29Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "I get a bit confused by the language \"no serialized headers\". It sounds like this means :method, :url, and :status would be omitted from {{cbor-representation}}, but I don't think that's what's intended.",
              "createdAt": "2018-08-16T21:39:24Z",
              "updatedAt": "2018-08-16T21:52:29Z"
            },
            {
              "originalPosition": 228,
              "body": "(Ditto.)",
              "createdAt": "2018-08-16T21:40:28Z",
              "updatedAt": "2018-08-16T21:52:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3MTAzMTIy",
          "commit": {
            "abbreviatedOid": "0840264"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Since @jyasskin is now OOO. I'll merge this and address @twifkak comments on a separate PR",
          "createdAt": "2018-08-17T05:41:14Z",
          "updatedAt": "2018-08-17T05:41:41Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "I'll do a separate PR for this.",
              "createdAt": "2018-08-17T05:41:15Z",
              "updatedAt": "2018-08-17T05:41:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 288,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4NDQwOTc0",
      "title": "Put a fallback URL at the beginning of signed exchanges",
      "url": "https://github.com/WICG/webpackage/pull/288",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This lets the browser redirect there if it doesn't recognize the version of the signed exchange.\r\n\r\nThis sits on top of #287 and #281, so please only review [`99fa76f`](https://github.com/WICG/webpackage/pull/288/commits/99fa76f42e04d3f4c0cc2d933f9f7d5ead2428ce). It fixes #242.\r\n\r\nOne question here is whether to include the method with the fallback URL. We can't do anything with a non-GET method right now, and after many years of HTTP, the only acceptable methods are GET and HEAD anyway, so I think we should consider dropping the method entirely, although not in this PR.\r\n\r\nsigned-responses: [Preview](https://jyasskin.github.io/webpackage/fallback-url/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/fix-276-clearly-reuse-header-bytes/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/fallback-url/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nLoading: [Preview](https://jyasskin.github.io/webpackage/fallback-url/loading.html#mp-http-fetch)",
      "createdAt": "2018-08-14T23:52:48Z",
      "updatedAt": "2018-08-20T21:41:49Z",
      "closedAt": "2018-08-20T07:21:22Z",
      "mergedAt": "2018-08-20T07:21:21Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3MTA0MjIz",
          "commit": {
            "abbreviatedOid": "99fa76f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "99fa76f lgtm",
          "createdAt": "2018-08-17T05:49:36Z",
          "updatedAt": "2018-08-17T05:49:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTIyNjE0",
          "commit": {
            "abbreviatedOid": "99fa76f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T07:10:16Z",
          "updatedAt": "2018-08-20T07:10:20Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I was wondering if we'd need to fix the blow example, that includes ':url' in cbor representation.",
              "createdAt": "2018-08-20T07:10:16Z",
              "updatedAt": "2018-08-20T07:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTIyODAx",
          "commit": {
            "abbreviatedOid": "99fa76f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T07:11:02Z",
          "updatedAt": "2018-08-20T07:11:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Good catch. I'll file a separate PR for this",
              "createdAt": "2018-08-20T07:11:02Z",
              "updatedAt": "2018-08-20T07:11:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTI2NTgz",
          "commit": {
            "abbreviatedOid": "99fa76f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T07:26:02Z",
          "updatedAt": "2018-08-20T07:26:03Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Filed #290",
              "createdAt": "2018-08-20T07:26:03Z",
              "updatedAt": "2018-08-20T07:26:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 290,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA5NDMyNjky",
      "title": "Update examples to match the new format",
      "url": "https://github.com/WICG/webpackage/pull/290",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@jyasskin FYI OOO",
      "createdAt": "2018-08-20T07:25:40Z",
      "updatedAt": "2018-08-20T08:23:20Z",
      "closedAt": "2018-08-20T08:23:20Z",
      "mergedAt": "2018-08-20T08:23:20Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTI3OTI3",
          "commit": {
            "abbreviatedOid": "e8564d7"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "non-owner lgtm",
          "createdAt": "2018-08-20T07:31:17Z",
          "updatedAt": "2018-08-20T07:31:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTI3OTU4",
          "commit": {
            "abbreviatedOid": "e8564d7"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-20T07:31:26Z",
          "updatedAt": "2018-08-20T07:31:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 291,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA5NzU3Nzgx",
      "title": "Add signedexchange/version",
      "url": "https://github.com/WICG/webpackage/pull/291",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces `Version` type to represent spec versions. This is needed to be a new package since this is referenced from multiple packages not only `signedexchange` but also `mice`.",
      "createdAt": "2018-08-21T09:12:00Z",
      "updatedAt": "2018-08-21T09:56:57Z",
      "closedAt": "2018-08-21T09:16:38Z",
      "mergedAt": "2018-08-21T09:16:38Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Lgtm",
          "createdAt": "2018-08-21T09:56:57Z",
          "updatedAt": "2018-08-21T09:56:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3OTcwODgw",
          "commit": {
            "abbreviatedOid": "713691f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-08-21T09:14:53Z",
          "updatedAt": "2018-08-21T09:14:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA5ODA1OTE3",
      "title": "Implement b2 version of encoder",
      "url": "https://github.com/WICG/webpackage/pull/292",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-21T12:18:15Z",
      "updatedAt": "2018-08-22T08:26:42Z",
      "closedAt": "2018-08-22T08:26:37Z",
      "mergedAt": "2018-08-22T08:26:37Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged @irori 's mice implementation",
          "createdAt": "2018-08-22T06:20:51Z",
          "updatedAt": "2018-08-22T06:20:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MDUxMjI1",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-21T13:12:36Z",
          "updatedAt": "2018-08-21T13:19:10Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "How about making `16*1024` a const MaximumSignatureHeaderValueLen",
              "createdAt": "2018-08-21T13:12:36Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 182,
              "body": "ditto",
              "createdAt": "2018-08-21T13:13:11Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 47,
              "body": "We need to resolve this before merge :)",
              "createdAt": "2018-08-21T13:18:45Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MDYzMTYx",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-21T13:39:38Z",
          "updatedAt": "2018-08-21T13:39:38Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Oops, nice catch",
              "createdAt": "2018-08-21T13:39:38Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzExMjU1",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-22T01:58:57Z",
          "updatedAt": "2018-08-22T01:58:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Let's use \"1b1\" as default until we have all the b2 changes in (i.e. http-mice-03).",
              "createdAt": "2018-08-22T01:58:58Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzEzMDQw",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-22T02:12:37Z",
          "updatedAt": "2018-08-22T02:16:20Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This should be `\"sxg1-b2\\x00\"`",
              "createdAt": "2018-08-22T02:12:37Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzE4Njc4",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-22T02:57:56Z",
          "updatedAt": "2018-08-22T02:57:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I thought the spec said the magic header byte is `\"sxg1\\x00\\x00\\x00\\x00\"`.\r\n\r\n> 8 bytes consisting of the ASCII characters \u201csxg1\u201d followed by 4 0x00 bytes, to serve as a file signature. This is redundant with the MIME type, and recipients that receive both MUST check that they match and stop parsing if they don\u2019t.",
              "createdAt": "2018-08-22T02:57:56Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzI2OTcw",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you!",
          "createdAt": "2018-08-22T04:10:49Z",
          "updatedAt": "2018-08-22T04:18:06Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Agreed. Change this later then.",
              "createdAt": "2018-08-22T04:10:49Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2018-08-22T04:14:14Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 169,
              "body": "Done (defined a local unexported const)",
              "createdAt": "2018-08-22T04:15:59Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 182,
              "body": "Done",
              "createdAt": "2018-08-22T04:16:03Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 14,
              "body": "Done, but I'd like to know if the spec is correct or not.",
              "createdAt": "2018-08-22T04:18:00Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzU5MTEx",
          "commit": {
            "abbreviatedOid": "1a24e7c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-22T07:25:13Z",
          "updatedAt": "2018-08-22T07:25:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzY1OTY0",
          "commit": {
            "abbreviatedOid": "1a24e7c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "mice/ lgtm",
          "createdAt": "2018-08-22T07:49:02Z",
          "updatedAt": "2018-08-22T07:49:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 294,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEwMzA2ODM1",
      "title": "gen-signedexchange: Add flag to optionally dump headers cbor for debu\u2026",
      "url": "https://github.com/WICG/webpackage/pull/294",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026gging",
      "createdAt": "2018-08-23T01:30:13Z",
      "updatedAt": "2018-08-23T02:49:49Z",
      "closedAt": "2018-08-23T02:18:36Z",
      "mergedAt": "2018-08-23T02:18:36Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4NzMxODE4",
          "commit": {
            "abbreviatedOid": "c8b0ef6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-23T01:39:37Z",
          "updatedAt": "2018-08-23T01:39:47Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Intended? (If so, please note in the patch description).",
              "createdAt": "2018-08-23T01:39:37Z",
              "updatedAt": "2018-08-23T02:06:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4NzM1NjMx",
          "commit": {
            "abbreviatedOid": "8270cd7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-23T02:06:55Z",
          "updatedAt": "2018-08-23T02:06:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "no. Thanks for the catch",
              "createdAt": "2018-08-23T02:06:55Z",
              "updatedAt": "2018-08-23T02:06:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4NzM2NzU3",
          "commit": {
            "abbreviatedOid": "8270cd7"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-23T02:15:01Z",
          "updatedAt": "2018-08-23T02:15:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4NzQxNTc4",
          "commit": {
            "abbreviatedOid": "8270cd7"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-23T02:49:48Z",
          "updatedAt": "2018-08-23T02:49:49Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I realized that the flag names include upper and lower cases... I was wondering if this is usual \ud83e\udd14 ",
              "createdAt": "2018-08-23T02:49:49Z",
              "updatedAt": "2018-08-23T02:49:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0MjExMDA3Nzcx",
      "title": "Snapshot implementation draft b2",
      "url": "https://github.com/WICG/webpackage/pull/296",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-27T05:19:21Z",
      "updatedAt": "2018-09-03T12:46:42Z",
      "closedAt": "2018-09-03T12:46:42Z",
      "mergedAt": "2018-09-03T12:46:42Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I need to append the ChangeLog items in ToT then backport.",
          "createdAt": "2018-08-27T05:20:17Z",
          "updatedAt": "2018-08-27T05:20:17Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated ChangeLog. PTAL",
          "createdAt": "2018-09-03T05:30:11Z",
          "updatedAt": "2018-09-03T05:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5NTg3OTc5",
          "commit": {
            "abbreviatedOid": "ee52825"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-27T05:52:41Z",
          "updatedAt": "2018-08-27T05:52:50Z",
          "comments": [
            {
              "originalPosition": 359,
              "body": "Remove this and next line",
              "createdAt": "2018-08-27T05:52:41Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5NTg5Mjg0",
          "commit": {
            "abbreviatedOid": "ee52825"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-27T06:02:02Z",
          "updatedAt": "2018-08-27T06:02:02Z",
          "comments": [
            {
              "originalPosition": 359,
              "body": "Done.",
              "createdAt": "2018-08-27T06:02:02Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5ODE4NDk3",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "All these comments should probably go on the main file, not the implementation snapshot, so I apologize for lazily making them here. Snapshot LGTM.",
          "createdAt": "2018-08-27T18:03:03Z",
          "updatedAt": "2018-08-27T18:27:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "May not be worth deciding now, but future integrity formats may want names containing a variable number of slashes (e.g. a pair of base64-encoded strings), so you may want an escaping mechanism eventually.",
              "createdAt": "2018-08-27T18:03:03Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 181,
              "body": "Why move this down here from line 419?",
              "createdAt": "2018-08-27T18:08:51Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 366,
              "body": "This means the magic \"sxg1-b2\" must always remain 7 chars. Out of curiosity:\r\n - What's after `b9`? `bA`..`bZ`? Or do we move to `g1` (for gamma)? :P\r\n - What's v1 look like? \"sxg1\\0\\0\\0\"?",
              "createdAt": "2018-08-27T18:20:36Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 362,
              "body": "(Given 65536 is longer than several existing browsers can support (AFAICT), perhaps the fetch spec should say how browsers should respond if the fallbackUrl is too long? Or specify a minimum length they must support? Or is this already covered by some other part of Fetch?)",
              "createdAt": "2018-08-27T18:24:36Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5OTM4OTY0",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-28T01:29:29Z",
          "updatedAt": "2018-08-28T01:29:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "IIUC, the string here refers to format id such as \"digest/mi-sha256-03\" so I think we are OK?",
              "createdAt": "2018-08-28T01:29:29Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5OTQwOTMw",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-28T01:43:11Z",
          "updatedAt": "2018-08-28T01:48:45Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "We wanted to clarify that the UAs may start processing the headers part before verifying the entire payload.\r\nBefore this change, invalid payload could make headers invalid. After this change the headers checks are somewhat independent.\r\n\r\nThe original change was from @jyasskin, so I may be wrong.",
              "createdAt": "2018-08-28T01:43:11Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 366,
              "body": "> - What's after b9? bA..bZ? Or do we move to g1 (for gamma)? :P\r\n\r\nWe hope to get to a standard before reaching bA :airplane: \r\n\r\n> - What's v1 look like? \"sxg1\\0\\0\\0\"?\r\n\r\nThat is the idea.",
              "createdAt": "2018-08-28T01:44:49Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 362,
              "body": "I'm not sure. Would you mind filing a separate issue?",
              "createdAt": "2018-08-28T01:46:47Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5OTYwNDAz",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-28T04:11:31Z",
          "updatedAt": "2018-08-28T04:11:31Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yeah, I think this is fine for the foreseeable future; I was just hypothesizing about a new integrity header.",
              "createdAt": "2018-08-28T04:11:31Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5OTYwODU0",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-28T04:15:23Z",
          "updatedAt": "2018-08-28T04:15:23Z",
          "comments": [
            {
              "originalPosition": 362,
              "body": "OK, filed #297.",
              "createdAt": "2018-08-28T04:15:23Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNjcwMjk0",
          "commit": {
            "abbreviatedOid": "54296b4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-03T06:19:26Z",
          "updatedAt": "2018-09-03T06:19:51Z",
          "comments": [
            {
              "originalPosition": 440,
              "body": "\"at the beginning of the `application/signed-exchange` format\" might be more precise.",
              "createdAt": "2018-09-03T06:19:26Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNjczMDcw",
          "commit": {
            "abbreviatedOid": "54296b4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-03T06:35:04Z",
          "updatedAt": "2018-09-03T06:35:04Z",
          "comments": [
            {
              "originalPosition": 440,
              "body": "Done.",
              "createdAt": "2018-09-03T06:35:04Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNzE0MjMw",
          "commit": {
            "abbreviatedOid": "df367f7"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, this looks good!",
          "createdAt": "2018-09-03T09:04:57Z",
          "updatedAt": "2018-09-03T09:04:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 298,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyNjU0MzM3",
      "title": "Update Change Log entries",
      "url": "https://github.com/WICG/webpackage/pull/298",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Ported from https://github.com/WICG/webpackage/pull/296",
      "createdAt": "2018-09-03T06:45:27Z",
      "updatedAt": "2018-11-29T07:13:53Z",
      "closedAt": "2018-11-29T07:13:53Z",
      "mergedAt": "2018-11-29T07:13:53Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MDM2NTUy",
          "commit": {
            "abbreviatedOid": "13a937f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks for adding these to the changelog. I added a commit suggesting different wording, which you're welcome to change again. :)",
          "createdAt": "2018-11-21T00:40:33Z",
          "updatedAt": "2018-11-21T00:40:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 301,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyOTA0Njky",
      "title": "dump-signedexchange: support b2 format",
      "url": "https://github.com/WICG/webpackage/pull/301",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also updates the spec comments in ReadExchange().",
      "createdAt": "2018-09-04T09:06:23Z",
      "updatedAt": "2018-09-05T00:50:30Z",
      "closedAt": "2018-09-05T00:50:26Z",
      "mergedAt": "2018-09-05T00:50:26Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxOTc3ODUw",
          "commit": {
            "abbreviatedOid": "0e5c716"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-04T09:16:30Z",
          "updatedAt": "2018-09-04T09:16:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMTEwMzI2",
          "commit": {
            "abbreviatedOid": "0e5c716"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm, thanks!",
          "createdAt": "2018-09-04T15:01:14Z",
          "updatedAt": "2018-09-04T15:01:45Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "`else` is not needed here?\r\n\r\n```go\r\nif ver == version.Version1b1 {\r\n  // ...\r\n  continue\r\n}\r\nreturn fmt.Errorf(\"signedexchange: found a deprecated request key %q\", keyURL)\r\n```\r\n",
              "createdAt": "2018-09-04T15:01:14Z",
              "updatedAt": "2018-09-05T00:47:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMzAyMjg5",
          "commit": {
            "abbreviatedOid": "1d295aa"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-05T00:47:42Z",
          "updatedAt": "2018-09-05T00:47:42Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "done.",
              "createdAt": "2018-09-05T00:47:42Z",
              "updatedAt": "2018-09-05T00:47:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 302,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzMDIyODYy",
      "title": "Add go.mod/go.sum",
      "url": "https://github.com/WICG/webpackage/pull/302",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "Add `go.mod` and `go.sum` so that the dependent library versions are specified explicitly. This affects Go 1.11 module usages (without $GOPATH), and should not affect the current usual usage (with $GOPATH).\r\n\r\nThis is a preparation for Go modules which will be officially introduced at Go 1.12.\r\n\r\nNote: you can test this by:\r\n\r\n1. Checking out https://github.com/WICG/webpackage at your local machine, not under `$GOPATH/src`\r\n2. Run `GO111MODULE=on go test ./...`\r\n",
      "createdAt": "2018-09-04T15:45:47Z",
      "updatedAt": "2019-01-21T08:14:43Z",
      "closedAt": "2019-01-21T07:56:53Z",
      "mergedAt": "2019-01-21T07:56:53Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I found some tests in bundle failed:\r\n\r\n```\r\n$ GO111MODULE=on go test ./...\r\n# github.com/WICG/webpackage/go/bundle\r\ngo/bundle/bundle.go:91: Fprintf format %s has arg e.Response.Status of wrong type int\r\n# github.com/WICG/webpackage/go/bundle/cmd/gen-bundle\r\ngo/bundle/cmd/gen-bundle/fromdir.go:90: Errorf call needs 1 arg but has 2 args\r\nok      github.com/WICG/webpackage/go/signedexchange    (cached)\r\nok      github.com/WICG/webpackage/go/signedexchange/cbor       (cached)\r\nok      github.com/WICG/webpackage/go/signedexchange/certurl    (cached)\r\nok      github.com/WICG/webpackage/go/signedexchange/internal/bigendian (cached)\r\nok      github.com/WICG/webpackage/go/signedexchange/mice       (cached)\r\nok      github.com/WICG/webpackage/go/webpack   (cached)\r\nok      github.com/WICG/webpackage/go/webpack/cbor      (cached)\r\n```\r\n\r\nIs this no longer maintained?",
          "createdAt": "2018-09-04T19:12:41Z",
          "updatedAt": "2018-09-04T19:12:41Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "go/bundle is not maintained anymore.\r\n",
          "createdAt": "2018-09-14T06:20:54Z",
          "updatedAt": "2018-09-14T06:20:54Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Then would it be better to remove bundle?",
          "createdAt": "2018-09-14T06:32:21Z",
          "updatedAt": "2018-09-14T06:32:21Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you update this PR?",
          "createdAt": "2019-01-07T00:15:58Z",
          "updatedAt": "2019-01-07T00:15:58Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> go/bundle is not maintained anymore.\r\n\r\nSorry, I meant `go/webpack` here. `go/bundle` should be fixed",
          "createdAt": "2019-01-07T03:25:19Z",
          "updatedAt": "2019-01-07T03:25:31Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\ngo: github.com/Sirupsen/logrus@v1.3.0: parsing go.mod: unexpected module path \"github.com/sirupsen/logrus\" \r\n```\r\n\r\nLooks like there are an unavailable package. I'll take a look.",
          "createdAt": "2019-01-15T05:58:42Z",
          "updatedAt": "2019-01-15T05:58:42Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/mrichman/hargo/pull/11 will fix this issue.",
          "createdAt": "2019-01-15T06:22:47Z",
          "updatedAt": "2019-01-15T06:22:47Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's wait for the hargo PR merge",
          "createdAt": "2019-01-17T05:16:59Z",
          "updatedAt": "2019-01-17T05:16:59Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@hajimehoshi now the pr is merged, would you update this pr?",
          "createdAt": "2019-01-21T05:56:49Z",
          "updatedAt": "2019-01-21T05:56:49Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated :-)",
          "createdAt": "2019-01-21T06:27:17Z",
          "updatedAt": "2019-01-21T06:27:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0NDc1MDIz",
          "commit": {
            "abbreviatedOid": "17b4330"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-21T07:56:47Z",
          "updatedAt": "2019-01-21T07:56:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 304,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzNDc3NTg4",
      "title": "Update gen-certurl test",
      "url": "https://github.com/WICG/webpackage/pull/304",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add OCSP and SCT to the test input\r\n- Remove an unused function",
      "createdAt": "2018-09-06T02:23:08Z",
      "updatedAt": "2018-09-06T03:00:04Z",
      "closedAt": "2018-09-06T03:00:01Z",
      "mergedAt": "2018-09-06T03:00:01Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzUyMjY4",
          "commit": {
            "abbreviatedOid": "8de6a8c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-06T02:24:13Z",
          "updatedAt": "2018-09-06T02:24:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzU2MjI3",
          "commit": {
            "abbreviatedOid": "8de6a8c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-06T02:54:08Z",
          "updatedAt": "2018-09-06T02:54:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzNDg1Mjgz",
      "title": "gen-certurl: Introduce CertChain type",
      "url": "https://github.com/WICG/webpackage/pull/305",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add `CertChain` type and replace `CreateCertChainCBOR()` with `CertChain.Write()`\r\n- Rename `parse.go` to `cert_chain.go`\r\n\r\n`adc920e` is just file renaming, so you might want to look at [`bbfbcfa`](https://github.com/WICG/webpackage/commit/bbfbcfaf0f479f1391395fd2dd8a64fa39e802d2) to see the diff.",
      "createdAt": "2018-09-06T03:28:04Z",
      "updatedAt": "2018-09-07T03:26:00Z",
      "closedAt": "2018-09-07T03:25:54Z",
      "mergedAt": "2018-09-07T03:25:54Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzYxNTI1",
          "commit": {
            "abbreviatedOid": "adc920e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-06T03:34:41Z",
          "updatedAt": "2018-09-06T03:37:05Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Would you name this const MagicString or something?",
              "createdAt": "2018-09-06T03:34:41Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            },
            {
              "originalPosition": 36,
              "body": "should we introduce a check so that item[1..] would not have OCSPResponse/SCTList?",
              "createdAt": "2018-09-06T03:36:53Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzY1MDgx",
          "commit": {
            "abbreviatedOid": "7477b5a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T04:03:15Z",
          "updatedAt": "2018-09-06T04:03:16Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Added a check for OCSP. For SCTList, having it in [1..] is allowed.",
              "createdAt": "2018-09-06T04:03:15Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzY1MDkx",
          "commit": {
            "abbreviatedOid": "7477b5a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T04:03:20Z",
          "updatedAt": "2018-09-06T04:03:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Done.",
              "createdAt": "2018-09-06T04:03:20Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzcyNjI4",
          "commit": {
            "abbreviatedOid": "7477b5a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "thx",
          "createdAt": "2018-09-06T05:04:16Z",
          "updatedAt": "2018-09-06T05:04:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTgyMjA1",
          "commit": {
            "abbreviatedOid": "7477b5a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-07T02:07:49Z",
          "updatedAt": "2018-09-07T02:13:23Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "`certchain.go` is better than `cert_chain.go`, since `_` has a special meaning in filenames in Go to indicate platforms (e.g. `foo_windows.go` is compiled only for Windows)",
              "createdAt": "2018-09-07T02:07:49Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            },
            {
              "originalPosition": 22,
              "body": "Use `%q` instead of `\\\"%s\\\"`",
              "createdAt": "2018-09-07T02:09:48Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            },
            {
              "originalPosition": 61,
              "body": "`if _, err := buf.WriteTo(os.Stdout); err != nil {`",
              "createdAt": "2018-09-07T02:11:01Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            },
            {
              "originalPosition": 22,
              "body": "Error messages should start with a small case: `input file ...`",
              "createdAt": "2018-09-07T02:13:15Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTkxNDQz",
          "commit": {
            "abbreviatedOid": "845d33f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T03:18:15Z",
          "updatedAt": "2018-09-07T03:18:15Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Done.",
              "createdAt": "2018-09-07T03:18:15Z",
              "updatedAt": "2018-09-07T03:18:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTkxNDc2",
          "commit": {
            "abbreviatedOid": "845d33f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T03:18:33Z",
          "updatedAt": "2018-09-07T03:18:33Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2018-09-07T03:18:33Z",
              "updatedAt": "2018-09-07T03:18:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTkxNDg2",
          "commit": {
            "abbreviatedOid": "845d33f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T03:18:37Z",
          "updatedAt": "2018-09-07T03:18:37Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Done.",
              "createdAt": "2018-09-07T03:18:37Z",
              "updatedAt": "2018-09-07T03:18:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 306,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzODE4ODIy",
      "title": "certurl: Add a parser of application/cert-chain+cbor format",
      "url": "https://github.com/WICG/webpackage/pull/306",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will be used by upcoming `dump-certurl` tool.",
      "createdAt": "2018-09-07T05:17:39Z",
      "updatedAt": "2018-09-10T07:49:11Z",
      "closedAt": "2018-09-10T07:49:05Z",
      "mergedAt": "2018-09-10T07:49:05Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjA1OTk5",
          "commit": {
            "abbreviatedOid": "8f710f7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-07T05:21:22Z",
          "updatedAt": "2018-09-07T05:21:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 307,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0MjA3OTY0",
      "title": "dump-signedexchange: Add a flag to dump only signature value",
      "url": "https://github.com/WICG/webpackage/pull/307",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-10T06:16:53Z",
      "updatedAt": "2018-09-10T06:45:10Z",
      "closedAt": "2018-09-10T06:45:06Z",
      "mergedAt": "2018-09-10T06:45:06Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNjQwNzg4",
          "commit": {
            "abbreviatedOid": "6de1a23"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-10T06:43:09Z",
          "updatedAt": "2018-09-10T06:43:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 308,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0MjI4NTQ3",
      "title": "Add dump-certurl tool",
      "url": "https://github.com/WICG/webpackage/pull/308",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Example output:\r\n```\r\nCertificate #0:\r\n  Subject: sxg.example.com\r\n  Valid from: 2018-08-30 03:34:29 +0000 UTC\r\n  Valid until: 2018-11-28 03:34:29 +0000 UTC\r\n  Issuer: Let's Encrypt Authority X3\r\n  Embedded SCT:\r\n    LogID: VYHUwhaQNgFK6gubVzxT8MDkOHhwJQgXL6OqHQcT0ww=\r\n    LogID: pFASaQVaFVReYhGrN7wQP2KuVXakXksXFEU+GyIQaiU=\r\nError: The main certificate does not have canSignHttpExchangesDraft extension\r\nOCSP response:\r\n  Status: 0 (good)\r\n  ProducedAt: 2018-09-05 04:34:00 +0000 UTC\r\n  ThisUpdate: 2018-09-05 04:00:00 +0000 UTC\r\n  NextUpdate: 2018-09-12 04:00:00 +0000 UTC\r\nCertificate #1:\r\n  Subject: Let's Encrypt Authority X3\r\n  Valid from: 2016-03-17 16:40:46 +0000 UTC\r\n  Valid until: 2021-03-17 16:40:46 +0000 UTC\r\n  Issuer: DST Root CA X3\r\n```",
      "createdAt": "2018-09-10T08:03:28Z",
      "updatedAt": "2018-09-11T08:33:37Z",
      "closedAt": "2018-09-11T08:33:33Z",
      "mergedAt": "2018-09-11T08:33:33Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDY4MzM0",
          "commit": {
            "abbreviatedOid": "b9cbec2"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-11T06:48:48Z",
          "updatedAt": "2018-09-11T06:48:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDkyNDgz",
          "commit": {
            "abbreviatedOid": "b9cbec2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-11T08:12:21Z",
          "updatedAt": "2018-09-11T08:12:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 309,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE1NDkxODcy",
      "title": "gen-signedexchange: Emit 1b2 format by default",
      "url": "https://github.com/WICG/webpackage/pull/309",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-14T06:20:14Z",
      "updatedAt": "2018-09-14T06:28:59Z",
      "closedAt": "2018-09-14T06:28:59Z",
      "mergedAt": "2018-09-14T06:28:59Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1MzY1NjMw",
          "commit": {
            "abbreviatedOid": "15ad135"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-14T06:25:13Z",
          "updatedAt": "2018-09-14T06:25:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NDg1NDUx",
      "title": "Grammar fixes",
      "url": "https://github.com/WICG/webpackage/pull/311",
      "state": "MERGED",
      "author": "dandv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-19T00:59:56Z",
      "updatedAt": "2018-09-19T21:33:42Z",
      "closedAt": "2018-09-19T01:34:54Z",
      "mergedAt": "2018-09-19T01:34:54Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2018-09-19T01:34:49Z",
          "updatedAt": "2018-09-19T01:34:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NjI5MDI2",
          "commit": {
            "abbreviatedOid": "2c38698"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-19T01:34:43Z",
          "updatedAt": "2018-09-19T01:34:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 312,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE4NTk1Mjg5",
      "title": "Update content-type value in README.md",
      "url": "https://github.com/WICG/webpackage/pull/312",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-27T10:08:12Z",
      "updatedAt": "2018-09-27T11:42:33Z",
      "closedAt": "2018-09-27T11:42:30Z",
      "mergedAt": "2018-09-27T11:42:30Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU5Mzc1MzQz",
          "commit": {
            "abbreviatedOid": "7cb1542"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-27T10:13:59Z",
          "updatedAt": "2018-09-27T10:13:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE4ODgxNjA0",
      "title": "Update Content-Type in examples/firebase.json to b2",
      "url": "https://github.com/WICG/webpackage/pull/313",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-28T07:48:55Z",
      "updatedAt": "2018-09-28T08:23:13Z",
      "closedAt": "2018-09-28T08:23:13Z",
      "mergedAt": "2018-09-28T08:23:13Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU5NzU5MDMz",
          "commit": {
            "abbreviatedOid": "1f3183a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-28T08:14:38Z",
          "updatedAt": "2018-09-28T08:14:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 317,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MTI5ODEx",
      "title": "Delete outdated examples.",
      "url": "https://github.com/WICG/webpackage/pull/317",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Keep firebase.json, which is still up-to-date.\r\n\r\nFixes #316.",
      "createdAt": "2018-10-18T23:30:25Z",
      "updatedAt": "2018-11-14T21:55:21Z",
      "closedAt": "2018-11-14T21:55:17Z",
      "mergedAt": "2018-11-14T21:55:17Z",
      "mergedBy": "twifkak",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is up to @jyasskin ",
          "createdAt": "2018-10-24T11:17:39Z",
          "updatedAt": "2018-10-24T11:17:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1MDk1NDcx",
          "commit": {
            "abbreviatedOid": "1890eb7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-11-14T21:49:45Z",
          "updatedAt": "2018-11-14T21:49:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI1MjY1MjI5",
      "title": "gen-signedexchange: Write SXG to stdout when \"-o -\" is given",
      "url": "https://github.com/WICG/webpackage/pull/318",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is useful when using gen-signedexchange in a command pipeline.",
      "createdAt": "2018-10-24T04:59:34Z",
      "updatedAt": "2018-10-25T01:28:17Z",
      "closedAt": "2018-10-25T01:27:57Z",
      "mergedAt": "2018-10-25T01:27:57Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzUzOTY4",
          "commit": {
            "abbreviatedOid": "999239c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T06:58:59Z",
          "updatedAt": "2018-10-24T06:59:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hmm, how about changing the default value an empty string, which means stdout?",
              "createdAt": "2018-10-24T06:58:59Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzYyMjQy",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T07:27:40Z",
          "updatedAt": "2018-10-24T07:27:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done. (I was a bit worried that users may forget to add -o and mess up their terminals with binary output... but this is probably just fine.)",
              "createdAt": "2018-10-24T07:27:40Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzYyNDA5",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-10-24T07:28:05Z",
          "updatedAt": "2018-10-24T07:28:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzY3NjMx",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T07:43:27Z",
          "updatedAt": "2018-10-24T07:43:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "+1 irori's concern. Can we isatty?\r\nOne possible impl of this is https://github.com/mattn/go-isatty but feel free to use alternatives",
              "createdAt": "2018-10-24T07:43:27Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzcxNzY3",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T07:54:48Z",
          "updatedAt": "2018-10-24T07:54:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "+1 to use isatty. You are suggesting that if -o is omitted and isatty is true, this application should show warnings?\r\n",
              "createdAt": "2018-10-24T07:54:48Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzkzNzU1",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T08:48:26Z",
          "updatedAt": "2018-10-24T08:48:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hmmm, isatty feels too fancy to me.\r\n\r\nCan we go with the original approach (\"-o -\" means stdout)? That's a common convention specified in the [POSIX Utility Syntax Guidelines](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html#tag_12_02) (Guideline 13) so it wouldn't surprise users.\r\n",
              "createdAt": "2018-10-24T08:48:26Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3ODEwOTY1",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T09:27:04Z",
          "updatedAt": "2018-10-24T09:27:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sure, I'm also fine with `-`. Stdout by default was just my preference, so let's go with `-` :-)",
              "createdAt": "2018-10-24T09:27:04Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3ODI0MTUx",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-24T09:57:25Z",
          "updatedAt": "2018-10-24T09:57:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTc5ODMz",
          "commit": {
            "abbreviatedOid": "999239c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-25T01:24:40Z",
          "updatedAt": "2018-10-25T01:24:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Changed back to `-` and merging. Thanks for the comments!",
              "createdAt": "2018-10-25T01:24:40Z",
              "updatedAt": "2018-10-25T01:24:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 320,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3MTg5MzI5",
      "title": "Add version field to the Exchange struct",
      "url": "https://github.com/WICG/webpackage/pull/320",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly just refactoring, except that dump-signedexchange now prints\r\nformat version.",
      "createdAt": "2018-10-31T07:53:34Z",
      "updatedAt": "2018-11-01T01:59:18Z",
      "closedAt": "2018-11-01T01:59:11Z",
      "mergedAt": "2018-11-01T01:59:11Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwMTM5MzQ3",
          "commit": {
            "abbreviatedOid": "89c5bea"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-10-31T08:42:33Z",
          "updatedAt": "2018-10-31T08:42:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTMyOTgx",
          "commit": {
            "abbreviatedOid": "89c5bea"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-01T01:54:27Z",
          "updatedAt": "2018-11-01T01:54:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 323,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3NDk0NjE0",
      "title": "Add Structured Headers parser",
      "url": "https://github.com/WICG/webpackage/pull/323",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is part of #319 and will be used to parse `signature` header.",
      "createdAt": "2018-11-01T02:27:11Z",
      "updatedAt": "2018-11-09T05:06:34Z",
      "closedAt": "2018-11-02T04:54:29Z",
      "mergedAt": "2018-11-02T04:54:29Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "FWIW, we've been collecting common tests in:\r\n  https://github.com/httpwg/structured-header-tests\r\n\r\nThey haven't been updated in a while, so they might be out of sync with the current spec, but I plan on spending some time on them soon.\r\n\r\nContributions most welcome, of course. Having a common test suite for all implementations should help intro considerably.",
          "createdAt": "2018-11-03T08:13:09Z",
          "updatedAt": "2018-11-03T08:13:09Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Current implementation lacks several features (toplevel is only Parameterised List, no float and boolean supports). I'd like to add these when I have time, and then we'll be able to use the test suite.",
          "createdAt": "2018-11-09T02:09:12Z",
          "updatedAt": "2018-11-09T02:09:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "Understood. Even if you just cherry-pick the applicable tests in the meantime, that would be great, as it would help assure there isn't too much drift. If there's anything we can do to help (e.g., separating into files differently, labelling test types, etc.) just say so.",
          "createdAt": "2018-11-09T05:06:34Z",
          "updatedAt": "2018-11-09T05:06:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTY3ODcz",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T06:18:41Z",
          "updatedAt": "2018-11-01T06:19:38Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I thought OWS is defined as a space char or a tab char that might be followed by whitespace characters: https://tools.ietf.org/html/rfc7230#section-3.2.3 In this implementation, only tab characters on left side would be removed.",
              "createdAt": "2018-11-01T06:18:42Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTYyNjEw",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T05:40:51Z",
          "updatedAt": "2018-11-01T06:26:07Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Simply []ParameterizedIdentifier?\r\n\r\n",
              "createdAt": "2018-11-01T05:40:51Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 2,
              "body": "Note to self: Did a quick search and looks like this is the first Go impl of the spec",
              "createdAt": "2018-11-01T05:44:04Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 134,
              "body": "Should we add `p.peekRune`?",
              "createdAt": "2018-11-01T06:15:04Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 34,
              "body": "We might want to use bytes.Buffer here? You can then use https://golang.org/pkg/bytes/#Buffer.ReadBytes and such",
              "createdAt": "2018-11-01T06:19:20Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 45,
              "body": "should we operate per `rune`?",
              "createdAt": "2018-11-01T06:24:57Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTY5OTk0",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Discussed offline. byte seems fine.",
          "createdAt": "2018-11-01T06:32:41Z",
          "updatedAt": "2018-11-01T06:32:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTc2MTU1",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:09:25Z",
          "updatedAt": "2018-11-01T07:09:26Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Sorry this was my misunderstanding",
              "createdAt": "2018-11-01T07:09:25Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTc2OTQy",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:14:14Z",
          "updatedAt": "2018-11-01T07:14:14Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "As we discussed offline, I'm ok to go with `byte`. Rather, should the parser cause errors when non-ASCII chars were found?",
              "createdAt": "2018-11-01T07:14:14Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTgwMzc0",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:31:41Z",
          "updatedAt": "2018-11-01T07:31:42Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "ASCII-ness is not explicitly checked, but non-ASCII characters will cause error in `perse*` functions where the character is consumed. For example, parseString() fails if the character isn't in the range [` `, `~`].",
              "createdAt": "2018-11-01T07:31:41Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTc5ODM3",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "sgtm in general",
          "createdAt": "2018-11-01T07:29:06Z",
          "updatedAt": "2018-11-01T07:33:31Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "nits: error message should start with small caps in convention (there are a lot of messages don't follow this rule in this project though...)\r\n\r\nhttps://github.com/golang/go/wiki/Errors\r\n\r\nHow about starting with `structuredheader:`?",
              "createdAt": "2018-11-01T07:29:06Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 1,
              "body": "Let's make it a different package `structured_header`. We'd need to export some functions.",
              "createdAt": "2018-11-01T07:30:51Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTgyNDY3",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:42:09Z",
          "updatedAt": "2018-11-01T07:42:10Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "I thought this is the preferred way?\r\n\r\nhttps://golang.org/pkg/testing/#pkg-overview\r\n\r\n> To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the \u201cgo test\u201d command is run. For more detail, run \u201cgo help test\u201d and \u201cgo help testflag\u201d.",
              "createdAt": "2018-11-01T07:42:10Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTg0ODE4",
          "commit": {
            "abbreviatedOid": "3be445f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:54:19Z",
          "updatedAt": "2018-11-01T07:54:19Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Done.",
              "createdAt": "2018-11-01T07:54:19Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTkzNzkx",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T08:32:36Z",
          "updatedAt": "2018-11-01T08:32:36Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Done.",
              "createdAt": "2018-11-01T08:32:36Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTk0MzEz",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T08:34:39Z",
          "updatedAt": "2018-11-01T08:34:39Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I'd like to keep using string, as functions like `strings.TrimLeft` can be used directly.",
              "createdAt": "2018-11-01T08:34:39Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNjA4NTgz",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T09:24:28Z",
          "updatedAt": "2018-11-01T09:24:29Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Yes, this is the preferred way.",
              "createdAt": "2018-11-01T09:24:28Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNjI0ODI2",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T10:15:33Z",
          "updatedAt": "2018-11-01T10:15:33Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "We discussed offline and concluded it would not be worth making this a different package by exposing a lot of functions. (There is a technique to expose functions only for testing, but it is a little messy). Let's keep as this is. Thanks.",
              "createdAt": "2018-11-01T10:15:33Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNjI2Mjc2",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T10:20:27Z",
          "updatedAt": "2018-11-01T10:24:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "nit: Parameters represents ...\r\n\r\n(I felt it is strange a plural noun followed by a verb in third-person singular form, but it looks like it is permitted e.g. https://golang.org/pkg/net/http/#PushOptions)",
              "createdAt": "2018-11-01T10:20:27Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 243,
              "body": "Couldn't we reach this with arbitrary user-input? Sorry if I am missing.",
              "createdAt": "2018-11-01T10:24:35Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTMyMjAw",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-02T00:10:22Z",
          "updatedAt": "2018-11-02T00:10:22Z",
          "comments": [
            {
              "originalPosition": 243,
              "body": "Line 228 guarantees that here's `*`.",
              "createdAt": "2018-11-02T00:10:22Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTM1MTA5",
          "commit": {
            "abbreviatedOid": "d2b2797"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-02T00:27:16Z",
          "updatedAt": "2018-11-02T00:27:16Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done",
              "createdAt": "2018-11-02T00:27:16Z",
              "updatedAt": "2018-11-02T00:27:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTY3OTAy",
          "commit": {
            "abbreviatedOid": "d2b2797"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-02T04:36:18Z",
          "updatedAt": "2018-11-02T04:36:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 325,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3NTcyNjEw",
      "title": "Do not use signedexchange/version in mice package",
      "url": "https://github.com/WICG/webpackage/pull/325",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "So that the package can be used independently from Signed Exchange.",
      "createdAt": "2018-11-01T10:21:12Z",
      "updatedAt": "2018-11-02T00:28:03Z",
      "closedAt": "2018-11-02T00:27:56Z",
      "mergedAt": "2018-11-02T00:27:56Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNjYwMzU2",
          "commit": {
            "abbreviatedOid": "d833742"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-01T12:18:14Z",
          "updatedAt": "2018-11-01T12:18:53Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "nit: No `()`",
              "createdAt": "2018-11-01T12:18:14Z",
              "updatedAt": "2018-11-02T00:23:55Z"
            },
            {
              "originalPosition": 36,
              "body": "ditto",
              "createdAt": "2018-11-01T12:18:19Z",
              "updatedAt": "2018-11-02T00:23:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTMwNDQx",
          "commit": {
            "abbreviatedOid": "d833742"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-02T00:00:44Z",
          "updatedAt": "2018-11-02T00:00:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTM0Njg3",
          "commit": {
            "abbreviatedOid": "ab5fcd6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-02T00:24:29Z",
          "updatedAt": "2018-11-02T00:24:29Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Done",
              "createdAt": "2018-11-02T00:24:29Z",
              "updatedAt": "2018-11-02T00:24:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTM0NzAy",
          "commit": {
            "abbreviatedOid": "ab5fcd6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-02T00:24:34Z",
          "updatedAt": "2018-11-02T00:24:34Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Done",
              "createdAt": "2018-11-02T00:24:34Z",
              "updatedAt": "2018-11-02T00:24:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 326,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3ODA0OTA4",
      "title": "Reject uncachable status code",
      "url": "https://github.com/WICG/webpackage/pull/326",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Chromium CL: https://chromium-review.googlesource.com/c/chromium/src/+/1313712\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/nyaxt/webpackage/pull/326.html\" title=\"Last updated on Nov 20, 2018, 5:59 AM GMT (95b849a)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/326/54c7a94...nyaxt:95b849a.html\" title=\"Last updated on Nov 20, 2018, 5:59 AM GMT (95b849a)\">Diff</a>",
      "createdAt": "2018-11-02T01:13:16Z",
      "updatedAt": "2018-11-20T20:08:23Z",
      "closedAt": "2018-11-20T20:08:23Z",
      "mergedAt": "2018-11-20T20:08:23Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu wdyt?",
          "createdAt": "2018-11-02T01:19:38Z",
          "updatedAt": "2018-11-02T01:19:38Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there is a reasonable set of status codes which we should allow, but not sure where the boundary is.\r\n\r\n- **1xx Informational**: IIUC, these are partial responses which doesn't make sense to be captured.\r\n- **non-cachable responses**: Disallowing those seem to align with the request method restrictions. (strawman)\r\n\r\n@kinu made a point that redirect is disallowed in the loading spec, so there is also discussion of where to enforce the restriction",
          "createdAt": "2018-11-02T01:28:26Z",
          "updatedAt": "2018-11-02T01:28:26Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm less sure about the non-cacheable responses, for example for CaheStorage we don't check any of these but specifically throw an error if it's 206 (partial response). And if we take a deeper look getting 203 (non-authoritative) seems a little weird, handling of 206 (partial content) responses would need to be discussed in the loading spec (as well as handling of range requests), and all 3xx are forbidden in the loading spec.  Overall I feel it might make better sense to have the part only in the loading spec, at least until we have a clearer thought of what should be valid.",
          "createdAt": "2018-11-02T02:39:29Z",
          "updatedAt": "2018-11-02T02:39:29Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Well or maybe we can just start with 200 only. Looking into other status code most of them don't really make sense. (I prefer forbidding it in the loading spec though) /cc @horo-t",
          "createdAt": "2018-11-02T09:01:40Z",
          "updatedAt": "2018-11-02T09:01:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "A status code that is uncacheable by default can still be cached if it has explicit freshness information. I think you need to reference the entire [response cacheability algorithm](https://httpwg.org/specs/rfc7234.html#response.cacheability).",
          "createdAt": "2018-11-03T06:52:40Z",
          "updatedAt": "2018-11-03T06:52:40Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu @horo-t @mnot Thank you for your input!\r\nI'll update the PR shortly to only allow 200 here to be most restrictive, but I'm open to loosen the restriction to the response cacheablility algorithm if we have a use case.",
          "createdAt": "2018-11-05T00:30:24Z",
          "updatedAt": "2018-11-05T00:30:24Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu Would you mind sharing the background why you'd prefer this to be loading spec?\r\n\r\nI'm mixed since we already have `:method` cacheability validation in the sxg format spec. While I think having it outside format spec makes sense if we consider non-webbrowser consumers in the future (which are not covered by `loading.md` iiuc).\r\n\r\nAnother strawman would be to have:\r\n- format spec say only cachable responses are signature valid\r\n- loading spec to allow only 200",
          "createdAt": "2018-11-05T00:41:43Z",
          "updatedAt": "2018-11-05T00:41:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1MTMwMTM3",
          "commit": {
            "abbreviatedOid": "0341c4b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-11-14T23:30:52Z",
          "updatedAt": "2018-11-14T23:48:11Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Let's replace the \"or not cacheable\" bit with the reference to https://httpwg.org/specs/rfc7234.html#rfc.section.3, since that also talks about methods.",
              "createdAt": "2018-11-14T23:33:51Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n1. If `exchange`'s response is not complete, (Section 3.1 of {{!RFC7234}}),\r\n```",
              "createdAt": "2018-11-14T23:37:43Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 6,
              "body": "I believe \"shared cache\" is the right term, according to https://httpwg.org/specs/rfc7234.html#rfc.section.1. \"public\" is a response directive, not a type of cache.\r\n\r\nI'd also rather not use the term \"cacheable\" here since https://httpwg.org/specs/rfc7234.html#rfc.section.3 doesn't define it as a predicate on responses. Instead perhaps:\r\n\r\n```suggestion\r\n1. If Section 3 of {{RFC7234}} forbids a shared cache from storing `exchange`'s response, return \"invalid\".\r\n```",
              "createdAt": "2018-11-14T23:41:21Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 5,
              "body": "I think I agree with having this tighter restriction in the loading spec only, at least for now. ",
              "createdAt": "2018-11-14T23:48:04Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjEwNzU2",
          "commit": {
            "abbreviatedOid": "0341c4b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for your review!",
          "createdAt": "2018-11-20T05:49:03Z",
          "updatedAt": "2018-11-20T05:56:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2018-11-20T05:49:04Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 6,
              "body": "Done.",
              "createdAt": "2018-11-20T05:49:11Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 3,
              "body": "Done",
              "createdAt": "2018-11-20T05:51:39Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2OTUyMDk4",
          "commit": {
            "abbreviatedOid": "95b849a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-11-20T20:05:05Z",
          "updatedAt": "2018-11-20T20:05:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3ODQ2OTg3",
      "title": " Implement mice decoder",
      "url": "https://github.com/WICG/webpackage/pull/327",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is part of #319.",
      "createdAt": "2018-11-02T06:52:55Z",
      "updatedAt": "2018-11-05T05:39:43Z",
      "closedAt": "2018-11-05T05:39:38Z",
      "mergedAt": "2018-11-05T05:39:38Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxMzk0NzE0",
          "commit": {
            "abbreviatedOid": "45d0a9c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-05T01:58:58Z",
          "updatedAt": "2018-11-05T02:04:13Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "multiple",
              "createdAt": "2018-11-05T01:58:58Z",
              "updatedAt": "2018-11-05T05:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxNDEyODQy",
          "commit": {
            "abbreviatedOid": "45d0a9c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-05T04:46:27Z",
          "updatedAt": "2018-11-05T04:46:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxNDE4NTgy",
          "commit": {
            "abbreviatedOid": "a41a7c3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-05T05:39:08Z",
          "updatedAt": "2018-11-05T05:39:09Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Done.",
              "createdAt": "2018-11-05T05:39:08Z",
              "updatedAt": "2018-11-05T05:39:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 328,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4MjI5MzI4",
      "title": "Update loading spec to impl b2 snapshot",
      "url": "https://github.com/WICG/webpackage/pull/328",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/nyaxt/webpackage/pull/328.html\" title=\"Last updated on Dec 18, 2018, 12:01 AM UTC (b2687a5)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/328/9b58b4c...nyaxt:b2687a5.html\" title=\"Last updated on Dec 18, 2018, 12:01 AM UTC (b2687a5)\">Diff</a>",
      "createdAt": "2018-11-05T03:08:46Z",
      "updatedAt": "2018-12-18T00:05:15Z",
      "closedAt": "2018-12-18T00:05:15Z",
      "mergedAt": "2018-12-18T00:05:15Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "ref #310 ",
          "createdAt": "2018-11-05T06:06:42Z",
          "updatedAt": "2018-11-05T06:06:42Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll address your comments shortly, but feel free to take over this change (or any of my PRs when you think it would be more productive).\r\nI'm happy with both having you pushing new changes to this PR branch or creating a new PR from scratch.",
          "createdAt": "2018-11-20T06:06:36Z",
          "updatedAt": "2018-11-20T06:06:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1OTA5Njcx",
          "commit": {
            "abbreviatedOid": "31271a0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Are you good making the updates to match -b2, or should I take over this change?",
          "createdAt": "2018-11-16T17:43:33Z",
          "updatedAt": "2018-11-16T18:18:20Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02#page-12 says this should be \r\n\r\n```suggestion\r\n    : \"digest/mi-sha256-03\"\r\n```",
              "createdAt": "2018-11-16T17:43:33Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 127,
              "body": "https://tools.ietf.org/html/draft-thomson-http-mice-03#section-3 says we need to parse this out of the Digest header, not look for a top-level header.",
              "createdAt": "2018-11-16T17:46:12Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 90,
              "body": "The b2 signed message in https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02#page-11 is significantly different from the b1 message.",
              "createdAt": "2018-11-16T17:50:30Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 82,
              "body": "b2 includes a fallback URL here. https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02#section-5.3",
              "createdAt": "2018-11-16T18:15:09Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjI5OTM5",
          "commit": {
            "abbreviatedOid": "31271a0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-20T07:27:37Z",
          "updatedAt": "2018-11-20T08:06:16Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "Done.",
              "createdAt": "2018-11-20T07:27:37Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 127,
              "body": "Thanks for catching this. I tried to add parse steps.",
              "createdAt": "2018-11-20T07:28:14Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 82,
              "body": "Added steps to extract the fallback URL + an assert that it matches the result of [=extracting the fallback URL=] algorithm",
              "createdAt": "2018-11-20T07:54:50Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 90,
              "body": "Ack. (Can address tomorrow, or feel free to take over)",
              "createdAt": "2018-11-20T08:06:11Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc5NjIzNDkz",
          "commit": {
            "abbreviatedOid": "3050644"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-29T04:18:18Z",
          "updatedAt": "2018-11-29T04:18:18Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Updated.",
              "createdAt": "2018-11-29T04:18:18Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1MzMwOTEy",
          "commit": {
            "abbreviatedOid": "0e6bf92"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-15T00:36:11Z",
          "updatedAt": "2018-12-15T00:36:12Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "The UTF-8 conversion only wound up in one of the two places, so I've refactored them together.",
              "createdAt": "2018-12-15T00:36:11Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1MzMxOTE0",
          "commit": {
            "abbreviatedOid": "c35cd85"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Please double-check the series of commits I added, but then this looks good to squash onto master. Thanks!",
          "createdAt": "2018-12-15T00:45:03Z",
          "updatedAt": "2018-12-15T00:45:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1ODU1OTY1",
          "commit": {
            "abbreviatedOid": "b2687a5"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2018-12-18T00:05:00Z",
          "updatedAt": "2018-12-18T00:05:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 329,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4Mjg4MjIw",
      "title": "Update test keys in signedexchange_test.go to secp256r1",
      "url": "https://github.com/WICG/webpackage/pull/329",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-05T09:30:17Z",
      "updatedAt": "2018-11-06T01:28:04Z",
      "closedAt": "2018-11-06T01:28:00Z",
      "mergedAt": "2018-11-06T01:28:00Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxNDk0MDI1",
          "commit": {
            "abbreviatedOid": "6a4270c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-05T10:32:13Z",
          "updatedAt": "2018-11-05T10:32:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 330,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4NTQ4NTEy",
      "title": "go/signedexchange: Drop RSA keys support",
      "url": "https://github.com/WICG/webpackage/pull/330",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "RSA keys are forbidden since before version b1, so there's no reason to\r\nkeep it.",
      "createdAt": "2018-11-06T01:37:50Z",
      "updatedAt": "2018-11-06T05:47:47Z",
      "closedAt": "2018-11-06T05:47:43Z",
      "mergedAt": "2018-11-06T05:47:43Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODM5MjE5",
          "commit": {
            "abbreviatedOid": "9fccfeb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-06T01:53:38Z",
          "updatedAt": "2018-11-06T01:53:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 331,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4NTgxNjg1",
      "title": "Add signature verifier to signingalgorithm.go",
      "url": "https://github.com/WICG/webpackage/pull/331",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This also moves signer_test.go to signingalgorithm_test.go, as it only uses `signingalgorithm` package.",
      "createdAt": "2018-11-06T05:54:57Z",
      "updatedAt": "2018-11-06T08:34:01Z",
      "closedAt": "2018-11-06T08:33:55Z",
      "mergedAt": "2018-11-06T08:33:55Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "(This is part of #319)",
          "createdAt": "2018-11-06T07:30:50Z",
          "updatedAt": "2018-11-06T07:30:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODg0MDI0",
          "commit": {
            "abbreviatedOid": "d79c0ce"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-06T07:08:27Z",
          "updatedAt": "2018-11-06T07:10:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Optional: add RFC 3279 ref?",
              "createdAt": "2018-11-06T07:08:27Z",
              "updatedAt": "2018-11-06T07:25:03Z"
            },
            {
              "originalPosition": 32,
              "body": "Can be another PR: prefix all error message with \"signingalgorithm: \"?",
              "createdAt": "2018-11-06T07:09:42Z",
              "updatedAt": "2018-11-06T07:25:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODg3Mzk4",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T07:25:19Z",
          "updatedAt": "2018-11-06T07:25:19Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Done.",
              "createdAt": "2018-11-06T07:25:19Z",
              "updatedAt": "2018-11-06T07:25:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODg3NDE0",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T07:25:22Z",
          "updatedAt": "2018-11-06T07:25:23Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2018-11-06T07:25:22Z",
              "updatedAt": "2018-11-06T07:25:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODg4NzY5",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T07:31:43Z",
          "updatedAt": "2018-11-06T07:31:46Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Do we plan to add another verifier other than `ecdsaVerifier`? If not, I think exporting `ecdsaVerifier` and returning it instead of returning an interface value should be fine.",
              "createdAt": "2018-11-06T07:31:43Z",
              "updatedAt": "2018-11-06T07:31:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODk1NzI5",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T07:59:57Z",
          "updatedAt": "2018-11-06T07:59:57Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "We may support ed25519 (and/or other non-legacy, non-RSA signing algorithms defined by TLS 1.3 or later) in the future.\r\n\r\nI'd like to use this interface in the first place, to minimize caller-side changes when we support them.",
              "createdAt": "2018-11-06T07:59:57Z",
              "updatedAt": "2018-11-06T07:59:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTAxNjQ4",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T08:20:32Z",
          "updatedAt": "2018-11-06T08:20:33Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Makes sense.",
              "createdAt": "2018-11-06T08:20:32Z",
              "updatedAt": "2018-11-06T08:20:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTAyNTg0",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T08:23:50Z",
          "updatedAt": "2018-11-06T08:24:34Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Don't we need a package name here?",
              "createdAt": "2018-11-06T08:23:50Z",
              "updatedAt": "2018-11-06T08:24:34Z"
            },
            {
              "originalPosition": 32,
              "body": "Ditto",
              "createdAt": "2018-11-06T08:23:56Z",
              "updatedAt": "2018-11-06T08:24:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTAzNTcy",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T08:26:50Z",
          "updatedAt": "2018-11-06T08:26:51Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "No, `signingalgorithm` is dot-imported at line 9.",
              "createdAt": "2018-11-06T08:26:51Z",
              "updatedAt": "2018-11-06T08:26:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTA0Mjk5",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T08:28:58Z",
          "updatedAt": "2018-11-06T08:28:58Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Oh, I missed that, sorry",
              "createdAt": "2018-11-06T08:28:58Z",
              "updatedAt": "2018-11-06T08:28:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTA0NTQ2",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-06T08:29:41Z",
          "updatedAt": "2018-11-06T08:29:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4NjI1Nzgw",
      "title": "go/signedexchange: Make serializeSignedMessage non-method func",
      "url": "https://github.com/WICG/webpackage/pull/332",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It was a method of Signer, but will be used by verifier too.\r\n\r\nThis is part of #319.",
      "createdAt": "2018-11-06T09:36:03Z",
      "updatedAt": "2018-11-07T00:47:28Z",
      "closedAt": "2018-11-07T00:47:24Z",
      "mergedAt": "2018-11-07T00:47:24Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTMyNDU5",
          "commit": {
            "abbreviatedOid": "1622916"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-06T09:44:35Z",
          "updatedAt": "2018-11-06T09:44:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTQxOTYx",
          "commit": {
            "abbreviatedOid": "1622916"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-06T10:06:44Z",
          "updatedAt": "2018-11-06T10:06:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 333,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4OTA1MTAw",
      "title": "dump-signedexchange: verify exchange's signature",
      "url": "https://github.com/WICG/webpackage/pull/333",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds -verify option to dump-signedexhcange, which runs\r\nthe verification algorithm [1] on the given signed-exchange.\r\n\r\nBy default certificate chain is fetched from signature's cert-url,\r\nbut that can be overridden by -cert flag.\r\n\r\nCurrently it only checks signature validity [2], and does not\r\nperform certificate verification (step 7 of [2]).\r\n\r\n[1] draft-yasskin-http-origin-signed-responses.html#cross-origin-trust\r\n[2] draft-yasskin-http-origin-signed-responses.html#signature-validity",
      "createdAt": "2018-11-07T03:14:32Z",
      "updatedAt": "2018-11-07T07:25:17Z",
      "closedAt": "2018-11-07T07:25:13Z",
      "mergedAt": "2018-11-07T07:25:13Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "This is the main patch of #319.",
          "createdAt": "2018-11-07T03:16:20Z",
          "updatedAt": "2018-11-07T03:16:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzMyNzgz",
          "commit": {
            "abbreviatedOid": "2dc8905"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-07T03:57:06Z",
          "updatedAt": "2018-11-07T03:59:11Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Would you add a comment what this is?",
              "createdAt": "2018-11-07T03:57:06Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzM1Njk4",
          "commit": {
            "abbreviatedOid": "2dc8905"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T04:19:10Z",
          "updatedAt": "2018-11-07T05:57:14Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "How about letting `verify` return error and handling it on the caller side? BTW, is it fine to print the error to stdout?",
              "createdAt": "2018-11-07T04:19:11Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            },
            {
              "originalPosition": 67,
              "body": "Optional: I prefer interface to function, but I think function is also fine here.",
              "createdAt": "2018-11-07T04:24:45Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            },
            {
              "originalPosition": 239,
              "body": "Should we compare port number?",
              "createdAt": "2018-11-07T04:25:59Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzQ4OTEx",
          "commit": {
            "abbreviatedOid": "ff1b1b4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:01:22Z",
          "updatedAt": "2018-11-07T06:01:22Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Oh, it was just copied from an existing test case, but it doesn't have to be fixed timestamp.\r\nChanged to `time.Now()`.\r\n",
              "createdAt": "2018-11-07T06:01:22Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzUwMzg0",
          "commit": {
            "abbreviatedOid": "ff1b1b4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:13:17Z",
          "updatedAt": "2018-11-07T06:13:17Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Would a constant time be better for testing in general?",
              "createdAt": "2018-11-07T06:13:17Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzUzODUx",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:35:05Z",
          "updatedAt": "2018-11-07T06:35:05Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Yeah maybe. (I was Chromium build sheriff on Mon and Tue, and saw tests failing because of the end of DST...)\r\n\r\nChanged to a (better-named) fixed timestamp.",
              "createdAt": "2018-11-07T06:35:05Z",
              "updatedAt": "2018-11-07T06:35:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzUzOTcx",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:35:38Z",
          "updatedAt": "2018-11-07T06:35:38Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Done.\r\n\r\nSince this is a dump tool, verification errors are not considered \"hard error\", so printing them to stdout and continue processing is fine I think.",
              "createdAt": "2018-11-07T06:35:38Z",
              "updatedAt": "2018-11-07T06:35:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU0Mjc5",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:37:19Z",
          "updatedAt": "2018-11-07T06:37:19Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "URL.Host contains port number.\r\nhttps://golang.org/pkg/net/url/#URL",
              "createdAt": "2018-11-07T06:37:19Z",
              "updatedAt": "2018-11-07T06:37:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU3MTkw",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:53:02Z",
          "updatedAt": "2018-11-07T06:53:02Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "I don't have strong opinion either. Can we go with a function pointer for now, since it requires fewer lines?",
              "createdAt": "2018-11-07T06:53:02Z",
              "updatedAt": "2018-11-07T06:53:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU4MDA1",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:57:27Z",
          "updatedAt": "2018-11-07T06:57:27Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Sure, go with a function pointer :-)",
              "createdAt": "2018-11-07T06:57:27Z",
              "updatedAt": "2018-11-07T06:57:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU4NDk3",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T07:00:00Z",
          "updatedAt": "2018-11-07T07:00:03Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "`fmt.Println(err)`? Now the error is handled by `log.Fatal`, which I think is different from what we want.",
              "createdAt": "2018-11-07T07:00:00Z",
              "updatedAt": "2018-11-07T07:00:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU5OTA5",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T07:07:42Z",
          "updatedAt": "2018-11-07T07:07:43Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "`verify` returns error not on verification errors, but when a bad command-line flag is given (e.g. -cert file doesn't exist). In such cases, probably we should exit with non-zero status.",
              "createdAt": "2018-11-07T07:07:42Z",
              "updatedAt": "2018-11-07T07:07:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzYyNDk1",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-07T07:20:45Z",
          "updatedAt": "2018-11-07T07:20:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 334,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4OTQ1NDAw",
      "title": "go/signedexchange: Update README.md",
      "url": "https://github.com/WICG/webpackage/pull/334",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "...mentioning about `dump-exchange`'s `-verify` option.\r\n\r\nThis is part of #319.",
      "createdAt": "2018-11-07T08:04:29Z",
      "updatedAt": "2018-11-07T08:55:32Z",
      "closedAt": "2018-11-07T08:11:54Z",
      "mergedAt": "2018-11-07T08:11:54Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzczMjU3",
          "commit": {
            "abbreviatedOid": "fc579a4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-07T08:07:45Z",
          "updatedAt": "2018-11-07T08:07:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 337,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI5NTY0ODc1",
      "title": "dump-signedexchange: correctly dump request headers",
      "url": "https://github.com/WICG/webpackage/pull/337",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-09T01:51:06Z",
      "updatedAt": "2018-11-09T01:56:24Z",
      "closedAt": "2018-11-09T01:56:24Z",
      "mergedAt": "2018-11-09T01:56:24Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Ooohh. good catch.",
          "createdAt": "2018-11-09T01:54:48Z",
          "updatedAt": "2018-11-09T01:54:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTczMjQ5MTQx",
          "commit": {
            "abbreviatedOid": "f343247"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-09T01:54:39Z",
          "updatedAt": "2018-11-09T01:54:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMwOTM0OTY5",
      "title": "Reject uncached headers",
      "url": "https://github.com/WICG/webpackage/pull/339",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #336 and fixes #340.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/nyaxt/webpackage/pull/339.html\" title=\"Last updated on Jan 10, 2019, 5:26 PM UTC (3e85268)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/339/80005f0...nyaxt:3e85268.html\" title=\"Last updated on Jan 10, 2019, 5:26 PM UTC (3e85268)\">Diff</a>",
      "createdAt": "2018-11-14T18:22:08Z",
      "updatedAt": "2019-02-22T23:17:09Z",
      "closedAt": "2019-01-10T17:31:58Z",
      "mergedAt": "2019-01-10T17:31:58Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "We would like to rely on https://github.com/httpwg/http-core/pull/181 instead. However we might want to use this for the implementation snapshot depending on the time frame.",
          "createdAt": "2019-01-07T01:08:49Z",
          "updatedAt": "2019-01-07T01:08:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm not hopeful that httpwg/http-core#181 will get in by the end of this week, so I'm probably going to add the rest of the hop-by-hop headers and other non-cached headers here and get this merged.",
          "createdAt": "2019-01-07T03:58:36Z",
          "updatedAt": "2019-01-07T03:58:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Please take a look. This will fix #336 and fix #340.",
          "createdAt": "2019-01-10T05:32:38Z",
          "updatedAt": "2019-01-10T05:32:38Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM. Updated ChangeLog",
          "createdAt": "2019-01-10T07:22:39Z",
          "updatedAt": "2019-01-10T07:22:39Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "2 more small changes, and now I'll merge.",
          "createdAt": "2019-01-10T17:23:40Z",
          "updatedAt": "2019-01-10T17:23:40Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay - why is the list of hop-by-hop headers here (and in Chromium) different from the one listed at https://tools.ietf.org/html/rfc2616#section-13.5.1?",
          "createdAt": "2019-02-22T23:17:09Z",
          "updatedAt": "2019-02-22T23:17:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2MDE3Nzcz",
          "commit": {
            "abbreviatedOid": "53b7429"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T23:27:13Z",
          "updatedAt": "2018-11-16T23:27:14Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "See https://github.com/WICG/webpackage/issues/336#issuecomment-439559157; I think we should reject all of the headers in the `kHopByHopResponseHeaders`, `kChallengeResponseHeaders`, and `kCookieResponseHeaders` arrays in https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc. Maybe that list should roll into the {{stateful-headers}} list?",
              "createdAt": "2018-11-16T23:27:14Z",
              "updatedAt": "2019-01-10T17:22:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDU0MTkx",
          "commit": {
            "abbreviatedOid": "557708e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-10T05:33:16Z",
          "updatedAt": "2019-01-10T05:33:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 341,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyMjAxODcw",
      "title": "verifier.go: Add checks for request method and stateful headers",
      "url": "https://github.com/WICG/webpackage/pull/341",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This implements Step 3-5 of the \"Cross-origin trust\" algorithm\r\n([Section 4 of draft-yasskin-http-origin-signed-responses.html](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.4)).",
      "createdAt": "2018-11-20T06:06:12Z",
      "updatedAt": "2018-11-20T06:54:45Z",
      "closedAt": "2018-11-20T06:54:40Z",
      "mergedAt": "2018-11-20T06:54:40Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjEzOTk4",
          "commit": {
            "abbreviatedOid": "253de33"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-11-20T06:08:50Z",
          "updatedAt": "2018-11-20T06:09:39Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Would you factor out a helper method so we wont have label jump `continue`s?",
              "createdAt": "2018-11-20T06:08:50Z",
              "updatedAt": "2018-11-20T06:28:41Z"
            },
            {
              "originalPosition": 39,
              "body": "L132 seems broken?",
              "createdAt": "2018-11-20T06:09:21Z",
              "updatedAt": "2018-11-20T06:28:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjE5MDU1",
          "commit": {
            "abbreviatedOid": "a921463"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-20T06:32:33Z",
          "updatedAt": "2018-11-20T06:32:33Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Done.",
              "createdAt": "2018-11-20T06:32:33Z",
              "updatedAt": "2018-11-20T06:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjE5MTI1",
          "commit": {
            "abbreviatedOid": "a921463"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-20T06:32:52Z",
          "updatedAt": "2018-11-20T06:32:52Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Not actually, 'e' refers to a local variable.\r\nAdded `` ` `` around `e` hoping to make it easier to understand.",
              "createdAt": "2018-11-20T06:32:52Z",
              "updatedAt": "2018-11-20T06:32:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjIxMTM5",
          "commit": {
            "abbreviatedOid": "a921463"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-20T06:43:36Z",
          "updatedAt": "2018-11-20T06:43:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjIyNzg3",
          "commit": {
            "abbreviatedOid": "a921463"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-20T06:52:26Z",
          "updatedAt": "2018-11-20T06:52:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 343,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyNTM2MjYw",
      "title": "go/signedexchange: More tests for signature verification",
      "url": "https://github.com/WICG/webpackage/pull/343",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-21T04:33:25Z",
      "updatedAt": "2018-11-27T01:18:16Z",
      "closedAt": "2018-11-27T01:17:45Z",
      "mergedAt": "2018-11-27T01:17:45Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased onto master after #344. PTAL",
          "createdAt": "2018-11-26T02:20:20Z",
          "updatedAt": "2018-11-26T02:20:20Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori: @hajimehoshi is on vacation, so please feel free to merge.",
          "createdAt": "2018-11-26T14:12:51Z",
          "updatedAt": "2018-11-26T14:12:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MDc1MDAw",
          "commit": {
            "abbreviatedOid": "afcba62"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T04:42:35Z",
          "updatedAt": "2018-11-21T04:42:50Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "The current situation around `Exchange.RequestHeaders` is quite tricky. We might want to resolve it first.\r\n`func (*Exchange) encodeRequest()` assumes `\":method\"` key to not be in the `RequestHeaders` map, while `func (*Exchange) decodeRequest()` will populate the key.",
              "createdAt": "2018-11-21T04:42:36Z",
              "updatedAt": "2018-11-26T02:18:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MDg0OTI0",
          "commit": {
            "abbreviatedOid": "afcba62"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T05:50:44Z",
          "updatedAt": "2018-11-21T05:50:44Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "OK, created #344.",
              "createdAt": "2018-11-21T05:50:44Z",
              "updatedAt": "2018-11-26T02:18:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MzA1ODEx",
          "commit": {
            "abbreviatedOid": "c1330ca"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-26T14:11:02Z",
          "updatedAt": "2018-11-26T14:12:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@hajimehoshi Any thoughts on using named return values here?\r\nhttps://tour.golang.org/basics/7 discourages using it on long func, but I'm open here.",
              "createdAt": "2018-11-26T14:11:02Z",
              "updatedAt": "2018-11-26T14:12:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 344,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyNTQ2MTEx",
      "title": "go/signedexchange: Refactor request method handling",
      "url": "https://github.com/WICG/webpackage/pull/344",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add `RequestMethod` field to the `Exchange` struct\r\n- `NewExchange()` takes `method` as a parameter\r\n- Fix a bug that request headers were not encoded\r\n- Function Renamings\r\n  - {encode,decode}Request -> {encode,decode}RequestMap\r\n  - {encode,decode}ResponseHeaders -> {encode,decode}ResponseMap",
      "createdAt": "2018-11-21T05:50:10Z",
      "updatedAt": "2018-11-26T02:02:21Z",
      "closedAt": "2018-11-26T02:02:21Z",
      "mergedAt": "2018-11-26T02:02:21Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Pushed one more commit. PTAL\r\n\r\n- gen-signedexchange: Add `-method` option\r\n- dump-signedexchange: Print exchange's request method",
          "createdAt": "2018-11-26T01:55:53Z",
          "updatedAt": "2018-11-26T01:55:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MTEzMTA3",
          "commit": {
            "abbreviatedOid": "f7c7462"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T08:06:01Z",
          "updatedAt": "2018-11-21T08:08:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "`http.MethodGet` sounds better",
              "createdAt": "2018-11-21T08:06:01Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            },
            {
              "originalPosition": 28,
              "body": "ditto",
              "createdAt": "2018-11-21T08:07:26Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            },
            {
              "originalPosition": 21,
              "body": "`http.MethodGet` and `http.MethodHead`",
              "createdAt": "2018-11-21T08:08:21Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MTE3MDA5",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T08:19:27Z",
          "updatedAt": "2018-11-21T08:19:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2018-11-21T08:19:27Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MTE3MDMw",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T08:19:31Z",
          "updatedAt": "2018-11-21T08:19:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Done",
              "createdAt": "2018-11-21T08:19:31Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MTE3MDcy",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T08:19:37Z",
          "updatedAt": "2018-11-21T08:19:37Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Done",
              "createdAt": "2018-11-21T08:19:37Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3NTQwMzk3",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-22T08:15:22Z",
          "updatedAt": "2018-11-22T08:15:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MTExNDI3",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-26T01:39:44Z",
          "updatedAt": "2018-11-26T01:39:44Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Make plural? `encoders` or `encs` or `es`?",
              "createdAt": "2018-11-26T01:39:44Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MTExNTA1",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-26T01:40:32Z",
          "updatedAt": "2018-11-26T01:40:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MTEyODEx",
          "commit": {
            "abbreviatedOid": "654e9cd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-26T01:55:08Z",
          "updatedAt": "2018-11-26T01:55:08Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "done",
              "createdAt": "2018-11-26T01:55:08Z",
              "updatedAt": "2018-11-26T01:55:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MTEzNDcz",
          "commit": {
            "abbreviatedOid": "654e9cd"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-26T02:01:19Z",
          "updatedAt": "2018-11-26T02:01:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 346,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1MTQzMjYz",
      "title": "Strictly UTF-8 decode the fallback URL",
      "url": "https://github.com/WICG/webpackage/pull/346",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Bikeshed warned that I'd never defined |fallbackUrl|, but I missed it\nbefore going on parental leave. Do y'all see any problems with picking this conversion from bytes to a string?\n\n@irori, we ought to test this with a couple bad fallback URLs, say one starting with a BOM, and one with an invalid sequence that the UTF-8 decoder might convert to U+FFFD. Would you be willing to add those tests?\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/346.html\" title=\"Last updated on Dec 1, 2018, 12:31 AM GMT (121ecb1)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/346/2eddf31...jyasskin:121ecb1.html\" title=\"Last updated on Dec 1, 2018, 12:31 AM GMT (121ecb1)\">Diff</a>",
      "createdAt": "2018-11-30T23:19:28Z",
      "updatedAt": "2018-12-20T08:44:08Z",
      "closedAt": "2018-12-05T15:37:48Z",
      "mergedAt": "2018-12-05T15:37:48Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I should add that I found https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc?l=920&rcl=6aa20f013414d789e8d72752a6885ef3d990d274 after I wrote this change, indicating that maybe we'd rather `Location` headers be all-ASCII. We can enforce that for SXG URLs if y'all think it's a good idea.\r\n\r\nThis is also related to https://github.com/whatwg/fetch/issues/843.",
          "createdAt": "2018-12-04T03:12:49Z",
          "updatedAt": "2018-12-04T03:12:49Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "UTF-8 is generally preferable I think, but it depends a bit on what kind of field this is. Happy to help if you could give some context.",
          "createdAt": "2018-12-04T10:37:48Z",
          "updatedAt": "2018-12-04T10:37:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@annevk This is the field at the beginning of the Signed Exchange format that gives both the URL of the inner resource and a target to redirect to if the Signed Exchange is broken (doesn't parse, the signature doesn't validate, maybe other things).",
          "createdAt": "2018-12-04T15:00:06Z",
          "updatedAt": "2018-12-04T15:00:06Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I'd make those UTF-8. The URL parser will turn it all into ASCII, but it seems preferable to be able to serialize in more ways.",
          "createdAt": "2018-12-05T09:03:43Z",
          "updatedAt": "2018-12-05T09:03:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks, @annevk!",
          "createdAt": "2018-12-05T15:38:41Z",
          "updatedAt": "2018-12-05T15:38:41Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "For the record, tests for this are https://github.com/web-platform-tests/wpt/commit/2e19cbe5d5d74821056d4ae2cef435accefaf4ef and https://github.com/web-platform-tests/wpt/commit/e663fa084dcdac43fea5cdd6c69b059b5ad0743f.",
          "createdAt": "2018-12-20T08:44:07Z",
          "updatedAt": "2018-12-20T08:44:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNTkwOTEz",
          "commit": {
            "abbreviatedOid": "121ecb1"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-03T01:21:20Z",
          "updatedAt": "2018-12-03T01:21:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgxMDYzNjg4",
          "commit": {
            "abbreviatedOid": "121ecb1"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sure, I will add the tests.",
          "createdAt": "2018-12-04T01:58:30Z",
          "updatedAt": "2018-12-04T01:58:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 348,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM3MDMyMTUx",
      "title": "Add a security consideration about content sniffing.",
      "url": "https://github.com/WICG/webpackage/pull/348",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This fixes #321, I think. @molnarg, how do you feel about this?\n\nI'll need to add this to bundles too, but I want to get the SXG text right first.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/348.html\" title=\"Last updated on Dec 13, 2018, 12:52 AM GMT (052993b)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/348/dcb188d...jyasskin:052993b.html\" title=\"Last updated on Dec 13, 2018, 12:52 AM GMT (052993b)\">Diff</a>",
      "createdAt": "2018-12-08T00:55:45Z",
      "updatedAt": "2018-12-19T22:43:38Z",
      "closedAt": "2018-12-19T22:43:35Z",
      "mergedAt": "2018-12-19T22:43:35Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Chromium CL: https://chromium-review.googlesource.com/c/chromium/src/+/1373430",
          "createdAt": "2018-12-13T02:29:02Z",
          "updatedAt": "2018-12-13T02:29:02Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I need some help understanding the model.\r\n\r\nIs the idea that `application/signed-exchange` and `application/webbundle` responses cannot be sniffed as scripts or same-origin quirks mode style sheets? If so, we could add them to <https://fetch.spec.whatwg.org/#should-response-to-request-be-blocked-due-to-mime-type?>. I don't think it matters for other nosniff contexts per https://mimesniff.spec.whatwg.org/#determining-the-computed-mime-type-of-a-resource.\r\n\r\nOr is the idea that the responses they encompass (i.e., those in the bundle/archive) cannot be sniffed? If so, we could \"dynamically inject\" this header when we create those responses ensuring \"determine nosniff\" always returns true for them downstream.",
          "createdAt": "2018-12-13T14:49:57Z",
          "updatedAt": "2018-12-13T14:49:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@annevk One of the bigger risks is that they might be sniffed as PDFs, Flash, or other plugin-recognized types. The risky file types don't necessarily follow the Fetch spec, so the header isn't guaranteed to work, but we thought it'd improve our chances.\r\n\r\n@mikewest may have other answers. He suggested requiring nosniff here. We also want to make internal responses automatically nosniff, but that'll come in a separate change.",
          "createdAt": "2018-12-13T16:59:48Z",
          "updatedAt": "2018-12-13T16:59:48Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Ah plugins, that is indeed a poorly specified area. Note that currently we don't have any language that suggests nosniff would work for plugins.",
          "createdAt": "2018-12-13T17:20:54Z",
          "updatedAt": "2018-12-13T17:20:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yep. I don't personally have evidence that this improves things for any particular plugin; we're just hoping. I don't have strong feelings about whether this is the right thing to do.",
          "createdAt": "2018-12-13T19:06:25Z",
          "updatedAt": "2018-12-13T19:06:25Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think we need to know concretely what this will help with so it can be tested for (and specified if it isn't already). In particular as we'd have to do this for other new formats too, presumably (e.g., Wasm)? (I see the benefits for the contained non-HTTP responses, but as you said that's separate.)",
          "createdAt": "2018-12-13T20:36:25Z",
          "updatedAt": "2018-12-13T20:36:25Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "In general, I'd like for us to be strict about new mechanisms we're adding to the platform that might result in executable code. I don't have any concrete examples of places where plugins could misinterpret an SXG response as something unfortunate, but there are a number of examples of plugins' propensity to zealously sniff incoming content into executable code. I'd like to make that less likely.\r\n\r\nThat said, when I was talking with @jyasskin about this a few days ago, I incorrectly assumed that `nosniff` applied to plugin content. In the meantime, @jyasskin pointed out that https://html.spec.whatwg.org/multipage/iframe-embed-object.html#object-type-detection makes strictly obeying `Content-Type` headers entirely optional for plugin resources, and that we apparently don't do so in Chrome. I think we should change that (though I don't have any data that would suggest that it's safe to do so; I'll add some metrics). If we don't, then I think I agree with @annevk that the Fetch bits of this change wouldn't have any teeth.\r\n\r\n> Or is the idea that the responses they encompass (i.e., those in the bundle/archive) cannot be sniffed? If so, we could \"dynamically inject\" this header when we create those responses ensuring \"determine nosniff\" always returns true for them downstream.\r\n\r\nAs above, I'd like for us to strictly enforce MIME type checks for resources contained in SXG responses. Implicitly injecting a nosniff requirement seems like it would indeed be simpler for developers, so I'd be on board with that kind of mechanism. It seems like requiring developers to include the header has a higher chance of increasing usage even in browsers that don't support SXG (as presumably developers would inject the header themselves on both the SXG-encoded resource, and the plain ol' resource), but that might be asking too much.",
          "createdAt": "2018-12-18T08:08:41Z",
          "updatedAt": "2018-12-18T08:08:41Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to revert the discussion of `X-Content-Type-Options:nosniff` in this PR, to land the general anti-sniffing advice, and then open a new PR that deals specifically with that header, both for the SXG itself and for its contents.",
          "createdAt": "2018-12-19T22:34:55Z",
          "updatedAt": "2018-12-19T22:34:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyOTIyNjMx",
          "commit": {
            "abbreviatedOid": "379f532"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-08T00:57:45Z",
          "updatedAt": "2018-12-08T00:57:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyOTI5MTcx",
          "commit": {
            "abbreviatedOid": "379f532"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-08T02:56:57Z",
          "updatedAt": "2018-12-08T02:56:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgzNTEyNDI5",
          "commit": {
            "abbreviatedOid": "ea22292"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "still lg",
          "createdAt": "2018-12-11T05:07:22Z",
          "updatedAt": "2018-12-11T05:07:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 351,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM4MjcxNzUx",
      "title": "gen-signedexchange: Add -nocheck flag",
      "url": "https://github.com/WICG/webpackage/pull/351",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This flag lets gen-signedexchange skip some input validations. This is needed to create SXGs for web-platform-tests.\r\n\r\nThis also fixes a bug that Exchange.Verify() fails when `url.Parse(fallbackUrl).String() != fallbackUrl`. (Note: current Chromium impl has the same bug, see https://crbug.com/914247)",
      "createdAt": "2018-12-13T05:47:01Z",
      "updatedAt": "2018-12-15T06:10:18Z",
      "closedAt": "2018-12-15T06:10:15Z",
      "mergedAt": "2018-12-15T06:10:15Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "bikeshed: `ignoreerrors` is more idionatic...\r\n\r\nhttps://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies\r\n\r\n2018\u5e7412\u670814\u65e5(\u91d1) 10:53\u3001Kunihiko Sakamoto \u3055\u3093\uff08notifications@github.com\uff09\u306e\u30e1\u30c3\u30bb\u30fc\u30b8:\r\n\r\n> *@irori* commented on this pull request.\r\n> ------------------------------\r\n>\r\n> In go/signedexchange/cmd/gen-signedexchange/main.go\r\n> <https://github.com/WICG/webpackage/pull/351#discussion_r241623334>:\r\n>\r\n> > @@ -47,6 +47,8 @@ var (\r\n>  \tflagDumpHeadersCbor      = flag.String(\"dumpHeadersCbor\", \"\", \"Dump metadata and headers encoded as a canonical CBOR to a file for debugging.\")\r\n>  \tflagOutput               = flag.String(\"o\", \"out.sxg\", \"Signed exchange output file. If value is '-', sxg is written to stdout.\")\r\n>\r\n> +\tflagSkipCheck = flag.Bool(\"skipcheck\", false, \"Do not reject invalid input arguments\")\r\n>\r\n> OK, renamed to -ignoreErrors.\r\n>\r\n> \u2014\r\n> You are receiving this because your review was requested.\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/WICG/webpackage/pull/351#discussion_r241623334>, or mute\r\n> the thread\r\n> <https://github.com/notifications/unsubscribe-auth/AABCNkEZrmjeeuer6WH2L_VEun5c_EaXks5u4wSegaJpZM4ZQ-Cg>\r\n> .\r\n>\r\n",
          "createdAt": "2018-12-14T02:05:04Z",
          "updatedAt": "2018-12-14T02:06:24Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "> bikeshed: `ignoreerrors` is more idionatic... https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies \r\n\r\nHmm we already have many camelCase flags and I'd like to keep the consistency.",
          "createdAt": "2018-12-14T06:23:29Z",
          "updatedAt": "2018-12-14T06:23:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTA4ODc1",
          "commit": {
            "abbreviatedOid": "4a18d31"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T05:48:18Z",
          "updatedAt": "2018-12-13T05:50:45Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I feel like `-nocheck=false` sounds confusing due to two negative words. Wouldn't `-skipcheck=false` be better?",
              "createdAt": "2018-12-13T05:48:18Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTEwMTIx",
          "commit": {
            "abbreviatedOid": "4a18d31"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T05:55:42Z",
          "updatedAt": "2018-12-13T05:55:43Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Or `flagCheck = flag.Bool(\"check\", true, ...)`?",
              "createdAt": "2018-12-13T05:55:43Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTEwNDYz",
          "commit": {
            "abbreviatedOid": "4a18d31"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T05:57:35Z",
          "updatedAt": "2018-12-13T05:57:35Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Both are fine :-)",
              "createdAt": "2018-12-13T05:57:35Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTExOTUz",
          "commit": {
            "abbreviatedOid": "d15d9b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T06:05:42Z",
          "updatedAt": "2018-12-13T06:05:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Renamed to `-skipcheck`, as default-true boolean flag feels a bit unusual to me.",
              "createdAt": "2018-12-13T06:05:42Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTEyMzk0",
          "commit": {
            "abbreviatedOid": "d15d9b2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-13T06:08:04Z",
          "updatedAt": "2018-12-13T06:10:12Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "bikeshedding: How about `-ignoreErrors` (aligned w/ `make`) or `-f` (most of coreutils)",
              "createdAt": "2018-12-13T06:08:04Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0OTQ0MDU2",
          "commit": {
            "abbreviatedOid": "c00b6ec"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-14T01:53:34Z",
          "updatedAt": "2018-12-14T01:53:34Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "OK, renamed to `-ignoreErrors`.",
              "createdAt": "2018-12-14T01:53:34Z",
              "updatedAt": "2018-12-14T01:53:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1MDIxNTU1",
          "commit": {
            "abbreviatedOid": "c00b6ec"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-12-14T09:17:32Z",
          "updatedAt": "2018-12-14T09:17:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 352,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MjI5ODU5",
      "title": "Allow SXGs to be loaded from localhost or files.",
      "url": "https://github.com/WICG/webpackage/pull/352",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See also some discussion in https://crbug.com/915576.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/352.html\" title=\"Last updated on Dec 17, 2018, 5:44 PM UTC (579eac9)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/352/d335219...jyasskin:579eac9.html\" title=\"Last updated on Dec 17, 2018, 5:44 PM UTC (579eac9)\">Diff</a>",
      "createdAt": "2018-12-17T17:44:01Z",
      "updatedAt": "2018-12-17T23:59:23Z",
      "closedAt": "2018-12-17T23:59:19Z",
      "mergedAt": "2018-12-17T23:59:19Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1ODUyMTkx",
          "commit": {
            "abbreviatedOid": "579eac9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-17T23:48:30Z",
          "updatedAt": "2018-12-17T23:48:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 353,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5NzAyMDUy",
      "title": "go: Initial b3 support",
      "url": "https://github.com/WICG/webpackage/pull/353",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Start adding support for #350\r\n\r\nThe output is identical to `b2` but the magic bytes for now.",
      "createdAt": "2018-12-19T03:34:57Z",
      "updatedAt": "2018-12-19T06:02:45Z",
      "closedAt": "2018-12-19T06:02:45Z",
      "mergedAt": "2018-12-19T06:02:45Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2Mzc3MjQy",
          "commit": {
            "abbreviatedOid": "cec7852"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-19T03:38:44Z",
          "updatedAt": "2018-12-19T03:38:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2MzkzMzU4",
          "commit": {
            "abbreviatedOid": "cec7852"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-12-19T05:39:18Z",
          "updatedAt": "2018-12-19T05:39:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 354,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMDE4ODM5",
      "title": "Prevent content-type sniffing",
      "url": "https://github.com/WICG/webpackage/pull/354",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@annevk @molnarg This has the somewhat controversial requirement that SXGs are served with `X-Content-Type-Options: nosniff` from #348. @molnarg, if we want this, we should show a case where it actually prevents a plugin from sniffing an executable content type.\n\nI've also added the promised requirement that clients treat the contents as including that header, and a requirement we haven't discussed yet that the contents actually include a `Content-Type` header.\n\n[signed-responses preview](https://jyasskin.github.io/webpackage/nosniff-header/draft-yasskin-http-origin-signed-responses.html#seccons-content-sniffing)\n[bundled-exchanges preview](https://jyasskin.github.io/webpackage/nosniff-header/draft-yasskin-wpack-bundled-exchanges.html#seccons-content-sniffing)\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/354.html\" title=\"Last updated on Jan 14, 2019, 7:30 PM UTC (cf5f1b1)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/354/595f72f...jyasskin:cf5f1b1.html\" title=\"Last updated on Jan 14, 2019, 7:30 PM UTC (cf5f1b1)\">Diff</a>",
      "createdAt": "2018-12-20T00:43:47Z",
      "updatedAt": "2019-01-16T04:27:50Z",
      "closedAt": "2019-01-16T04:27:47Z",
      "mergedAt": "2019-01-16T04:27:47Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "No objections from me, though I'm curious why the extra measures to prevent content-sniffing the inner response. Given the other safety measures in #348, is still there a concern that a plugin might unexpectedly trigger after the virtual redirect?",
          "createdAt": "2018-12-20T07:22:30Z",
          "updatedAt": "2018-12-20T07:22:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#348 warns folks away from doing dangerous things, but doesn't prevent them, especially if they host the SXG on a separate domain. Adding XCTO:nosniff to the inner responses protects the signing domain.",
          "createdAt": "2018-12-20T23:29:51Z",
          "updatedAt": "2018-12-20T23:29:51Z"
        },
        {
          "author": "molnarg",
          "authorAssociation": "NONE",
          "body": "The X-Content-Type-Options and the Content-Type header is more for preventing non-plugin (e.g. HTML) content sniffing, as described in https://mimesniff.spec.whatwg.org. Plugins can just ignore all headers in the worst case (though some of them look at the headers), but browser content sniffing will have to obey the headers as mandated in the MIME sniffing spec (Content-Type header) and the fetch spec: https://fetch.spec.whatwg.org/#x-content-type-options-header (X-Content-Type-Options header).\r\n\r\nAs a concrete example for plugins, Flash (which is a plugin that looks at headers) will refuse to execute if there is a Content-Type header that is not application/x-shockwave-flash https://miki.it/blog/2014/7/8/abusing-jsonp-with-rosetta-flash#mitigations-by-website-owners",
          "createdAt": "2018-12-29T15:01:43Z",
          "updatedAt": "2018-12-29T15:01:43Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "So this requirement would prevent the package itself and its contents from being executed as a script and used as a style sheet (in very limited circumstances, assuming the contents are not labeled with a JavaScript MIME type or text/css). Per https://mimesniff.spec.whatwg.org/#determining-the-computed-mime-type-of-a-resource I don't think it would prevent any other kind of sniffing for the package except for maybe plugins but it sounds like they don't really care for this header. I guess that's fine?\r\n\r\nPlease use https://fetch.spec.whatwg.org/#concept-header-extract-mime-type rather than the MIME Sniffing definition of obtaining a MIME type btw (sorry, agreed that this all needs cleaning up).",
          "createdAt": "2019-01-02T14:27:38Z",
          "updatedAt": "2019-01-02T14:27:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The \"extract mime type\" change is done. The Content-Type will always be set to \"application/signed-exchange\" for signed exchanges, so no risk of Flash claiming the content, or of executing as script or a stylesheet. It seems unlikely that this content will parse as a script or stylesheet anyway, with the NULs early in the format, but XCTO does a better job of blocking stylesheets than adding the content type to the [\"Should response to request be blocked due to its MIME type?\"](https://fetch.spec.whatwg.org/#should-response-to-request-be-blocked-due-to-mime-type?) list.\r\n\r\nMike suggests @otherdaniel may have time to review the constraints on the inner resource, but if that's not done by Monday, I think we can merge this anyway and fix up problems as people point them out.",
          "createdAt": "2019-01-10T17:59:25Z",
          "updatedAt": "2019-01-10T17:59:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2ODY5MDYy",
          "commit": {
            "abbreviatedOid": "8c417f9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-20T07:04:50Z",
          "updatedAt": "2018-12-20T07:04:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 355,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMDcwNDU2",
      "title": "go/signedexchange: Rework TestSignedExchange",
      "url": "https://github.com/WICG/webpackage/pull/355",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is the most basic test case, but before this patch it only covered\r\nthe b1 format. Also, we did not have any tests for `ReadExchange()`.\r\n\r\nAfter this patch, it tests all the supported format versions, by using\r\n`ReadExchange()` to deserialize exchanges.",
      "createdAt": "2018-12-20T06:59:31Z",
      "updatedAt": "2018-12-20T07:42:08Z",
      "closedAt": "2018-12-20T07:42:04Z",
      "mergedAt": "2018-12-20T07:42:04Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2ODY4ODc5",
          "commit": {
            "abbreviatedOid": "8f1dca4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-20T07:03:52Z",
          "updatedAt": "2018-12-20T07:03:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2ODc2MzE4",
          "commit": {
            "abbreviatedOid": "8f1dca4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-12-20T07:39:35Z",
          "updatedAt": "2018-12-20T07:39:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 356,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMDg5OTQy",
      "title": "go/signedexchange: Run signedexchange tests against all supported versions",
      "url": "https://github.com/WICG/webpackage/pull/356",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This patch turns all existing tests in signedexchange_test.go\r\ninto grouped tests parameterized by format version.",
      "createdAt": "2018-12-20T08:37:47Z",
      "updatedAt": "2018-12-21T06:22:22Z",
      "closedAt": "2018-12-21T06:22:17Z",
      "mergedAt": "2018-12-21T06:22:17Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@hajimehoshi WDYT?",
          "createdAt": "2018-12-21T06:03:36Z",
          "updatedAt": "2018-12-21T06:03:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2ODkzMTk0",
          "commit": {
            "abbreviatedOid": "0de25ed"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-20T08:43:51Z",
          "updatedAt": "2018-12-20T08:43:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjgxOTc1",
          "commit": {
            "abbreviatedOid": "0de25ed"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm (I didn't know `(*testing.T).Run()`. That's good to know :-)",
          "createdAt": "2018-12-21T06:16:10Z",
          "updatedAt": "2018-12-21T06:16:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 357,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMzY3NTIy",
      "title": "go: [b3] omit request map",
      "url": "https://github.com/WICG/webpackage/pull/357",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit updates the CBOR representation of the exchange headers to\r\nonly contain response map.",
      "createdAt": "2018-12-21T04:11:57Z",
      "updatedAt": "2019-01-06T23:37:39Z",
      "closedAt": "2019-01-06T23:37:39Z",
      "mergedAt": "2019-01-06T23:37:39Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, you would need to update `TestSignedExchange` in signedexchange_test.go since request header is not seen in the deserialized Exchange in 1b3.",
          "createdAt": "2018-12-21T04:34:16Z",
          "updatedAt": "2018-12-21T04:34:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjY5MDcy",
          "commit": {
            "abbreviatedOid": "203be61"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T04:24:49Z",
          "updatedAt": "2018-12-21T04:24:50Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Maybe `e.Version != version.version1b1 && e.Version != version.version1b2` (assuming that future versions don't have the request map)?",
              "createdAt": "2018-12-21T04:24:49Z",
              "updatedAt": "2018-12-21T04:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjY5MTA5",
          "commit": {
            "abbreviatedOid": "203be61"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T04:25:17Z",
          "updatedAt": "2018-12-21T04:25:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Reaching here is a bug of this package, so `panic` would be fine.",
              "createdAt": "2018-12-21T04:25:17Z",
              "updatedAt": "2018-12-21T04:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjcxNzM2",
          "commit": {
            "abbreviatedOid": "203be61"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T04:49:25Z",
          "updatedAt": "2018-12-21T04:56:32Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done.",
              "createdAt": "2018-12-21T04:49:25Z",
              "updatedAt": "2018-12-21T04:56:32Z"
            },
            {
              "originalPosition": 13,
              "body": "Done.",
              "createdAt": "2018-12-21T04:49:33Z",
              "updatedAt": "2018-12-21T04:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjcyODgy",
          "commit": {
            "abbreviatedOid": "fb57e7d"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-21T05:00:40Z",
          "updatedAt": "2018-12-21T05:00:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3Mjc2MTE1",
          "commit": {
            "abbreviatedOid": "fb57e7d"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-12-21T05:31:00Z",
          "updatedAt": "2018-12-21T05:31:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MTkxNDA5",
          "commit": {
            "abbreviatedOid": "fb57e7d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This matches #360 as far as I can see.",
          "createdAt": "2019-01-03T21:32:23Z",
          "updatedAt": "2019-01-03T21:32:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 358,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMzcyNzcy",
      "title": "Fix format string errors",
      "url": "https://github.com/WICG/webpackage/pull/358",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-12-21T05:01:53Z",
      "updatedAt": "2018-12-21T05:38:50Z",
      "closedAt": "2018-12-21T05:22:22Z",
      "mergedAt": "2018-12-21T05:22:22Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjczNzUx",
          "commit": {
            "abbreviatedOid": "31e34e9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-21T05:08:06Z",
          "updatedAt": "2018-12-21T05:08:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3Mjc2OTg0",
          "commit": {
            "abbreviatedOid": "31e34e9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2018-12-21T05:38:50Z",
          "updatedAt": "2018-12-21T05:38:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 359,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQxODIyNTcz",
      "title": "Use Fetch's method of extracting a MIME type instead of MIMEsniff.",
      "url": "https://github.com/WICG/webpackage/pull/359",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks for the pointer, @annevk.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/359.html\" title=\"Last updated on Jan 7, 2019, 9:12 PM UTC (51fc87c)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/359/80005f0...jyasskin:51fc87c.html\" title=\"Last updated on Jan 7, 2019, 9:12 PM UTC (51fc87c)\">Diff</a>",
      "createdAt": "2019-01-02T19:06:58Z",
      "updatedAt": "2019-01-10T00:06:45Z",
      "closedAt": "2019-01-10T00:06:41Z",
      "mergedAt": "2019-01-10T00:06:41Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "If you indeed want to include parameters you want to omit the double quotes, per discussion in https://github.com/whatwg/mimesniff/issues/52. Typically these kind of checks ignore parameters however, so you might want to add a note to that effect and carefully test for it. (I'm actually not aware of a place where we do a literal check.)",
          "createdAt": "2019-01-04T08:18:05Z",
          "updatedAt": "2019-01-04T08:18:05Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, if everyone else ignores parameters, we will here too. Done and thanks.",
          "createdAt": "2019-01-04T18:14:28Z",
          "updatedAt": "2019-01-04T18:14:28Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@nyaxt @kinu FYI, this changes the `application/cert-chain+cbor` MIME type check to allow and ignore parameters.",
          "createdAt": "2019-01-10T00:05:57Z",
          "updatedAt": "2019-01-10T00:05:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4OTM4MDI5",
          "commit": {
            "abbreviatedOid": "e8272d4"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-03T09:19:17Z",
          "updatedAt": "2019-01-03T09:21:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It should be either a MIME type or failure at this point.",
              "createdAt": "2019-01-03T09:19:17Z",
              "updatedAt": "2019-01-07T21:12:31Z"
            },
            {
              "originalPosition": 19,
              "body": "I suspect you want to return the essence of the returned MIME type, meaning this will have to be slightly more involved. (It was a little ambiguous already. E.g., do parameters matter?)",
              "createdAt": "2019-01-03T09:21:12Z",
              "updatedAt": "2019-01-07T21:12:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MTA3Nzg0",
          "commit": {
            "abbreviatedOid": "e8272d4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks for checking this!",
          "createdAt": "2019-01-03T17:28:06Z",
          "updatedAt": "2019-01-03T17:35:40Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Whoops, thanks!",
              "createdAt": "2019-01-03T17:28:06Z",
              "updatedAt": "2019-01-07T21:12:31Z"
            },
            {
              "originalPosition": 19,
              "body": "I intended to forbid parameters here, since https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#internet-media-type-applicationcert-chaincbor doesn't define any. I think the current text accomplishes that? If you think it's better to ignore parameters (by using the essence), I'm happy to do that instead.",
              "createdAt": "2019-01-03T17:31:08Z",
              "updatedAt": "2019-01-07T21:12:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 360,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQxODg1NTAy",
      "title": "Rely on variants",
      "url": "https://github.com/WICG/webpackage/pull/360",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This depends on https://github.com/httpwg/http-extensions/pull/744. @mnot should probably take a look.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/360.html\" title=\"Last updated on Jan 7, 2019, 8:56 PM UTC (c7afd7d)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/360/67ecc93...jyasskin:c7afd7d.html\" title=\"Last updated on Jan 7, 2019, 8:56 PM UTC (c7afd7d)\">Diff</a>",
      "createdAt": "2019-01-03T01:03:04Z",
      "updatedAt": "2019-01-07T21:10:37Z",
      "closedAt": "2019-01-07T21:10:32Z",
      "mergedAt": "2019-01-07T21:10:32Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjQ5Njk5",
          "commit": {
            "abbreviatedOid": "17ff994"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-06T23:21:42Z",
          "updatedAt": "2019-01-06T23:36:15Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Should we clarify that they are response headers to align with your other edits?",
              "createdAt": "2019-01-06T23:21:42Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjU2OTg5",
          "commit": {
            "abbreviatedOid": "17ff994"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T01:36:58Z",
          "updatedAt": "2019-01-07T01:37:06Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "I think we ban POST method by this \"not safe\" check. (POST is actually cachable per https://tools.ietf.org/html/rfc7231#section-4.2.3 ). Should we keep this check?",
              "createdAt": "2019-01-07T01:36:58Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjY5OTE2",
          "commit": {
            "abbreviatedOid": "17ff994"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T03:44:30Z",
          "updatedAt": "2019-01-07T03:47:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes. I'll do that in the morning before I merge.",
              "createdAt": "2019-01-07T03:44:30Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            },
            {
              "originalPosition": 165,
              "body": "This line did ban POST, but since the headers can't encode a method anymore, I don't think we need to keep it.",
              "createdAt": "2019-01-07T03:45:45Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5Njc3NTA5",
          "commit": {
            "abbreviatedOid": "17ff994"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T05:00:58Z",
          "updatedAt": "2019-01-07T05:00:58Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Ah I missed that. Thanks for the explanation :)",
              "createdAt": "2019-01-07T05:00:58Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 361,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyMTE1NTc4",
      "title": "Restrict the browser's request's method to GET or HEAD.",
      "url": "https://github.com/WICG/webpackage/pull/361",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Since this is after a 303 redirect, I think the method can only be something else if a service worker messes with things, but we should prevent service workers from getting us into a weird state.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/361.html\" title=\"Last updated on Jan 3, 2019, 9:28 PM UTC (e33e03f)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/361/8f7d57c...jyasskin:e33e03f.html\" title=\"Last updated on Jan 3, 2019, 9:28 PM UTC (e33e03f)\">Diff</a>",
      "createdAt": "2019-01-03T21:28:02Z",
      "updatedAt": "2019-01-07T21:11:31Z",
      "closedAt": "2019-01-07T21:11:28Z",
      "mergedAt": "2019-01-07T21:11:28Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @kinu @horo-t ",
          "createdAt": "2019-01-06T23:37:19Z",
          "updatedAt": "2019-01-06T23:37:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjUwMzIw",
          "commit": {
            "abbreviatedOid": "e33e03f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-06T23:36:46Z",
          "updatedAt": "2019-01-06T23:36:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 363,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyNTQ0Njg0",
      "title": "verifier.go: Reject incomplete responses",
      "url": "https://github.com/WICG/webpackage/pull/363",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is part of #362.",
      "createdAt": "2019-01-07T03:35:40Z",
      "updatedAt": "2019-01-11T05:56:50Z",
      "closedAt": "2019-01-11T01:40:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Response completeness is no longer required. (#368)\r\nClosing.",
          "createdAt": "2019-01-11T01:40:17Z",
          "updatedAt": "2019-01-11T01:40:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjgwMjI0",
          "commit": {
            "abbreviatedOid": "9b4ae79"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-01-07T05:26:13Z",
          "updatedAt": "2019-01-07T05:26:19Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "`http.StatusPartialContent`",
              "createdAt": "2019-01-07T05:26:14Z",
              "updatedAt": "2019-01-07T05:26:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 364,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyNTQ0OTAx",
      "title": "[b3] go: Verify if the response is complete",
      "url": "https://github.com/WICG/webpackage/pull/364",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@irori We should merge the changes w/ https://github.com/WICG/webpackage/pull/363",
      "createdAt": "2019-01-07T03:37:44Z",
      "updatedAt": "2019-01-09T07:10:52Z",
      "closedAt": "2019-01-09T07:10:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing because of #368 ",
          "createdAt": "2019-01-09T07:10:47Z",
          "updatedAt": "2019-01-09T07:10:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 367,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyNTgwMjg5",
      "title": "[b3] go: Verify if the response is cacheable by a shared cache",
      "url": "https://github.com/WICG/webpackage/pull/367",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-07T08:01:07Z",
      "updatedAt": "2019-01-10T01:20:38Z",
      "closedAt": "2019-01-10T01:20:32Z",
      "mergedAt": "2019-01-10T01:20:32Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@hajimehoshi PTL, this one is not blocked by spec discussions.",
          "createdAt": "2019-01-09T07:07:01Z",
          "updatedAt": "2019-01-09T07:07:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMDg0MzIz",
          "commit": {
            "abbreviatedOid": "f62ac8e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-08T03:51:22Z",
          "updatedAt": "2019-01-08T03:51:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjQ4NDIy",
          "commit": {
            "abbreviatedOid": "f62ac8e"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-01-09T09:59:39Z",
          "updatedAt": "2019-01-09T09:59:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 368,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzMTkzMjQz",
      "title": "Don't require the enclosed response to be complete #365",
      "url": "https://github.com/WICG/webpackage/pull/368",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-09T02:28:34Z",
      "updatedAt": "2019-01-10T07:23:19Z",
      "closedAt": "2019-01-10T07:23:19Z",
      "mergedAt": "2019-01-10T07:23:19Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDAwMjIx",
          "commit": {
            "abbreviatedOid": "58bf215"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This seems good, but you'll have to rebase.",
          "createdAt": "2019-01-10T00:02:45Z",
          "updatedAt": "2019-01-10T00:02:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 369,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzMjE5MjM3",
      "title": "go: Introduce certurl.NewCertChain",
      "url": "https://github.com/WICG/webpackage/pull/369",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-09T05:51:09Z",
      "updatedAt": "2019-01-09T06:46:42Z",
      "closedAt": "2019-01-09T06:46:34Z",
      "mergedAt": "2019-01-09T06:46:34Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNTg2NDcx",
          "commit": {
            "abbreviatedOid": "dd66cff"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-09T06:26:04Z",
          "updatedAt": "2019-01-09T06:26:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 370,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzMjI5MDYx",
      "title": "gen-signedexchange: Verify generated exchange",
      "url": "https://github.com/WICG/webpackage/pull/370",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "This patch lets gen-signedexchange validate the generated exchange\r\nusing `Verify()`, when `-ignoreErrors` flag is not specified.\r\n\r\nBreaking change: Now `signedexchange.NewExchange` takes request URL as a\r\nstring (not a `*url.URL`), and does not return an error.",
      "createdAt": "2019-01-09T06:53:09Z",
      "updatedAt": "2019-01-11T06:05:48Z",
      "closedAt": "2019-01-11T06:05:31Z",
      "mergedAt": "2019-01-11T06:05:31Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated after #371. PTAL",
          "createdAt": "2019-01-10T09:51:29Z",
          "updatedAt": "2019-01-10T09:51:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNTk0MTY2",
          "commit": {
            "abbreviatedOid": "45548c4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T07:10:03Z",
          "updatedAt": "2019-01-09T07:10:12Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Would you briefly summarize what the logic here is doing? (or factor out a `func` with a name which indicate what it is doing?",
              "createdAt": "2019-01-09T07:10:03Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjEyMTQ1",
          "commit": {
            "abbreviatedOid": "bda71fe"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T08:24:27Z",
          "updatedAt": "2019-01-09T08:24:27Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Added comments and tweaked block structure a bit.",
              "createdAt": "2019-01-09T08:24:27Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjEzNDY5",
          "commit": {
            "abbreviatedOid": "bda71fe"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T08:28:41Z",
          "updatedAt": "2019-01-09T08:28:42Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Noticed that this decodes MI-encoding of e.Payload.  #371 will resolve this.",
              "createdAt": "2019-01-09T08:28:42Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTI1MTAz",
          "commit": {
            "abbreviatedOid": "99fdcbf"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-10T09:59:48Z",
          "updatedAt": "2019-01-10T09:59:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTI1MDc3",
          "commit": {
            "abbreviatedOid": "99fdcbf"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T09:59:43Z",
          "updatedAt": "2019-01-10T10:00:13Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Do we need this check ?",
              "createdAt": "2019-01-10T09:59:43Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNDkxNTMy",
          "commit": {
            "abbreviatedOid": "c08b3d1"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-11T01:46:45Z",
          "updatedAt": "2019-01-11T01:46:45Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ah thanks for the catch. Removed.",
              "createdAt": "2019-01-11T01:46:45Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNTAxNjY5",
          "commit": {
            "abbreviatedOid": "c08b3d1"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-01-11T02:51:24Z",
          "updatedAt": "2019-01-11T02:51:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 371,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzMjQ1OTg5",
      "title": "go: Verify() shouldn't replace Payload",
      "url": "https://github.com/WICG/webpackage/pull/371",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi",
        "nyaxt"
      ],
      "labels": [],
      "body": "Before this patch, `e.Verify()` replaced `e.Payload` with mice-decoded\r\npayload bytes. It's unintuitive that `Verify()` mutates the `Exchange`, so\r\nthis patch lets `Verify()` return the decoded payload in addition to\r\nthe boolean result.",
      "createdAt": "2019-01-09T08:20:16Z",
      "updatedAt": "2019-01-10T09:42:25Z",
      "closedAt": "2019-01-10T09:42:18Z",
      "mergedAt": "2019-01-10T09:42:18Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "This blocks #370.",
          "createdAt": "2019-01-09T08:22:57Z",
          "updatedAt": "2019-01-09T08:22:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjQ4NzU4",
          "commit": {
            "abbreviatedOid": "3de064e"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T10:00:30Z",
          "updatedAt": "2019-01-09T10:00:31Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "We'd want comments about the returning values.",
              "createdAt": "2019-01-09T10:00:30Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDM0Nzc4",
          "commit": {
            "abbreviatedOid": "5718783"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T03:05:42Z",
          "updatedAt": "2019-01-10T03:05:42Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Done.",
              "createdAt": "2019-01-10T03:05:42Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDM3NzAy",
          "commit": {
            "abbreviatedOid": "5718783"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T03:25:02Z",
          "updatedAt": "2019-01-10T03:25:02Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I think `Verify` doesn't have to return a boolean value: how about returning the decoded payload bytes on success, or nil otherwise?",
              "createdAt": "2019-01-10T03:25:02Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDUzNjQ2",
          "commit": {
            "abbreviatedOid": "7fb498f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T05:29:06Z",
          "updatedAt": "2019-01-10T05:29:07Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Done.\r\nI was reluctant to do that since the distinction between an empty slice and nil is subtle, but probably it's just okay.",
              "createdAt": "2019-01-10T05:29:06Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDU0OTg0",
          "commit": {
            "abbreviatedOid": "7fb498f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T05:38:48Z",
          "updatedAt": "2019-01-10T05:38:48Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Ah, I'm really sorry but I missed the case when this function succeeds and the result is empty. Then `Verify` should return a boolean value indicating success. (Using a difference between a nil slice and 0-length slice would be confusing)\r\n\r\nThen the signature of this function would be\r\n\r\n```go\r\nfunc (e *Exchange) Verify(verificationTime time.Time, certFetcher CertFetcher, l *log.Logger) ([]byte, bool)\r\n```\r\n",
              "createdAt": "2019-01-10T05:38:48Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDU2MzUy",
          "commit": {
            "abbreviatedOid": "1030552"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T05:47:49Z",
          "updatedAt": "2019-01-10T05:47:49Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "No problem, done :)",
              "createdAt": "2019-01-10T05:47:49Z",
              "updatedAt": "2019-01-10T05:47:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDYwNzM4",
          "commit": {
            "abbreviatedOid": "1030552"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-01-10T06:15:31Z",
          "updatedAt": "2019-01-10T06:15:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 372,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzNzQ3Nzg5",
      "title": "minor: close brackets in reference to RFC",
      "url": "https://github.com/WICG/webpackage/pull/372",
      "state": "MERGED",
      "author": "rz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-10T16:22:39Z",
      "updatedAt": "2019-01-10T16:27:08Z",
      "closedAt": "2019-01-10T16:27:08Z",
      "mergedAt": "2019-01-10T16:27:07Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMjkzNzcz",
          "commit": {
            "abbreviatedOid": "888fde4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Whoops, thanks.",
          "createdAt": "2019-01-10T16:25:31Z",
          "updatedAt": "2019-01-10T16:25:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 373,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzOTA1NjIw",
      "title": " go: Implement uncached-headers check",
      "url": "https://github.com/WICG/webpackage/pull/373",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "",
      "createdAt": "2019-01-11T04:16:14Z",
      "updatedAt": "2019-01-11T04:53:44Z",
      "closedAt": "2019-01-11T04:53:44Z",
      "mergedAt": "2019-01-11T04:53:44Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNTE1NDEy",
          "commit": {
            "abbreviatedOid": "8d3a6c7"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-11T04:39:33Z",
          "updatedAt": "2019-01-11T04:39:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 374,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0NjUyNDI2",
      "title": "Introduce signed exchange report for distributors",
      "url": "https://github.com/WICG/webpackage/pull/374",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "This change introduces the signed exchange report for distributors discussed at https://github.com/w3c/network-error-logging/issues/99#issuecomment-453421388.\n\nExemple:\n```\n{\n  \"type\": \"network-error\",\n  \"url\": \"https://publisher.example/article.html\",\n  \"age\": 234,\n  \"user_agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) ...\",\n  \"body\": {\n    \"referrer\": \"https://aggregator.example/article.html\",\n    \"sampling_fraction\": 1,\n    \"server_ip\": \"123.122.121.120\",  // The IP address of distributor.example.\n    \"protocol\": \"http/1.1\",\n    \"method\": \"GET\",\n    \"status_code\": 200,\n    \"elapsed_time\": 1234,\n    \"phase\": \"sxg\",\n    \"type\": \"sxg.failed\",\n\n    \"sxg\": {\n      \"outer_url\": \"https://distributor.example/publisher.example/article.html.sxg\",\n      \"inner_url\": \"https://publisher.example/article.html\",\n      \"cert_url\": \"https://distributor.example/publisher.example/cert\"\n    },\n  }\n}\n```\n\nThis spec change requires the new OPTIONAL `additional body` argument of the algorithm of \"Generate a network error report\" of Network Error Logging spec. https://github.com/w3c/network-error-logging/pull/100\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/374.html\" title=\"Last updated on Feb 15, 2019, 2:32 AM UTC (7365813)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/374/aa31685...horo-t:7365813.html\" title=\"Last updated on Feb 15, 2019, 2:32 AM UTC (7365813)\">Diff</a>",
      "createdAt": "2019-01-15T02:06:37Z",
      "updatedAt": "2019-02-28T03:34:50Z",
      "closedAt": "2019-02-27T21:18:20Z",
      "mergedAt": "2019-02-27T21:18:20Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Could you please review again?\r\nI want to start the implementation of this feature in Chromium.",
          "createdAt": "2019-02-07T01:39:58Z",
          "updatedAt": "2019-02-07T01:39:58Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@igrigorik ,  @dcreager  Could you please review this PR?",
          "createdAt": "2019-02-13T00:10:27Z",
          "updatedAt": "2019-02-13T00:10:27Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I closed and reopened this PR to trigger Travis CI which has failed due to xml2rfc bug (https://trac.tools.ietf.org/tools/xml2rfc/trac/ticket/393).",
          "createdAt": "2019-02-15T02:34:41Z",
          "updatedAt": "2019-02-15T02:34:41Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Could you please merge this pull request?\r\n\r\nI have already implemented it in Chromium.\r\nhttps://crrev.com/c/1468855",
          "createdAt": "2019-02-22T02:07:06Z",
          "updatedAt": "2019-02-22T02:07:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTYyMTUw",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T17:27:07Z",
          "updatedAt": "2019-01-28T17:27:08Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "@dcreager In NEL we went with `elapsed-time`? Or is our example outdated in Reporting? \r\n\r\nWe should make sure that keys are consistent. It may make sense to add a non-normative note somewhere in Reporting about conventions we want to enforce?",
              "createdAt": "2019-01-28T17:27:08Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTY1OTIy",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T17:35:14Z",
          "updatedAt": "2019-01-28T17:35:14Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "Outdated example, we went with `elapsed_time`.  TAG recommended `camel_case` for JSON field names.  I like your suggestion of noting the conventions!",
              "createdAt": "2019-01-28T17:35:14Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTcxMTM1",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T17:46:28Z",
          "updatedAt": "2019-01-28T17:46:28Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "@igrigorik do you see `elapsed-time` in the current NEL draft somewhere?  I'm seeing it spelled correctly (`elapsed_time`) everywhere, but want to make sure I didn't miss anything!",
              "createdAt": "2019-01-28T17:46:28Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTgzNzg5",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T18:14:37Z",
          "updatedAt": "2019-01-28T18:14:37Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "Ah, I might be looking at the outdated TR: https://www.w3.org/TR/reporting/#sample-reports",
              "createdAt": "2019-01-28T18:14:37Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTg5MTUw",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T18:26:43Z",
          "updatedAt": "2019-01-28T18:26:44Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "Oh good catch!  Those are still present in the [latest editor's draft](https://w3c.github.io/reporting/#sample-reports) too.",
              "createdAt": "2019-01-28T18:26:43Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0MzMzMjQ1",
          "commit": {
            "abbreviatedOid": "6e4d8ec"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Here's a round of review, but there's more coming.",
          "createdAt": "2019-01-19T00:55:28Z",
          "updatedAt": "2019-01-28T21:29:43Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "A request's URL is a URL record, not an ECMAScript object. You'll need to explicitly run the URL serializer to get a string.",
              "createdAt": "2019-01-19T00:55:28Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 296,
              "body": "This is usually phrased more like \r\n\r\n```html\r\nTo <dfn>queue a signed exchange report</dfn> |report|, the UA MUST:\r\n```\r\n\r\nThat ties into Infra requirements like https://infra.spec.whatwg.org/#algorithms.",
              "createdAt": "2019-01-19T00:58:45Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 7,
              "body": "You don't need this now that you've marked the definition with `data-export`.",
              "createdAt": "2019-01-28T19:38:10Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 6,
              "body": "You shouldn't need this anymore, after https://github.com/w3c/network-error-logging/pull/102. Remember to [update your bikeshed data](https://tabatkins.github.io/bikeshed/#updating-bikeshed) to get the new definition.",
              "createdAt": "2019-01-28T19:39:50Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 301,
              "body": "https://w3c.github.io/network-error-logging/#network-requests says \"For user agents that service requests according to the [FETCH] standard, a network request corresponds to one execution of the HTTP-network fetch algorithm.\", while [outer request](https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/374.html#signed-exchange-report-outer-request) is an instance of https://fetch.spec.whatwg.org/#concept-request, which is shared across multiple executions of the HTTP-network fetch algorithm. @dcreager, what are we actually supposed to pass here?",
              "createdAt": "2019-01-28T21:06:11Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n            |actualResponse|, reporting to |report|, in the context of |request|'s\r\n```\r\n\r\nOr put the `, reporting to...` part at the end.",
              "createdAt": "2019-01-28T21:08:36Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 15,
              "body": "Please pull more of this out of the \"monkeypatch\" section into dedicated algorithms.\r\n\r\nHere, I think it makes sense to have a \"new signed exchange report\" algorithm, which takes the inputs you need to initialize the report.",
              "createdAt": "2019-01-28T21:11:39Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 30,
              "body": "Does it work to have `queuing signed exchange report` take both a report and a result, which reduces the length of these substeps by a step?",
              "createdAt": "2019-01-28T21:15:34Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 32,
              "body": "Pull this whole block into an algorithm, so you can write just\r\n\r\n```bikeshed\r\n1. [=In parallel=], [=wait and queue a report for=] |parsedExchange| and |report|.\r\n```",
              "createdAt": "2019-01-28T21:17:39Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n            of the server from which the user agent received the |actualResponse|,\r\n```",
              "createdAt": "2019-01-28T21:18:36Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 18,
              "body": "This needs to be transmitted as a [response](https://fetch.spec.whatwg.org/#concept-response) field in the Fetch spec. Could you [file a Fetch issue](https://github.com/whatwg/fetch/issues/new) about tracking it, and @ annevk and me? It'll probably have something to do with https://fetch.spec.whatwg.org/#concept-connection-obtain, but I want Anne's feedback before picking a particular layering.",
              "createdAt": "2019-01-28T21:28:17Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 55,
              "body": "Is this an arbitrary `[=string=]`, one from an enumerated set of strings, an object of some type, or something else?",
              "createdAt": "2019-01-28T21:29:17Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Mjk1NDY3",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Ok, that's the rest.",
          "createdAt": "2019-01-28T22:36:20Z",
          "updatedAt": "2019-01-28T23:19:19Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n:: The result of loading signed exchange.\r\n```\r\n\r\nAnd similarly s/A/The/ in the below definitions.",
              "createdAt": "2019-01-28T22:36:20Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 64,
              "body": "Please design this to accommodate signed exchanges with multiple signatures, each one of which might have a `cert-url`.",
              "createdAt": "2019-01-28T22:40:30Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n|response|, reporting to a [=signed exchange report=] |report|, in the context of an\r\n```",
              "createdAt": "2019-01-28T22:49:57Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nwhich indicates an error, as described by the following steps:\r\n```\r\n\r\nor just\r\n\r\n```suggestion\r\nwhich indicates an error:\r\n```",
              "createdAt": "2019-01-28T22:51:34Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 85,
              "body": "Since you take the report itself, why return the failure reason instead of just setting it into the report's result? (I'm not saying to just set it, rather that you should find a reason to decide one way or the other.)",
              "createdAt": "2019-01-28T22:52:10Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 62,
              "body": "What's the default value, before it gets set? And for \"cert URL\" below.",
              "createdAt": "2019-01-28T22:53:44Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 55,
              "body": "Looks like it's enumerated. Please define all the possible values, either as `<dfn>`s or as a [WebIDL enumeration](https://heycam.github.io/webidl/#idl-enums), and have the uses link to those definitions.\r\n\r\n@dcreager / @igrigorik, I lean toward using a WebIDL enumeration, since that lets us easily group the values and refer to the set when defining operations' return types, but do you have a preference? Should the defined values include the \"sxg.\" that they'll have as the report's [type](https://w3c.github.io/network-error-logging/#predefined-network-error-types)?",
              "createdAt": "2019-01-28T22:55:08Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 154,
              "body": "@dcreager, how do you feel about abbreviating vs spelling out \"certificate\"?",
              "createdAt": "2019-01-28T23:02:28Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 169,
              "body": "I'm a little worried this'll get stale if [read a body](https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/374.html#reading-a-body) ever grows another kind of error return. Maybe move the definition of the error type into that algorithm?",
              "createdAt": "2019-01-28T23:04:36Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\r\n<dfn>Parsing the Signature header field</dfn> |signatureString|, reporting to a\r\n```\r\n\r\nand probably put it after |client|.",
              "createdAt": "2019-01-28T23:05:20Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 183,
              "body": "Same change to \"returned by the following steps\" as above.",
              "createdAt": "2019-01-28T23:06:47Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 249,
              "body": "```suggestion\r\n|certSha256|, reporting to a [=signed exchange report=] |report|, in the context of an\r\n```",
              "createdAt": "2019-01-28T23:09:26Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 261,
              "body": "```suggestion\r\n    of the server from which the user agent recieved the |certResponse|, if\r\n```",
              "createdAt": "2019-01-28T23:10:08Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 304,
              "body": "Should we abort these steps or send the report as-is? If aborting is right, please add a `Note:` paragraph saying why.",
              "createdAt": "2019-01-28T23:13:58Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 309,
              "body": "```suggestion\r\n    * `outer_url`: |report|'s [=signed exchange report/outer request=]'s\r\n```\r\n\r\nI think?\r\n\r\nOr\r\n\r\n```suggestion\r\n    : `outer_url`\r\n    :: |report|'s [=signed exchange report/outer request=]'s\r\n```",
              "createdAt": "2019-01-28T23:14:45Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 319,
              "body": "Should it be `\"sxg.ok\"` or just `\"ok\"`?",
              "createdAt": "2019-01-28T23:15:51Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 327,
              "body": "Do we need to block all errors when the certificate comes from a different IP than the SXG or just certificate errors? Add a `Note:` paragraph (or a privacy consideration like in https://w3c.github.io/network-error-logging/#privacy-considerations) saying why we block whatever we block.",
              "createdAt": "2019-01-28T23:18:51Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MzYyMzMz",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T03:17:10Z",
          "updatedAt": "2019-01-29T03:17:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Humm.. when I removed this line I saw the error even after updating the bikeshed data.\r\n```\r\nLINE ~1059: No 'dfn' refs found for 'generate a network error report'\r\n```",
              "createdAt": "2019-01-29T03:17:11Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Mzc4MTMw",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T04:59:31Z",
          "updatedAt": "2019-01-29T04:59:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@tabatkins, did I do something wrong? https://github.com/tabatkins/bikeshed-data/commit/913e4ff6ee06e56f604f53a6906c729576fe0c6c incorporated the network-error-logging data but doesn't include this definition. Do I need `data-export=\"\"` instead of just [`data-export`](https://github.com/w3c/network-error-logging/blob/gh-pages/index.html#L1021)?",
              "createdAt": "2019-01-29T04:59:31Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Mzc4NzY4",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for the review!",
          "createdAt": "2019-01-29T05:03:53Z",
          "updatedAt": "2019-01-29T06:01:44Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "When |report|'s [=signed exchange report/result=] is `\"ok\"`, |report body|'s `\"type\"` is `\"sxg.ok\"`.",
              "createdAt": "2019-01-29T05:03:53Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 15,
              "body": "done",
              "createdAt": "2019-01-29T05:04:09Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 19,
              "body": "done",
              "createdAt": "2019-01-29T05:04:14Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 25,
              "body": "done",
              "createdAt": "2019-01-29T05:04:17Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 30,
              "body": "done",
              "createdAt": "2019-01-29T05:04:20Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 32,
              "body": "done",
              "createdAt": "2019-01-29T05:04:23Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 55,
              "body": "done",
              "createdAt": "2019-01-29T05:04:31Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 62,
              "body": "done",
              "createdAt": "2019-01-29T05:04:35Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 64,
              "body": "Done. Changed to `<dfn>cert URL list</dfn>`",
              "createdAt": "2019-01-29T05:04:38Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 84,
              "body": "done",
              "createdAt": "2019-01-29T05:04:47Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 85,
              "body": "It is intended to reduces the length of lines. I wanted to avoid writing ``Set |report|'s [=signed exchange report/result=] to `\"parse_error\"\\` and return a failure.`` many places.\r\nDo you think this is better?",
              "createdAt": "2019-01-29T05:05:01Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 86,
              "body": "done",
              "createdAt": "2019-01-29T05:05:06Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 169,
              "body": "done",
              "createdAt": "2019-01-29T05:05:13Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 180,
              "body": "done",
              "createdAt": "2019-01-29T05:05:18Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 183,
              "body": "done",
              "createdAt": "2019-01-29T05:05:21Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 249,
              "body": "done",
              "createdAt": "2019-01-29T05:05:25Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 261,
              "body": "done",
              "createdAt": "2019-01-29T05:05:29Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 296,
              "body": "done",
              "createdAt": "2019-01-29T05:05:34Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 304,
              "body": "Added `Note:` paragraph.",
              "createdAt": "2019-01-29T05:05:42Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 300,
              "body": "done",
              "createdAt": "2019-01-29T05:05:47Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 309,
              "body": "done",
              "createdAt": "2019-01-29T05:05:49Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 18,
              "body": "Filed https://github.com/whatwg/fetch/issues/863",
              "createdAt": "2019-01-29T05:16:35Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 55,
              "body": "Changed to use `<dfn>`. How about this?",
              "createdAt": "2019-01-29T05:36:03Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 327,
              "body": "Changed to check if the result is \"signature_verification_error\" or \"cert_verification_error\" or \"cert_fetch_error\" or \"cert_parse_error\". And added note.",
              "createdAt": "2019-01-29T05:56:01Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Nzk2MDM5",
          "commit": {
            "abbreviatedOid": "e1b6af5"
          },
          "author": "tabatkins",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T21:35:10Z",
          "updatedAt": "2019-01-29T21:35:10Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Checking with @plinss about this; the only difference from how Bikeshed normally outputs heading-dfns is that Bikeshed includes a `data-lt`, and it might be that Shepherd (@plinss' tool that parses the specs) relies on the presence of that attribute.\r\n\r\n(Boolean vs empty value on `data-export` doesn't matter.)",
              "createdAt": "2019-01-29T21:35:10Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3ODQ4NDA3",
          "commit": {
            "abbreviatedOid": "e1b6af5"
          },
          "author": "tabatkins",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-30T00:05:15Z",
          "updatedAt": "2019-01-30T00:05:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "And fixed, it was a minor bug in Shepherd's scraping logic for ReSpec documents; it was looking for the definition attributes on the *section* rather than the heading (since respec is section-centric). Fixed now, and the definition shows up as of <https://github.com/tabatkins/bikeshed-data/commit/e62a91cf098bc6f293a711660205d5d05cf2e781>",
              "createdAt": "2019-01-30T00:05:15Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3ODc5ODk3",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-30T02:27:17Z",
          "updatedAt": "2019-01-30T02:27:30Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thank you @tabatkins.\r\nI removed this line.\r\nhttps://github.com/WICG/webpackage/pull/374/commits/5ef3228375e6e8f17349aae9c731a7f777dd4e1f",
              "createdAt": "2019-01-30T02:27:17Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3ODgwMTkw",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-30T02:28:50Z",
          "updatedAt": "2019-01-30T02:28:50Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I will remove this after https://github.com/w3c/network-error-logging/pull/100 will be merged.",
              "createdAt": "2019-01-30T02:28:50Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5MDY5OTM5",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-01T13:22:50Z",
          "updatedAt": "2019-02-01T13:22:50Z",
          "comments": [
            {
              "originalPosition": 301,
              "body": "Ping? @dcreager ",
              "createdAt": "2019-02-01T13:22:50Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5NjI2MDMx",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-04T14:56:11Z",
          "updatedAt": "2019-02-04T14:56:12Z",
          "comments": [
            {
              "originalPosition": 301,
              "body": "I think that it should be that [fetch request](https://fetch.spec.whatwg.org/#concept-request) instance that is passed in.  We probably need to update NEL to just be defined in terms of fetch, instead of keeping the currently muddy language that tries to allow NEL to work with non-browser non-fetch HTTP clients.  (So for instance, to update NEL to have it pull out [current URL](https://fetch.spec.whatwg.org/#concept-request-current-url) to fill in the body of the report in a less hand-wavy way.)",
              "createdAt": "2019-02-04T14:56:11Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzQ4NDE5",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T22:08:33Z",
          "updatedAt": "2019-02-07T23:32:57Z",
          "comments": [
            {
              "originalPosition": 388,
              "body": "The inner URL is also a URL record, and needs to be serialized in order to be an ECMAScript String.",
              "createdAt": "2019-02-07T22:08:34Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 385,
              "body": "The [ASCII encoding](https://infra.spec.whatwg.org/#ascii-encode) yields an Infra byte sequence, not an ECMAScript object. It looks like you can just use `The [=URL serializer|serialization=] of ...` directly.",
              "createdAt": "2019-02-07T22:27:17Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 389,
              "body": "This needs to serialize all the URLs and then create an array, perhaps via https://heycam.github.io/webidl/#es-sequence.\r\n\r\nThe whole thing might be simpler if you write a WebIDL dictionary type for this, and then convert it to an ES object all at once.",
              "createdAt": "2019-02-07T22:31:33Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n            [=queue a signed exchange report=] |report| with\r\n```\r\n\r\nI think.",
              "createdAt": "2019-02-07T22:33:05Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 365,
              "body": "Most of the calls look like `queue a signed exchange report |report| with \"...\" as the result`, so let's make the definition look like that too:\r\n\r\n```suggestion\r\nTo <dfn>queue a signed exchange report</dfn> |report| with |result| as the result, the UA MUST:\r\n```",
              "createdAt": "2019-02-07T23:02:26Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 378,
              "body": "Don't use normative language like \"MUST\" in a Note, and try to avoid passive voice (\"be called\") in general. Instead, describe what happens, and ideally link to where it happens. So, what algorithm winds up calling [deliver a network report](https://github.com/w3c/network-error-logging/pull/100) in this case?",
              "createdAt": "2019-02-07T23:06:06Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 40,
              "body": "I'm uncomfortable that it's allowed to be an empty string. https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/374.html#ref-for-signed-exchange-report-result%E2%91%A0, especially, results in a type of just \"sxg.\" in that case. I think you're just using that as a default, so maybe:\r\n\r\n```suggestion\r\n:: The result string of loading signed exchange. This must be unset or one of \"<dfn>`ok`</dfn>\", ...\r\n```",
              "createdAt": "2019-02-07T23:21:01Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 55,
              "body": "Looks fine to me. I'd still like feedback from @dcreager or @igrigorik about whether we ought to include the \"sxg.\" in most of the values, and especially whether we should omit the \"sxg.\" for \"ok\".",
              "createdAt": "2019-02-07T23:32:56Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzc1ODEy",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T23:34:36Z",
          "updatedAt": "2019-02-07T23:36:57Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "That's not quite right: the first \"cert-url\" parameter only has 1 URL, but there may be multiple signature headers, each with its own \"cert-url\".\r\n\r\nDo we need to associate each certificate with its server IP, or is just having an unmatched bag ok?",
              "createdAt": "2019-02-07T23:34:36Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\nstring which indicates an error, as described by the following steps:\r\n```",
              "createdAt": "2019-02-07T23:36:02Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 85,
              "body": "What you have is probably clearer that the result is always set.",
              "createdAt": "2019-02-07T23:36:57Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzc2NTg1",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-07T23:37:34Z",
          "updatedAt": "2019-02-07T23:38:03Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@dcreager, how do you feel about abbreviating vs spelling out \"certificate\"?",
              "createdAt": "2019-02-07T23:37:34Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNDcwODkz",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@jyasskin Thank you for the review. How about this change?",
          "createdAt": "2019-02-08T08:32:20Z",
          "updatedAt": "2019-02-08T09:06:59Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "done",
              "createdAt": "2019-02-08T08:32:20Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 40,
              "body": "done",
              "createdAt": "2019-02-08T08:32:26Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 388,
              "body": "done",
              "createdAt": "2019-02-08T08:33:12Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 385,
              "body": "done",
              "createdAt": "2019-02-08T08:33:15Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 378,
              "body": "Changed to `UA have called [=deliver a network report=] algorithm with the error report`.\r\n\r\nAs @dcreager [says](https://github.com/w3c/network-error-logging/pull/100#discussion_r251683522), unfortunately there is no caller of [deliver a network report](https://github.com/w3c/network-error-logging/pull/100) yet. But I think fetch spec will call it.",
              "createdAt": "2019-02-08T08:35:27Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 389,
              "body": "Changed to ``The [=sequence type=] of the result of [=URL serializer|serialization=] of each element of |report|'s [=signed exchange report/cert URL list=].``\r\nIs this OK?",
              "createdAt": "2019-02-08T08:36:34Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 365,
              "body": "done",
              "createdAt": "2019-02-08T08:49:01Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 55,
              "body": "Changed to ``The list of [=URL=] which first element is the first \"`cert-url`\" parameter of signed exchange, if available. Otherwise, an empty list.``\r\n\r\nI think it is OK, because currently this spec only supports the first cert-url.\r\n\r\nWhen we will support multiple certificates, we must check the all IP address of cert URLs before sending certificate related errors (signature_verification_error, cert_verification_error, cert_fetch_error, cert_parse_error) to avoid cross site information leak. ",
              "createdAt": "2019-02-08T08:50:51Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 77,
              "body": "Done",
              "createdAt": "2019-02-08T08:56:41Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODM5MDYx",
          "commit": {
            "abbreviatedOid": "fc5e25e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Please wait for @igrigorik and/or @dcreager to weigh in on this, but aside from lots of nits, it looks good to me. (And I won't be around to re-review next week.)",
          "createdAt": "2019-02-09T00:50:57Z",
          "updatedAt": "2019-02-09T01:05:25Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n:: The list of [=URLs=] in \"`cert-url`\" parameters for the signed exchange's signatures, if available.\r\n```\r\n\r\nThis definition doesn't have to say that we currently only support one signature.",
              "createdAt": "2019-02-09T00:50:57Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n:: The list of IP addresses of the servers from which the user agent received the certificates listed in [=signed exchange report/cert URL list=].\r\n```",
              "createdAt": "2019-02-09T00:51:54Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 76,
              "body": "```suggestion\r\nreporting to a [=signed exchange report=] |report|, returns an [=exchange=] or a\r\n```",
              "createdAt": "2019-02-09T00:52:25Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\nstring which indicates a [=signed exchange report/result=] as described by the following steps:\r\n```\r\n\r\n?",
              "createdAt": "2019-02-09T00:52:33Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 86,
              "body": "Does the following make reports more clear? Otherwise, I worry people won't know which origin we're talking about.\r\n\r\n```suggestion\r\n    trustworthy origin=], return \"[=signed exchange report/non_secure_distributor=]\".\r\n```",
              "createdAt": "2019-02-09T00:54:06Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\n1. [=Read a body=] from |stream| into |parsedExchange|'s\r\n```",
              "createdAt": "2019-02-09T00:57:06Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\n    this returns an error string, return it.\r\n```\r\n\r\nSince I don't think we identify these strings as errors otherwise.",
              "createdAt": "2019-02-09T00:57:45Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 187,
              "body": "```suggestion\r\n[=signed exchange report=] |report|, returns an [=exchange signature=] or\r\n```",
              "createdAt": "2019-02-09T00:58:23Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 188,
              "body": "Similarly, maybe link to the report result, which lists the possible strings.",
              "createdAt": "2019-02-09T00:58:43Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 255,
              "body": "```suggestion\r\n|certSha256| in the context of an [=environment settings object=] |client|,\r\n```",
              "createdAt": "2019-02-09T00:59:09Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 257,
              "body": "As above to describe the possible errors.",
              "createdAt": "2019-02-09T00:59:46Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 305,
              "body": "This needs rebasing (which will remove the line).",
              "createdAt": "2019-02-09T01:01:42Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 378,
              "body": "```suggestion\r\n    of the server and the |policy| don't match. In this case, the UA has called\r\n```",
              "createdAt": "2019-02-09T01:03:05Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 396,
              "body": "My instinct is that the `type` should just be `\"ok\"` in the success case, and not `\"sxg.ok\"`, to match other successful loads, but I defer to @igrigorik or @dcreager.",
              "createdAt": "2019-02-09T01:04:30Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyNDQ5MzM1",
          "commit": {
            "abbreviatedOid": "fc5e25e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you",
          "createdAt": "2019-02-12T02:10:07Z",
          "updatedAt": "2019-02-12T02:27:38Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Done",
              "createdAt": "2019-02-12T02:10:07Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 61,
              "body": "Done",
              "createdAt": "2019-02-12T02:10:40Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 76,
              "body": "Done",
              "createdAt": "2019-02-12T02:11:00Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 77,
              "body": "Done",
              "createdAt": "2019-02-12T02:11:25Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 86,
              "body": "Sounds good.\r\nDone.",
              "createdAt": "2019-02-12T02:12:32Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 164,
              "body": "Done",
              "createdAt": "2019-02-12T02:12:54Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 166,
              "body": "Done.",
              "createdAt": "2019-02-12T02:13:05Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 187,
              "body": "Done",
              "createdAt": "2019-02-12T02:13:20Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 188,
              "body": "Done",
              "createdAt": "2019-02-12T02:14:57Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 257,
              "body": "Done",
              "createdAt": "2019-02-12T02:16:33Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 255,
              "body": "Done",
              "createdAt": "2019-02-12T02:18:27Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 378,
              "body": "Done",
              "createdAt": "2019-02-12T02:18:45Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 305,
              "body": "Done",
              "createdAt": "2019-02-12T02:24:56Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyOTc5MzU5",
          "commit": {
            "abbreviatedOid": "ff79193"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks good, @horo-t, pending a couple of small nits!  Sorry for the delay in reviewing.",
          "createdAt": "2019-02-13T00:31:54Z",
          "updatedAt": "2019-02-13T00:36:34Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Just merged the NEL issue.",
              "createdAt": "2019-02-13T00:31:54Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 45,
              "body": "I'm okay with that, it actually matches the spelling of the [predefined TLS errors](https://w3c.github.io/network-error-logging/#secure-connection-establishment-errors) in the NEL spec.",
              "createdAt": "2019-02-13T00:33:10Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 396,
              "body": "Agreed.  `ok` should be the standard value for \"everything worked as expected\".  I like the `sxg.` prefix for any non-success results.",
              "createdAt": "2019-02-13T00:35:25Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyOTkxMzg0",
          "commit": {
            "abbreviatedOid": "ff79193"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you.",
          "createdAt": "2019-02-13T01:22:55Z",
          "updatedAt": "2019-02-13T01:31:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Deleted.\r\nBut we need to wait [bikeshed-data](https://github.com/tabatkins/bikeshed-data/) to be updated.",
              "createdAt": "2019-02-13T01:22:55Z",
              "updatedAt": "2019-02-13T01:31:25Z"
            },
            {
              "originalPosition": 396,
              "body": "Done.",
              "createdAt": "2019-02-13T01:27:26Z",
              "updatedAt": "2019-02-13T01:31:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 375,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0Njg3NTUw",
      "title": "Remove go/webpack",
      "url": "https://github.com/WICG/webpackage/pull/375",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PTAL",
      "createdAt": "2019-01-15T06:30:55Z",
      "updatedAt": "2019-01-16T05:41:28Z",
      "closedAt": "2019-01-16T05:41:25Z",
      "mergedAt": "2019-01-16T05:41:25Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkyOTY5NzI4",
          "commit": {
            "abbreviatedOid": "41a40ea"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-16T04:28:15Z",
          "updatedAt": "2019-01-16T04:28:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 377,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ1Njk0MDE5",
      "title": "Define a CAA parameter governing CanSignHttpExchanges cert issuance.",
      "url": "https://github.com/WICG/webpackage/pull/377",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This gives a stronger indication that the domain owner has opted into the new\r\nsecurity risks than just that a CA issued a certificate with the extension.\r\n\r\n@AGWA, how's this look? https://tools.ietf.org/html/draft-ietf-acme-caa-06#section-3 has a MUST, which I've downgraded to a SHOULD here after reading draft-ietf-acme-caa's IANA considerations.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/define-caa/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req); [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/define-caa/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2019-01-18T00:45:27Z",
      "updatedAt": "2019-02-06T19:35:52Z",
      "closedAt": "2019-02-06T19:35:49Z",
      "mergedAt": "2019-02-06T19:35:48Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "still lgtm",
          "createdAt": "2019-01-21T05:56:25Z",
          "updatedAt": "2019-01-21T05:56:25Z"
        },
        {
          "author": "AGWA",
          "authorAssociation": "NONE",
          "body": "As current worded, it's OK for a CA which isn't listed in any issue/issuwild property to issue certificates with the CanSignHttpExchanges extension.  Instead, I'd suggest:\r\n\r\n> CA SHOULD NOT issue certificates with the CanSignHttpExchanges extension defined in {{cross-origin-cert-req}} unless an applicable issue or issuewild property exists for the CA, and the \"cansignhttpexchanges\" parameter is present on the property and is equal to \"yes\"",
          "createdAt": "2019-01-22T19:56:04Z",
          "updatedAt": "2019-01-22T19:56:04Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@AGWA Thanks! Done.",
          "createdAt": "2019-01-22T20:20:32Z",
          "updatedAt": "2019-01-22T20:20:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm hoping one of the certificate experts (@AGWA, @sleevi, @clintwilson) will approve this before I merge it.",
          "createdAt": "2019-01-28T22:13:39Z",
          "updatedAt": "2019-01-28T22:13:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkzOTY3OTUx",
          "commit": {
            "abbreviatedOid": "7a69583"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-18T06:57:58Z",
          "updatedAt": "2019-01-18T06:57:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkzOTY4ODUz",
          "commit": {
            "abbreviatedOid": "7a69583"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-18T07:02:35Z",
          "updatedAt": "2019-01-18T07:02:35Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Am I correct that this only applies to CA who issue certificates via ACME protocol?\r\n\r\n",
              "createdAt": "2019-01-18T07:02:35Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0MTc5NTI4",
          "commit": {
            "abbreviatedOid": "7a69583"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-18T16:32:22Z",
          "updatedAt": "2019-01-18T16:32:23Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "No. All CAs are required to check for and respect CAA (if present) by the Baseline Requirements.\r\n\r\nThis change would require that site operators wishing to obtain a CanSignHttpExchanges certificate take affirmative steps to modify their DNS to indicate consent. Combined with the above requirement, this spec change has the effect of declaring how all CAs must obtain consent to issue these certificates, and declaring the means by which site operators can deny consent. It favors 'defenders' (site operators at risk from a CA using a less-than-ideal validation method or being tricked temporarily) by requiring consent by opt-in, rather than opt-out.",
              "createdAt": "2019-01-18T16:32:23Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0NDUxNjEw",
          "commit": {
            "abbreviatedOid": "d4ba0cc"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-21T05:47:56Z",
          "updatedAt": "2019-01-21T05:47:56Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Thanks for the explanation.",
              "createdAt": "2019-01-21T05:47:56Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1MjE2NDQ5",
          "commit": {
            "abbreviatedOid": "3bb506a"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-22T20:30:43Z",
          "updatedAt": "2019-01-22T20:30:44Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "1) In general, we should avoid SHOULD/SHOULD NOT requirements unless we provide guidance on when there are applicable exceptions. Alternatively, MUST/MUST NOT provides a clearer, unambiguous processing model, modulo what error handling should be (which presumably is MUST NOT issue)\r\n\r\n2) The reference to the BRs may end up being circular. The BRs state the rules for which a CA can include arbitrary extensions (7.1.2.4.), so if there are requirements expressed here, they should trigger the rules of 7.1.2.4 (a) (ii) and 7.1.2.4 (b), and thus require following this spec and whatever it describes.",
              "createdAt": "2019-01-22T20:30:44Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1MjU5MDA0",
          "commit": {
            "abbreviatedOid": "60d4800"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-22T22:16:29Z",
          "updatedAt": "2019-01-22T22:16:29Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I've moved this to the definition of the CanSignHttpExchanges *extension*, where there's no question that we can MUST CAs. Now I don't need to point at the BRs.",
              "createdAt": "2019-01-22T22:16:29Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Mjk5MjIw",
          "commit": {
            "abbreviatedOid": "4a4517a"
          },
          "author": "AGWA",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T22:46:55Z",
          "updatedAt": "2019-01-28T22:46:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I just realized that this wording could be interpreted as allowing a CA to include the extension if just one of the dNSNames in the certificate has `cansignhttpexchanges=yes`. :grimacing: Obviously, the intent is that this parameter must be present for every dNSName.  I'll propose some better wording in a little bit unless someone else beats me to it.",
              "createdAt": "2019-01-28T22:46:55Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MzEwMzIz",
          "commit": {
            "abbreviatedOid": "4a4517a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T23:21:37Z",
          "updatedAt": "2019-01-28T23:21:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "See, this is why I wait. :)",
              "createdAt": "2019-01-28T23:21:38Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3NzA0NjE1",
          "commit": {
            "abbreviatedOid": "4a4517a"
          },
          "author": "AGWA",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T18:11:31Z",
          "updatedAt": "2019-01-29T18:11:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "How about:\r\n\r\n> A conforming CA MUST NOT issue certificates with this extension unless, for each dNSName in the subjectAltName extension of the certificate to be issued:\r\n> 1. An \"issue\" or \"issuewild\" CAA property ({{!RFC6844}}) exists that authorizes the CA to issue the certificate; and\r\n> 2. The \"cansignhttpexchanges\" parameter ({{caa-cansignhttpexchanges}}) is present on the property and is equal to \"yes\"",
              "createdAt": "2019-01-29T18:11:32Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3ODU3NDg4",
          "commit": {
            "abbreviatedOid": "badcb29"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-30T00:43:10Z",
          "updatedAt": "2019-01-30T00:43:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done. RFC6844 manages to avoid saying that a certificate's domains are listed in the dNSName, but if saying it here is a problem, we have plenty of time to revise the wording.",
              "createdAt": "2019-01-30T00:43:10Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk4Mzk0NTE2",
          "commit": {
            "abbreviatedOid": "badcb29"
          },
          "author": "AGWA",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-31T01:53:38Z",
          "updatedAt": "2019-01-31T01:53:39Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I cribbed the \"each dNSName in the subjectAltName extension\" wording from the BR's section on CAA so it should be solid.",
              "createdAt": "2019-01-31T01:53:38Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 379,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2OTU4MDgw",
      "title": "[WIP] Variants",
      "url": "https://github.com/WICG/webpackage/pull/379",
      "state": "OPEN",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The implementation is not finished yet. Not all tests pass.\r\n\r\nI used `header.ParseValueAndParams` as the counterpart of `ParseParameterisedList`, but I feel like I'd need to implement the counterpart myself.",
      "createdAt": "2019-01-23T12:56:24Z",
      "updatedAt": "2019-02-15T02:01:40Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR just implements `variants.MatchRequest`. Let's discuss how to implement actual usages later.\r\n\r\nPTAL",
          "createdAt": "2019-01-25T08:04:51Z",
          "updatedAt": "2019-01-25T08:04:51Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated my Chromium-side patch (https://crrev.com/c/1426205) fixing some TODOs and adding more tests. Would you reflect the diff into this PR? Thanks!",
          "createdAt": "2019-01-29T04:16:06Z",
          "updatedAt": "2019-01-29T04:16:06Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. It looks like I'd need to implement `MatchesMimeType` in Go. I couldn't find a third-party library that does the same thing.",
          "createdAt": "2019-02-14T10:41:45Z",
          "updatedAt": "2019-02-14T10:41:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDU1MzQw",
          "commit": {
            "abbreviatedOid": "5023f85"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T02:01:40Z",
          "updatedAt": "2019-02-15T02:01:40Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Please use `structuredheader.ParseListOfLists` (added at #395)",
              "createdAt": "2019-02-15T02:01:40Z",
              "updatedAt": "2019-02-15T02:01:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 380,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MDUzNjU0",
      "title": "Update the references to header-structure to -09.",
      "url": "https://github.com/WICG/webpackage/pull/380",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/update-structured-headers/draft-yasskin-http-origin-signed-responses.html.",
      "createdAt": "2019-01-23T17:27:54Z",
      "updatedAt": "2019-01-23T18:49:41Z",
      "closedAt": "2019-01-23T18:49:36Z",
      "mergedAt": "2019-01-23T18:49:36Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1Njc4MDA4",
          "commit": {
            "abbreviatedOid": "bc21bcb"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-23T18:35:15Z",
          "updatedAt": "2019-01-23T18:40:15Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "In the non-diff above: \"This specification gives no meaning to the identifier itself\". Per httpwg/http-extensions#720, you may want to update this to \"the primary identifier itself\".",
              "createdAt": "2019-01-23T18:35:15Z",
              "updatedAt": "2019-01-23T18:40:15Z"
            },
            {
              "originalPosition": 105,
              "body": "Ditto the next two paragraphs. Not sure if you want to stick \"primary\" in front of all of them, because too verbose. Maybe the first instance per para.",
              "createdAt": "2019-01-23T18:38:30Z",
              "updatedAt": "2019-01-23T18:40:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1NjgzNjcx",
          "commit": {
            "abbreviatedOid": "bc21bcb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-23T18:47:34Z",
          "updatedAt": "2019-01-23T18:47:34Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Hm, https://github.com/httpwg/http-extensions/commit/3c96a9b14e82f0356f09ac680a2943bdca9830fc then removes that term in favor of \"token\". I think I'm going to keep just \"identifier\" here, since I think it's clear enough that it refers to the parameterised thing, and not any of the parameters, but @mnot FYI in case you want dependent specs to do something else.\r\n\r\nThanks for pointing out the question though!",
              "createdAt": "2019-01-23T18:47:34Z",
              "updatedAt": "2019-01-23T18:47:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 381,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MDY3NzU2",
      "title": "Add a privacy consideration about watermarking.",
      "url": "https://github.com/WICG/webpackage/pull/381",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @youennf for describing this risk.\r\n\r\nPreview at https://jyasskin.github.io/webpackage/watermarking/draft-yasskin-http-origin-signed-responses.html#priv-watermarking.",
      "createdAt": "2019-01-23T18:16:05Z",
      "updatedAt": "2019-03-15T21:39:49Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk4NDIyNTky",
          "commit": {
            "abbreviatedOid": "a9e3375"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-31T04:43:54Z",
          "updatedAt": "2019-01-31T04:43:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 382,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MDg3MjA3",
      "title": "Update the TLS reference to the final RFC.",
      "url": "https://github.com/WICG/webpackage/pull/382",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "idnits caught that I'd forgotten to do this when TLS was published.",
      "createdAt": "2019-01-23T19:24:02Z",
      "updatedAt": "2019-01-23T19:54:19Z",
      "closedAt": "2019-01-23T19:54:16Z",
      "mergedAt": "2019-01-23T19:54:16Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 383,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MTM5Mjk1",
      "title": "Bound validity periods to 90 days.",
      "url": "https://github.com/WICG/webpackage/pull/383",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is not necessarily the limit we'll want in the long run, but it\r\nhelps ensure that any future changes can go into effect reasonably\r\nquickly.\r\n\r\nI won't submit this until I have some indication that the folks who have already started experimenting with signed exchanges can handle 90-day certificates.\r\n\r\n@clintwilson, I want to make sure this doesn't cause any problems for you, since I believe Digicert has been issuing certificates with validity periods longer than 90 days. I don't intend to declare that any of your existing certificates are out of bounds.\r\n\r\n@AGWA, this isn't intended to stop discussion on #378, just to put _some_ limit in place while we figure out what the right limit is.\r\n\r\nPreview: https://jyasskin.github.io/webpackage/90-day-lifetime/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req\r\nDiff: https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/90-day-lifetime/draft-yasskin-http-origin-signed-responses.txt",
      "createdAt": "2019-01-23T22:32:15Z",
      "updatedAt": "2019-02-08T19:41:46Z",
      "closedAt": "2019-02-08T19:41:43Z",
      "mergedAt": "2019-02-08T19:41:43Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "clintwilson",
          "authorAssociation": "NONE",
          "body": "We don't, today, enforce a maximum validity outside of the 825 days for all public TLS certs. It'll require a relatively small change to add a lower max validity, but it's not a major issue. My only concern would be a nearish-term change to that max validity again. Meaning that I'd like to see some very rough consensus on max validity before we start working in that update. \r\nIn the meantime, any validity can be issued today between 1-825 days, so we can support testing efforts with shorter lived certificates immediately.\r\nDoes that seem like a fair approach, or would it be better to have that 90 day enforcement in place first?",
          "createdAt": "2019-01-24T04:28:55Z",
          "updatedAt": "2019-01-24T04:28:55Z"
        },
        {
          "author": "shigeki",
          "authorAssociation": "NONE",
          "body": "We are now ordering a SXG certificate to Digicert. Shortening its lifetime affects our budget and operation plan for our SXG trial. Please also consider the issuing process with CA because ACME is not used for it.",
          "createdAt": "2019-01-25T01:24:10Z",
          "updatedAt": "2019-01-25T01:24:10Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "> I won't submit this until I have some indication that the folks who have already started experimenting with signed exchanges can handle 90-day certificates.\r\n\r\nIt'd be probably helpful to clarify what should / would happen to the sites that are already experimenting (or ordering) when this change takes effect, and on any other nearish-term changes.",
          "createdAt": "2019-01-25T09:39:07Z",
          "updatedAt": "2019-01-25T09:39:07Z"
        },
        {
          "author": "clintwilson",
          "authorAssociation": "NONE",
          "body": "@shigeki Just a note that ordering for shorter validity will also automatically prorate/decrease the price of the certificate relative to the validity selected. If you need any help with your account or testing, please don't hesitate to reach out.\r\nI think we could also get ACME to work for provisioning if that's beneficial. We'll have to map the inclusion of the extension out of band, so I'd need to come up with a solution there, but otherwise it should be feasible.",
          "createdAt": "2019-01-25T14:15:57Z",
          "updatedAt": "2019-01-25T14:15:57Z"
        },
        {
          "author": "shigeki",
          "authorAssociation": "NONE",
          "body": "@clintwilson Thank for offering your help. We can purchase only one or two years SXG certs via Cyberturst in Japan. \r\n\r\nACME needs challenge and response so that we can do it to fallbackURL if it is online. Currently fallbackURL is implemented as reqeustURL. That has a risk to renew the existing cert in online .\r\n\r\nI think it is too early to limit the lifetime of SXG cert in 90 days for we do not know if it can really operative. \r\n\r\n6.2. Off-path attackers in Security considerations only describes about an attacker who already possesses a valid certificate. We should add the consideration of how much we need to care about misissuance  of CA before discussing SXG cert lifetime. Do we really need to care about a serious CA incident such as DigiNotar in 2011?",
          "createdAt": "2019-01-28T01:09:07Z",
          "updatedAt": "2019-01-28T01:09:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@shigeki Thanks for the feedback and for continuing the conversation via @sisidovski. It looks like you've found a way to get a [<1-year certificate](https://crt.sh/?id=1177695640) that matches the timeline I added here since your comment.\r\n\r\nI wrote up some considerations at https://github.com/WICG/webpackage/issues/378#issuecomment-459831551 that I think mean we should go for a 90-day max-lifetime for this year, and the other 2 people who voted, agreed. Given that, I'm going to merge this change.",
          "createdAt": "2019-02-08T19:37:51Z",
          "updatedAt": "2019-02-08T19:37:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 384,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MjMzMzgw",
      "title": "go: Update verifier to b3 spec",
      "url": "https://github.com/WICG/webpackage/pull/384",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Update spec comments\r\n- Headers must contain `Content-Type` (#354)\r\n- Check request method only for b1 and b2",
      "createdAt": "2019-01-24T07:59:06Z",
      "updatedAt": "2019-01-25T01:40:12Z",
      "closedAt": "2019-01-25T01:39:39Z",
      "mergedAt": "2019-01-25T01:39:39Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTAwODUw",
          "commit": {
            "abbreviatedOid": "1ba3eb4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-24T08:26:00Z",
          "updatedAt": "2019-01-24T08:26:06Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I was wondering why the loggers are different.",
              "createdAt": "2019-01-24T08:26:00Z",
              "updatedAt": "2019-01-24T08:26:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTI1MjAx",
          "commit": {
            "abbreviatedOid": "1ba3eb4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-24T09:29:05Z",
          "updatedAt": "2019-01-24T09:29:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTMwMjk4",
          "commit": {
            "abbreviatedOid": "1ba3eb4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-24T09:40:48Z",
          "updatedAt": "2019-01-24T09:40:48Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Because I don't want to mess up test output when failure is expected (that's why I use `nullLogger` here), while log message could be useful for debug when failure is unexpected (so `stdoutLogger` in the above).\r\n\r\nBTW probably we should use helper functions for these assertions. https://github.com/WICG/webpackage/pull/385",
              "createdAt": "2019-01-24T09:40:48Z",
              "updatedAt": "2019-01-24T09:40:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTQ4NzEx",
          "commit": {
            "abbreviatedOid": "1ba3eb4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-24T10:17:19Z",
          "updatedAt": "2019-01-24T10:17:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 385,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MjU5ODIy",
      "title": "go: Add helper functions for verifier test",
      "url": "https://github.com/WICG/webpackage/pull/385",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-24T09:40:28Z",
      "updatedAt": "2019-01-25T01:51:42Z",
      "closedAt": "2019-01-25T01:51:38Z",
      "mergedAt": "2019-01-25T01:51:38Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTM1MDE0",
          "commit": {
            "abbreviatedOid": "5f25dd8"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-24T09:50:27Z",
          "updatedAt": "2019-01-24T09:50:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTQ5MDY1",
          "commit": {
            "abbreviatedOid": "5f25dd8"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-24T10:18:08Z",
          "updatedAt": "2019-01-24T10:18:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 386,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ4MzQwNDIz",
      "title": "Security considerations for future-dated OCSP responses and stolen private keys.",
      "url": "https://github.com/WICG/webpackage/pull/386",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@sleevi, how's this look?\r\n\r\nPreview at https://jyasskin.github.io/webpackage/future-dated-ocsp/draft-yasskin-http-origin-signed-responses.html#seccons-off-path",
      "createdAt": "2019-01-29T01:01:03Z",
      "updatedAt": "2019-02-06T19:20:40Z",
      "closedAt": "2019-02-06T19:20:35Z",
      "mergedAt": "2019-02-06T19:20:35Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5ODUwMDg3",
          "commit": {
            "abbreviatedOid": "edb54c2"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-04T22:58:40Z",
          "updatedAt": "2019-02-04T23:04:02Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "s/will/should/",
              "createdAt": "2019-02-04T22:58:40Z",
              "updatedAt": "2019-02-06T19:11:17Z"
            },
            {
              "originalPosition": 78,
              "body": "I'm not sure if this PR is the best place to address it, but it does heavily overlap with the OCSP analysis you provided and the discussion of short-lived certs; namely, the security considerations of validation risks to certificates.\r\n\r\nGrossly oversimplifying:\r\n- Because these certificates can be used without being on path, then exploits in validation practices become more useful\r\n- OCSP is reactive, once an issue is detected\r\n- CAA (and lifetimes) are useful in ensuring robustness at time of issuance\r\n- These methods (CAA, OCSP, reduced lifetime) are existing issues that the ecosystem faces; the only difference is in the calculus about being on-path, hence stronger mitigations than the status-quo",
              "createdAt": "2019-02-04T23:03:06Z",
              "updatedAt": "2019-02-06T19:11:17Z"
            },
            {
              "originalPosition": 78,
              "body": "Oh, and I mention it here because private key compromise and validation compromise are similar in the capabilities they grant, with key compromise being less detectable.",
              "createdAt": "2019-02-04T23:03:45Z",
              "updatedAt": "2019-02-06T19:11:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNzUxMTQy",
          "commit": {
            "abbreviatedOid": "edb54c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T19:06:30Z",
          "updatedAt": "2019-02-06T19:11:37Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "It's stronger than \"should\". How about \"a CT log has promised to publish the mis-issued certificate within\"?",
              "createdAt": "2019-02-06T19:06:30Z",
              "updatedAt": "2019-02-06T19:11:37Z"
            },
            {
              "originalPosition": 78,
              "body": "That's a good unifying point. I'm going to send another PR to talk about it after the CAA requirement is merged.",
              "createdAt": "2019-02-06T19:09:57Z",
              "updatedAt": "2019-02-06T19:11:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNzU0Nzg4",
          "commit": {
            "abbreviatedOid": "00a921b"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T19:14:22Z",
          "updatedAt": "2019-02-06T19:14:23Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "SGTM! Yeah, just wanted to call out 'expected'/'required' from 'actual' behaviour :)",
              "createdAt": "2019-02-06T19:14:22Z",
              "updatedAt": "2019-02-06T19:14:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 392,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUwNjM0NjAw",
      "title": "go: Update structuredheader to header-structure-09",
      "url": "https://github.com/WICG/webpackage/pull/392",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Change the refs to draft-ietf-httpbis-header-structure-09\r\n- Use the new \"key\" type for parameter keys\r\n- Identifier was renamed to Token",
      "createdAt": "2019-02-06T05:01:01Z",
      "updatedAt": "2019-02-08T01:26:09Z",
      "closedAt": "2019-02-08T01:25:58Z",
      "mergedAt": "2019-02-08T01:25:58Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzk1NjQy",
          "commit": {
            "abbreviatedOid": "a5b3bce"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T01:01:25Z",
          "updatedAt": "2019-02-08T01:01:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 394,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxMjk2NzYw",
      "title": "Fix #393: Use the right type for the integrity header.",
      "url": "https://github.com/WICG/webpackage/pull/394",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n#exchange-signature-integrity-header, #read-a-body\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/394.html\" title=\"Last updated on Feb 7, 2019, 10:49 PM UTC (d8b73dd)\">Preview</a> (<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/394.html#exchange-signature-integrity-header\" title=\"#exchange-signature-integrity-header\">#exchange-signature-\u2026</a>) (<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/394.html#read-a-body\" title=\"#read-a-body\">#read-a-body</a>) | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/394/3997c75...jyasskin:d8b73dd.html\" title=\"Last updated on Feb 7, 2019, 10:49 PM UTC (d8b73dd)\">Diff</a>",
      "createdAt": "2019-02-07T22:47:56Z",
      "updatedAt": "2019-02-08T01:43:37Z",
      "closedAt": "2019-02-08T01:43:30Z",
      "mergedAt": "2019-02-08T01:43:30Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzg0Mzcw",
          "commit": {
            "abbreviatedOid": "d8b73dd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T00:09:43Z",
          "updatedAt": "2019-02-08T00:09:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzk1NzUy",
          "commit": {
            "abbreviatedOid": "d8b73dd"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T01:01:55Z",
          "updatedAt": "2019-02-08T01:01:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 395,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxMzYzMTE4",
      "title": "go: Add structuredheader.ParseListOfLists",
      "url": "https://github.com/WICG/webpackage/pull/395",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will be used to parse Variant / Variant-Key headers.",
      "createdAt": "2019-02-08T06:17:32Z",
      "updatedAt": "2019-02-15T01:39:51Z",
      "closedAt": "2019-02-15T01:39:26Z",
      "mergedAt": "2019-02-15T01:39:26Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMTA3Nzg5",
          "commit": {
            "abbreviatedOid": "b40906e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T13:37:07Z",
          "updatedAt": "2019-02-11T13:42:25Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Style nit: https://golang.org/doc/effective_go.html#mixed-caps\r\n\r\nNote to self: I was going to comment `innerList := []Item{}`, but found https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices",
              "createdAt": "2019-02-11T13:37:07Z",
              "updatedAt": "2019-02-12T01:34:09Z"
            },
            {
              "originalPosition": 91,
              "body": "subCamelCase (for other vars too. sorry, should have caught in earlier reviews)",
              "createdAt": "2019-02-11T13:38:17Z",
              "updatedAt": "2019-02-12T01:34:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyNDQwNDEw",
          "commit": {
            "abbreviatedOid": "b40906e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-12T01:36:57Z",
          "updatedAt": "2019-02-12T01:37:50Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Done",
              "createdAt": "2019-02-12T01:36:57Z",
              "updatedAt": "2019-02-12T01:37:50Z"
            },
            {
              "originalPosition": 91,
              "body": "Oops, done.",
              "createdAt": "2019-02-12T01:37:12Z",
              "updatedAt": "2019-02-12T01:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyNDQxODQx",
          "commit": {
            "abbreviatedOid": "b5d64ea"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-12T01:43:52Z",
          "updatedAt": "2019-02-12T01:43:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 396,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNTc5NjA5",
      "title": "Don't require CAs to cap lifetime or check CAA until May 1.",
      "url": "https://github.com/WICG/webpackage/pull/396",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This makes it clear that existing CAs aren't breaking any rules just because I changed the draft.",
      "createdAt": "2019-02-08T19:53:35Z",
      "updatedAt": "2019-03-01T17:43:05Z",
      "closedAt": "2019-03-01T17:42:58Z",
      "mergedAt": "2019-03-01T17:42:58Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It was @clintwilson's spot, to be clear. :)",
          "createdAt": "2019-02-08T20:09:57Z",
          "updatedAt": "2019-02-08T20:09:57Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI this updates #377 for #383. (just for the auto-backlinks)",
          "createdAt": "2019-02-21T02:18:11Z",
          "updatedAt": "2019-02-21T02:18:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNzYxMDQw",
          "commit": {
            "abbreviatedOid": "b63bd5f"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Good spot.\r\n\r\nWhile certificate lifetimes can be 'easily' changed by altering CA's certificate issuing profile, the CAA enforcement will actually require changes to the validation infrastructure, so it makes sense to clearly phase this in for CAs that have or are implementing support, while also setting clear expectations about what the end state will look like.",
          "createdAt": "2019-02-08T19:57:49Z",
          "updatedAt": "2019-02-08T19:57:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 398,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzMjg4NDc3",
      "title": "dump-signedexchange: make validation success/failure more obvious",
      "url": "https://github.com/WICG/webpackage/pull/398",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Prints validation result at the top\r\n- Adds a blank line between validation result and dump\r\n\r\nFixes #389.",
      "createdAt": "2019-02-15T02:24:20Z",
      "updatedAt": "2019-02-15T05:25:22Z",
      "closedAt": "2019-02-15T05:25:16Z",
      "mergedAt": "2019-02-15T05:25:16Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDg0Njcx",
          "commit": {
            "abbreviatedOid": "5a5c7b9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-15T05:23:11Z",
          "updatedAt": "2019-02-15T05:23:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 401,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2OTI5NjA0",
      "title": "Add an example of Signed Exchange Report",
      "url": "https://github.com/WICG/webpackage/pull/401",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/WICG/webpackage/issues/400\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/401.html\" title=\"Last updated on Mar 5, 2019, 5:06 AM UTC (544592e)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/401/af43527...horo-t:544592e.html\" title=\"Last updated on Mar 5, 2019, 5:06 AM UTC (544592e)\">Diff</a>",
      "createdAt": "2019-02-28T04:37:32Z",
      "updatedAt": "2019-03-06T22:46:14Z",
      "closedAt": "2019-03-06T22:46:14Z",
      "mergedAt": "2019-03-06T22:46:14Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Please review this.",
          "createdAt": "2019-02-28T04:39:14Z",
          "updatedAt": "2019-02-28T04:39:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA5NzAwNTI3",
          "commit": {
            "abbreviatedOid": "8e7e75b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-01T17:35:37Z",
          "updatedAt": "2019-03-01T18:28:50Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Use one of the assigned example IPv4 addresses from https://tools.ietf.org/html/rfc5737#section-3 or IPv6 addresses from https://tools.ietf.org/html/rfc3849#section-2, for example, `192.0.2.42`.",
              "createdAt": "2019-03-01T17:35:38Z",
              "updatedAt": "2019-03-05T05:05:52Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n    If a [=NEL policy=] was received from the distributor's origin, `distributor.example`, this step\r\n```",
              "createdAt": "2019-03-01T17:39:35Z",
              "updatedAt": "2019-03-05T05:05:52Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n    will send the following JSON data to describe an invalid signature:\r\n```\r\n\r\nI'm not tied to using an invalid signature as the error type, but I think I'd like to say something about the kind of error.",
              "createdAt": "2019-03-01T17:49:10Z",
              "updatedAt": "2019-03-05T05:05:52Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n        \"type\": \"sxg.signature_verification_error\",\r\n```\r\n\r\n`sxg.failed` happens in pretty specific cases that don't seem likely to apply to the rest of this example.",
              "createdAt": "2019-03-01T17:50:12Z",
              "updatedAt": "2019-03-05T05:05:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNDkzNjk4",
          "commit": {
            "abbreviatedOid": "8e7e75b"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-05T05:02:07Z",
          "updatedAt": "2019-03-05T05:07:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Done",
              "createdAt": "2019-03-05T05:02:07Z",
              "updatedAt": "2019-03-05T05:07:33Z"
            },
            {
              "originalPosition": 10,
              "body": "Done",
              "createdAt": "2019-03-05T05:02:34Z",
              "updatedAt": "2019-03-05T05:07:33Z"
            },
            {
              "originalPosition": 20,
              "body": "Done",
              "createdAt": "2019-03-05T05:03:11Z",
              "updatedAt": "2019-03-05T05:07:33Z"
            },
            {
              "originalPosition": 26,
              "body": "Done",
              "createdAt": "2019-03-05T05:03:25Z",
              "updatedAt": "2019-03-05T05:07:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 404,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYwNjUyMDEx",
      "title": "go: Add strucured header writer",
      "url": "https://github.com/WICG/webpackage/pull/404",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds ToString() method to the structured header types, and\r\nuses it from signer.go.",
      "createdAt": "2019-03-13T07:30:09Z",
      "updatedAt": "2019-03-15T01:04:22Z",
      "closedAt": "2019-03-15T01:04:18Z",
      "mergedAt": "2019-03-15T01:04:18Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNzk1MTg2",
          "commit": {
            "abbreviatedOid": "92da76c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-13T07:41:15Z",
          "updatedAt": "2019-03-13T07:41:16Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "`String` is more idiomatic in Go.",
              "createdAt": "2019-03-13T07:41:15Z",
              "updatedAt": "2019-03-13T08:55:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzODAyMjY5",
          "commit": {
            "abbreviatedOid": "92da76c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-13T08:04:49Z",
          "updatedAt": "2019-03-13T08:04:49Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Doesn't `String()` usually return just a `string`? This returns an `error` too.",
              "createdAt": "2019-03-13T08:04:49Z",
              "updatedAt": "2019-03-13T08:55:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzODE1OTAx",
          "commit": {
            "abbreviatedOid": "92da76c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-13T08:41:50Z",
          "updatedAt": "2019-03-13T08:41:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Right, but using `To` is not common in Go.\r\n\r\nThere is an actual usecase of `String` that also returns error: https://godoc.org/golang.org/x/text/encoding#Decoder.String",
              "createdAt": "2019-03-13T08:41:50Z",
              "updatedAt": "2019-03-13T08:55:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzODIyMzk3",
          "commit": {
            "abbreviatedOid": "3b2b24a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-13T08:56:55Z",
          "updatedAt": "2019-03-13T08:56:56Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Got it, thanks for finding the example. Done.",
              "createdAt": "2019-03-13T08:56:55Z",
              "updatedAt": "2019-03-13T08:56:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzODg1MzM1",
          "commit": {
            "abbreviatedOid": "3b2b24a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-03-13T11:07:45Z",
          "updatedAt": "2019-03-13T11:07:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE0ODI2NDY5",
          "commit": {
            "abbreviatedOid": "3b2b24a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-15T00:42:44Z",
          "updatedAt": "2019-03-15T00:42:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 406,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYxNzI5NDYz",
      "title": "Define -impl-03",
      "url": "https://github.com/WICG/webpackage/pull/406",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See #350.\r\n\r\nDoes what's here match what we actually implemented?\r\n\r\nI'm thinking of also removing [`Accept-Signature`](https://jyasskin.github.io/webpackage/define-03/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#accept-signature) and [transferring a signed exchange as a same-origin response](https://jyasskin.github.io/webpackage/define-03/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#same-origin-response). Do you think we'll want to implement those with the definitions here before we go to -b4?",
      "createdAt": "2019-03-15T23:57:00Z",
      "updatedAt": "2019-07-03T23:54:21Z",
      "closedAt": "2019-07-03T23:54:17Z",
      "mergedAt": "2019-07-03T23:54:17Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'll add a mention that [the Variants-04 header implies variants-05 processing](https://groups.google.com/a/chromium.org/d/topic/webpackage-dev/KTKvQTT9FKI/discussion) in a future PR, after variants-05 is published.",
          "createdAt": "2019-03-20T20:32:20Z",
          "updatedAt": "2019-03-20T20:32:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2OTcwNzgz",
          "commit": {
            "abbreviatedOid": "34123d8"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't think AMP's first signer & SXG cache will produce or consume same-origin responses _or_ PUSH_PROMISEs in the near term. I can't speak for Chromium folks.",
          "createdAt": "2019-03-20T20:41:59Z",
          "updatedAt": "2019-03-20T22:05:45Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Perhaps rephrase \"an HTTP response (including content negotiation information)\", for clarity later on that the conneg gets signed over.",
              "createdAt": "2019-03-20T20:41:59Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 440,
              "body": "Oops, this and `Variant-Key` are not actually versioned AMP-side, so this snapshot paid off. Leave it as-is here; I'll fix that in our impl.",
              "createdAt": "2019-03-20T21:58:55Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 589,
              "body": "Should header-structure 07 -> 09 be in this changelog somewhere?",
              "createdAt": "2019-03-20T22:03:56Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3NTYyNTkz",
          "commit": {
            "abbreviatedOid": "34123d8"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-22T01:46:56Z",
          "updatedAt": "2019-03-22T01:47:43Z",
          "comments": [
            {
              "originalPosition": 500,
              "body": "Does this imply that implementation must not fallback-redirect if they don't match?\r\n",
              "createdAt": "2019-03-22T01:46:56Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 547,
              "body": "`integrity=\"digest/mi-sha256-03\"`?",
              "createdAt": "2019-03-22T01:47:01Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDQ1MTgy",
          "commit": {
            "abbreviatedOid": "9b01a79"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-23T16:14:41Z",
          "updatedAt": "2019-03-23T16:16:54Z",
          "comments": [
            {
              "originalPosition": 395,
              "body": "Should we align to draft-yasskin-http-origin-signed-responses.md here to rely on \"The above requirements on CAs...\" paragraph?",
              "createdAt": "2019-03-23T16:14:41Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIyOTcwNDA1",
          "commit": {
            "abbreviatedOid": "972ce5e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I've also removed Accept-Signature and same-origin responses for this -impl draft.",
          "createdAt": "2019-04-04T19:53:47Z",
          "updatedAt": "2019-04-04T20:26:05Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This is the text from the main spec, so if we change it, we should change it in both places. The text below about the dedicated format says content negotiation is encoded with Variants, which is a response header, so I'm inclined not to change anything.",
              "createdAt": "2019-04-04T19:53:47Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 395,
              "body": "draft-yasskin-http-origin-signed-responses is written the way it is so that all the bits that won't go into the final RFC are sitting in one place. That makes it harder to read than it needs to be, so I moved the timeline up into the main section for the -impl draft. I think this is fine?",
              "createdAt": "2019-04-04T19:55:19Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 440,
              "body": "Thanks.",
              "createdAt": "2019-04-04T19:55:31Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 500,
              "body": "It does imply that, and I think that's the right choice: the server has full control over its `Content-Type` header and should make sure that matches the file signature. However, let me know if this doesn't match our implementation and I'll change it in the -impl draft.",
              "createdAt": "2019-04-04T19:58:50Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 589,
              "body": "It's covered in \"Updates to match {{I-D.yasskin-http-origin-signed-responses-05}}.\"",
              "createdAt": "2019-04-04T20:05:50Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 547,
              "body": "Done, thanks.",
              "createdAt": "2019-04-04T20:06:40Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIzMDcwNzYz",
          "commit": {
            "abbreviatedOid": "f88a3ea"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-05T01:37:35Z",
          "updatedAt": "2019-04-05T01:37:36Z",
          "comments": [
            {
              "originalPosition": 500,
              "body": "Current Chromium implementation does fallback redirect in this case.\r\n\r\nLet's continue discussing in #397 on when we should fallback.",
              "createdAt": "2019-04-05T01:37:35Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI3MDk4MTQ3",
          "commit": {
            "abbreviatedOid": "f88a3ea"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T10:00:37Z",
          "updatedAt": "2019-04-16T10:00:38Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "Update line 636 so that `main-certificate`'s validity period is checked too?\r\n\r\nBTW Chrome doesn't implement this yet. I'll try to implement this in M75. https://crbug.com/953165",
              "createdAt": "2019-04-16T10:00:38Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzc4ODIy",
          "commit": {
            "abbreviatedOid": "97af4c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T23:49:48Z",
          "updatedAt": "2019-07-03T23:49:49Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "Done.",
              "createdAt": "2019-07-03T23:49:48Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 407,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYyMjY1MzEx",
      "title": "UTF-8 decode the fallback URL",
      "url": "https://github.com/WICG/webpackage/pull/407",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And a miscellaneous fix to a reference.",
      "createdAt": "2019-03-18T23:50:36Z",
      "updatedAt": "2019-03-20T19:41:50Z",
      "closedAt": "2019-03-20T19:41:47Z",
      "mergedAt": "2019-03-20T19:41:47Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE1OTA2NDU3",
          "commit": {
            "abbreviatedOid": "5013726"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-18T23:53:43Z",
          "updatedAt": "2019-03-18T23:53:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 408,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYyMjY3ODE1",
      "title": "Promote the privacy-preserving prefetch use case to \"Essential\"",
      "url": "https://github.com/WICG/webpackage/pull/408",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It's what our current most enthusiastic customer (AMP) depends on, so we\r\nshould be sure not to break it.",
      "createdAt": "2019-03-19T00:05:06Z",
      "updatedAt": "2019-03-23T20:20:57Z",
      "closedAt": "2019-03-23T20:20:54Z",
      "mergedAt": "2019-03-23T20:20:54Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDQzNDk4",
          "commit": {
            "abbreviatedOid": "f31de2d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-23T15:28:08Z",
          "updatedAt": "2019-03-23T15:28:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 410,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYzMDc0NzYw",
      "title": "Change gen-signedexchange default to b3.",
      "url": "https://github.com/WICG/webpackage/pull/410",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-20T23:36:06Z",
      "updatedAt": "2019-03-23T15:26:57Z",
      "closedAt": "2019-03-23T15:26:57Z",
      "mergedAt": "2019-03-23T15:26:57Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @jeffjose",
          "createdAt": "2019-03-20T23:42:29Z",
          "updatedAt": "2019-03-20T23:42:29Z"
        },
        {
          "author": "jeffjose",
          "authorAssociation": "NONE",
          "body": "Can we update b2 -> b3 here too please? https://github.com/WICG/webpackage/blob/master/examples/firebase.json",
          "createdAt": "2019-03-21T00:02:44Z",
          "updatedAt": "2019-03-21T00:02:44Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@jeffjose Yep, that's in this PR.",
          "createdAt": "2019-03-21T00:13:46Z",
          "updatedAt": "2019-03-21T00:13:46Z"
        },
        {
          "author": "jeffjose",
          "authorAssociation": "NONE",
          "body": "Ah yes, missed it the first time around. Thank you, @twifkak!",
          "createdAt": "2019-03-21T00:26:03Z",
          "updatedAt": "2019-03-21T00:26:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDQzNDM5",
          "commit": {
            "abbreviatedOid": "68ac72a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-23T15:26:31Z",
          "updatedAt": "2019-03-23T15:26:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 412,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYzODQ0NjA2",
      "title": "Update go readme",
      "url": "https://github.com/WICG/webpackage/pull/412",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-23T16:38:04Z",
      "updatedAt": "2019-03-25T14:38:32Z",
      "closedAt": "2019-03-25T14:38:31Z",
      "mergedAt": "2019-03-25T14:38:31Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your review. Will commit once CI pass",
          "createdAt": "2019-03-25T13:32:10Z",
          "updatedAt": "2019-03-25T13:32:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDU4MTU0",
          "commit": {
            "abbreviatedOid": "afad7d6"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-03-23T22:10:38Z",
          "updatedAt": "2019-03-23T22:16:49Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Nit:\r\n\r\n```suggestion\r\nYour signed exchange needs to be signed with a certificate with the [\"CanSignHttpExchanges\" extension](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req).\r\n```",
              "createdAt": "2019-03-23T22:10:38Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n1. Get a certificate from a CA. You have to use prime256v1 ecdsa keys, as you did in the previous section. Please follow the CA's instructions. (For example, [DigiCert](https://www.digicert.com/account/ietf/http-signed-exchange.php) offers the right kind of certificates.)\r\n```",
              "createdAt": "2019-03-23T22:11:47Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            },
            {
              "originalPosition": 44,
              "body": "I think it's still worthwhile to describe the chrome://flags/#allow-sxg-certs-without-extension flag until someone's offering free CanSignHttpExchanges certificates. The old text for it, of course, isn't right, and I don't mind getting the new text in a separate PR.",
              "createdAt": "2019-03-23T22:16:41Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDc3NTk5",
          "commit": {
            "abbreviatedOid": "0a5b841"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-24T11:44:55Z",
          "updatedAt": "2019-03-24T11:44:55Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Added #allow-sxg-certs-without-extension instructions back",
              "createdAt": "2019-03-24T11:44:55Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MTEwMzY3",
          "commit": {
            "abbreviatedOid": "381ec42"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-24T23:57:12Z",
          "updatedAt": "2019-03-24T23:57:27Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Since a self-signed certificate is used in this section, mentioning about `--ignore-certificate-errors-spki-list` would be still useful.",
              "createdAt": "2019-03-24T23:57:12Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MzIwMjAz",
          "commit": {
            "abbreviatedOid": "381ec42"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-25T13:17:37Z",
          "updatedAt": "2019-03-25T13:17:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2019-03-25T13:17:37Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MzIxNDg5",
          "commit": {
            "abbreviatedOid": "eece0e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-25T13:19:59Z",
          "updatedAt": "2019-03-25T13:23:02Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n      # Note that --user-data-dir is required for --ignore-certificate-errors-spki-list\r\n```",
              "createdAt": "2019-03-25T13:19:59Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 414,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY0ODEyMjc0",
      "title": "go/bundle: Add support for the manifest section",
      "url": "https://github.com/WICG/webpackage/pull/414",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Please take a look when you have time.",
      "createdAt": "2019-03-27T07:48:31Z",
      "updatedAt": "2019-03-29T02:17:31Z",
      "closedAt": "2019-03-29T02:17:19Z",
      "mergedAt": "2019-03-29T02:17:19Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5MzM2MDA2",
          "commit": {
            "abbreviatedOid": "66768d5"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-27T09:06:08Z",
          "updatedAt": "2019-03-27T09:06:28Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Can we make Manifest section optional?",
              "createdAt": "2019-03-27T09:06:08Z",
              "updatedAt": "2019-03-28T03:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5MzM5NjE4",
          "commit": {
            "abbreviatedOid": "66768d5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-27T09:14:06Z",
          "updatedAt": "2019-03-27T09:14:06Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "It's optional. If `b.ManifestURL` is nil, `newManifestSection` returns nil and the manifest section won't be emitted.",
              "createdAt": "2019-03-27T09:14:06Z",
              "updatedAt": "2019-03-28T03:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5MzUwOTIz",
          "commit": {
            "abbreviatedOid": "66768d5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-27T09:37:05Z",
          "updatedAt": "2019-03-27T09:37:12Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Can we use `WriteTo` instead of getter property interface?\r\n\r\nhttps://golang.org/pkg/io/#WriterTo",
              "createdAt": "2019-03-27T09:37:05Z",
              "updatedAt": "2019-03-28T03:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5MzU3Nzk3",
          "commit": {
            "abbreviatedOid": "66768d5"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-27T09:50:43Z",
          "updatedAt": "2019-03-27T09:50:43Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Thanks for explanation. I think we want to make that clear from reading only this part of the code.\r\n`newManifestSection` returning `nil, nil` is a surprising behavior to me.\r\n\r\nSome ideas:\r\n- `if url != \"\"` before newManifestSection\r\n- Alternate namings? `tryCreateManifestSection`?\r\n- Add comment explaining the behavior here?",
              "createdAt": "2019-03-27T09:50:43Z",
              "updatedAt": "2019-03-28T03:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODI0MDU2",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T03:59:01Z",
          "updatedAt": "2019-03-28T03:59:01Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Thanks for the suggestions. Chenged to check `b.ManifestURL != nil` before newManifestSection.",
              "createdAt": "2019-03-28T03:59:01Z",
              "updatedAt": "2019-03-28T03:59:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODI0MTkx",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T03:59:54Z",
          "updatedAt": "2019-03-28T03:59:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2019-03-28T03:59:54Z",
              "updatedAt": "2019-03-28T03:59:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODcxMjI1",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T07:53:44Z",
          "updatedAt": "2019-03-28T07:53:44Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Ah sorry but I meant to remove section interface and use `io.WriterTo` instead",
              "createdAt": "2019-03-28T07:53:44Z",
              "updatedAt": "2019-03-28T07:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODczMTQ1",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T08:00:02Z",
          "updatedAt": "2019-03-28T08:00:02Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Hmm. We need to write (name, length) pair and section content separately, so just a `WriterTo` doesn't suffice.",
              "createdAt": "2019-03-28T08:00:02Z",
              "updatedAt": "2019-03-28T08:00:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODc1MDc3",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-28T08:06:07Z",
          "updatedAt": "2019-03-28T08:06:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTU4NDUx",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T11:16:11Z",
          "updatedAt": "2019-03-28T11:16:11Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Oh I see.\r\n\r\nIn this case, I prefer to define e.g. `MarshalCbor` function that takes cbor's encoder to having getters, but that's optional.",
              "createdAt": "2019-03-28T11:16:11Z",
              "updatedAt": "2019-03-28T11:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTU4NDgz",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-03-28T11:16:16Z",
          "updatedAt": "2019-03-28T11:16:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIwMzUwNjEz",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-29T02:16:31Z",
          "updatedAt": "2019-03-29T02:16:31Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Let me merge this as-is, and do the refactoring separately.",
              "createdAt": "2019-03-29T02:16:31Z",
              "updatedAt": "2019-03-29T02:16:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 415,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY1MTYxNzgx",
      "title": "Fix gen-signedexchange example -date value",
      "url": "https://github.com/WICG/webpackage/pull/415",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`Z` doesn't have an offset suffix.",
      "createdAt": "2019-03-28T02:10:55Z",
      "updatedAt": "2019-03-28T02:37:46Z",
      "closedAt": "2019-03-28T02:37:43Z",
      "mergedAt": "2019-03-28T02:37:43Z",
      "mergedBy": "twifkak",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODA5NDMy",
          "commit": {
            "abbreviatedOid": "3a8a9f0"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-28T02:33:19Z",
          "updatedAt": "2019-03-28T02:33:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 416,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY1MjI5ODU2",
      "title": "TravisCI: Test go code",
      "url": "https://github.com/WICG/webpackage/pull/416",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-28T08:28:12Z",
      "updatedAt": "2019-08-22T04:26:12Z",
      "closedAt": "2019-08-22T04:26:12Z",
      "mergedAt": "2019-08-22T04:26:12Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Gentle ping",
          "createdAt": "2019-04-15T00:47:26Z",
          "updatedAt": "2019-04-15T00:47:26Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to manually rebase and merge this, and will create a separate PR for the Jeffrey's suggestion.",
          "createdAt": "2019-08-22T04:24:24Z",
          "updatedAt": "2019-08-22T04:24:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNjgyMTYz",
          "commit": {
            "abbreviatedOid": "22df502"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This looks great! I'd like it to run in parallel if possible. Does it still work if you remove the `stages` section and replace `stage: go` with `name: \"Go\"` and `stage: spec` with `name: \"Specifications\"`?",
          "createdAt": "2019-08-08T16:10:33Z",
          "updatedAt": "2019-08-08T16:10:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 417,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY1MjUxOTIz",
      "title": "go: Add basic test for bundle.go",
      "url": "https://github.com/WICG/webpackage/pull/417",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-28T09:37:51Z",
      "updatedAt": "2019-03-29T02:22:04Z",
      "closedAt": "2019-03-29T02:21:56Z",
      "mergedAt": "2019-03-29T02:21:56Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTIzNjAx",
          "commit": {
            "abbreviatedOid": "f75bf71"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T10:00:25Z",
          "updatedAt": "2019-03-28T10:00:32Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "can we use bundle.Bundle instead of `.` import?",
              "createdAt": "2019-03-28T10:00:25Z",
              "updatedAt": "2019-03-28T10:00:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTU2ODU2",
          "commit": {
            "abbreviatedOid": "f75bf71"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T11:12:22Z",
          "updatedAt": "2019-03-28T11:12:22Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I think using a dot in a test package is common, but I'm fine with both.",
              "createdAt": "2019-03-28T11:12:22Z",
              "updatedAt": "2019-03-28T11:12:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTY4MjQx",
          "commit": {
            "abbreviatedOid": "f75bf71"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-28T11:40:18Z",
          "updatedAt": "2019-03-28T11:40:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 424,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczMzIyMDY0",
      "title": "Commit the threat model from #422",
      "url": "https://github.com/WICG/webpackage/pull/424",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@johnwilander, here's an attempt to make your threat model a little more formal so that we can evaluate a range of attacks and mitigations against it. Did I capture roughly what the WebKit team is thinking? Thanks for engaging!",
      "createdAt": "2019-04-24T22:33:59Z",
      "updatedAt": "2019-05-13T18:56:27Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "How is this doing as a first draft of the anti-tracking threat model? I'm hoping to send some more PRs digging into the proposed mitigations, but I'd like to have rough agreement on the base first.",
          "createdAt": "2019-05-01T19:45:20Z",
          "updatedAt": "2019-05-01T19:45:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Jeffrey cited this PR in an email, and just reading through the text, I'm confused.  Are you really attempting to prevent two cooperating origins from exchanging information?",
          "createdAt": "2019-05-10T01:35:37Z",
          "updatedAt": "2019-05-10T01:35:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "My understanding from #422 is that @johnwilander and Safari's ITP2 are indeed trying to prevent two cooperating origins from exchanging information. Specifically, when following a link from AdTech to News, if AdTech can send AdTech's notion of the user's ID to News in any request where News also gets its own notion of the user's ID, then News can remember that association and use it augment AdTech's profile of the user or request user-specific ads from AdTech on all subsequent pages.\r\n\r\nThere may be limitations on AdTech's ability to get News to cooperate (see \"Attacker Non-Capabilities\"), but I haven't been able to get a description of those that I believe in.",
          "createdAt": "2019-05-13T18:56:27Z",
          "updatedAt": "2019-05-13T18:56:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMTE0MDM1",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T11:50:34Z",
          "updatedAt": "2019-04-26T11:57:53Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Nit: the points are not written as attacker goals",
              "createdAt": "2019-04-26T11:50:34Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            },
            {
              "originalPosition": 117,
              "body": "With Server Timing, we have response headers that are directly readable from JS, so embedding the UID through them might be feasible even without on-the-fly signing. So we need to make sure that the distributor cannot add arbitrary non-signed headers to the internal response, as well as that the external response Server Timing headers are not exposed to the navigated page.\r\nI believe that's already the case, tbh, but IMO it's worthwhile to explicitly note that.",
              "createdAt": "2019-04-26T11:54:16Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            },
            {
              "originalPosition": 171,
              "body": "It also seems like the distributor can use the referrer in order to include a UID (e.g. redirect through a unique path, and have a permissive ReferrerPolicy). Mitigation can be to enforce stricter ReferrerPolicy on redirects or in general.",
              "createdAt": "2019-04-26T11:57:45Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjYyOTk4",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:03:10Z",
          "updatedAt": "2019-04-26T17:03:10Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'd say web rather than Internet since we're talking about web browsers here. I don't think the success of our efforts remains to be seen, and even if it were, this comment comes across as opinionated.",
              "createdAt": "2019-04-26T17:03:10Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjYzMTEz",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:03:29Z",
          "updatedAt": "2019-04-26T17:03:30Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "browsers \u2013> browser engines",
              "createdAt": "2019-04-26T17:03:30Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY0MzY3",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:06:45Z",
          "updatedAt": "2019-04-26T17:06:45Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "\"We\" has become confused here. It shouldn't be the same \"we\" criticizing tracking vectors and \"we\" are told. I would rewrite this without attribution.",
              "createdAt": "2019-04-26T17:06:45Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY1MjQz",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:08:56Z",
          "updatedAt": "2019-04-26T17:08:57Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I don't think \"that other work\" is defined here. The other work is potentially years into the future and I don't think we should indicate that Web Packaging can punt on tracking issues in wait for such \"other work.\"",
              "createdAt": "2019-04-26T17:08:57Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY2MTY0",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:11:07Z",
          "updatedAt": "2019-04-26T17:11:07Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "We should add that AdTech can help or convince News to set up a signing *service* as an alternative to handing over keys. With such a service, AdTech can create the package, calculate its hash, and send the hash over for signing, all on the fly.\r\n\r\nAlso, we should stick to one term. Currently we mention both certificates and private keys. I think private keys are the most accurate term.",
              "createdAt": "2019-04-26T17:11:07Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY2OTI1",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:12:41Z",
          "updatedAt": "2019-04-26T17:12:41Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "See my comment above on certificates vs private keys.",
              "createdAt": "2019-04-26T17:12:41Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY3NTUx",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:14:07Z",
          "updatedAt": "2019-04-26T17:14:07Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Here the potential for a service is mentioned. See my comment on this above.",
              "createdAt": "2019-04-26T17:14:07Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY5Mjg4",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:18:25Z",
          "updatedAt": "2019-04-26T17:18:25Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "I've only given casual thought to how a webpage can instruct the browser to restrict a load because it is for a signed package. Two ideas: 1) a /.well-known/ location or 2) a special HTTP redirect similar to an upgrade.",
              "createdAt": "2019-04-26T17:18:25Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY5NzM3",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:19:29Z",
          "updatedAt": "2019-04-26T17:19:29Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I think there\u2019s value in continuing to separate these concepts.\r\n\r\nIt would seem that your threat considerations consider the following scenarios:\r\n1. AdTech creates a private key and obtains a certificate on News\u2019 behalf (e.g. as CDNs commonly do)\r\n1. News generates the key and then shares with AdTech\r\n1. News holds the private key, but then signs on AdTech\u2019s behalf (as commonly practiced by CDNs, typically called Split-TLS)\r\n1. TLS Delegated Creds have a fourth model, where News generates the key, and then authorizes a key for AdTech\r\n\r\nThese each seem to represent different combinations, with the last being particularly relevant in the discussion of certificates and keys",
              "createdAt": "2019-04-26T17:19:29Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjcwMTIw",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:20:19Z",
          "updatedAt": "2019-04-26T17:20:20Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Isn\u2019t this correct as is? For example, Brave shares the same Browser Engine as Edge and Chromium, but represent their own approaches to reduce tracking ability.",
              "createdAt": "2019-04-26T17:20:19Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjcxNzY5",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:23:57Z",
          "updatedAt": "2019-04-26T17:23:57Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "WebKit is an engine used in multiple browsers and web rendering applications. If the text should indeed refer to browsers, it should be Safari. But web technologies are mostly about engines.",
              "createdAt": "2019-04-26T17:23:57Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMzU4NDk2",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T21:00:58Z",
          "updatedAt": "2019-04-26T23:56:15Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "+1 for being consistent, and I'm happy to follow John's preference to keep this with WebKit and \"engines\".",
              "createdAt": "2019-04-26T21:00:59Z",
              "updatedAt": "2019-04-26T23:56:15Z"
            },
            {
              "originalPosition": 4,
              "body": "Sorry, removed.",
              "createdAt": "2019-04-26T21:05:12Z",
              "updatedAt": "2019-04-26T23:56:15Z"
            },
            {
              "originalPosition": 159,
              "body": "I don't think we need to write down all the details in this document, but I'm thinking of:\r\n\r\n1. In https://wicg.github.io/webpackage/loading.html#mp-http-network-or-cache-fetch 20.2, add\r\n   * httpRequest\u2019s [credentials mode](https://fetch.spec.whatwg.org/#concept-request-credentials-mode) is `\"omit\"`\"\r\n   * httpRequest\u2019s method is `GET`\r\n   * etc.\r\n\r\n   to the constraints on \"setting _response_ to httpRequest\u2019s stashed exchange's response.\"\r\n2. Add an attribute to `<a>` tags to let them cause credential-less fetches, and similarly anywhere else we want to enable signed packages that [`crossorigin`](https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attribute) isn't sufficient. There may be a more ergonomic way to do this with `/.well-known/` or [origin policy](https://wicg.github.io/origin-policy/).\r\n\r\nIf we wind up thinking this is the right mitigation for this problem, I think we'll propose and discuss the new `credentials=\"omit\"` mechanism in a separate repository, since it could also be useful independent of web packaging.",
              "createdAt": "2019-04-26T21:25:24Z",
              "updatedAt": "2019-04-26T23:56:15Z"
            },
            {
              "originalPosition": 20,
              "body": "Rewritten. I'm not sure if I've preserved the important bits from your original issue, so please double-check.",
              "createdAt": "2019-04-26T22:42:14Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 27,
              "body": "Indeed. I was trying to get at the idea that we can assume the other changes are done when designing fixes for Web Packaging, but I'm not sure the best way to say that.\r\n\r\nFor example, if AdTech can convey user IDs through the Referer header, we'll want to strip that header when redirecting cross-origin regardless of the cause of the redirect. The Web Packaging design should be able to assume that's done, rather than adding a special case for just the [redirect](https://wicg.github.io/webpackage/loading.html#mp-http-fetch) embedded in the Web Packaging processing model.\r\n\r\nMaybe the new text explains that thought better?",
              "createdAt": "2019-04-26T22:56:28Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 64,
              "body": "I've elaborated this section with @sleevi's 4 possibilities. I think they mostly differ in how visible AdTech's misbehavior would be to News, and how long that misbehavior could keep affecting users after News terminated the relationship with AdTech.\r\n\r\nI agree that we need to be precise about which of \"certificate\" or \"private key\" is correct in each location, but because they mean different things, I don't think we can talk about just one of them. I'm using phrasing that implies that a certificate signs the package, which matches https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req, but strictly a private key (or keypair?) signs the package and the certificate just vouches for the authority of that key. I'm happy to take better wording.",
              "createdAt": "2019-04-26T23:20:06Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 87,
              "body": "Indeed. https://increment.com/security/approachable-threat-modeling/ would call these \"Invariants\", but it's not clear that would be intuitive to random folks reading this. I'll rephrase them.",
              "createdAt": "2019-04-26T23:29:55Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 110,
              "body": "I've rephrased this as a reference to the new wording in Attacker Capabilities and removed the sub-item.",
              "createdAt": "2019-04-26T23:33:00Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 117,
              "body": "It's a security requirement that the distributor can't add response headers to the post-redirect response. https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signed-headers mentions that idea, although it's in a section nobody's implementing. The application/signed-exchange format just can't represent such unsigned post-redirect response headers.\r\n\r\nI don't think Server-Timing response headers on a 303 response get exposed to the post-redirect javascript. So I'm not sure there's really anything to say here.",
              "createdAt": "2019-04-26T23:51:45Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 171,
              "body": "As I'm saying in https://github.com/WICG/webpackage/pull/424#discussion_r279031642, I think we'll need to block that communication route on all redirects, so it's not special to web packages. Do you want me to add a separate attack describing it below?",
              "createdAt": "2019-04-26T23:56:09Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 425,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczNzAyOTA3",
      "title": "Use Case: Least Authority CDN Serving",
      "url": "https://github.com/WICG/webpackage/pull/425",
      "state": "OPEN",
      "author": "davidstrauss",
      "authorAssociation": "FIRST_TIME_CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While working on the security architecture for Drupal's planned auto-update features, I realized that many of our use cases could be solvable using SXG rather than rolling our own signing mechanism (as APT and Yum have) to support offline signatures for metadata from update servers. We already intend to distribute the metadata via a CDN that has appropriate certificates for drupal.org, but we also don't want the attack surface introduced by every POP being a potential point of compromise. Given that we control the client side in these scenarios, SXG represents one brightly lit path to trusting the metadata without relying solely on TLS or using baroque integrations with GnuPG.",
      "createdAt": "2019-04-25T22:22:24Z",
      "updatedAt": "2019-10-17T21:40:01Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "davidstrauss",
          "authorAssociation": "NONE",
          "body": "> I believe I convinced @davidstrauss a couple months ago that his underlying use case was better served by signify or minisign.\r\n\r\nWe were convinced! We have a working implementation in testing now:\r\n\r\n* https://github.com/drupal/php-signify\r\n* https://github.com/mbaynton/drupal-signing-oracle\r\n\r\nHowever, we extended the Signify design to support expiring intermediate keypairs. We did this for two reasons, which I'll mention here because SXG does support this use case (via X.509) better than Signify's design:\r\n\r\nFirst, Drupal needs to sign artifacts produced in its online build infrastructure. These artifacts include builds of community-provided code that may be malicious. Signing these builds requires the key -- or the ability to sign -- to be available to this high-risk system. However, most cloud HSMs don't support ed25519. We don't have a natural place to deploy custom hardware for the Drupal Association, so we opted for using a VM as a signing oracle (to still create some isolation in case of build server compromise). Still, we wanted to anchor trust in something other than a key deployed to a VM in the cloud.\r\n\r\nSecond, Drupal lacks a natural key rotation interval akin to OpenBSD's six-month-ish release cycle. Drupal's major releases get support for years, and users expect to be able to upgrade across fairly arbitrary point releases. This creates tension between (a) rotating across point releases (perhaps not every one) and potentially breaking the ability of older point releases to validate current builds versus (b) rotating across major releases and having keys live for 5+ years. It would also be possible to have (c) older point releases \"walk\" their way to trusting the current build key, but that seemed fragile. An intermediate keypair makes rotation a question of operations effort versus security -- with no end-user impacts.\r\n\r\nSo, an intermediate keypair seemed like an elegant way to keep the root offline and support arbitrary rotations of the secrets in the deployed build infrastructure. (We currently hope to rotate intermediate keys quarterly.) Otherwise, we were quite happy with what Signify provided as a design.\r\n\r\nWe plan to secure the offline root by using YubiHSM hardware.",
          "createdAt": "2019-10-17T21:38:20Z",
          "updatedAt": "2019-10-17T21:40:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjU1OTY4",
          "commit": {
            "abbreviatedOid": "2e76b5e"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Fly-by comment; not a full review, which I'll leave to @jyasskin.",
          "createdAt": "2019-04-26T16:46:08Z",
          "updatedAt": "2019-04-26T16:53:47Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I wonder if Must-Staple is a closer analogy to what is required. An origin could not enforce that their CDN includes a certain HTTP header on all responses, but they could enforce that the only certificate they bestow upon the CDN has a given extension. (As to whether that extension could or should be marked critical, I'm not sure.) Supporting clients would, when confronted with a TLS connection backed by such a cert, only honor responses that are signed with an SXG cert.",
              "createdAt": "2019-04-26T16:46:08Z",
              "updatedAt": "2019-04-26T16:53:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMzczODcx",
          "commit": {
            "abbreviatedOid": "2e76b5e"
          },
          "author": "davidstrauss",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T21:52:11Z",
          "updatedAt": "2019-04-26T21:52:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "> I wonder if Must-Staple is a closer analogy to what is required.\r\n\r\nPerhaps I should rephrase the text, as the forward-looking idea is less about the mechanism (HSTS-style, Must-Staple, or otherwise) and more about allowing a site to inform clients to expect SXG responses. That expectation should be sticky or, at least, resistant to downgrade attacks.\r\n\r\nI agree that an extension applied to the TLS certificate would be a technologically elegant way to solve the issue. I'd argue that such an extension should be non-critical, as that would allow existing clients to interact as before, while clients aware of the extension could enforce SXG on responses. SXG enforcement is a defense-in-depth against POP/proxy compromise, which I think is another argument for a non-critical designation.\r\n\r\nI try to push back against new certificate extensions for practical reasons, though. They create a barrier to entry for people who implement or deploy the design. That raises some reasons I looked first to HSTS: it's broadly used, doesn't require external facilitation (e.g. by a CA), and has no up-front or ongoing costs to web site administrators.\r\n\r\n> An origin could not enforce that their CDN includes a certain HTTP header on all responses, but they could enforce that the only certificate they bestow upon the CDN has a given extension.\r\n\r\nThis is true, but what I had in mind was the broader world of HSTS rather than just the header. In practice, qualifying HSTS headers get cached in browsers and bundled into the HSTS Preload List, both of which continue enforcement even if the header goes missing. (So, while a compromised POP could stop sending an SXG enforcement header, clients would still expect SXG.) I'm unsure whether this is the most desirable approach to SXG enforcement, but it's one established pattern that's possible to apply here.",
              "createdAt": "2019-04-26T21:52:11Z",
              "updatedAt": "2019-04-26T23:20:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwOTUxNjI2",
          "commit": {
            "abbreviatedOid": "2e76b5e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "First, sorry for leaving this review for so long.\r\n\r\nI believe I convinced @davidstrauss a couple months ago that his underlying use case was better served by [signify](https://www.openbsd.org/papers/bsdcan-signify.html) or [minisign](https://jedisct1.github.io/minisign/). (I found those via https://latacora.micro.blog/2019/07/16/the-pgp-problem.html.)\r\n\r\nHowever, I believe there are two interesting use cases here:\r\n\r\n1. The one in the title, letting CDNs serve a site without letting them change the content. This one is *difficult* and requires at least two exciting components beyond signed exchanges:\r\n   1. The CDN, by definition, gets the traffic that looked your origin up in DNS. That means it also gets the traffic from a CA trying to verify who owns the domain using method [3.2.2.4.6 Agreed-Upon Change to Website](https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.6.pdf), so it can just get a new certificate as your origin. This might be solvable using [CAA](https://en.wikipedia.org/wiki/DNS_Certification_Authority_Authorization) and some \"I got here first\" account restriction with the allowed CAs, but that seems fragile, so it might be worth designing something else.\r\n   1. As @mnot [pointed out](https://www.iab.org/wp-content/IAB-uploads/2019/06/mnot.pdf), when the browser tries to create a connection to your origin, it checks that the target (the CDN) has the private key for a trusted certificate for that origin, which the CDN of course can't have if we don't want them forging content. As Mark said, we'd need to invent a way for the server to tell your browser to create the \"TLS\" connection but only accept content within valid SXGs. And to preserve confidentiality against network attackers other than the CDN, we'd need to actually authenticate the CDN itself in some other way. And I don't see a way for a server to migrate to this scheme while still supporting old clients. Mark suggests [LURK](https://datatracker.ietf.org/wg/lurk/charter/), which I don't understand well enough to endorse.\r\n\r\n1. Ensuring users get correct content even if your frontend is compromised. (And it might be reasonable to think of an evil CDN like a compromised frontend.) I think the HSTS-like mechanism proposed here actually accomplishes this, and we don't need the complexity of origin-trusted certificates to get here. Instead, you'd serve a `TBD-Content-Public-Key-Pins: ed25519=(*base64-public-key* ...), max-age=seconds` header which the client would trust on first use, and subsequent responses would only be trusted if they were signed by that public key. You'd store the private key in your build system but keep it away from frontends. This is similar to [Signature-based SRI](https://github.com/mikewest/signature-based-sri) but works on top-level resources. Note that this has [footguns](https://groups.google.com/a/chromium.org/d/topic/blink-dev/he9tr7p3rZ8/discussion) very similar to [Public Key Pinning](https://en.wikipedia.org/wiki/HTTP_Public_Key_Pinning). Apps like end-to-end encrypted messaging systems and password managers would probably be interested in using this.\r\n\r\nI propose to add both use cases to this document with descriptions like above, with a note that I don't expect the CDN use case to happen any time soon. I'll send 2 PRs.",
          "createdAt": "2019-10-11T22:20:29Z",
          "updatedAt": "2019-10-11T22:20:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 426,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczNzU5NjA3",
      "title": "go/signedexchange: ParsePrivateKey takes pem text, not DER bytes",
      "url": "https://github.com/WICG/webpackage/pull/426",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To make it consistent with ParseCertificates().",
      "createdAt": "2019-04-26T04:44:28Z",
      "updatedAt": "2019-04-26T08:21:45Z",
      "closedAt": "2019-04-26T08:21:36Z",
      "mergedAt": "2019-04-26T08:21:36Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMDI0NDg3",
          "commit": {
            "abbreviatedOid": "e05e667"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-26T08:00:18Z",
          "updatedAt": "2019-04-26T08:00:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMDI1MzQ2",
          "commit": {
            "abbreviatedOid": "e05e667"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-26T08:02:29Z",
          "updatedAt": "2019-04-26T08:02:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 427,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1MDgyMjQ3",
      "title": "Add support for JSON output",
      "url": "https://github.com/WICG/webpackage/pull/427",
      "state": "MERGED",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adds a switch, `-json` to `dump-signedexchange` (fixes #418):\r\n\r\n```sh\r\n$ curl -sS -H 'accept: application/signed-exchange;v=b3' -H 'amp-cache-transform: google;v=\"1\"' https://amp.dev/ | ./dump-signedexchange -json\r\n{\r\n  \"Valid\": true,\r\n  \"Payload\": \"\",\r\n  \"SignatureHeaderValue\": {\r\n    \"cert-sha256\": \"lWfYk+0jeC/HkleYD4fj98y6GixIjocIkMpjsB8dToA=\",\r\n    \"cert-url\": \"https://amp.dev/amppkg/cert/lWfYk-0jeC_HkleYD4fj98y6GixIjocIkMpjsB8dToA\",\r\n    \"date\": 1559608738,\r\n    \"expires\": 1560213538,\r\n    \"integrity\": \"digest/mi-sha256-03\",\r\n    \"sig\": \"MEYCIQDNXSYTBrsbJVJrm79lPTRXITmvraoQj77axnslJa7HUwIhAOwTFoVFhQwfYICNHa+fSewH6mxaD5K6YPdcGbbgIG6w\",\r\n    \"validity-url\": \"https://amp.dev/amppkg/validity\"\r\n  },\r\n  \"Version\": \"1b3\",\r\n\u2026\r\n```\r\n\r\nCan be used with e.g. https://stedolan.github.io/jq/ to extract specific properties such as the cert-url:\r\n\r\n```sh\r\n$ curl -sS -H 'accept: application/signed-exchange;v=b3' -H 'amp-cache-transform: google;v=\"1\"' https://amp.dev/ | ./dump-signedexchange -json | jq -r '.SignatureHeaderValue|.\"cert-url\"'\r\nhttps://amp.dev/amppkg/cert/lWfYk-0jeC_HkleYD4fj98y6GixIjocIkMpjsB8dToA\r\n```\r\n\r\n(FYI @patrickkettner re #418, had a quick look and just figured I'd have a go at this!)",
      "createdAt": "2019-05-01T16:40:26Z",
      "updatedAt": "2019-06-06T05:29:23Z",
      "closedAt": "2019-06-06T05:29:23Z",
      "mergedAt": "2019-06-06T05:29:23Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "/cc @nyaxt",
          "createdAt": "2019-05-02T10:53:57Z",
          "updatedAt": "2019-05-02T10:53:57Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the review @nyaxt! I think it's ready for another pass now.",
          "createdAt": "2019-06-05T00:43:52Z",
          "updatedAt": "2019-06-05T00:43:52Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nyaxt Updated, PTAL!",
          "createdAt": "2019-06-05T11:55:11Z",
          "updatedAt": "2019-06-05T11:55:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNjQ4NjY5",
          "commit": {
            "abbreviatedOid": "2f78984"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T16:41:50Z",
          "updatedAt": "2019-05-01T16:41:51Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "To make `golint` happy.",
              "createdAt": "2019-05-01T16:41:51Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzUxNjk0",
          "commit": {
            "abbreviatedOid": "2f78984"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you!",
          "createdAt": "2019-05-03T07:42:55Z",
          "updatedAt": "2019-05-03T07:51:24Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I'd like to avoid duplicating struct def if possible.\r\n\r\nWould you mind omitting payload via `json:\"-\"` for now?",
              "createdAt": "2019-05-03T07:42:55Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 54,
              "body": "If we omit payload,\r\n```\r\nstruct {\r\n  Valid bool\r\n  *Exchange\r\n  Payload string\r\n}{\r\n  ok,\r\n  e,\r\n  payload\r\n}\r\n```",
              "createdAt": "2019-05-03T07:46:26Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 24,
              "body": "Would you pass `certFetcher` via this func's argument?",
              "createdAt": "2019-05-03T07:47:29Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 22,
              "body": "I feel like this should live in dump-signedexchange, since users who wish to use this Go code as a library is unlikely to need this.",
              "createdAt": "2019-05-03T07:49:20Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 23,
              "body": "Would you pass verificationTime via this func's argument?",
              "createdAt": "2019-05-03T07:50:14Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY1OTA1",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:41:03Z",
          "updatedAt": "2019-06-05T00:41:04Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Done (kinda\u2014I couldn't get `json:\"-\"` to work quite as expected).",
              "createdAt": "2019-06-05T00:41:03Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY1OTc3",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:41:26Z",
          "updatedAt": "2019-06-05T00:41:26Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Reworked a bit, but I think this is done.",
              "createdAt": "2019-06-05T00:41:26Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY1OTg5",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:41:32Z",
          "updatedAt": "2019-06-05T00:41:33Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Done.",
              "createdAt": "2019-06-05T00:41:32Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY2MzI2",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:43:23Z",
          "updatedAt": "2019-06-05T00:43:23Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done. (FWIW, I originally put it here because the signature matched that of `PrettyPrintHeaders()`.)",
              "createdAt": "2019-06-05T00:43:23Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY2MzQ3",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:43:29Z",
          "updatedAt": "2019-06-05T00:43:30Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done.",
              "createdAt": "2019-06-05T00:43:29Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1Nzc2MDMy",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T01:36:14Z",
          "updatedAt": "2019-06-05T01:40:20Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Would you try `omitempty`?",
              "createdAt": "2019-06-05T01:36:14Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 39,
              "body": "would you factor this part out so jsonPrintHeaders can also use `*flagCert` if available?\r\n\r\nI think we can create a `func initCertFetcher() (func(url string) ([]byte, error), error)` which returns signedexchange.DefaultCertFetcher if no `*flagCert` and read `*flagCert` if avail.",
              "createdAt": "2019-06-05T01:39:57Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1OTQ3NjEw",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T11:28:18Z",
          "updatedAt": "2019-06-05T11:28:19Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "That works, thanks!",
              "createdAt": "2019-06-05T11:28:19Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1OTU3NDg4",
          "commit": {
            "abbreviatedOid": "f14841a"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T11:53:59Z",
          "updatedAt": "2019-06-05T11:53:59Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Nice, done!",
              "createdAt": "2019-06-05T11:53:59Z",
              "updatedAt": "2019-06-05T11:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MzYwODAx",
          "commit": {
            "abbreviatedOid": "f14841a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-06T04:44:55Z",
          "updatedAt": "2019-06-06T04:44:56Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "The return type can be written as `(signedexchange.CertFetcher, error)`",
              "createdAt": "2019-06-06T04:44:56Z",
              "updatedAt": "2019-06-06T04:44:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MzY3NDA4",
          "commit": {
            "abbreviatedOid": "f14841a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\nLet's merge this (I may create a follow up patch for function signature, etc.).\r\nThank you for the patch!",
          "createdAt": "2019-06-06T05:26:13Z",
          "updatedAt": "2019-06-06T05:26:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 428,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1MTM5NTk2",
      "title": "Remove credentials from the certificate fetch.",
      "url": "https://github.com/WICG/webpackage/pull/428",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This removes one avenue by which a distributor could send its notion of\na user's ID to another origin, for server-side correlation with that\norigin's cookies. That correlation would violate the goals in #422 and seems easy to block.\n\nThanks @kristoferbaxter and @twifkak for pointing this out.\n\nI don't *think* it's useful to customize the content of a certificate chain to a particular user, especially since the hash of the certificate itself is locked in by the SXG's signature. But if anyone sees a way this'll break things, please speak up.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/428.html\" title=\"Last updated on May 1, 2019, 8:05 PM UTC (1321699)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/428/9634466...jyasskin:1321699.html\" title=\"Last updated on May 1, 2019, 8:05 PM UTC (1321699)\">Diff</a>",
      "createdAt": "2019-05-01T20:05:33Z",
      "updatedAt": "2019-05-01T22:26:20Z",
      "closedAt": "2019-05-01T20:34:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzQxNTcw",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "PR description LGTM; I'll defer to y'all on whether the syntax/semantics of the implementation are correct.",
          "createdAt": "2019-05-01T20:28:24Z",
          "updatedAt": "2019-05-01T20:28:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Pardon my naivete wrt the fetch monkeypatch,\r\n\r\nhttps://fetch.spec.whatwg.org/#concept-request-credentials-mode says:\r\n> Unless stated otherwise, it is \"`omit`\".\r\n\r\nIs it stated otherwise somewhere? Or is duplicate to avoid confusion?",
              "createdAt": "2019-05-01T20:28:24Z",
              "updatedAt": "2019-05-01T20:28:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzQ0Mjcw",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T20:34:56Z",
          "updatedAt": "2019-05-01T20:34:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Argh, thanks for pointing that out. Yep, this PR is a no-op. Never mind!",
              "createdAt": "2019-05-01T20:34:56Z",
              "updatedAt": "2019-05-01T20:34:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzY5NDQw",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "kristoferbaxter",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T21:39:18Z",
          "updatedAt": "2019-05-01T21:39:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks for taking a look anyway. I thought this value default was changed, https://github.com/whatwg/fetch/pull/585. \r\n\r\nIt might still be worthwhile to ensure it's set to \"omit\".",
              "createdAt": "2019-05-01T21:39:18Z",
              "updatedAt": "2019-05-01T21:39:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzczMzA5",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T21:50:41Z",
          "updatedAt": "2019-05-01T21:50:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It seems like \"same-origin\" would still address the threat mentioned in the PR description (\"another origin\"); is there another threat you had in mind?",
              "createdAt": "2019-05-01T21:50:41Z",
              "updatedAt": "2019-05-01T21:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzgzNDQy",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "kristoferbaxter",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T22:26:08Z",
          "updatedAt": "2019-05-01T22:26:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Making the value `omit` would only be for completeness sake \u2013 I believe `same-origin` gives the same level of protection but unnecessarily sends cookies for same origin cert requests.",
              "createdAt": "2019-05-01T22:26:08Z",
              "updatedAt": "2019-05-01T22:26:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 429,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NTE3ODky",
      "title": "Adds support for URI input to dump-signedexchange",
      "url": "https://github.com/WICG/webpackage/pull/429",
      "state": "MERGED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes some quality of life improvements for the dump-signedexchange tool\r\n\r\n- Adds support for reading a signed exchange from an HTTPS endpoint rather than from the file system. This feels much more natural to use and allows for faster debugging.\r\n- Allows for more granular control over the output. Generally when I dump a signed exchange, I don't want to see the entire HTML, I'm interested in the signature and the headers.\r\n\r\nEDIT:\r\n- The tool will also warn the user if -i or -uri is not passed instead of simply hanging indefinitely\r\n\r\nEDIT 2:\r\n- Allows the version to be specified with the `-version` flag which defaults to the latest version\r\n- Allows a header such as `AMP-Cache-Transform: google;v=1` to be sent along with the `-uri` request with the `-requestHeader` flag\r\n- Fixes a few instances of `singedexchange` and makes them `signedexchange`\r\n\r\nEDIT 3:\r\n- Added info about json flag to README\r\n- Allows more than one header to be passed with -requestHeader flag\r\n- Mime type factored to version.go\r\n- Input flags take precedence over pipe",
      "createdAt": "2019-05-02T21:00:29Z",
      "updatedAt": "2019-06-13T02:34:56Z",
      "closedAt": "2019-06-13T02:34:56Z",
      "mergedAt": "2019-06-13T02:34:56Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @gabbifish @twifkak ",
          "createdAt": "2019-05-02T21:01:28Z",
          "updatedAt": "2019-05-02T21:01:28Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "Comments should be addressed at this point, let me know if there are further improvements that should be made.",
          "createdAt": "2019-05-03T16:55:45Z",
          "updatedAt": "2019-05-03T16:55:45Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "What do people here think about defaulting `-payload` to false and `-verify` to true? When I use this tool I only really care about the headers/verification and don't want the payload printed. I feel that's probably typical and those would make sensible defaults. That said, I don't want to change the default behavior of the tool w/o explicit buy-in.",
          "createdAt": "2019-05-03T19:12:55Z",
          "updatedAt": "2019-05-03T19:12:55Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Quick comment, haven\u2019t looked at this PR closely: with these changes, is it possible to cleanly output just the payload? Am wondering because this is something I\u2019m interested in extracting (to pass to other tooling).\r\n\r\nHaving convenient access to the payload was part of the original purpose of my PR #427 (edit), but I think after the comments are addressed it won\u2019t output the payload at all, so it would be nice to be able to get it via this PR ;-). (Don\u2019t care whether it\u2019s the default or not.)",
          "createdAt": "2019-05-03T21:26:50Z",
          "updatedAt": "2019-05-03T21:27:21Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "> Quick comment, haven\u2019t looked at this PR closely: with these changes, is it possible to cleanly output just the payload? \r\n\r\nYes! You can simply pass `-headers=false` and only the payload will be printed :)\r\n\r\n",
          "createdAt": "2019-05-03T21:32:36Z",
          "updatedAt": "2019-05-03T21:32:36Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori @nyaxt comments should be addressed",
          "createdAt": "2019-06-10T19:35:02Z",
          "updatedAt": "2019-06-10T19:35:02Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "The newly added `-json` flag coerces the strings `<` `>` and `&` to UTF-8. For instance, when outputting the `Link` header it will look like this:\r\n\r\n```    \r\n\"Link\": [\r\n      \"\\u003chttps://cdn.ampproject.org/v0.js\\u003e;rel=preload;as=script\"\r\n    ],\r\n```\r\n\r\nI have a fix that will print the JSON w/proper encoding that I can include in this PR if y'all think it would be beneficial. \r\n\r\nAfter:\r\n\r\n```\r\n\"Link\": [\r\n   \"<https://cdn.ampproject.org/v0.js>;rel=preload;as=script\"\r\n],\r\n```",
          "createdAt": "2019-06-10T20:22:39Z",
          "updatedAt": "2019-06-10T20:23:53Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@EverlastingBugstopper Ah, I didn't notice that! Yes I think that would be good to fix here (or in a different PR). It seems like the reason to encode those characters is to try to protect against problems that result from embedding JSON within HTML but that seems a bit unlikely in this case.",
          "createdAt": "2019-06-10T22:35:26Z",
          "updatedAt": "2019-06-10T22:35:26Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "I've pushed fix for JSON encoding (don't feel a separate PR is necessary, the change is small) and removed the unnecessary `\"\"` pointers from the README",
          "createdAt": "2019-06-11T14:43:17Z",
          "updatedAt": "2019-06-11T14:43:17Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori Comments addressed",
          "createdAt": "2019-06-12T22:06:27Z",
          "updatedAt": "2019-06-12T22:06:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMjcxNDkz",
          "commit": {
            "abbreviatedOid": "31ebe5d"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-02T22:48:11Z",
          "updatedAt": "2019-05-02T22:48:11Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I use `dump-signedexchange` at the end of a pipe sometimes. I'd prefer if you updated this to allow the case where stdin != /dev/pty or whatever. Alternatively, maybe we could make `-i -` a valid syntax if it isn't already.",
              "createdAt": "2019-05-02T22:48:11Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMjg2ODAx",
          "commit": {
            "abbreviatedOid": "31ebe5d"
          },
          "author": "gabbifish",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Some small comments below! The error handling might play better with the piping use pattern Devin described.",
          "createdAt": "2019-05-02T23:55:13Z",
          "updatedAt": "2019-05-03T00:00:16Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'd rename this flagFilename to emphasize this pertains to local files, especially since flagURI has been added.",
              "createdAt": "2019-05-02T23:55:13Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 83,
              "body": "consistent with error returning above, I might make this an error: \r\n```suggestion\r\n\t\tfmt.Errorf(\"Need to pass -uri with URI of sxg or -i with file location of sxg \\n\")\r\n```",
              "createdAt": "2019-05-02T23:58:59Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzI0NDc5",
          "commit": {
            "abbreviatedOid": "2cdeb59"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T05:13:03Z",
          "updatedAt": "2019-05-03T05:13:04Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I didn't know you could use `dump-signedexchange` like that! Makes a lot of sense though. I've added that functionality back and documented a use case in the README.",
              "createdAt": "2019-05-03T05:13:03Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzI0NjQ4",
          "commit": {
            "abbreviatedOid": "2cdeb59"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T05:14:43Z",
          "updatedAt": "2019-05-03T05:14:44Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Turns out the `flag` library can print the usage. I've changed this message to simply print the usage, though it doesn't return anything. Do you think that pattern is OK even though the function doesn't return an error?",
              "createdAt": "2019-05-03T05:14:43Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzI1Njcy",
          "commit": {
            "abbreviatedOid": "60ea74d"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T05:23:53Z",
          "updatedAt": "2019-05-03T05:24:54Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "These four lines are the same in each branch of the if. Maybe just `var in` outside the `if` and set it in each branch.",
              "createdAt": "2019-05-03T05:24:19Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzI1ODAz",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T05:25:20Z",
          "updatedAt": "2019-05-03T05:25:20Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Nice! Thanks.",
              "createdAt": "2019-05-03T05:25:20Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzU5NzEz",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T08:09:55Z",
          "updatedAt": "2019-05-03T08:18:42Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Should we use b3 since it is now the default version?",
              "createdAt": "2019-05-03T08:09:55Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 13,
              "body": "ditto",
              "createdAt": "2019-05-03T08:10:01Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 45,
              "body": "Would you specify `any` here or add a commandline flag to modify this? (I'd like to avoid having `google` as default)",
              "createdAt": "2019-05-03T08:14:38Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 44,
              "body": "Would you make `b3` part configurable via command line flag?",
              "createdAt": "2019-05-03T08:15:34Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 55,
              "body": "I think we can rely on `strings.TrimSpace(*flagFilename) == \"-\"` instead",
              "createdAt": "2019-05-03T08:18:24Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzYzNzU2",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T08:22:58Z",
          "updatedAt": "2019-05-03T08:22:58Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Maybe even best to leave AMP-Cache-Transform out of this binary entirely and have a generic -requestHeader flag.",
              "createdAt": "2019-05-03T08:22:58Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzY0MjM4",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T08:24:34Z",
          "updatedAt": "2019-05-03T08:24:34Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Either works for me, but I like the current approach the best. Allows pipe usage to work without specifying `-i` at all, while still presenting the usage info when not in a pipe.",
              "createdAt": "2019-05-03T08:24:34Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNTIzNjYx",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T15:12:08Z",
          "updatedAt": "2019-05-03T15:12:09Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "I prefer early returns:\r\n\r\n```\r\nif e == nil {\r\n    flag.PrintDefaults()\r\n    return nil\r\n}\r\n```",
              "createdAt": "2019-05-03T15:12:09Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNTcwMzgz",
          "commit": {
            "abbreviatedOid": "77cd1a7"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T16:54:47Z",
          "updatedAt": "2019-05-03T16:54:47Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "This should be done, if there is an obvious better way to do this, please let me know.",
              "createdAt": "2019-05-03T16:54:47Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNTcwNTc4",
          "commit": {
            "abbreviatedOid": "77cd1a7"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T16:55:19Z",
          "updatedAt": "2019-05-03T16:55:19Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I've kept this as is, input can come from the pipe, the -i flag or the -uri flag",
              "createdAt": "2019-05-03T16:55:19Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNTg3OTQ2",
          "commit": {
            "abbreviatedOid": "77cd1a7"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks! Some nits. If @nyaxt approves before I do, don't wait for my approval. I'll defer that to him anyway.",
          "createdAt": "2019-05-03T17:36:35Z",
          "updatedAt": "2019-05-03T17:43:23Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Use [`strings.SplitN`](https://golang.org/pkg/strings/#SplitN), as it's possible for values to contain colons (e.g. `Location` or `Link`).",
              "createdAt": "2019-05-03T17:36:36Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 103,
              "body": "(opt, nit) Set `in` to `nil` at declaration time and compare to `nil` here.",
              "createdAt": "2019-05-03T17:39:18Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNzIyODc0",
          "commit": {
            "abbreviatedOid": "a61232d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-04T05:21:44Z",
          "updatedAt": "2019-05-04T05:27:22Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Would you factor this out as `func (v Version) MimeType() string` in `version.go`?",
              "createdAt": "2019-05-04T05:21:45Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 34,
              "body": "Would you do this in a way similar to https://github.com/WICG/webpackage/blob/master/go/signedexchange/cmd/gen-signedexchange/main.go#L52 ?",
              "createdAt": "2019-05-04T05:25:54Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0MzI3Mzgx",
          "commit": {
            "abbreviatedOid": "a61232d"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T06:26:08Z",
          "updatedAt": "2019-05-07T06:28:49Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Currently this tool prints mice-decoded payload if `-verify` is given (because `verify()` decodes the payload), but after this patch payload is not decoded at this point.\r\n\r\nI know this is confusing and we should fix it (#431), but can we keep the current behavior for now?\r\n",
              "createdAt": "2019-05-07T06:26:08Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 64,
              "body": "Would you move this branch to the last? I think the flags should take precedence.",
              "createdAt": "2019-05-07T06:26:14Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ3NzAxMjIx",
          "commit": {
            "abbreviatedOid": "a61232d"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-10T16:07:58Z",
          "updatedAt": "2019-06-10T16:07:59Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I believe this behavior is unchanged",
              "createdAt": "2019-06-10T16:07:58Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4MDE3ODYz",
          "commit": {
            "abbreviatedOid": "6929aeb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-11T08:18:47Z",
          "updatedAt": "2019-06-11T08:20:52Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "> the value should be enclosed with double quotations `\"\"`\r\n\r\nThis might be confusing, as `dump-signedexchange` itself doesn't interpret quotations. Quotations may be needed by command-line shells, but exact rules for quotation / escaping could be different by shells (so it's probably out of scope of this document).",
              "createdAt": "2019-06-11T08:18:48Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 64,
              "body": "`defer in.Close()` here?",
              "createdAt": "2019-06-11T08:18:54Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4MDcxMjQz",
          "commit": {
            "abbreviatedOid": "6929aeb"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-11T09:57:41Z",
          "updatedAt": "2019-06-11T09:57:41Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I'm not sure if I'm reading the docs right, but the examples don't seem to match the docs\u2014?\r\n\r\nThe examples seem to match curl's syntax (aside from the actual switch name), which seems like a good approach--well-understood by developers, and various tools seem to now output curl syntax for debugging (e.g. Chrome and Safari developer tools).",
              "createdAt": "2019-06-11T09:57:41Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4MjIzMTkx",
          "commit": {
            "abbreviatedOid": "6929aeb"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-11T14:39:01Z",
          "updatedAt": "2019-06-11T14:39:01Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Not sure exactly what needs to happen here as `io.Reader has no field or method Close`",
              "createdAt": "2019-06-11T14:39:01Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4MjI0Nzk5",
          "commit": {
            "abbreviatedOid": "6929aeb"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-11T14:41:13Z",
          "updatedAt": "2019-06-11T14:41:14Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "@ithinkihaveacat The examples should match? Could you point out what specifically is confusing? After this PR the tool will be able to take sxg input from a curl command and also by passing the URI via flag",
              "createdAt": "2019-06-11T14:41:13Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4NTExOTY2",
          "commit": {
            "abbreviatedOid": "f006f58"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, looking good.",
          "createdAt": "2019-06-12T01:38:34Z",
          "updatedAt": "2019-06-12T01:58:59Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Ah, then how about this:\r\n```\r\nf, err := os.Open(*flagFilename)\r\nif err != nil {\r\n  return err\r\n}\r\ndefer f.Close()\r\nin = f\r\n```",
              "createdAt": "2019-06-12T01:38:34Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n`dump-signedexchange` can also operate on piped input. For instance, you could run the following command to retrieve a b3 signed exchange.\r\n```",
              "createdAt": "2019-06-12T01:49:33Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nIf the specified URI requires a special header to serve a signed exchange, you can pass request headers via the `-requestHeader` flag. The header key and value should be separated by a `:`.\r\n```",
              "createdAt": "2019-06-12T01:53:02Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nWhen the `-uri` flag is passed to `dump-signedexchange`, you can specify the sxg version to request by passing a `-version` flag. For instance, if you wanted to request a `1b2` signed exchange, you would run the following command. By default, the version is `1b3`.\r\n```",
              "createdAt": "2019-06-12T01:55:55Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nIf you would like only the signature to be printed, pass the `-signature` flag.\r\n```",
              "createdAt": "2019-06-12T01:56:03Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MTAyMTMy",
          "commit": {
            "abbreviatedOid": "a38020b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2019-06-13T02:33:28Z",
          "updatedAt": "2019-06-13T02:33:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 437,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwNDI2NjE5",
      "title": "Fix minor typo",
      "url": "https://github.com/WICG/webpackage/pull/437",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-05-20T14:53:42Z",
      "updatedAt": "2019-05-20T15:22:41Z",
      "closedAt": "2019-05-20T15:22:40Z",
      "mergedAt": "2019-05-20T15:22:40Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5NTY1OTM4",
          "commit": {
            "abbreviatedOid": "c7ef1c4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-20T15:17:04Z",
          "updatedAt": "2019-05-20T15:17:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 439,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg1NjU1NDc4",
      "title": "dump-signedexchange: Refactor main.go",
      "url": "https://github.com/WICG/webpackage/pull/439",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Create certFetcher and verificationTime outside of jsonPrintHeaders()\r\n- Simplify initCertFetcher() function signature\r\n- Dump all signatures in the signature header",
      "createdAt": "2019-06-06T06:07:54Z",
      "updatedAt": "2019-06-06T09:17:00Z",
      "closedAt": "2019-06-06T09:16:49Z",
      "mergedAt": "2019-06-06T09:16:49Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2Mzk2NDk1",
          "commit": {
            "abbreviatedOid": "985cb96"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-06-06T07:17:28Z",
          "updatedAt": "2019-06-06T07:17:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 440,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg2MzUxMzk2",
      "title": "sinature -> signature",
      "url": "https://github.com/WICG/webpackage/pull/440",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix typo in error message.",
      "createdAt": "2019-06-07T22:31:25Z",
      "updatedAt": "2019-06-08T00:20:47Z",
      "closedAt": "2019-06-08T00:20:47Z",
      "mergedAt": "2019-06-08T00:20:47Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ3MzQ1NTU3",
          "commit": {
            "abbreviatedOid": "2d852b4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-06-08T00:20:23Z",
          "updatedAt": "2019-06-08T00:20:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 443,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4MTQ0NjMy",
      "title": "Correct logic to display warnings on unused flags",
      "url": "https://github.com/WICG/webpackage/pull/443",
      "state": "MERGED",
      "author": "ibnesayeed",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the warning is displayed when unnecessary flags are not specified, but it should be the other way.",
      "createdAt": "2019-06-14T00:46:01Z",
      "updatedAt": "2019-06-14T05:14:35Z",
      "closedAt": "2019-06-14T05:14:35Z",
      "mergedAt": "2019-06-14T05:14:35Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NzExMzYw",
          "commit": {
            "abbreviatedOid": "97082b6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2019-06-14T05:14:18Z",
          "updatedAt": "2019-06-14T05:14:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 444,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4MjEyODUw",
      "title": "dump-certurl: Add check for certificate's validity period",
      "url": "https://github.com/WICG/webpackage/pull/444",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Print warning or error message if main certificate has a validity period\r\nlonger than 90 days.",
      "createdAt": "2019-06-14T07:27:11Z",
      "updatedAt": "2019-06-17T01:32:07Z",
      "closedAt": "2019-06-17T01:32:01Z",
      "mergedAt": "2019-06-17T01:32:01Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @yutakahirano",
          "createdAt": "2019-06-14T07:27:40Z",
          "updatedAt": "2019-06-14T07:27:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NzcyMDg2",
          "commit": {
            "abbreviatedOid": "1793d93"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-06-14T08:30:27Z",
          "updatedAt": "2019-06-14T08:30:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 447,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyNjg2ODIw",
      "title": "Make dump-signedexchange show header integrity value",
      "url": "https://github.com/WICG/webpackage/pull/447",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This header integrity value will be used in \"allowed-alt-sxg\" link header to support subresource signed exchange loading.\r\n\r\nhttps://github.com/WICG/webpackage/issues/347#issuecomment-467743010",
      "createdAt": "2019-06-28T04:49:30Z",
      "updatedAt": "2019-06-28T07:43:16Z",
      "closedAt": "2019-06-28T07:43:16Z",
      "mergedAt": "2019-06-28T07:43:15Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "kumagi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM, It's very helpful feature for implementing subresource handling functions!",
          "createdAt": "2019-06-28T05:01:08Z",
          "updatedAt": "2019-06-28T05:01:08Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> Please re-run gofmt to fix indent around flag definitions.\r\n\r\ndone.\r\n",
          "createdAt": "2019-06-28T07:17:36Z",
          "updatedAt": "2019-06-28T07:17:36Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2019-06-28T07:43:04Z",
          "updatedAt": "2019-06-28T07:43:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg0MzQ3",
          "commit": {
            "abbreviatedOid": "8f2491b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T04:57:08Z",
          "updatedAt": "2019-06-28T05:05:53Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I don't think we need a flag - always printing header integrity is fine.",
              "createdAt": "2019-06-28T04:57:09Z",
              "updatedAt": "2019-06-28T07:16:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg4MjY1",
          "commit": {
            "abbreviatedOid": "044a439"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T05:20:48Z",
          "updatedAt": "2019-06-28T05:20:48Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Done.\r\nMoved into \"if *flagHeaders {}\"",
              "createdAt": "2019-06-28T05:20:48Z",
              "updatedAt": "2019-06-28T07:16:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg5MDU1",
          "commit": {
            "abbreviatedOid": "044a439"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Please re-run gofmt to fix indent around flag definitions.",
          "createdAt": "2019-06-28T05:24:47Z",
          "updatedAt": "2019-06-28T05:24:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 448,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyNjg5NjA3",
      "title": "CBOR header key must not contain UPPERCASE alphabet",
      "url": "https://github.com/WICG/webpackage/pull/448",
      "state": "MERGED",
      "author": "kumagi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-05#section-3.2\r\n\r\n```\r\nFor each response header field, the header field's lowercase name\r\n      as a byte string to the header field's value as a byte string.\r\n```\r\n\r\nWe should check response header's key does not contains uppercase name along with this spec.",
      "createdAt": "2019-06-28T05:09:17Z",
      "updatedAt": "2019-06-28T07:49:46Z",
      "closedAt": "2019-06-28T07:49:46Z",
      "mergedAt": "2019-06-28T07:49:46Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "kumagi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I appended the same logic into `decodeRequestMap` too.",
          "createdAt": "2019-06-28T05:45:39Z",
          "updatedAt": "2019-06-28T05:45:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg5NjM4",
          "commit": {
            "abbreviatedOid": "c4d2e0c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Could you add the same check in `decodeRequestMap` too? Current version of SXG (b3) only have response headers, but b1 and b2 have request headers which also must be lower-cased.",
          "createdAt": "2019-06-28T05:27:47Z",
          "updatedAt": "2019-06-28T05:35:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Please assign `string(key)` to a temporary variable and use it here and line 209 ([]byte -> string conversion makes a copy).",
              "createdAt": "2019-06-28T05:27:47Z",
              "updatedAt": "2019-06-28T05:43:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTkyNjQ1",
          "commit": {
            "abbreviatedOid": "b3b5fd8"
          },
          "author": "kumagi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T05:44:21Z",
          "updatedAt": "2019-06-28T05:44:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "OK, I'll assign it into `key_str`.",
              "createdAt": "2019-06-28T05:44:21Z",
              "updatedAt": "2019-06-28T05:44:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NjI4MTEw",
          "commit": {
            "abbreviatedOid": "b3b5fd8"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2019-06-28T07:48:59Z",
          "updatedAt": "2019-06-28T07:48:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 450,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzM0NzA1",
      "title": "Update the bundle format",
      "url": "https://github.com/WICG/webpackage/pull/450",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/update-bundle-format/draft-yasskin-wpack-bundled-exchanges.html.\r\n\r\nSorry for the late mail: I belatedly realized the [IETF deadline](https://datatracker.ietf.org/meeting/105/important-dates/) is Monday, and it\u2019d be nice to have an update to the bundle format published then. We\u2019ll be able to publish another revision at the beginning of the IETF week.\r\n\r\nThis update includes:\r\n\r\n* An invariant fallback URL, like signed exchanges have.\r\n* A version number, so we can easily know to fall back to a redirect.\r\n* Some infrastructure to identify what kind of error broke the parse, which can feed into both Network Error Logging and #397\u2019s discussion of when to fall back.\r\n* The [index](https://jyasskin.github.io/webpackage/update-bundle-format/draft-yasskin-wpack-bundled-exchanges.html#index-section) maps URLs to a Variants value + a list of the responses for each possible Variant-Key.\r\n* A new [signatures](https://jyasskin.github.io/webpackage/update-bundle-format/draft-yasskin-wpack-bundled-exchanges.html#signatures-section) section allows authorities to vouch for particular subsets of the bundle. For cross-origin trust, which I think will get defined in the loading spec, I think the requirement that the validity-url is same-origin is going to force us to make those single-origin subsets, even when there might be a certificate that is trusted to sign multiple origins. I\u2019ve run the basic structure by @sleevi who liked that the signed fields are all together in a byte string.\r\n",
      "createdAt": "2019-07-05T05:01:01Z",
      "updatedAt": "2019-07-10T17:56:50Z",
      "closedAt": "2019-07-08T18:41:05Z",
      "mergedAt": "2019-07-08T18:41:05Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjY0ODUx",
          "commit": {
            "abbreviatedOid": "dbb60f6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm from my side",
          "createdAt": "2019-07-08T02:27:00Z",
          "updatedAt": "2019-07-08T04:24:45Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "A \"format error\" with `fallbackUrl`?",
              "createdAt": "2019-07-08T02:27:00Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            },
            {
              "originalPosition": 320,
              "body": "Say that `location-in-responses` is the second and the third element of `responses`?",
              "createdAt": "2019-07-08T03:09:53Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            },
            {
              "originalPosition": 413,
              "body": "Remove \"N/A\"?",
              "createdAt": "2019-07-08T03:55:16Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NzgzNjE2",
          "commit": {
            "abbreviatedOid": "dbb60f6"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm % some comments.",
          "createdAt": "2019-07-08T09:24:43Z",
          "updatedAt": "2019-07-08T09:39:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "fallback URL == primaryUrl, is that right?  Felt it could be more clearly written out somewhere earlier than 3.3, step 21.",
              "createdAt": "2019-07-08T09:24:43Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            },
            {
              "originalPosition": 188,
              "body": "At this point we must have primaryUrl (or we can't return an error with fallbackUrl)?",
              "createdAt": "2019-07-08T09:29:58Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDQ5MDQ1",
          "commit": {
            "abbreviatedOid": "dbb60f6"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T17:25:44Z",
          "updatedAt": "2019-07-08T18:34:24Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Indeed, I've added a statement of that in 2.2.",
              "createdAt": "2019-07-08T17:25:44Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            },
            {
              "originalPosition": 151,
              "body": "Thanks, done.",
              "createdAt": "2019-07-08T18:27:59Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            },
            {
              "originalPosition": 188,
              "body": "Yep, I've moved this to an Assert on the previous line.",
              "createdAt": "2019-07-08T18:29:14Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            },
            {
              "originalPosition": 320,
              "body": "Good idea. Done.",
              "createdAt": "2019-07-08T18:30:59Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            },
            {
              "originalPosition": 413,
              "body": "Whoops, done.",
              "createdAt": "2019-07-08T18:31:12Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5ODc4NTc2",
          "commit": {
            "abbreviatedOid": "a39514f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-10T05:40:31Z",
          "updatedAt": "2019-07-10T05:40:32Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Oh, I had overlooked this... Now the top-level array has 6 elements, so this should be \"86 48 ...\".",
              "createdAt": "2019-07-10T05:40:31Z",
              "updatedAt": "2019-07-10T05:40:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYwMjYxMjky",
          "commit": {
            "abbreviatedOid": "a39514f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-10T17:56:49Z",
          "updatedAt": "2019-07-10T17:56:50Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Thanks! https://github.com/WICG/webpackage/pull/454",
              "createdAt": "2019-07-10T17:56:50Z",
              "updatedAt": "2019-07-10T17:56:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 451,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NTIwNDg3",
      "title": "Update load-response for the new return value of load-metadata.",
      "url": "https://github.com/WICG/webpackage/pull/451",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This should just be a bookkeeping change, so I'm going to merge it right away to make the IETF deadline, but please let me know if I got any of these changes wrong, and I'll fix them later.\r\n\r\nPreview at https://jyasskin.github.io/webpackage/update-load-response/draft-yasskin-wpack-bundled-exchanges.html#semantics-load-response.",
      "createdAt": "2019-07-08T22:35:11Z",
      "updatedAt": "2019-07-09T05:02:43Z",
      "closedAt": "2019-07-08T22:41:59Z",
      "mergedAt": "2019-07-08T22:41:59Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MjY5OTQz",
          "commit": {
            "abbreviatedOid": "d492607"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2019-07-09T05:02:43Z",
          "updatedAt": "2019-07-09T05:02:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 452,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NTM2NTgw",
      "title": "Improve impl 03",
      "url": "https://github.com/WICG/webpackage/pull/452",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/improve-impl-03/draft-yasskin-httpbis-origin-signed-exchanges-impl.html. Have I missed anything in describing how Chrome uses the b3 format? I'll publish -impl-03 on July 21.",
      "createdAt": "2019-07-08T23:59:42Z",
      "updatedAt": "2019-07-22T14:39:55Z",
      "closedAt": "2019-07-22T14:39:53Z",
      "mergedAt": "2019-07-22T14:39:53Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks @irori. That's fixed now.",
          "createdAt": "2019-07-10T16:48:43Z",
          "updatedAt": "2019-07-10T16:48:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5Mzc3NjEw",
          "commit": {
            "abbreviatedOid": "3519551"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\n> Have I missed anything in describing how Chrome uses the b3 format?\r\n\r\nI only see just one minor thing; otherwise I think this matches Chrome's behavior.\r\n\r\nSection 5.3. application/signed-exchange format\r\n> 1. 8 bytes consisting of the ASCII characters \u201csxg1-b3\u201d followed by a 0 byte, to serve as a file signature. This is redundant with the MIME type, and recipients that receive both MUST check that they match and stop parsing if they don\u2019t. \r\n\r\nChrome continues parsing until `fallbackUrl`, to perform fallback redirect in this case (version mismatch).\r\n",
          "createdAt": "2019-07-09T09:26:54Z",
          "updatedAt": "2019-07-09T09:26:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 453,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1ODk3NDAy",
      "title": "Provide error message for unexpected mime type",
      "url": "https://github.com/WICG/webpackage/pull/453",
      "state": "MERGED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When fetching with the `-uri` flag, the go http client can give us a more helpful error message than `unknown magic bytes: [60 33 100 111 99 116 121 112]`\r\n\r\nThis PR checks the mime type of the response against the expected mime type for the version it is requesting and if they do not equal, it will error with `GET \"https://example.com\" responded with unexpected content type \"text/html; charset=utf-8\"`",
      "createdAt": "2019-07-09T19:56:24Z",
      "updatedAt": "2019-07-16T05:25:47Z",
      "closedAt": "2019-07-16T05:25:47Z",
      "mergedAt": "2019-07-16T05:25:47Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5ODQxMDQ5",
          "commit": {
            "abbreviatedOid": "31cc678"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-07-10T02:15:17Z",
          "updatedAt": "2019-07-10T02:15:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 454,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk2MjgxMDM2",
      "title": "Use the right initial byte for the top-level 6-element array.",
      "url": "https://github.com/WICG/webpackage/pull/454",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks irori for noticing!",
      "createdAt": "2019-07-10T17:56:41Z",
      "updatedAt": "2019-07-22T14:37:52Z",
      "closedAt": "2019-07-22T14:37:50Z",
      "mergedAt": "2019-07-22T14:37:50Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYwNDI2MDQw",
          "commit": {
            "abbreviatedOid": "e37aefc"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm % comment",
          "createdAt": "2019-07-11T01:06:36Z",
          "updatedAt": "2019-07-11T01:06:53Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Magic number in Section 6.1 should be updated as well.\r\n",
              "createdAt": "2019-07-11T01:06:36Z",
              "updatedAt": "2019-07-22T14:27:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY0ODUzOTY4",
          "commit": {
            "abbreviatedOid": "07c00e4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-22T14:28:42Z",
          "updatedAt": "2019-07-22T14:28:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done, thanks.",
              "createdAt": "2019-07-22T14:28:42Z",
              "updatedAt": "2019-07-22T14:28:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 455,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk2Mjg5Nzk1",
      "title": "Fix a couple badly-padded base64 strings.",
      "url": "https://github.com/WICG/webpackage/pull/455",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @yuizumi!",
      "createdAt": "2019-07-10T18:23:45Z",
      "updatedAt": "2019-08-09T18:38:15Z",
      "closedAt": "2019-08-09T18:38:04Z",
      "mergedAt": "2019-08-09T18:38:04Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyOTE0NTM3",
          "commit": {
            "abbreviatedOid": "64b0c0e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-09T01:55:44Z",
          "updatedAt": "2019-08-09T01:55:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 456,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3NzU4OTE0",
      "title": "Delete buick.png",
      "url": "https://github.com/WICG/webpackage/pull/456",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is unused, and its creation commit offers no hint of its purpose.",
      "createdAt": "2019-07-15T19:38:18Z",
      "updatedAt": "2019-07-15T20:41:31Z",
      "closedAt": "2019-07-15T20:41:27Z",
      "mergedAt": "2019-07-15T20:41:27Z",
      "mergedBy": "twifkak",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMDM1MTI1",
          "commit": {
            "abbreviatedOid": "7826b3c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks. The use was removed in #131.",
          "createdAt": "2019-07-15T19:45:29Z",
          "updatedAt": "2019-07-15T19:45:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 457,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3ODA2MzE3",
      "title": "`dump-signedexchange -verify`: decode MICE again.",
      "url": "https://github.com/WICG/webpackage/pull/457",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This functionality was reverted in #429 (I think unintentionally);\r\nre-enabling, to allow use of this tool as a hacky way to extract\r\nMICE-decoded payload, via something like:\r\n\r\n$ cat sxg | dump-signedexchange -verify | sed '0,/^payload /d' >html",
      "createdAt": "2019-07-15T22:12:57Z",
      "updatedAt": "2019-07-16T04:59:58Z",
      "closedAt": "2019-07-16T04:59:58Z",
      "mergedAt": "2019-07-16T04:59:58Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMTExODk0",
          "commit": {
            "abbreviatedOid": "453a4ca"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "oops \ud83d\ude1b ",
          "createdAt": "2019-07-15T22:42:58Z",
          "updatedAt": "2019-07-15T22:42:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMTg3NzE1",
          "commit": {
            "abbreviatedOid": "453a4ca"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-07-16T04:59:38Z",
          "updatedAt": "2019-07-16T04:59:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 458,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3OTA2NzU5",
      "title": "go/bundle: Add support for multiple versions",
      "url": "https://github.com/WICG/webpackage/pull/458",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a preparation for supporting the new bundle format (#450).\r\n\r\n- Introduces `Version` type to represent spec versions. `version.Unversioned` represents the old format before #450.\r\n- `gen-bundle` now accepts `-version` flag. Note that it doesn't generate valid bundle in the new format yet.",
      "createdAt": "2019-07-16T07:17:01Z",
      "updatedAt": "2019-07-18T07:38:30Z",
      "closedAt": "2019-07-18T07:38:24Z",
      "mergedAt": "2019-07-18T07:38:24Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @yutakahirano @toyoshim",
          "createdAt": "2019-07-16T07:28:09Z",
          "updatedAt": "2019-07-16T07:28:09Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@nyaxt @hajimehoshi PTAL when you have time.",
          "createdAt": "2019-07-18T02:28:03Z",
          "updatedAt": "2019-07-18T02:28:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMjI1NTQ2",
          "commit": {
            "abbreviatedOid": "7ba49dd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-16T07:17:26Z",
          "updatedAt": "2019-07-16T07:17:26Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@jyasskin What implementation-specific version string should we use?",
              "createdAt": "2019-07-16T07:17:26Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzMjUzOTU5",
          "commit": {
            "abbreviatedOid": "40a5980"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-17T18:58:29Z",
          "updatedAt": "2019-07-17T18:58:30Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I\u2019d take \u201cb1\\0\\0\u201d for now, roughly matching signed exchanges.",
              "createdAt": "2019-07-17T18:58:30Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNDAyNjYw",
          "commit": {
            "abbreviatedOid": "40a5980"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-18T02:27:23Z",
          "updatedAt": "2019-07-18T02:27:24Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "OK, let's use \"b1\\0\\0\" for now.",
              "createdAt": "2019-07-18T02:27:24Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNDcwNzUx",
          "commit": {
            "abbreviatedOid": "40a5980"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm w/ nits",
          "createdAt": "2019-07-18T07:24:39Z",
          "updatedAt": "2019-07-18T07:25:54Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "The comment should start with `HeaderMagicBytesUnversioned is ...`",
              "createdAt": "2019-07-18T07:24:39Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            },
            {
              "originalPosition": 24,
              "body": "ditto",
              "createdAt": "2019-07-18T07:24:45Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNDc1NDky",
          "commit": {
            "abbreviatedOid": "bd71e13"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-18T07:35:21Z",
          "updatedAt": "2019-07-18T07:35:39Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "done.",
              "createdAt": "2019-07-18T07:35:21Z",
              "updatedAt": "2019-07-18T07:35:39Z"
            },
            {
              "originalPosition": 24,
              "body": "done.",
              "createdAt": "2019-07-18T07:35:27Z",
              "updatedAt": "2019-07-18T07:35:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 459,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3OTIyMjc2",
      "title": "certs.go: Remove PKCS#1 handling in parsePrivateKeyBlock()",
      "url": "https://github.com/WICG/webpackage/pull/459",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was a leftover from RSA keys support, which was removed in #330.",
      "createdAt": "2019-07-16T08:06:59Z",
      "updatedAt": "2019-07-17T00:53:54Z",
      "closedAt": "2019-07-17T00:53:49Z",
      "mergedAt": "2019-07-17T00:53:49Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMzA3Nzkw",
          "commit": {
            "abbreviatedOid": "b15659f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-16T09:56:18Z",
          "updatedAt": "2019-07-16T09:56:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMzgwOTIx",
          "commit": {
            "abbreviatedOid": "b15659f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-16T12:32:54Z",
          "updatedAt": "2019-07-16T12:32:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 460,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk4Nzk0MDk2",
      "title": "go/bundle: Move decoder / encoder code to separate files",
      "url": "https://github.com/WICG/webpackage/pull/460",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This patch splits `bundle.go` into three files:\r\n\r\n- `bundle.go` - definition of common data types and some utility functions\r\n- `encoder.go` - bundle generation code\r\n- `decoder.go` - bundle parsing code\r\n\r\nCode moves only, no functional changes.\r\n",
      "createdAt": "2019-07-18T07:51:11Z",
      "updatedAt": "2019-07-18T08:04:08Z",
      "closedAt": "2019-07-18T08:03:48Z",
      "mergedAt": "2019-07-18T08:03:48Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @toyoshim @yutakahirano",
          "createdAt": "2019-07-18T07:51:48Z",
          "updatedAt": "2019-07-18T07:51:48Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the quick review!",
          "createdAt": "2019-07-18T08:04:04Z",
          "updatedAt": "2019-07-18T08:04:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNDg3MzA2",
          "commit": {
            "abbreviatedOid": "5a15e6d"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-18T08:00:15Z",
          "updatedAt": "2019-07-18T08:00:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 461,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk4ODI2MDAx",
      "title": "go/bundle: Add support for PrimaryURL (aka fallbackURL)",
      "url": "https://github.com/WICG/webpackage/pull/461",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Adds `PrimaryURL` field to `Bundle` struct, and adds parsing / serializing code for that\r\n- Updates loadMetadata() to reflect the spec changes of #450\r\n  - Now it returns a fallback URL if available\r\n  - Updated spec ref comments\r\n",
      "createdAt": "2019-07-18T09:23:11Z",
      "updatedAt": "2019-07-24T04:53:35Z",
      "closedAt": "2019-07-24T04:53:25Z",
      "mergedAt": "2019-07-24T04:53:25Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @toyoshim @yutakahirano",
          "createdAt": "2019-07-18T09:23:35Z",
          "updatedAt": "2019-07-18T09:23:35Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the review!",
          "createdAt": "2019-07-24T04:53:32Z",
          "updatedAt": "2019-07-24T04:53:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NTE1NDMx",
          "commit": {
            "abbreviatedOid": "515a2c1"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-23T16:02:14Z",
          "updatedAt": "2019-07-23T16:12:06Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'd like to keep `error` as the last return arg list.\r\n\r\ntwo ideas:\r\n1. reorder the return arg list, or\r\n2. create a struct which implements error interface, which allows fallbackUrl extraction",
              "createdAt": "2019-07-23T16:02:14Z",
              "updatedAt": "2019-07-24T01:34:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NzU0NzA0",
          "commit": {
            "abbreviatedOid": "25135da"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-24T01:36:51Z",
          "updatedAt": "2019-07-24T01:36:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Created LoadMetadataError struct which embeds an error interface.",
              "createdAt": "2019-07-24T01:36:51Z",
              "updatedAt": "2019-07-24T01:36:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NzYzODEy",
          "commit": {
            "abbreviatedOid": "25135da"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-24T02:23:00Z",
          "updatedAt": "2019-07-24T02:23:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 464,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMDM0MzIz",
      "title": "Pin -impl-03 on header-structure-10.",
      "url": "https://github.com/WICG/webpackage/pull/464",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/impl-03-on-header-structure-10/draft-yasskin-httpbis-origin-signed-exchanges-impl.html. This was needed because header-structure released a -11 which isn't used by the sxg-03 implementations.",
      "createdAt": "2019-07-22T20:51:31Z",
      "updatedAt": "2019-07-23T01:52:35Z",
      "closedAt": "2019-07-23T01:52:33Z",
      "mergedAt": "2019-07-23T01:52:33Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1MTM2NTM0",
          "commit": {
            "abbreviatedOid": "a98eca4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-07-23T01:48:48Z",
          "updatedAt": "2019-07-23T01:48:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 466,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwNTc3MTIy",
      "title": "go/bundle: Add support for the new index section format",
      "url": "https://github.com/WICG/webpackage/pull/466",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds parsing / serializing code of the index section in the new (b1) format (#450).\r\nCurrently, multiple responses for a single URL is not supported.\r\n\r\nAfter this patch, gen-bundle generates valid bundles in b1 format.\r\n\r\ncc: @toyoshim @yutakahirano",
      "createdAt": "2019-07-24T06:23:11Z",
      "updatedAt": "2019-08-06T01:47:18Z",
      "closedAt": "2019-08-06T01:47:10Z",
      "mergedAt": "2019-08-06T01:47:10Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@hajimehoshi @nyaxt PTAL when you have time.\r\nThanks!",
          "createdAt": "2019-07-30T07:55:28Z",
          "updatedAt": "2019-07-30T07:55:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcwNzU1MDM3",
          "commit": {
            "abbreviatedOid": "a9e5b8a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-05T13:09:26Z",
          "updatedAt": "2019-08-05T13:23:20Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Optional Nit: make err msg prefix consistent with others?\r\n\"bundle.index: Failed to...\"",
              "createdAt": "2019-08-05T13:09:26Z",
              "updatedAt": "2019-08-06T01:08:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcxMDcyOTE1",
          "commit": {
            "abbreviatedOid": "1878af5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-06T01:09:45Z",
          "updatedAt": "2019-08-06T01:09:46Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Done.",
              "createdAt": "2019-08-06T01:09:46Z",
              "updatedAt": "2019-08-06T01:09:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 467,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwODU2Njk4",
      "title": "Replace the second -impl author with Kunihiko, who's now in charge of implementation.",
      "url": "https://github.com/WICG/webpackage/pull/467",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-24T19:09:01Z",
      "updatedAt": "2019-07-25T03:27:47Z",
      "closedAt": "2019-07-25T03:27:45Z",
      "mergedAt": "2019-07-25T03:27:45Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2MzgzMzQy",
          "commit": {
            "abbreviatedOid": "fcfdf8f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-25T03:24:00Z",
          "updatedAt": "2019-07-25T03:24:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 474,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAyNDIxMjU2",
      "title": "Update go/signedexchange/README.md",
      "url": "https://github.com/WICG/webpackage/pull/474",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Use `-days 90` when creating a self-signed certificate, as certificate\r\nlifetime is limited to maximum 90 days. (#383)",
      "createdAt": "2019-07-30T09:57:34Z",
      "updatedAt": "2019-07-31T05:29:56Z",
      "closedAt": "2019-07-31T05:29:50Z",
      "mergedAt": "2019-07-31T05:29:50Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY4NzkxMjcx",
          "commit": {
            "abbreviatedOid": "e0a55a8"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-07-31T05:29:00Z",
          "updatedAt": "2019-07-31T05:29:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 475,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzMjMyMjI4",
      "title": "CBOR decoder: block  resource exhaustion attacks",
      "url": "https://github.com/WICG/webpackage/pull/475",
      "state": "MERGED",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As stated in https://tools.ietf.org/html/rfc7049#section-8, CBOR decoder should be careful about resource exhaustion attacks. Typical one could be passing `0x5BFFFFFFFFFFFFFFFF`, a header saying \"I am a byte string of length 2^64 - 1\", without actual data followed.\r\n\r\nCurrent implementation allocates memory for following bytes exactly as the header requested:\r\nhttps://github.com/WICG/webpackage/blob/ce24b25d587c891a45aa6602fef2ded1854d45fa/go/signedexchange/cbor/decoder.go#L93-L98\r\n\r\nFor instance, Chromium checks the size of rest bytes beforehand to defend against this:\r\nhttps://github.com/chromium/chromium/blob/6efa1184771ace08f3e2162b0255c93526d1750d/components/cbor/reader.cc#L352-L355\r\n\r\nDisclaimer: I'm not familiar with golang so if there is any better solution, please go that way.\r\n\r\nGolang's `io.Reader` seems a sort of \"stream\" interface therefore the same solution cannot be applicable.\r\nAlternatives could be\r\n- Stop using `io.Reader`\r\n- Read byte by byte into growing buffer\r\n- Try to read by doubling the size (read 1 byte, 2 byte, 4byte, 8 byte...)\r\n(The last two are almost same in terms of amortized complexity trick but the latter can be faster if the read operation costs)\r\n\r\nCurrent choice is to use `bytes.Buffer`, which is, to my understanding, a wrapped growing byte vector which can behave as `io.Writer`. That's because changing to this is super-easy and doesn't cost computation time a lot, very similar to the second solution above.\r\n\r\n",
      "createdAt": "2019-08-01T06:12:33Z",
      "updatedAt": "2019-08-01T07:50:25Z",
      "closedAt": "2019-08-01T07:50:25Z",
      "mergedAt": "2019-08-01T07:50:25Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for reviewing! I added one.",
          "createdAt": "2019-08-01T07:46:26Z",
          "updatedAt": "2019-08-01T07:46:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5NDI0MDcz",
          "commit": {
            "abbreviatedOid": "9c563eb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you! Code change lgtm.\r\n\r\nWould you add a test in `decoder_test.go` which just checks that the decoder doesn't crash on such an input?\r\n",
          "createdAt": "2019-08-01T06:47:56Z",
          "updatedAt": "2019-08-01T06:47:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5NDQ4NTg0",
          "commit": {
            "abbreviatedOid": "8a25098"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-08-01T07:49:32Z",
          "updatedAt": "2019-08-01T07:49:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 476,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzMjYyMTg2",
      "title": "Fix error message: mix-up between encode and decode",
      "url": "https://github.com/WICG/webpackage/pull/476",
      "state": "MERGED",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While working on #475 I happened to find tiny errata in the file.",
      "createdAt": "2019-08-01T07:52:15Z",
      "updatedAt": "2019-08-01T07:55:55Z",
      "closedAt": "2019-08-01T07:55:55Z",
      "mergedAt": "2019-08-01T07:55:55Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5NDUwOTY3",
          "commit": {
            "abbreviatedOid": "301a1b3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-08-01T07:54:10Z",
          "updatedAt": "2019-08-01T07:54:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 479,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDE0NzM0",
      "title": "gen-bundle: Better support for b1 and refactoring",
      "url": "https://github.com/WICG/webpackage/pull/479",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Behavioral changes:\r\n- -startURL flag is renamed to -primaryURL, and now it's required\r\n- -startURL and -manifestURL must be absolute\r\n\r\nNon-behavioral changes:\r\n- Move fromHar() and its helpers to a separate file (fromhar.go)\r\n- Now fromHar() and fromDir() return a list of exchanges\r\n",
      "createdAt": "2019-08-08T05:33:14Z",
      "updatedAt": "2019-08-08T07:34:12Z",
      "closedAt": "2019-08-08T07:34:12Z",
      "mergedAt": "2019-08-08T07:34:12Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "(Trying to re-run Travis CI)",
          "createdAt": "2019-08-08T07:25:45Z",
          "updatedAt": "2019-08-08T07:25:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyMzgyODgz",
          "commit": {
            "abbreviatedOid": "df78f5f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T07:20:26Z",
          "updatedAt": "2019-08-08T07:20:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 480,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDIxNDY2",
      "title": "cbor/encoder.go: EncodeMap() should fail on duplicated map keys",
      "url": "https://github.com/WICG/webpackage/pull/480",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-08T06:03:44Z",
      "updatedAt": "2019-08-08T07:17:19Z",
      "closedAt": "2019-08-08T07:17:14Z",
      "mergedAt": "2019-08-08T07:17:14Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyMzgwMDcy",
          "commit": {
            "abbreviatedOid": "856abb8"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T07:13:27Z",
          "updatedAt": "2019-08-08T07:13:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 481,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDg0NjU0",
      "title": "gen-bundle: Do not create multiple exchanges for single URL",
      "url": "https://github.com/WICG/webpackage/pull/481",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-08T09:20:31Z",
      "updatedAt": "2019-08-08T09:30:31Z",
      "closedAt": "2019-08-08T09:30:26Z",
      "mergedAt": "2019-08-08T09:30:25Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNDQ2NTEz",
          "commit": {
            "abbreviatedOid": "dae6384"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T09:23:55Z",
          "updatedAt": "2019-08-08T09:23:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 482,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDg1NzYz",
      "title": "gen-bundle: Remove warning for -primaryURL with -har",
      "url": "https://github.com/WICG/webpackage/pull/482",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Forgot to remove in #479.",
      "createdAt": "2019-08-08T09:23:13Z",
      "updatedAt": "2019-08-08T09:30:54Z",
      "closedAt": "2019-08-08T09:30:49Z",
      "mergedAt": "2019-08-08T09:30:49Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNDQ5NDY5",
          "commit": {
            "abbreviatedOid": "b4e9020"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T09:29:15Z",
          "updatedAt": "2019-08-08T09:29:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 483,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDg3MDY4",
      "title": "gen-bundle: Update the default format version to b1",
      "url": "https://github.com/WICG/webpackage/pull/483",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-08T09:26:32Z",
      "updatedAt": "2019-08-08T09:31:20Z",
      "closedAt": "2019-08-08T09:31:13Z",
      "mergedAt": "2019-08-08T09:31:13Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNDQ5NTky",
          "commit": {
            "abbreviatedOid": "96d59cb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T09:29:27Z",
          "updatedAt": "2019-08-08T09:29:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 484,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NzkzMjk2",
      "title": "Fix #445: Empty responses like redirections don't need a content type.",
      "url": "https://github.com/WICG/webpackage/pull/484",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Does this make sense?",
      "createdAt": "2019-08-09T00:20:07Z",
      "updatedAt": "2019-08-09T18:37:40Z",
      "closedAt": "2019-08-09T18:37:38Z",
      "mergedAt": "2019-08-09T18:37:38Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyOTE0MjYx",
          "commit": {
            "abbreviatedOid": "139e65e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-08-09T01:54:18Z",
          "updatedAt": "2019-08-09T01:54:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 485,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA3MTc2MzQx",
      "title": "Move go/signedexchange/internal/signingalgorithm package to go/internal/",
      "url": "https://github.com/WICG/webpackage/pull/485",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This package will be used from go/bundle too.",
      "createdAt": "2019-08-14T05:42:26Z",
      "updatedAt": "2019-08-14T10:40:30Z",
      "closedAt": "2019-08-14T06:20:54Z",
      "mergedAt": "2019-08-14T06:20:54Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0Njg1NjEy",
          "commit": {
            "abbreviatedOid": "607850d"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-14T06:18:56Z",
          "updatedAt": "2019-08-14T06:18:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0ODAzMzI0",
          "commit": {
            "abbreviatedOid": "607850d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2019-08-14T10:40:30Z",
          "updatedAt": "2019-08-14T10:40:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 486,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA3OTY0OTY2",
      "title": "go: Refactor certchain.go",
      "url": "https://github.com/WICG/webpackage/pull/486",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- `CertChainItem` struct is renamed to `AugmentedCertificate` (to match the spec).\r\n- Added methods that {encode,decode} an `AugmentedCertificate` {to,from}\r\n  `cbor.{Encoder,Decoder}`. These will be used from go/bundle to process the\r\n  signatures section.\r\n- Utility methods `Validate()` and `CertSha256()` are added.",
      "createdAt": "2019-08-16T07:02:15Z",
      "updatedAt": "2019-08-16T07:28:48Z",
      "closedAt": "2019-08-16T07:28:20Z",
      "mergedAt": "2019-08-16T07:28:20Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc1ODAyNDcy",
          "commit": {
            "abbreviatedOid": "18b9831"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-16T07:08:04Z",
          "updatedAt": "2019-08-16T07:10:05Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Would you describe what `AugmentedCertificate` is as a comment?",
              "createdAt": "2019-08-16T07:08:05Z",
              "updatedAt": "2019-08-16T07:22:19Z"
            },
            {
              "originalPosition": 16,
              "body": "(Would you add a specref?)",
              "createdAt": "2019-08-16T07:10:01Z",
              "updatedAt": "2019-08-16T07:22:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc1ODA3MjY5",
          "commit": {
            "abbreviatedOid": "ed747b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-16T07:23:14Z",
          "updatedAt": "2019-08-16T07:23:15Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Spec ref added.",
              "createdAt": "2019-08-16T07:23:14Z",
              "updatedAt": "2019-08-16T07:23:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 487,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4NDIxNDg4",
      "title": "go: Refactor mice versioning code",
      "url": "https://github.com/WICG/webpackage/pull/487",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Pure refactoring, no behavioral changes.",
      "createdAt": "2019-08-19T02:28:51Z",
      "updatedAt": "2019-08-19T05:32:18Z",
      "closedAt": "2019-08-19T05:32:03Z",
      "mergedAt": "2019-08-19T05:32:03Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzIwMjA0",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T02:38:26Z",
          "updatedAt": "2019-08-19T02:38:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I was wondering if this change keeps this behavior.",
              "createdAt": "2019-08-19T02:38:27Z",
              "updatedAt": "2019-08-19T02:38:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzI2Mzk0",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T03:18:03Z",
          "updatedAt": "2019-08-19T03:18:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzI3Mjgy",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T03:23:54Z",
          "updatedAt": "2019-08-19T03:23:54Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Any counter examples? `IntegrityIdentifier()` returns `\"digest/mi-sha256-03\"` for `Draft03Encoding`, which matches `\"digest/\" + enc.ContentEncoding()`.",
              "createdAt": "2019-08-19T03:23:54Z",
              "updatedAt": "2019-08-19T03:23:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzQzNTQx",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T05:11:01Z",
          "updatedAt": "2019-08-19T05:11:05Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Hm, I could not see the assumption from this PR.",
              "createdAt": "2019-08-19T05:11:01Z",
              "updatedAt": "2019-08-19T05:11:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzQ3MDM5",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T05:30:05Z",
          "updatedAt": "2019-08-19T05:30:05Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Well, the original code assumed that the digest algorithm and the HTTP content encoding share the same name. This holds for [http-mice-03](https://tools.ietf.org/html/draft-thomson-http-mice-03#section-6), but it's not necessarily true.",
              "createdAt": "2019-08-19T05:30:05Z",
              "updatedAt": "2019-08-19T05:30:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 488,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4NTI2Nzgy",
      "title": "go/bundle: Implement encoder / decoder for the signatures section",
      "url": "https://github.com/WICG/webpackage/pull/488",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds data structures for the signature section [1], and encoder / decoder for the section. Signing and verification code will be added in follow-up PRs.\r\n\r\n[1] https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#signatures-section",
      "createdAt": "2019-08-19T09:42:51Z",
      "updatedAt": "2019-08-20T01:10:11Z",
      "closedAt": "2019-08-20T01:10:06Z",
      "mergedAt": "2019-08-20T01:10:06Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for your review!",
          "createdAt": "2019-08-20T01:02:33Z",
          "updatedAt": "2019-08-20T01:02:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NDY3OTUw",
          "commit": {
            "abbreviatedOid": "3a4b250"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T10:24:31Z",
          "updatedAt": "2019-08-19T10:25:14Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "nit: You can write `{}` instead of `struct{}{}`",
              "createdAt": "2019-08-19T10:24:31Z",
              "updatedAt": "2019-08-20T01:01:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NTkwNzYw",
          "commit": {
            "abbreviatedOid": "3a4b250"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T14:18:38Z",
          "updatedAt": "2019-08-19T14:18:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2ODg1NzA1",
          "commit": {
            "abbreviatedOid": "6ac59c6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-20T01:02:23Z",
          "updatedAt": "2019-08-20T01:02:23Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Done.",
              "createdAt": "2019-08-20T01:02:23Z",
              "updatedAt": "2019-08-20T01:02:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 489,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4ODI1ODI5",
      "title": "Provisionally register media types.",
      "url": "https://github.com/WICG/webpackage/pull/489",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Once this is in, I'll send the actual requests to\r\nhttps://www.iana.org/form/media-types.",
      "createdAt": "2019-08-19T23:55:05Z",
      "updatedAt": "2019-09-26T23:04:54Z",
      "closedAt": "2019-09-04T04:54:30Z",
      "mergedAt": "2019-09-04T04:54:30Z",
      "mergedBy": "kinu",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzMzc1MjY4",
          "commit": {
            "abbreviatedOid": "6a22190"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sorry for the delay. This lgtm!",
          "createdAt": "2019-09-04T04:54:15Z",
          "updatedAt": "2019-09-04T04:54:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 490,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4OTEyMjEz",
      "title": "go/bundle: Add sign-bundle tool",
      "url": "https://github.com/WICG/webpackage/pull/490",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds `sign-bundle` command line tool. It takes an existing bundle, a certificate chain (generated by `gen-certurl`) and a private key, and creates a new bundle with a \"signatures\" section added.\r\n\r\nThe generated signatures section includes a signature that covers all exchanges whose hostname matches the certificate. Also, this tool encodes those exchanges with the mi-sha256-03 content encoding.",
      "createdAt": "2019-08-20T07:27:28Z",
      "updatedAt": "2019-08-26T01:38:02Z",
      "closedAt": "2019-08-26T01:37:53Z",
      "mergedAt": "2019-08-26T01:37:53Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Could you review `signer.go` to see if the signing message is correct?",
          "createdAt": "2019-08-20T07:27:42Z",
          "updatedAt": "2019-08-20T07:27:42Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the reviews!",
          "createdAt": "2019-08-26T01:32:29Z",
          "updatedAt": "2019-08-26T01:32:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjU3MTU4",
          "commit": {
            "abbreviatedOid": "2d9897c"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Non-authoritative lgtm",
          "createdAt": "2019-08-22T08:14:53Z",
          "updatedAt": "2019-08-22T08:20:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "nit: thils -> this",
              "createdAt": "2019-08-22T08:14:53Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            },
            {
              "originalPosition": 27,
              "body": "a \"signed-subset\" structure",
              "createdAt": "2019-08-22T08:18:08Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjY4NDYx",
          "commit": {
            "abbreviatedOid": "6f1d017"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-22T08:36:33Z",
          "updatedAt": "2019-08-22T08:36:34Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "fixed",
              "createdAt": "2019-08-22T08:36:34Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjY4NTQx",
          "commit": {
            "abbreviatedOid": "6f1d017"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-22T08:36:41Z",
          "updatedAt": "2019-08-22T08:36:42Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "fixed",
              "createdAt": "2019-08-22T08:36:41Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4OTg3NjIx",
          "commit": {
            "abbreviatedOid": "6f1d017"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-23T13:09:08Z",
          "updatedAt": "2019-08-23T13:17:23Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Optional nit: we may want to copy main()/run() idiom: https://github.com/WICG/webpackage/blob/master/go/bundle/cmd/dump-bundle/main.go#L62",
              "createdAt": "2019-08-23T13:09:08Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc5MjUwODQx",
          "commit": {
            "abbreviatedOid": "6f1d017"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "The signature format looks right, thanks!",
          "createdAt": "2019-08-23T22:48:22Z",
          "updatedAt": "2019-08-23T22:52:45Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "I think this is ok, but it may lead to duplicate intermediate certificates in the authorities list.",
              "createdAt": "2019-08-23T22:48:22Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc5MzY3NjY0",
          "commit": {
            "abbreviatedOid": "f50a840"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-26T01:30:42Z",
          "updatedAt": "2019-08-26T01:30:42Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Done.",
              "createdAt": "2019-08-26T01:30:42Z",
              "updatedAt": "2019-08-26T01:30:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc5MzY3ODE2",
          "commit": {
            "abbreviatedOid": "f50a840"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-26T01:32:01Z",
          "updatedAt": "2019-08-26T01:32:01Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "Added a TODO comment to deduplicate intermediate certificates.",
              "createdAt": "2019-08-26T01:32:01Z",
              "updatedAt": "2019-08-26T01:32:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 491,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA5Nzc4NDU5",
      "title": "TravisCI: Run jobs in parallel",
      "url": "https://github.com/WICG/webpackage/pull/491",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a follow up to https://github.com/WICG/webpackage/pull/416.",
      "createdAt": "2019-08-22T04:43:26Z",
      "updatedAt": "2019-08-22T20:33:25Z",
      "closedAt": "2019-08-22T20:33:24Z",
      "mergedAt": "2019-08-22T20:33:24Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, this seems to be working well.\r\nhttps://travis-ci.org/WICG/webpackage/builds/575171117",
          "createdAt": "2019-08-22T04:50:51Z",
          "updatedAt": "2019-08-22T04:50:51Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2019-08-22T20:33:13Z",
          "updatedAt": "2019-08-22T20:33:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4NjcwNzQ0",
          "commit": {
            "abbreviatedOid": "a968db1"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-22T20:33:06Z",
          "updatedAt": "2019-08-22T20:33:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 492,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA5ODMzMjY0",
      "title": "README: link to bundle tool",
      "url": "https://github.com/WICG/webpackage/pull/492",
      "state": "MERGED",
      "author": "proppy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- add link to bundle too\r\n- fix signedexchange `go install` url",
      "createdAt": "2019-08-22T08:12:08Z",
      "updatedAt": "2019-08-23T01:17:50Z",
      "closedAt": "2019-08-23T01:17:50Z",
      "mergedAt": "2019-08-23T01:17:50Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjU2NTk4",
          "commit": {
            "abbreviatedOid": "97d627b"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The tools are still being updated but could be good to have links...",
          "createdAt": "2019-08-22T08:13:47Z",
          "updatedAt": "2019-08-22T08:13:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjY2NzE3",
          "commit": {
            "abbreviatedOid": "97d627b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-22T08:33:09Z",
          "updatedAt": "2019-08-22T08:33:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4NjcxMzQ3",
          "commit": {
            "abbreviatedOid": "97d627b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-22T20:34:19Z",
          "updatedAt": "2019-08-22T20:34:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 493,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEwNzU2MjU0",
      "title": "go/bundle: Add signature verifier",
      "url": "https://github.com/WICG/webpackage/pull/493",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After this patch, `dump-bundle` tool will verify exchanges based on the\r\ncontent of the `signatures` section.\r\n\r\nThe `Dump` method in `bundle.go` is moved to `dump-bundle/main.go` to avoid\r\ncircular package dependency between `go/bundle` and `go/bundle/signature`.",
      "createdAt": "2019-08-26T04:17:16Z",
      "updatedAt": "2019-08-28T09:14:19Z",
      "closedAt": "2019-08-28T09:14:14Z",
      "mergedAt": "2019-08-28T09:14:14Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNjgxODg0",
          "commit": {
            "abbreviatedOid": "67af904"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-28T08:54:01Z",
          "updatedAt": "2019-08-28T08:55:12Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Is it OK not to take io.Writer?",
              "createdAt": "2019-08-28T08:54:01Z",
              "updatedAt": "2019-08-28T09:04:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNjg2MjU5",
          "commit": {
            "abbreviatedOid": "67af904"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T09:01:28Z",
          "updatedAt": "2019-08-28T09:01:29Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I think stdout-only is fine for now, as user can redirect the output.",
              "createdAt": "2019-08-28T09:01:28Z",
              "updatedAt": "2019-08-28T09:04:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 494,
      "id": "MDExOlB1bGxSZXF1ZXN0MzExNzMzODkz",
      "title": "go/bundle: Fix CBOR type in signing message",
      "url": "https://github.com/WICG/webpackage/pull/494",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`variants-value` is a [byte string](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#index-section), not a text string.",
      "createdAt": "2019-08-28T08:50:06Z",
      "updatedAt": "2019-08-28T12:01:44Z",
      "closedAt": "2019-08-28T08:56:46Z",
      "mergedAt": "2019-08-28T08:56:46Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNjc5OTE1",
          "commit": {
            "abbreviatedOid": "e93cdb2"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-28T08:50:37Z",
          "updatedAt": "2019-08-28T08:50:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNzc3MzYy",
          "commit": {
            "abbreviatedOid": "e93cdb2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2019-08-28T12:01:44Z",
          "updatedAt": "2019-08-28T12:01:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 495,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEzNDMzODIy",
      "title": "gen-bundle: Add option to create a bundle from URL list",
      "url": "https://github.com/WICG/webpackage/pull/495",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After this patch, `gen-bundle -URLList urls.txt` will fetch URLs listed\r\nin `urls.txt` and create a bundle from their responses.\r\n",
      "createdAt": "2019-09-03T06:02:43Z",
      "updatedAt": "2019-09-03T07:17:33Z",
      "closedAt": "2019-09-03T07:17:27Z",
      "mergedAt": "2019-09-03T07:17:27Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgyNzc4MDgw",
          "commit": {
            "abbreviatedOid": "765b06e"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2019-09-03T06:17:39Z",
          "updatedAt": "2019-09-03T06:18:51Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "nit:\r\n\r\n# A line starting with '#' is a comment.",
              "createdAt": "2019-09-03T06:17:39Z",
              "updatedAt": "2019-09-03T06:25:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgyNzgwNzQy",
          "commit": {
            "abbreviatedOid": "4710bf3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-03T06:25:49Z",
          "updatedAt": "2019-09-03T06:25:49Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "done",
              "createdAt": "2019-09-03T06:25:49Z",
              "updatedAt": "2019-09-03T06:25:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgyNzk5MTI1",
          "commit": {
            "abbreviatedOid": "4710bf3"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-03T07:14:37Z",
          "updatedAt": "2019-09-03T07:14:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 501,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0ODU0ODM4",
      "title": "Add a rough draft charter for the IETF WPACK WG.",
      "url": "https://github.com/WICG/webpackage/pull/501",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is based on the problem statement and scope drafted in https://docs.google.com/document/d/1OUZcl6yQSJ5eZxMrbo6O2tVRW_U_bv0PZUxAVtR1GYA/edit and discussed at https://mailarchive.ietf.org/arch/msg/wpack/ctrnRXXda2X6z0Z6creNcTQX9AM.",
      "createdAt": "2019-10-04T21:23:25Z",
      "updatedAt": "2019-10-10T17:45:18Z",
      "closedAt": "2019-10-10T17:45:17Z",
      "mergedAt": "2019-10-10T17:45:17Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 503,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2OTIwMzM1",
      "title": "Add a pre-installation use case.",
      "url": "https://github.com/WICG/webpackage/pull/503",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I don't fully understand this use case, and why other solutions don't work well, so please suggest improvements.\r\n\r\n@bkardell @riju",
      "createdAt": "2019-10-10T20:40:13Z",
      "updatedAt": "2019-10-14T19:40:52Z",
      "closedAt": "2019-10-14T19:40:51Z",
      "mergedAt": "2019-10-14T19:40:51Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "riju",
          "authorAssociation": "NONE",
          "body": "I basically meant use cases like a Digital Signage, similar to [Chrome's kiosk mode](https://developer.chrome.com/apps/manifest/kiosk_enabled), without PlayStore/WebStore and user's ability to install apps. The device can be a Point of Sale device or a Shopping mall / Library Catalog system, usually single-purpose, where the app is managed by some admin. \r\n\r\nChrome Apps on CrOS in kiosk mode fills this gap, but if someone wants to run say, their downstream chromium on Linux and not use Chrome extensions but Web Standards, WebPackaging might help to pre-install their app in such a scenario.",
          "createdAt": "2019-10-11T11:44:48Z",
          "updatedAt": "2019-10-11T11:44:48Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "> I basically meant use cases like a Digital Signage, similar to [Chrome's kiosk mode](https://developer.chrome.com/apps/manifest/kiosk_enabled), without PlayStore/WebStore and user's ability to install apps. The device can be a Point of Sale device or a Shopping mall / Library Catalog system, usually single-purpose, where the app is managed by some admin.\r\n\r\nIf the device comes with web packaging in the way @jyasskin described in the change I think it'd work like that but are there something specifically more you wanted to see / evolve?",
          "createdAt": "2019-10-11T14:13:48Z",
          "updatedAt": "2019-10-11T14:13:48Z"
        },
        {
          "author": "bkardell",
          "authorAssociation": "NONE",
          "body": "I'd like to + in @zdobersek here..",
          "createdAt": "2019-10-11T15:44:08Z",
          "updatedAt": "2019-10-11T15:44:08Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@riju In the Digital Signage/Point of Sale/Shopping mall/Library Catalog case, would the device likely be completely disconnected from the internet? Or is it that it's easier to manage a single-app device by pushing the app to it, rather than hosting the app on a web server?\r\n\r\nIf these kiosk apps don't use the Service Worker mechanism to stay up to date, this may actually be a different use case than pre-installed apps.\r\n\r\nI'm also happy if you want to just send me the change to the text that you think would improve the description.\r\n\r\n",
          "createdAt": "2019-10-11T16:42:19Z",
          "updatedAt": "2019-10-11T16:42:19Z"
        },
        {
          "author": "bkardell",
          "authorAssociation": "NONE",
          "body": "@jyasskin I'm not entirely sure - It seems like connecting to the internet to stay up to date is optional in any case once you have the pwa? It's quite possible that you never update because the device works just fine and they have no interwebs... Is there a reason it requires an entirely different architecture or solution really?  It feels like it can fit the same model very well.  Of course, they don't do that now, or if they do they do some very custom/complex stuff to achieve it - but this is rather simple and elegant, it seems to me.",
          "createdAt": "2019-10-11T22:22:12Z",
          "updatedAt": "2019-10-11T22:23:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@bkardell I think the no-internet case is enabled by the yes-internet design, but because the package in that case is not really \"on the web\", I've had more trouble justifying why it should be an IETF goal. But maybe folks will be easier to convince than my mental model of them. :)",
          "createdAt": "2019-10-11T22:30:44Z",
          "updatedAt": "2019-10-11T22:30:44Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this, but @riju, feel free to suggest changes at any point.",
          "createdAt": "2019-10-14T19:40:29Z",
          "updatedAt": "2019-10-14T19:40:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMzc1NDI4",
          "commit": {
            "abbreviatedOid": "0a29188"
          },
          "author": "bkardell",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-10T21:58:55Z",
          "updatedAt": "2019-10-10T21:58:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "it's also a pretty weird build step, isn't it?   If you built a million devices each of them would do some browsing before shipping?  and if you have actual user profiles that will be established somehow along the way, I'm not sure how that would work either.",
              "createdAt": "2019-10-10T21:58:55Z",
              "updatedAt": "2019-10-10T22:16:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMzgwNTY3",
          "commit": {
            "abbreviatedOid": "0a29188"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-10T22:12:55Z",
          "updatedAt": "2019-10-10T22:12:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Yeah, maybe you can build images from the post-browsing filesystem, but now all your cookies are shared. And the browser's out-of-box experience is gone.",
              "createdAt": "2019-10-10T22:12:55Z",
              "updatedAt": "2019-10-10T22:16:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwNzEwNTk0",
          "commit": {
            "abbreviatedOid": "a9bafcd"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for starting this, this aligns pretty much with what I've been thinking about.",
          "createdAt": "2019-10-11T14:08:56Z",
          "updatedAt": "2019-10-11T14:08:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 504,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI3OTYyNjA1",
      "title": "Frontend compromise use case",
      "url": "https://github.com/WICG/webpackage/pull/504",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I think this describes the easier half of #425, with the second use case mentioned in https://github.com/WICG/webpackage/pull/425#pullrequestreview-300951626 left for another PR.\r\n\r\n@davidstrauss, does it make sense to use this instead of your PR?\r\n\r\nRendered version at https://jyasskin.github.io/webpackage/frontend-compromise-use-case/draft-yasskin-webpackage-use-cases.html#compromised-frontend.",
      "createdAt": "2019-10-14T20:35:54Z",
      "updatedAt": "2019-10-30T22:33:26Z",
      "closedAt": "2019-10-30T22:33:25Z",
      "mergedAt": "2019-10-30T22:33:25Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "davidstrauss",
          "authorAssociation": "NONE",
          "body": "> @davidstrauss, does it make sense to use this instead of your PR?\r\n\r\nI believe it does, yes. Thank you for the write-up!",
          "createdAt": "2019-10-17T21:02:43Z",
          "updatedAt": "2019-10-17T21:02:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 505,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI4MTAwMjk4",
      "title": "Make manifest section of Bundled HTTP Exchanges optional",
      "url": "https://github.com/WICG/webpackage/pull/505",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently there is no need to make \"manifest\" section mandatory.\r\n\r\nChromium side CL: https://crrev.com/c/1861614\r\n",
      "createdAt": "2019-10-15T06:31:50Z",
      "updatedAt": "2019-10-16T23:52:01Z",
      "closedAt": "2019-10-16T01:37:16Z",
      "mergedAt": "2019-10-16T01:37:16Z",
      "mergedBy": "horo-t",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "(This fixes #499)",
          "createdAt": "2019-10-15T06:40:43Z",
          "updatedAt": "2019-10-15T06:40:43Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "[Abstract](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.abstract), [section 2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.2) and [section 2.2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.2.2) are also mentioning about manifest as mandatory resource. Would you change those as well?",
          "createdAt": "2019-10-15T06:42:49Z",
          "updatedAt": "2019-10-15T06:42:49Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> [Abstract](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.abstract), [section 2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.2) and [section 2.2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.2.2) are also mentioning about manifest as mandatory resource. Would you change those as well?\r\n\r\nDone",
          "createdAt": "2019-10-15T07:13:18Z",
          "updatedAt": "2019-10-15T07:13:18Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-15T07:16:57Z",
          "updatedAt": "2019-10-15T07:16:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzEwMjg4",
          "commit": {
            "abbreviatedOid": "a3eb454"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T07:48:19Z",
          "updatedAt": "2019-10-15T07:59:29Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "No need to mention manifest here. How about this?\r\n```\r\nA bundle is logically a set of HTTP exchanges, with a URL identifying the\r\nprimary resource of the bundle.\r\n```\r\n",
              "createdAt": "2019-10-15T07:48:19Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            },
            {
              "originalPosition": 28,
              "body": "I think you can just remove the `manifest` item below (L160-164) and leave the other text in this section unchanged. Section 3.3.2 has all the information about the manifest section.",
              "createdAt": "2019-10-15T07:49:54Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            },
            {
              "originalPosition": 48,
              "body": "s/keys/key/",
              "createdAt": "2019-10-15T07:53:22Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzI5Nzcx",
          "commit": {
            "abbreviatedOid": "2362cfa"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:23:58Z",
          "updatedAt": "2019-10-15T08:23:59Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "done",
              "createdAt": "2019-10-15T08:23:59Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzI5ODAy",
          "commit": {
            "abbreviatedOid": "2362cfa"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:24:02Z",
          "updatedAt": "2019-10-15T08:24:02Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "done",
              "createdAt": "2019-10-15T08:24:02Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzI5ODIy",
          "commit": {
            "abbreviatedOid": "2362cfa"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:24:04Z",
          "updatedAt": "2019-10-15T08:24:04Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "done",
              "createdAt": "2019-10-15T08:24:04Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzQ2MzM1",
          "commit": {
            "abbreviatedOid": "2362cfa"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:50:53Z",
          "updatedAt": "2019-10-15T08:51:03Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "s/entries/an entry/\r\n(sorry for not noticing in the previous round)",
              "createdAt": "2019-10-15T08:50:53Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzUxODAx",
          "commit": {
            "abbreviatedOid": "d985754"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:59:16Z",
          "updatedAt": "2019-10-15T08:59:16Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "done",
              "createdAt": "2019-10-15T08:59:16Z",
              "updatedAt": "2019-10-15T08:59:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzUzMTE2",
          "commit": {
            "abbreviatedOid": "d985754"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-10-15T09:01:25Z",
          "updatedAt": "2019-10-15T09:01:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAyOTM5ODE0",
          "commit": {
            "abbreviatedOid": "d985754"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "LGTM. I'll add the changelog entry at least by the time I publish draft-03.",
          "createdAt": "2019-10-16T23:52:01Z",
          "updatedAt": "2019-10-16T23:52:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 506,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMwMjgyMjA1",
      "title": "Add JavaScript library for generating bundles",
      "url": "https://github.com/WICG/webpackage/pull/506",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The `gen-bundle` Go tool is convenient for simple use cases, but developers who want to support WebBundle generation for their site may need more fine-grained control.\r\n\r\nThis adds a simple JavaScript library (npm package) for creating application/webbundle resources, which could be used as a building block of popular frontend development toolchain (such as plugins for gulp, webpack, etc.).\r\n",
      "createdAt": "2019-10-21T08:30:04Z",
      "updatedAt": "2019-10-25T07:41:37Z",
      "closedAt": "2019-10-25T07:41:36Z",
      "mergedAt": "2019-10-25T07:41:36Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-21T08:34:36Z",
          "updatedAt": "2019-10-21T08:34:36Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "If you want to try this, download [webbundle-0.0.1.tgz](https://drive.google.com/file/d/1kWZQDei8paRk5fyiBRHszYlmP6IHExME/view?usp=sharing) and run `npm install webbundle-0.0.1.tgz`.",
          "createdAt": "2019-10-21T08:37:37Z",
          "updatedAt": "2019-10-21T08:37:37Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @kinu WDYT?\r\n\r\nI think having JS-based tool would lower the hurdle for developers who want to integrate bundle generation step to their workflow.",
          "createdAt": "2019-10-21T08:53:55Z",
          "updatedAt": "2019-10-21T08:53:55Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems we can't publish `webbundle` package because the name is too similar to existing package `web-bundle` (which is not related to web packaing).\r\n\r\nSo I've renamed this package to `wicg-webbundle`.\r\n",
          "createdAt": "2019-10-25T01:44:01Z",
          "updatedAt": "2019-10-25T01:44:01Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems `wbn` is still available for package name. Let's use it.",
          "createdAt": "2019-10-25T07:35:26Z",
          "updatedAt": "2019-10-25T07:35:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NjcwMTAx",
          "commit": {
            "abbreviatedOid": "0855518"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lg to me.  @jyasskin if you have any thoughts on how / if these tools should be placed here or else please chime in!",
          "createdAt": "2019-10-23T07:04:36Z",
          "updatedAt": "2019-10-23T07:09:17Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "This could throw if urlString is a relative URL, right?  Maybe write about that somewhere?\r\n\r\nShould we also error out if protocol is not http/https?",
              "createdAt": "2019-10-23T07:04:37Z",
              "updatedAt": "2019-10-25T07:31:41Z"
            },
            {
              "originalPosition": 2,
              "body": "Maybe also write out that currently it doesn't support origin-signed exchanges.",
              "createdAt": "2019-10-23T07:06:01Z",
              "updatedAt": "2019-10-25T07:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NjkyMDQ1",
          "commit": {
            "abbreviatedOid": "9bc5960"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T07:50:40Z",
          "updatedAt": "2019-10-23T07:54:02Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Done.",
              "createdAt": "2019-10-23T07:50:40Z",
              "updatedAt": "2019-10-25T07:31:41Z"
            },
            {
              "originalPosition": 124,
              "body": "Done.",
              "createdAt": "2019-10-23T07:53:54Z",
              "updatedAt": "2019-10-25T07:31:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 508,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxODY2MDMx",
      "title": "gen-bundle: Add -headerOverride flag",
      "url": "https://github.com/WICG/webpackage/pull/508",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This can be used to inject arbitrary headers to bundled responses. For example, `Access-Control-Allow-Origin: *` may be added to workaround CORS errors in untrusted bundles.",
      "createdAt": "2019-10-24T05:47:59Z",
      "updatedAt": "2019-10-24T08:33:37Z",
      "closedAt": "2019-10-24T08:28:26Z",
      "mergedAt": "2019-10-24T08:28:26Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-24T05:55:23Z",
          "updatedAt": "2019-10-24T05:55:23Z"
        },
        {
          "author": "marcoscaceres",
          "authorAssociation": "MEMBER",
          "body": "Marked as  substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-24T05:58:38Z",
          "updatedAt": "2019-10-24T05:58:38Z"
        },
        {
          "author": "marcoscaceres",
          "authorAssociation": "MEMBER",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-24T05:58:41Z",
          "updatedAt": "2019-10-24T05:58:41Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2019-10-24T08:28:35Z",
          "updatedAt": "2019-10-24T08:28:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2Mzg2Njc5",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm w/ nits",
          "createdAt": "2019-10-24T08:06:14Z",
          "updatedAt": "2019-10-24T08:07:41Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'd write\r\n\r\n```go\r\nfunc (h headerArgs) String() string {\r\n\treturn fmt.Sprintf(\"%v\", h)\r\n}\r\n```",
              "createdAt": "2019-10-24T08:06:14Z",
              "updatedAt": "2019-10-24T08:07:41Z"
            },
            {
              "originalPosition": 19,
              "body": "ditto",
              "createdAt": "2019-10-24T08:06:22Z",
              "updatedAt": "2019-10-24T08:07:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2Mzk2MzQw",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T08:23:24Z",
          "updatedAt": "2019-10-24T08:23:24Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "We cannot use non-pointer `headerArgs` here because this function overwrites the pointed value.",
              "createdAt": "2019-10-24T08:23:24Z",
              "updatedAt": "2019-10-24T08:23:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2Mzk4Mzkz",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T08:26:52Z",
          "updatedAt": "2019-10-24T08:26:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Let me keep using `*headerArgs` here for consistency with `Set()`.\r\n\r\nAlso, `fmt.Sprintf(\"%v\", h)` would recursively call `h.String()` so we'll need a type conversion to prevent that, which is a bit unfortunate.",
              "createdAt": "2019-10-24T08:26:52Z",
              "updatedAt": "2019-10-24T08:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NDAyMzEy",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T08:33:23Z",
          "updatedAt": "2019-10-24T08:33:24Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Oh you're right.",
              "createdAt": "2019-10-24T08:33:24Z",
              "updatedAt": "2019-10-24T08:33:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NDAyNDM5",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T08:33:37Z",
          "updatedAt": "2019-10-24T08:33:37Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Ack",
              "createdAt": "2019-10-24T08:33:37Z",
              "updatedAt": "2019-10-24T08:33:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 509,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxOTI0ODM1",
      "title": "Add \"Using Bundles\" section to go/bundle/README",
      "url": "https://github.com/WICG/webpackage/pull/509",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "with caveats for unsigned bundles.\r\n\r\nPreview: https://github.com/irori/webpackage/tree/readme/go/bundle#using-bundles",
      "createdAt": "2019-10-24T08:39:58Z",
      "updatedAt": "2019-10-28T06:42:11Z",
      "closedAt": "2019-10-28T06:42:10Z",
      "mergedAt": "2019-10-28T06:42:10Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-28T03:25:20Z",
          "updatedAt": "2019-10-28T03:25:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NDU2ODc0",
          "commit": {
            "abbreviatedOid": "c940769"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T10:00:51Z",
          "updatedAt": "2019-10-24T10:01:01Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "'current', 'currently' --> as of Chrome 80 ?\r\n\r\nAs of Chrome 80, only unsigned bundles are supported and they can only be loaded from local files. Such bundles are loaded as \"untrusted\" pages, where:",
              "createdAt": "2019-10-24T10:00:51Z",
              "updatedAt": "2019-10-28T01:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTIyODAy",
          "commit": {
            "abbreviatedOid": "c940769"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:52:55Z",
          "updatedAt": "2019-10-24T23:52:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "All these problems below are only for Chrome.\r\nI think we should have a doc about these information in chromium repository, and this document should have a link to that.\r\nSo can we can update the information when we change the implementation synchronously.\r\n\r\nHow about this?\r\n\r\nChrome (80+) experimentally supports Web Bundles with some limitations. See [this document](https://chromium.googlesource.com/chromium/src/+/refs/heads/master/content/browser/web_package/web_bundles.md) for more details.\r\n",
              "createdAt": "2019-10-24T23:52:55Z",
              "updatedAt": "2019-10-28T01:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTQ1ODUy",
          "commit": {
            "abbreviatedOid": "c940769"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T01:43:52Z",
          "updatedAt": "2019-10-25T01:43:52Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Having this doc in chromium repository and linking from here sounds good, so +1",
              "createdAt": "2019-10-25T01:43:52Z",
              "updatedAt": "2019-10-28T01:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTYyNjEx",
          "commit": {
            "abbreviatedOid": "c940769"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T03:07:34Z",
          "updatedAt": "2019-10-25T03:07:35Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "OK, created https://chromium-review.googlesource.com/c/chromium/src/+/1880413.",
              "createdAt": "2019-10-25T03:07:34Z",
              "updatedAt": "2019-10-28T01:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NjE3OTI0",
          "commit": {
            "abbreviatedOid": "95f0fc9"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-10-28T02:14:01Z",
          "updatedAt": "2019-10-28T02:14:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NjI5MjM0",
          "commit": {
            "abbreviatedOid": "95f0fc9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-28T03:25:54Z",
          "updatedAt": "2019-10-28T03:25:54Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done",
              "createdAt": "2019-10-28T03:25:54Z",
              "updatedAt": "2019-10-28T03:25:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NjQ5OTcw",
          "commit": {
            "abbreviatedOid": "95f0fc9"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-28T05:47:14Z",
          "updatedAt": "2019-10-28T05:47:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 510,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMzNDE0MjQ2",
      "title": "gen-bundle: Verify that an exchange for primary URL exists",
      "url": "https://github.com/WICG/webpackage/pull/510",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After this patch, bundle.Write() fails if the bundle doesn't have\r\nan exchange for its primary URL.\r\n\r\nAlso add `-primaryURL` flag to the command-line examples in README.",
      "createdAt": "2019-10-29T03:20:45Z",
      "updatedAt": "2019-10-29T03:26:36Z",
      "closedAt": "2019-10-29T03:26:36Z",
      "mergedAt": "2019-10-29T03:26:35Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA4MjU3NTMy",
          "commit": {
            "abbreviatedOid": "1997eef"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-29T03:23:00Z",
          "updatedAt": "2019-10-29T03:23:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 511,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0MTE0ODQ4",
      "title": "Mention \"Web Bundles\" in README",
      "url": "https://github.com/WICG/webpackage/pull/511",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm a bit afraid people coming from \"Web Bundles\" article may feel lost if they don't see anything that says \"Web Bundles\". Wdyt?",
      "createdAt": "2019-10-30T09:21:13Z",
      "updatedAt": "2019-10-30T23:16:45Z",
      "closedAt": "2019-10-30T23:16:44Z",
      "mergedAt": "2019-10-30T23:16:44Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-30T22:31:00Z",
          "updatedAt": "2019-10-30T22:31:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTU2NzAw",
          "commit": {
            "abbreviatedOid": "f6f713d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:21:27Z",
          "updatedAt": "2019-10-30T22:23:22Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "We could just switch the primary name here.\r\n\r\n```suggestion\r\n1. [Web Bundles (previously called Bundled HTTP exchanges)](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html)\r\n```\r\n\r\nAnd I could change the title of the IETF draft.",
              "createdAt": "2019-10-30T22:21:27Z",
              "updatedAt": "2019-10-30T23:08:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 512,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NzExNDgw",
      "title": "Add explainer for navigation with Web Bundles",
      "url": "https://github.com/WICG/webpackage/pull/512",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "Text is still rough, but it'd be useful to have something like this.",
      "createdAt": "2019-10-31T07:10:00Z",
      "updatedAt": "2019-11-04T02:19:16Z",
      "closedAt": "2019-11-04T02:19:15Z",
      "mergedAt": "2019-11-04T02:19:15Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@kinu, could you formally [join the WICG](https://www.w3.org/community/wicg/participants) and [link your Github and W3C accounts](https://labs.w3.org/repo-manager/pr/id/WICG/webpackage/512)?",
          "createdAt": "2019-10-31T20:05:17Z",
          "updatedAt": "2019-10-31T20:05:17Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review! I've linked my github and w3c account, and requesting to join WICG.",
          "createdAt": "2019-11-01T03:29:27Z",
          "updatedAt": "2019-11-01T03:29:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjA2MTA1",
          "commit": {
            "abbreviatedOid": "3ea7e98"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-31T22:00:43Z",
          "updatedAt": "2019-10-31T22:26:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we can leave this back-reference in the commit message instead of the body.",
              "createdAt": "2019-10-31T22:00:43Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nToday, loading a website basically means retrieving multiple resources from one or multiple web servers. This gives the web the great strengths of being linkable, indexable, composable and ephemeral, but it also makes it difficult for a website to:\r\n```",
              "createdAt": "2019-10-31T22:06:09Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 19,
              "body": "I think you can drop the quotes around \"full\". This phrasing doesn't imply that you *have to* include the full website, just that it's possible.\r\n\r\n```suggestion\r\nInstead, imagine if we could bundle up a full website in a single resource file, so that the website could be shared via a SD card or over some p2p protocol, or could be retrieved from a fast cache or a nearby proxy. It would open up several interesting use cases.\r\n```",
              "createdAt": "2019-10-31T22:08:57Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThe **Web Bundles** proposal tries to achieve this. It\u2019s a format that can represent a collection of HTTP resources, and therefore can represent one or multiple web pages in a single file, including their subresources like scripts, images and styles.  It\u2019s a part of the [Web Packaging](https://github.com/WICG/webpackage) project and is also known as \"**Bundled HTTP Exchanges**\" ([spec proposal](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html)).\r\n```",
              "createdAt": "2019-10-31T22:11:24Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nThis document explains how a browser can navigate to a Web Bundle so that a user can open one.\r\n```",
              "createdAt": "2019-10-31T22:12:45Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n## Example Scenarios: Save and browse unsigned content\r\n```",
              "createdAt": "2019-10-31T22:12:57Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nA UA can provide a **'Save as bundle'** feature that dynamically generates an unsigned bundle of the page that its user is currently browsing.  Then anyone can create a bundled representation of the current page, and they can browse it later themself or share it with a nearby friend via one of several native file-sharing apps.\r\n```",
              "createdAt": "2019-10-31T22:16:00Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 28,
              "body": "@estark37 commented that showing the original URL is probably a bad idea. It sounds like we'll show the package's URL and/or a chip describing what's happening.\r\n\r\n```suggestion\r\nWhen someone else browses the unsigned bundle, they can browse around and see the site, including the results of its JavaScript executing.  Note that in this case the page inside the unsigned bundle is not given any access to the cookies or storage of the original site.\r\n```",
              "createdAt": "2019-10-31T22:18:37Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n# Details of how the browser handles navigation\r\n```\r\n\r\nI'm not doing a detailed review of the text below, because it's intrinsically more technical than we want to make an explainer's audience read. It'll eventually move into the specification.",
              "createdAt": "2019-10-31T22:20:01Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nThe author of a site creates a bundle for part or all of their site, signs the bundle with the site\u2019s certificate, and then publishes the bundle in a way that interested users can find it. Users can then share this bundle peer-to-peer until its expiration time.\r\n```",
              "createdAt": "2019-10-31T22:21:19Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\n## Example Scenarios: Publishing signed content\r\n```",
              "createdAt": "2019-10-31T22:21:25Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nLater, when a user receives the bundle, maybe by opening it from an SD card or by navigating to the distribution URL where the bundle is published, they can open it with their UA.  The UA parses and verifies the bundle\u2019s signature, and then opens the pages inside the bundle, without actually connecting to the site's server, but with assurance that it's safe to show the real site in the URL bar and use the site's local storage.  If the bundle represents multiple pages for the site, the user can browse those pages without worrying about connectivity.\r\n```",
              "createdAt": "2019-10-31T22:25:06Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 82,
              "body": "This is incorporated into https://docs.google.com/document/d/1BYQEi8xkXDAg9lxm3PaoMzEutuQAZi1r8Y0pLaFJQoo/edit, so I think we don't need it here. \r\n\r\n```suggestion\r\n```\r\n",
              "createdAt": "2019-10-31T22:26:23Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjc3ODU1",
          "commit": {
            "abbreviatedOid": "7a977a0"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T03:28:54Z",
          "updatedAt": "2019-11-01T03:28:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good idea, done.",
              "createdAt": "2019-11-01T03:28:55Z",
              "updatedAt": "2019-11-01T03:28:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 513,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NzY4NDU4",
      "title": "js/bundle: Add decoder",
      "url": "https://github.com/WICG/webpackage/pull/513",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-31T09:27:10Z",
      "updatedAt": "2019-11-01T05:12:53Z",
      "closedAt": "2019-11-01T05:12:52Z",
      "mergedAt": "2019-11-01T05:12:52Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODAyODAw",
          "commit": {
            "abbreviatedOid": "5b1b3ac"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T11:13:36Z",
          "updatedAt": "2019-10-31T11:13:36Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I'd use `const` for `bundle`, `exchanges`, `url`, and `resp` (no reassignments)",
              "createdAt": "2019-10-31T11:13:36Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODA0Nzgw",
          "commit": {
            "abbreviatedOid": "5b1b3ac"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-31T11:17:24Z",
          "updatedAt": "2019-10-31T11:17:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjQwMTYx",
          "commit": {
            "abbreviatedOid": "5b1b3ac"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T00:01:31Z",
          "updatedAt": "2019-11-01T00:29:02Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "for (const resp of responses) {",
              "createdAt": "2019-11-01T00:01:31Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 60,
              "body": "const indexEntry",
              "createdAt": "2019-11-01T00:02:01Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 64,
              "body": "const",
              "createdAt": "2019-11-01T00:02:13Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 71,
              "body": "const",
              "createdAt": "2019-11-01T00:02:47Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 92,
              "body": "const",
              "createdAt": "2019-11-01T00:03:55Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 104,
              "body": "const",
              "createdAt": "2019-11-01T00:04:04Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 109,
              "body": "const",
              "createdAt": "2019-11-01T00:04:25Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 114,
              "body": "status = Number(val);",
              "createdAt": "2019-11-01T00:09:27Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 20,
              "body": "semicolon",
              "createdAt": "2019-11-01T00:17:50Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 81,
              "body": "Unnecessary semicolon",
              "createdAt": "2019-11-01T00:18:21Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 11,
              "body": "!==",
              "createdAt": "2019-11-01T00:19:42Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 89,
              "body": "!==",
              "createdAt": "2019-11-01T00:20:00Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 86,
              "body": "\"public\" modifier not needed.",
              "createdAt": "2019-11-01T00:24:30Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 4,
              "body": "Sorry I'm not familiar with TS.\r\nWhy are you using trailing \"_\"?",
              "createdAt": "2019-11-01T00:26:31Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 3,
              "body": "Can we have JSDoc comments for this?",
              "createdAt": "2019-11-01T00:28:09Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 83,
              "body": "Can we have JSDoc comments for this?",
              "createdAt": "2019-11-01T00:28:17Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjU3Mzcz",
          "commit": {
            "abbreviatedOid": "5b1b3ac"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "All fixed. I'll create another PR for style fixes of `encoder.ts`.",
          "createdAt": "2019-11-01T01:36:49Z",
          "updatedAt": "2019-11-01T02:21:08Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "done",
              "createdAt": "2019-11-01T01:36:50Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 11,
              "body": "done",
              "createdAt": "2019-11-01T01:37:45Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 20,
              "body": "done",
              "createdAt": "2019-11-01T01:37:58Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 33,
              "body": "done",
              "createdAt": "2019-11-01T01:50:15Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 60,
              "body": "done",
              "createdAt": "2019-11-01T01:50:28Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 64,
              "body": "done",
              "createdAt": "2019-11-01T01:50:34Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 71,
              "body": "done",
              "createdAt": "2019-11-01T01:50:41Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 81,
              "body": "done",
              "createdAt": "2019-11-01T01:50:53Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 86,
              "body": "done",
              "createdAt": "2019-11-01T01:51:21Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 89,
              "body": "done",
              "createdAt": "2019-11-01T01:51:31Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 92,
              "body": "done",
              "createdAt": "2019-11-01T01:51:39Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 104,
              "body": "done",
              "createdAt": "2019-11-01T01:51:50Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 109,
              "body": "done",
              "createdAt": "2019-11-01T01:51:58Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 114,
              "body": "done",
              "createdAt": "2019-11-01T01:52:08Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 4,
              "body": "This was to avoid conflict with the `version` getter function, but I changed it to a public field.",
              "createdAt": "2019-11-01T02:01:09Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 3,
              "body": "Added, although I'm not really sure if we should require JSDocs in this package.",
              "createdAt": "2019-11-01T02:09:19Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 83,
              "body": "done",
              "createdAt": "2019-11-01T02:09:35Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjkzOTM4",
          "commit": {
            "abbreviatedOid": "26804cf"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-01T05:10:52Z",
          "updatedAt": "2019-11-01T05:10:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 514,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1Mjc1NDcw",
      "title": "js/bundle: Style fix for encoder.ts",
      "url": "https://github.com/WICG/webpackage/pull/514",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-01T04:30:40Z",
      "updatedAt": "2019-11-01T05:25:28Z",
      "closedAt": "2019-11-01T05:25:28Z",
      "mergedAt": "2019-11-01T05:25:28Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk2MTAw",
          "commit": {
            "abbreviatedOid": "d78582c"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-01T05:24:07Z",
          "updatedAt": "2019-11-01T05:24:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 515,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1Mjg5MzY0",
      "title": "js/bundle: Add tests",
      "url": "https://github.com/WICG/webpackage/pull/515",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also bumps package version to 0.0.2.",
      "createdAt": "2019-11-01T05:58:09Z",
      "updatedAt": "2019-11-06T01:31:07Z",
      "closedAt": "2019-11-06T01:31:06Z",
      "mergedAt": "2019-11-06T01:31:06Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNTE3MTg4",
          "commit": {
            "abbreviatedOid": "b0a79f3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-05T06:11:15Z",
          "updatedAt": "2019-11-05T06:20:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think we should have a pre-generated test bundle file to detect unexpected regressions (or format change).",
              "createdAt": "2019-11-05T06:11:16Z",
              "updatedAt": "2019-11-05T08:14:25Z"
            },
            {
              "originalPosition": 6,
              "body": "We should have no-manifest wbn test case.",
              "createdAt": "2019-11-05T06:15:08Z",
              "updatedAt": "2019-11-05T08:14:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNTU3NDcy",
          "commit": {
            "abbreviatedOid": "b0a79f3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-05T08:14:41Z",
          "updatedAt": "2019-11-05T08:15:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2019-11-05T08:14:42Z",
              "updatedAt": "2019-11-05T08:15:42Z"
            },
            {
              "originalPosition": 6,
              "body": "The pre-generated wbn doesn't have a manifest.",
              "createdAt": "2019-11-05T08:14:59Z",
              "updatedAt": "2019-11-05T08:15:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyMTQ4NDU3",
          "commit": {
            "abbreviatedOid": "50a3f7e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-06T01:29:50Z",
          "updatedAt": "2019-11-06T01:29:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 516,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MTAxNTk3",
      "title": "Replace bundle demo link to a newer one",
      "url": "https://github.com/WICG/webpackage/pull/516",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://youtu.be/xAujz66la3Y this one uses the term \"Web Bundles\"\r\n(Same scenario & materials with the previous one, with a little more editing)",
      "createdAt": "2019-11-04T02:24:07Z",
      "updatedAt": "2019-11-04T06:14:46Z",
      "closedAt": "2019-11-04T06:14:45Z",
      "mergedAt": "2019-11-04T06:14:45Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I probably should have merged this into the previous commit... just replacing a link.  (The video can be replaced/re-edited further though)",
          "createdAt": "2019-11-04T02:25:09Z",
          "updatedAt": "2019-11-04T02:25:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODcyMzEz",
          "commit": {
            "abbreviatedOid": "e0a6e60"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-11-04T03:55:51Z",
          "updatedAt": "2019-11-04T03:55:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 517,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NDk4Mzky",
      "title": "Improve the signed-exchanges privacy considerations.",
      "url": "https://github.com/WICG/webpackage/pull/517",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Maybe I can make the 23:59 UTC IETF draft deadline in 2 hours?\r\n\r\nPreview at https://jyasskin.github.io/webpackage/privacy-tweaks/draft-yasskin-http-origin-signed-responses.html#privacy-considerations.",
      "createdAt": "2019-11-04T21:54:44Z",
      "updatedAt": "2019-11-04T23:35:42Z",
      "closedAt": "2019-11-04T23:35:41Z",
      "mergedAt": "2019-11-04T23:35:41Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNDI1NzIx",
          "commit": {
            "abbreviatedOid": "638d9f9"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T23:32:15Z",
          "updatedAt": "2019-11-04T23:32:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 518,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NjA1OTM5",
      "title": "Update go/bundle/README.md",
      "url": "https://github.com/WICG/webpackage/pull/518",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Make it explicit that manifestUrl is optional (and also added some texts).\r\n\r\nUsers should ultimately refer to the code or run the tool to see detailed parameter options, but wanted to add some info to unconfuse. Wdyt?",
      "createdAt": "2019-11-05T05:49:33Z",
      "updatedAt": "2019-11-06T08:25:04Z",
      "closedAt": "2019-11-06T08:25:02Z",
      "mergedAt": "2019-11-06T08:25:02Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "(Closing and re-opening to kick Travis CI)",
          "createdAt": "2019-11-06T01:14:15Z",
          "updatedAt": "2019-11-06T01:14:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNTE5MjQ1",
          "commit": {
            "abbreviatedOid": "72ae510"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-11-05T06:19:51Z",
          "updatedAt": "2019-11-05T06:19:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 519,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MTI2ODIz",
      "title": "TravisCI: Test nodejs module",
      "url": "https://github.com/WICG/webpackage/pull/519",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-06T01:48:00Z",
      "updatedAt": "2019-11-06T02:27:51Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Would you take a look?",
          "createdAt": "2019-11-06T02:27:51Z",
          "updatedAt": "2019-11-06T02:27:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 520,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MjU2Njk2",
      "title": "Add \"Using Bundles\" section to js/bundle/README.md",
      "url": "https://github.com/WICG/webpackage/pull/520",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The content is copied from go/bundle/README.md. Having this information\r\nhere too would be useful.",
      "createdAt": "2019-11-06T09:28:06Z",
      "updatedAt": "2019-11-07T00:52:15Z",
      "closedAt": "2019-11-07T00:52:14Z",
      "mergedAt": "2019-11-07T00:52:14Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyODA1OTM5",
          "commit": {
            "abbreviatedOid": "249c3c7"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-06T23:07:50Z",
          "updatedAt": "2019-11-06T23:07:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyODI2MTM5",
          "commit": {
            "abbreviatedOid": "249c3c7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-06T23:26:51Z",
          "updatedAt": "2019-11-06T23:26:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 521,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3ODE4Njc5",
      "title": "Update the header of js/bundle/README.md",
      "url": "https://github.com/WICG/webpackage/pull/521",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This README is also shown in the [npm package page](https://www.npmjs.com/package/wbn), so having \"js/bundle\" as title is a bit confusing.",
      "createdAt": "2019-11-07T02:04:56Z",
      "updatedAt": "2019-11-08T07:23:00Z",
      "closedAt": "2019-11-08T07:22:59Z",
      "mergedAt": "2019-11-08T07:22:59Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzOTI0NTY4",
          "commit": {
            "abbreviatedOid": "e1c7fee"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-08T07:21:55Z",
          "updatedAt": "2019-11-08T07:21:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 523,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4NTM3Njc5",
      "title": "js/bundle: Make sure to give CBOR encoder sufficient buffer size",
      "url": "https://github.com/WICG/webpackage/pull/523",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`CBOR.encode()` chokes and generates broken output if given data is\r\nlarger than its `highWaterMark` option value [1].\r\n\r\nSo, this patch:\r\n\r\n- Give sufficient buffer size when encoding\r\n- Add checks for encoded results (throws if it doesn't fit the buffer)\r\n- `encodedLength()` internally uses `encode()`, so avoid using it for\r\n  potentially large objects\r\n\r\nThis fixes #522.\r\n\r\n[1] https://github.com/hildjj/node-cbor#highwatermark",
      "createdAt": "2019-11-08T06:50:49Z",
      "updatedAt": "2019-11-12T01:16:12Z",
      "closedAt": "2019-11-12T01:16:11Z",
      "mergedAt": "2019-11-12T01:16:10Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@sisidovski Would you please take a look?\r\nThanks!",
          "createdAt": "2019-11-08T06:52:18Z",
          "updatedAt": "2019-11-08T06:52:18Z"
        },
        {
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me! @irori",
          "createdAt": "2019-11-11T11:05:21Z",
          "updatedAt": "2019-11-11T11:05:21Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@horo-t @kinu Would you stamp this? Looks like an approval from a reviewer with write access is needed.",
          "createdAt": "2019-11-12T00:19:28Z",
          "updatedAt": "2019-11-12T00:19:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0MTczODMx",
          "commit": {
            "abbreviatedOid": "f9aa6c3"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T12:35:45Z",
          "updatedAt": "2019-11-08T13:06:56Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "This line just checks duplication and doesn't use return value, correct? If so, it would be more clear to use `array.some` instead of `.find`!",
              "createdAt": "2019-11-08T12:35:46Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            },
            {
              "originalPosition": 57,
              "body": "`const` is preferable to make sure this variable won't be changed.",
              "createdAt": "2019-11-08T12:42:46Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            },
            {
              "originalPosition": 59,
              "body": "I'm not sure what this comment means. It looks using `encodedLength` in below.",
              "createdAt": "2019-11-08T12:46:35Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTIzNjM4",
          "commit": {
            "abbreviatedOid": "f9aa6c3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks!",
          "createdAt": "2019-11-09T00:30:55Z",
          "updatedAt": "2019-11-09T00:56:57Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Done.",
              "createdAt": "2019-11-09T00:30:55Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            },
            {
              "originalPosition": 57,
              "body": "This can't be `const` since the value is assigned in the if-else statement below.",
              "createdAt": "2019-11-09T00:41:31Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            },
            {
              "originalPosition": 59,
              "body": "Oh, you are right. I meant `encodedLength(content)` shouldn't be used. Updated the comment.\r\n\r\nThe trick used here needs some knowledge about CBOR encoding to understand.\r\n\r\nThe `responses` section is an array, and CBOR's array encoding is the concatenation of:\r\n\r\n1. variable-length integer encoding of the array length\r\n2. CBOR-encoded contents of the array elements\r\n\r\n`this.currentResponsesOffset` holds the length of 2, and the length of 1 can be calculated by `encodedLength(this.responses.length)`. The `encodedLength` operation is cheap heare, because the argument is just a number.\r\n",
              "createdAt": "2019-11-09T00:54:25Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0ODE4Nzcw",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-11T10:42:28Z",
          "updatedAt": "2019-11-11T11:03:50Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Oh I just thought you can write something like\r\n\r\n```js\r\nconst length = (name === 'responses') ? this.currentResponsesOffset + encodedLength(this.responses.length) : encodedLength(content)\r\n```\r\n\r\nBut it's okay, you don't have to rewrite it.",
              "createdAt": "2019-11-11T10:42:29Z",
              "updatedAt": "2019-11-11T11:03:50Z"
            },
            {
              "originalPosition": 59,
              "body": "Gotcha. Thanks for the clarification. ",
              "createdAt": "2019-11-11T11:03:50Z",
              "updatedAt": "2019-11-11T11:03:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0ODI5Mzk0",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-11T11:04:32Z",
          "updatedAt": "2019-11-11T11:04:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjMwMDMz",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @sisidovski!",
          "createdAt": "2019-11-12T00:16:46Z",
          "updatedAt": "2019-11-12T00:17:26Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I see.\r\nLet me keep current code. I think it's slightly easier to understand.",
              "createdAt": "2019-11-12T00:16:46Z",
              "updatedAt": "2019-11-12T00:17:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjQzNTc5",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Lgtm",
          "createdAt": "2019-11-12T01:09:28Z",
          "updatedAt": "2019-11-12T01:10:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjQ0MTY5",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-12T01:11:45Z",
          "updatedAt": "2019-11-12T01:11:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 524,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4Njg3NDc4",
      "title": "js/bundle: Support node 8.x",
      "url": "https://github.com/WICG/webpackage/pull/524",
      "state": "MERGED",
      "author": "sisidovski",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a tiny fix.\r\n\r\nI'm not sure this is intended or not, but global `URL` class was added from Node 10.x.\r\n\r\nThis change will support 8.x which is still at the maintenance LTS stage, actually it will be eol [soon](https://github.com/nodejs/Release) though. Even if doesn't support 8.x, at least supported node version should be specified via \"engines\" field in package.json.\r\n\r\n@irori Could you have a look? Thanks!",
      "createdAt": "2019-11-08T13:55:31Z",
      "updatedAt": "2019-11-09T01:02:39Z",
      "closedAt": "2019-11-09T01:02:38Z",
      "mergedAt": "2019-11-09T01:02:38Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-11-09T01:01:52Z",
          "updatedAt": "2019-11-09T01:01:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTI4NDA5",
          "commit": {
            "abbreviatedOid": "e0f699e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-11-09T01:02:17Z",
          "updatedAt": "2019-11-09T01:02:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 525,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4ODI1MTAz",
      "title": "Rename \"Bundled Exchanges\" to \"Web Bundles\" everywhere.",
      "url": "https://github.com/WICG/webpackage/pull/525",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The bundled things aren't really exchanges anymore: they're a request\nURL and a response that is expected to include its content negotiation\ninformation in the Variants header.\n\n@jpmedley @uskay FYI.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/525.html\" title=\"Last updated on Nov 8, 2019, 7:29 PM UTC (30cb778)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/525/271865a...jyasskin:30cb778.html\" title=\"Last updated on Nov 8, 2019, 7:29 PM UTC (30cb778)\">Diff</a>",
      "createdAt": "2019-11-08T19:29:24Z",
      "updatedAt": "2019-11-08T20:32:35Z",
      "closedAt": "2019-11-08T20:32:34Z",
      "mergedAt": "2019-11-08T20:32:34Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NDM1OTA5",
          "commit": {
            "abbreviatedOid": "30cb778"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-08T20:14:06Z",
          "updatedAt": "2019-11-08T20:15:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We might want to change the file name as well eventually?",
              "createdAt": "2019-11-08T20:14:07Z",
              "updatedAt": "2019-11-08T20:15:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NDM5OTYx",
          "commit": {
            "abbreviatedOid": "30cb778"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T20:23:21Z",
          "updatedAt": "2019-11-08T20:23:22Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We might, but it's a bit more difficult to rename IETF drafts. The point at which they get adopted by the working group will be a rename anyway, so we can fix up filenames then, both here and for signed exchanges.",
              "createdAt": "2019-11-08T20:23:21Z",
              "updatedAt": "2019-11-08T20:23:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 529,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NjQzNjkx",
      "title": "Explainer on the anti-tracking problem for signed packages",
      "url": "https://github.com/WICG/webpackage/pull/529",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@johnwilander @davidben @bslassey Here's a description of how we could prevent distributors from using packages to transfer user IDs between sites. What holes do you still see in it? Do you have any favorite options for the places I've listed several possible choices?\r\n\r\nThanks!\r\n\r\n[Preview](https://github.com/WICG/webpackage/blob/anti-tracking/explainers/anti-tracking.md)",
      "createdAt": "2019-11-11T22:27:51Z",
      "updatedAt": "2019-12-12T22:59:11Z",
      "closedAt": "2019-12-12T22:59:10Z",
      "mergedAt": "2019-12-12T22:59:10Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3ODY5MzM4",
          "commit": {
            "abbreviatedOid": "b6f9af0"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-15T21:06:27Z",
          "updatedAt": "2019-11-15T21:30:09Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Ideally we'd be able to talk about which network partition this uses too, but I'm not sure if the spec framework for that exists yet. :-/",
              "createdAt": "2019-11-15T21:06:28Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 226,
              "body": "This is a bit contrived, but here's an odd scenario.\r\n\r\npublisher.example makes some content only available to paying subscribers. This website is written to the web of today and doesn't need fancy client-side machinery, so it uses server-side logic on the top-level HTML fetch by checking some first-party cookie.\r\n\r\n Some user subscribes and pays this publisher. The attacker now directs the user to some article but it's uncredentialed. Now even though the top-level URL says publisher.example and the user is a paying customer, the user is greeted with a request for money. The user now gets upset at the publisher for asking for even more money.\r\n\r\n(Realistically the user will probably just thing something weird happened, click the \"login\" button, and things will probably settle quickly enough. But it is rather weird.)",
              "createdAt": "2019-11-15T21:17:26Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 231,
              "body": "Something that might be worth mentioning: SXGs ensures the credentialed and uncredentialed versions of the top-level resources are the same, which motivates for the package-only options.",
              "createdAt": "2019-11-15T21:25:17Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 62,
              "body": "Something that might be worth writing out explicitly:\r\n\r\nIf I'm understanding things right, this option and the second option are qualitatively different from the remaining ones and prenavigate. These say that there are two ways a referrer may choose to enter a first-party site, credentialed or uncredentialed. The other options don't change the semantics of top-level navigations (aside from the SXG origin substitution capability itself), but are trying to slot an uncredentialed package fetch somehow.",
              "createdAt": "2019-11-15T21:29:15Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTM1NTcw",
          "commit": {
            "abbreviatedOid": "b6f9af0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T01:12:22Z",
          "updatedAt": "2019-12-10T01:15:36Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Which do we want it to use? I think it's the uncredentialed partition from the origin of the SXG, and the contents get to cross into the credentialed partition for the origin that signed them?",
              "createdAt": "2019-12-10T01:12:22Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 62,
              "body": "I've written this.",
              "createdAt": "2019-12-10T01:12:33Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 226,
              "body": "I've now described this as \"surprising users\". I agree that the user will probably just click \"login\" or \"reload\" in that case, although we'd need to run a user study to be confident of that, if folks think it's important.",
              "createdAt": "2019-12-10T01:13:47Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 231,
              "body": "They don't guarantee they're the same. They basically allow the site to assert that the uncredentialed version is good enough, which is similar to the assertion with the `Allow-Uncredentialed-Navigation` header.",
              "createdAt": "2019-12-10T01:14:35Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTA5MzUw",
          "commit": {
            "abbreviatedOid": "e3b1b44"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T20:03:28Z",
          "updatedAt": "2019-12-10T20:03:28Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "Ah yeah, that's a better phrasing.",
              "createdAt": "2019-12-10T20:03:28Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTExOTM5",
          "commit": {
            "abbreviatedOid": "e3b1b44"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T20:08:01Z",
          "updatedAt": "2019-12-10T20:08:01Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "There isn't really a singular uncredentialed partition right now. We do partition credentialed and uncredentialed connections, but it was more a consequence of not confusing connection-based auth (client certs, NTLM, Channel ID at one point, etc) than an actual partition. In theory a smarter connection pool could pool across those without messing that up.\r\n\r\nI don't think anyone is partitioning the HTTP cache by credentialed vs uncredentialed. (I'm *sure* sites always correctly labels their `Vary: Cookie` resources. :-) ) And pages can freely make uncredentialed subresource requests and either write data via URLs or read data via CORS-readable responses. I believe that means credentialed vs uncredentialed is useful for threat models that consider intentional state mechanisms (so CSRF and such), but that it's not useful for threat models which consider random caches being misused as state (which we seem to be converging on for anti-tracking).\r\n\r\nhttps://github.com/kinu/speculative-loading talks about using a temporary partition, which would probably require a bit of spec machinery if that's what we settle on.",
              "createdAt": "2019-12-10T20:08:01Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNTcyMTgw",
          "commit": {
            "abbreviatedOid": "d9eb40a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-12T22:40:21Z",
          "updatedAt": "2019-12-12T22:40:22Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I've added some handwaving about figuring this out. I'll merge this now, but we can update it as we get the spec text worked out.",
              "createdAt": "2019-12-12T22:40:21Z",
              "updatedAt": "2019-12-12T22:40:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 530,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NjcyNjY3",
      "title": "js/bundle: Bump version to 0.0.3",
      "url": "https://github.com/WICG/webpackage/pull/530",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'll merge this after #523 and publish to npm.",
      "createdAt": "2019-11-12T00:25:31Z",
      "updatedAt": "2019-11-12T01:16:48Z",
      "closedAt": "2019-11-12T01:16:47Z",
      "mergedAt": "2019-11-12T01:16:47Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjQ0MDQz",
          "commit": {
            "abbreviatedOid": "5e68d30"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-12T01:11:20Z",
          "updatedAt": "2019-11-12T01:11:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjQ0MjI1",
          "commit": {
            "abbreviatedOid": "5e68d30"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-12T01:11:56Z",
          "updatedAt": "2019-11-12T01:11:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 534,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxODE4Njc5",
      "title": "Charter edits to align with BoF chair and AD's advice",
      "url": "https://github.com/WICG/webpackage/pull/534",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-17T04:29:43Z",
      "updatedAt": "2019-11-17T08:20:34Z",
      "closedAt": "2019-11-17T08:20:33Z",
      "mergedAt": "2019-11-17T08:20:33Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 536,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzOTAwMzQ5",
      "title": "gen-bundle: Add -ignoreErrors flag",
      "url": "https://github.com/WICG/webpackage/pull/536",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Sometimes we need to create invalid bundles (e.g. for testing).",
      "createdAt": "2019-11-21T08:20:53Z",
      "updatedAt": "2019-11-21T08:25:59Z",
      "closedAt": "2019-11-21T08:25:58Z",
      "mergedAt": "2019-11-21T08:25:58Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNzA1MDA3",
          "commit": {
            "abbreviatedOid": "f88809f"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-21T08:23:59Z",
          "updatedAt": "2019-11-21T08:23:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 537,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ0MzY1ODI1",
      "title": "js/bundle: interpret the critical section",
      "url": "https://github.com/WICG/webpackage/pull/537",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WebBundle parser must fail if the `critical` section includes unknown section names.\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#name-parsing-the-critical-sectio",
      "createdAt": "2019-11-22T06:09:54Z",
      "updatedAt": "2020-04-06T03:11:52Z",
      "closedAt": "2020-04-06T03:11:33Z",
      "mergedAt": "2020-04-06T03:11:33Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@sisidovski Could you take a look?",
          "createdAt": "2019-11-22T06:11:30Z",
          "updatedAt": "2019-11-22T06:11:30Z"
        },
        {
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@irori Sorry to be late to review PR.",
          "createdAt": "2019-12-23T06:30:07Z",
          "updatedAt": "2019-12-23T06:30:07Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@sisidovski No worries, thanks!\r\n@kinu for approving review",
          "createdAt": "2019-12-23T09:37:31Z",
          "updatedAt": "2019-12-23T09:37:31Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, somehow totally overlooked this. (Is this still not stale?)",
          "createdAt": "2020-04-06T02:37:08Z",
          "updatedAt": "2020-04-06T02:37:08Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! (I also forgot this...)",
          "createdAt": "2020-04-06T03:11:46Z",
          "updatedAt": "2020-04-06T03:11:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NzI2Nzc4",
          "commit": {
            "abbreviatedOid": "3dff0bc"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-12-23T06:29:27Z",
          "updatedAt": "2019-12-23T06:29:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3OTAzNjM0",
          "commit": {
            "abbreviatedOid": "3dff0bc"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-06T02:36:14Z",
          "updatedAt": "2020-04-06T02:36:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 538,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ0ODA1MzMy",
      "title": "Add \"X-Content-Type-Options: nosniff\" to example of firebase hosting config",
      "url": "https://github.com/WICG/webpackage/pull/538",
      "state": "MERGED",
      "author": "sykmhmh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixed for\r\n```\r\nSigned exchange response without \"X-Content-Type-Options: nosniff\" header is not supported.\r\n```",
      "createdAt": "2019-11-23T12:37:54Z",
      "updatedAt": "2019-11-26T01:29:03Z",
      "closedAt": "2019-11-26T01:29:03Z",
      "mergedAt": "2019-11-26T01:29:03Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "marcoscaceres",
          "authorAssociation": "MEMBER",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-11-25T09:40:57Z",
          "updatedAt": "2019-11-25T09:40:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNjgxMjc4",
          "commit": {
            "abbreviatedOid": "7bd9236"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2019-11-26T01:28:49Z",
          "updatedAt": "2019-11-26T01:28:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 539,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2NTIzMTEw",
      "title": "gen-bundle: Add support for Variants",
      "url": "https://github.com/WICG/webpackage/pull/539",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The index section of bundle maps URLs to a Variants value + a list of\r\nthe responses for each possible Variant-Key (#450). But before this\r\npatch gen-bundle could not generate a bundle that have multiple variants\r\nfor single URL.\r\n\r\nThis patch teaches indexSection.Finalize() to generate entries with\r\nnon-empty variants-value, based on the responses' Variant and\r\nVariant-Key headers [1].\r\n\r\n[1] https://tools.ietf.org/html/draft-ietf-httpbis-variants-05",
      "createdAt": "2019-11-28T05:05:26Z",
      "updatedAt": "2019-11-28T08:41:46Z",
      "closedAt": "2019-11-28T08:41:45Z",
      "mergedAt": "2019-11-28T08:41:45Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MTA1NzY4",
          "commit": {
            "abbreviatedOid": "5c2a61b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-11-28T07:58:14Z",
          "updatedAt": "2019-11-28T07:58:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 540,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2NjAxMzA1",
      "title": "go/bundle: Support non-empty variants in decoder",
      "url": "https://github.com/WICG/webpackage/pull/540",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This enables dump-bundle to read bundles that have multiple variants\r\nfor single URL.\r\n\r\nAlso this adds a roundtrip test (serialize and then deserialize) for a\r\nbundle with variants.",
      "createdAt": "2019-11-28T09:28:12Z",
      "updatedAt": "2019-11-29T01:56:13Z",
      "closedAt": "2019-11-29T01:56:12Z",
      "mergedAt": "2019-11-29T01:56:12Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MjIxMDIz",
          "commit": {
            "abbreviatedOid": "77d6973"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-28T11:20:15Z",
          "updatedAt": "2019-11-28T11:20:16Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "optional: `SupportsVariants`?",
              "createdAt": "2019-11-28T11:20:15Z",
              "updatedAt": "2019-11-29T01:50:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MjIyMDgx",
          "commit": {
            "abbreviatedOid": "77d6973"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-11-28T11:22:29Z",
          "updatedAt": "2019-11-28T11:22:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0NDkyMjky",
          "commit": {
            "abbreviatedOid": "97910b3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-29T01:51:09Z",
          "updatedAt": "2019-11-29T01:51:10Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Done.",
              "createdAt": "2019-11-29T01:51:09Z",
              "updatedAt": "2019-11-29T01:51:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 541,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4MjE1ODgy",
      "title": "gen-bundle: Allow multiple entries for single URL",
      "url": "https://github.com/WICG/webpackage/pull/541",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This enables `gen-bundle -har` to create bundles that have multiple\r\nentries for single URL, if all responses have `Variants:` header.",
      "createdAt": "2019-12-03T09:26:16Z",
      "updatedAt": "2019-12-04T00:54:32Z",
      "closedAt": "2019-12-04T00:54:31Z",
      "mergedAt": "2019-12-04T00:54:31Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2MTMxNjYw",
          "commit": {
            "abbreviatedOid": "b8c4ea5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-03T13:20:43Z",
          "updatedAt": "2019-12-03T13:20:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 542,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4NjU2NzI5",
      "title": "Add an explainer for subresource signed exchanges",
      "url": "https://github.com/WICG/webpackage/pull/542",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I uploaded explainer documents of subresource signed exchanges to my\r\nrepository (https://github.com/horo-t/subresource-signed-exchange).\r\nBut they should be in this webpackage repository.\r\nSo this patch copies them from \"horo-t/subresource-signed-exchange\"\r\nrepository.\r\n\r\nSpec issue: https://github.com/WICG/webpackage/issues/347\r\nTAG review: https://github.com/w3ctag/design-reviews/issues/352",
      "createdAt": "2019-12-04T02:05:19Z",
      "updatedAt": "2020-01-06T04:12:28Z",
      "closedAt": "2020-01-06T04:12:27Z",
      "mergedAt": "2020-01-06T04:12:27Z",
      "mergedBy": "horo-t",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3MTgwMjcz",
          "commit": {
            "abbreviatedOid": "ba63b10"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I didn't get to the Signed Exchange subresource substitution or fully review the security questionnaire for the rel=alternate explainer.",
          "createdAt": "2019-12-04T21:54:40Z",
          "updatedAt": "2019-12-05T00:54:38Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nWe want to allow the publisher of a resource to declare that a signed exchange is available holding the content of either that resource or one of its subresources. We expect aggregator sites (SNS, News site, search engine..) to use this to cache the signed version of a resource in order to serve it to their users. We expect UAs to use this to allow users to save the page in signed exchange format. When the publisher identifies a same-origin signed exchange for a cross-origin subresource, the UA can use that information to recursively prefetch the subresource without exposing its speculative activity across origins.\r\n\r\n[`<link rel=\"alternate\" type=\"application/signed-exchange\" href=...>`](https://html.spec.whatwg.org/multipage/links.html#rel-alternate) and the equivalent `Link` header are already defined to declare that the referenced document is a reformulation of the current document as a signed exchange. To offer signed exchanges for subresources, we propose to use the [`anchor` parameter](https://tools.ietf.org/html/rfc8288#section-3.2) to identify the replaced subresource. This may be the first use of the `anchor` parameter in the web platform.\r\n```",
              "createdAt": "2019-12-04T21:54:40Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 3,
              "body": "Could you wrap lines at 80 columns?",
              "createdAt": "2019-12-04T23:56:05Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nWe want to extend the usage of the existing [rel=alternate](https://html.spec.whatwg.org/multipage/links.html#rel-alternate) link header for signed exchange. Using this link header, the content publishers can declare that the resource is available in signed exchange format. This can be used both by the crawlers of aggregator sites  (social networks, News site, search engine..) and by the UAs. The crawlers can cache and serve the signed exchange of the content in their own server. The UAs can provide the users with a way to save the page in signe exchange format. And also signed exchange alternate links can be used to recursively prefetch appropriate subresource signed exchanges while prefetching the main resource signed exchange.\r\n```\r\n\r\nI think SNS means \"social networking service\", from https://en.wikipedia.org/wiki/SNS, but I had to look it up. We should expand acronyms at least the first time we use them, but I think we can just avoid this one.",
              "createdAt": "2019-12-04T23:57:02Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nWe want to extend the usage of the existing [rel=alternate](https://html.spec.whatwg.org/multipage/links.html#rel-alternate) link header for signed exchange. Using this link header, the content publishers can declare that the resource is available in signed exchange format. This can be used both by the crawlers of aggregator sites  (SNS, News site, search engine..) and by the UAs. The crawlers can cache and serve the signed exchange of the content in their own server. The UAs can provide the users with a way to save the page in signed exchange format. And also signed exchange alternate links can be used to recursively prefetch appropriate subresource signed exchanges while prefetching the main resource signed exchange.\r\n```",
              "createdAt": "2019-12-04T23:57:43Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n   - While the user of the UA is browsing an article (article.html), and if there is a signed exchange alternate link, the UA can provide the user with a way to save the page in signed exchange format. The saved file can be used to share with other users.\r\n```",
              "createdAt": "2019-12-04T23:57:54Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n### Discovery of a signed exchange for the main resource\r\n```\r\n\r\nHowever, I'm not sure this use needs to be in an explainer at all. The \"Otherwise\" branch in https://html.spec.whatwg.org/multipage/links.html#rel-alternate already says that \"The keyword creates a hyperlink referencing an alternate representation of the current document. The nature of the referenced document is given by the hreflang, and type attributes.\" There's nothing new in saying that a signed exchange can be an alternate representation of a document. So maybe delete this whole sub-section.",
              "createdAt": "2019-12-05T00:01:01Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 13,
              "body": "Omit an `anchor` parameter if it's the same URL as the resource it appears in.\r\n```suggestion\r\n```",
              "createdAt": "2019-12-05T00:01:54Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 7,
              "body": "\r\n```suggestion\r\n1. A publisher can offer a signed exchange version of a resource using either a `Link` header on that resource of a `<link rel=\"alternate\">` element within the resource.\r\n```",
              "createdAt": "2019-12-05T00:04:17Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 7,
              "body": "I don't think the paragraphs in this section are really an ordered list.\r\n\r\n```suggestion\r\nContent publishers can declare the URL of signed exchange format of the content using an alternate link HTTP header or using an alternate link HTML element.\r\n```",
              "createdAt": "2019-12-05T00:04:54Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 20,
              "body": "Also omit this one.\r\n```suggestion\r\n            >\r\n```",
              "createdAt": "2019-12-05T00:05:47Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 32,
              "body": "I don't think crawlers are likely to respect subresource signed exchanges. They can just go to the original host, which can offer the signed exchange as a same-document alternative. So remove from here down to \"The aggregator site will serve\"?",
              "createdAt": "2019-12-05T00:17:22Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nWhile a user is browsing an aggregator site (https://feed.example), the aggregator guesses that the user is likely to want to read a particular article (https://publisher.example/article.html) and so inserts a prefetch link pointing to a signed exchange version of that article.\r\n```",
              "createdAt": "2019-12-05T00:19:36Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nWhen the UA prefetches the signed exchange (article.html.sxg), the aggregator server includes a declaration that one of `article.html`'s subresources (https://cdn.publisher.example/lib.js) is also available from the same aggregator.\r\n```",
              "createdAt": "2019-12-05T00:21:03Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nTo prevent an attacker from loading an incompatible version of the subresource, the resource _inside_ the signed exchange has to identify the exact version of the replacement signed exchange using a `Link: ... rel=\"allowed-alt-sxg\"` with the hash of the signed headers (which themselves include a hash of the content).\r\n\r\nTo prevent a tracker from conveying a user ID in their choice of which subresources to prefetch, the inner resource has to preload the same subresources that the aggregator prefetches.\r\n```",
              "createdAt": "2019-12-05T00:27:02Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nIf the user navigates to the expected article, both the main resource of the article and the script subresource are loaded from the prefetched signed exchanges.\r\n```",
              "createdAt": "2019-12-05T00:27:41Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 128,
              "body": "Also, to prevent tracking (user ID transfer), if the aggregator failed to prefetch a subresource that the main resource preloads, the UA must drop all of the subresource prefetches. If the aggregator prefetches a superset of the preloaded subresources, the UA must drop the ones that weren't preloaded.",
              "createdAt": "2019-12-05T00:30:41Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 92,
              "body": "Probably just remove this sub-header.",
              "createdAt": "2019-12-05T00:47:35Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nWhile prefetching an HTML resource:\r\n```\r\n\r\nThen write an explicit loop that checks if every preload has a matching and allowed prefetch before deciding to use all of the prefetches.",
              "createdAt": "2019-12-05T00:53:30Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3Mzc1NDcw",
          "commit": {
            "abbreviatedOid": "ba63b10"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for the review.",
          "createdAt": "2019-12-05T08:30:30Z",
          "updatedAt": "2019-12-05T09:41:28Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Done",
              "createdAt": "2019-12-05T08:30:30Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 3,
              "body": "done",
              "createdAt": "2019-12-05T08:32:25Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 6,
              "body": "Deleted this whole sub-section.",
              "createdAt": "2019-12-05T08:35:22Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 61,
              "body": "Done.",
              "createdAt": "2019-12-05T08:42:17Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2019-12-05T08:42:22Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 65,
              "body": "done",
              "createdAt": "2019-12-05T08:47:17Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 73,
              "body": "done",
              "createdAt": "2019-12-05T08:47:26Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 83,
              "body": "Done",
              "createdAt": "2019-12-05T08:48:57Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 92,
              "body": "Done",
              "createdAt": "2019-12-05T08:56:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 128,
              "body": "Done",
              "createdAt": "2019-12-05T09:22:22Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 86,
              "body": "Done",
              "createdAt": "2019-12-05T09:37:34Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 3,
              "body": "done",
              "createdAt": "2019-12-05T09:37:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4NDk4OTQ1",
          "commit": {
            "abbreviatedOid": "3a44a08"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-06T22:49:39Z",
          "updatedAt": "2019-12-07T00:20:18Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I wonder if \"replaceable\" would be a better word than \"replaced\", since the UA isn't required to replace it.\r\n\r\n```suggestion\r\nidentify the replaceable subresource. This may be the first use of the `anchor`\r\n```",
              "createdAt": "2019-12-06T22:49:39Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nsubresources. We expect aggregator sites (social networks, news sites, search\r\n```",
              "createdAt": "2019-12-06T22:50:28Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nengines, etc.) to use this to cache the signed version of a resource in order to\r\n```",
              "createdAt": "2019-12-06T22:50:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\npage in signed exchange format so they can share it with their peers. When the publisher identifies a same-origin\r\n```",
              "createdAt": "2019-12-06T22:51:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 36,
              "body": "I think this could join the previous paragraph. \r\n```suggestion\r\nThe aggregator server expresses this by serving `article.html.sxg` with a `Link` header identifying the subresource's alternate form:\r\n```",
              "createdAt": "2019-12-06T23:18:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nWhile prefetching an HTML resource in signed exchange format:\r\n```",
              "createdAt": "2019-12-06T23:19:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\n1. When the UA detects a \"preload\" link HTTP header in the inner response,\r\n```",
              "createdAt": "2019-12-06T23:19:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 76,
              "body": "```suggestion\r\ncheck whether a matching \u201callowed-alt-sxg\u201d link HTTP header in the inner response\r\n```",
              "createdAt": "2019-12-06T23:19:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\nexists or not. (Note that multiple `allowed-alt-sxg` links can be present for the same preload if they include `variants` and `variant-key` attributes. In that case, the UA uses the algorithm ...\r\n```",
              "createdAt": "2019-12-06T23:21:45Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n1. If an `allowed-alt-sxg` link exists, check whether the signed exchange was served with a matching \u201calternate\u201d link HTTP header.\r\n```",
              "createdAt": "2019-12-06T23:23:02Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\n1. If the outer signed exchange did identify an alternate version of the subresource, prefetch the subresource signed exchange instead ...\r\n```",
              "createdAt": "2019-12-06T23:24:16Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 149,
              "body": "The state of the cache for another origin is potentially sensitive, and this specification avoids exposing it by making the decision to fetch an alternative not depend on the presence or absence of the subresource in its cache.",
              "createdAt": "2019-12-06T23:28:53Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 152,
              "body": "Prefetched resources, including signed exchanges, are stored to the HTTP cache as normal, but the association of a signed exchange with its contained resource is not persisted. Right now, the contained resource is not independently stored in the HTTP cache, although that decision may be revisited.",
              "createdAt": "2019-12-06T23:30:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 157,
              "body": "The use of Variants exposes the UA's content negotiation preferences to the aggregator's origin, but that's already exposed by the UA's Accept headers.",
              "createdAt": "2019-12-06T23:31:37Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 167,
              "body": "Well, yes, loading a script from a signed exchange is different from loading it over TLS. We think it's not *significantly* different.",
              "createdAt": "2019-12-06T23:38:12Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 175,
              "body": "```suggestion\r\n   - None\r\n```",
              "createdAt": "2019-12-06T23:38:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 189,
              "body": "There's active discussion about how signed exchanges are a downgrade compared to TLS, and this particular specification allows recursive use of signed exchanges.",
              "createdAt": "2019-12-06T23:40:35Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 90,
              "body": "I believe it's this content negotiation that makes subresource signed exchanges continue to be interesting even after we ship signed bundles. Could you discuss that here?",
              "createdAt": "2019-12-06T23:44:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 1,
              "body": "It's not clear to me how this explainer is different from the explainer above. If the one above had only use cases that didn't use `rel=allowed-alt-sxg` (for example, to allow a page to declaratively replace its own cross-origin subresources with same-origin SXGs), they'd be clearly different, but its use cases do use `rel=allowed-alt-sxg`. Could you either merge them or make them more distinct?",
              "createdAt": "2019-12-06T23:45:57Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 5,
              "body": "The introduction should start with the user problem we want to solve, rather than the technical solution we think solves it.",
              "createdAt": "2019-12-06T23:46:19Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 23,
              "body": "We should say what's problematic, not just declare that it is. Specifically,\r\n\r\n```suggestion\r\nfile while the user is browsing the feed site. But this leaks that the user's search results include a page using this JS library before the user has consented by clicking on the link.\r\n```",
              "createdAt": "2019-12-06T23:48:58Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 25,
              "body": "This seems to overlap with the `rel=prenavigate` discussion. Could you link to the most recent state of that discussion, and if it doesn't completely solve the problem, add a separate section here, maybe an appendix, that explains how prenavigate isn't sufficient.",
              "createdAt": "2019-12-06T23:54:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nSigned Exchanges solve this\r\n```",
              "createdAt": "2019-12-06T23:55:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 36,
              "body": "The publisher doesn't have to independently provide the header integrity value, right? That's computable from the SXG itself?",
              "createdAt": "2019-12-07T00:05:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\n1. The signed HTTP response inside the signed exchange (https://publisher.example/article.html) has an `allowed-alt-sxg` link header to declare\r\n```",
              "createdAt": "2019-12-07T00:06:56Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nexactly what version of the subresource is compatible with this main resource.\r\n```",
              "createdAt": "2019-12-07T00:07:16Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "I think this paragraph can go away?",
              "createdAt": "2019-12-07T00:10:22Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 51,
              "body": "This is probably better solved by bundles.",
              "createdAt": "2019-12-07T00:10:39Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 69,
              "body": "These seem like Chromium-internal concepts rather than things the TAG needs to think about.",
              "createdAt": "2019-12-07T00:11:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 88,
              "body": "This seems very similar to other explainer's algorithm. Maybe add anything that's missing there and remove this one?",
              "createdAt": "2019-12-07T00:12:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nfor this purpose, because SRI\u2019s integrity only covers the content body and not any of the headers.\r\n```",
              "createdAt": "2019-12-07T00:14:35Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 132,
              "body": "This section is covered in the other explainer.",
              "createdAt": "2019-12-07T00:15:33Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\nThe `header-integrity` parameter of the `allowed-alt-sxg` link is the SHA256 hash value of the *signedHeaders* value from the\r\n```",
              "createdAt": "2019-12-07T00:16:26Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 115,
              "body": "```suggestion\r\nagain or changes the signing key. This header-integrity value also guarantees the content body hasn't changed, because the signed headers are required to include a `Digest` header with a hash of the content body.\r\n```",
              "createdAt": "2019-12-07T00:17:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 188,
              "body": "Only include this section in one of the explainers.",
              "createdAt": "2019-12-07T00:18:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 137,
              "body": "And to prevent the distributor from selecting a version of the subresource that isn't compatible with the selected version of the main resource, which might introduce a security hole.",
              "createdAt": "2019-12-07T00:20:14Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4NjkyODg5",
          "commit": {
            "abbreviatedOid": "3a44a08"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Merged to one explainer.\r\nhttps://github.com/horo-t/webpackage/blob/add-subresource-signed-exchange/explainers/signed-exchange-subresource-subtitution-explainer.md\r\n\r\nPlease review this.",
          "createdAt": "2019-12-09T05:23:11Z",
          "updatedAt": "2019-12-09T09:58:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "done",
              "createdAt": "2019-12-09T05:23:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 6,
              "body": "done",
              "createdAt": "2019-12-09T05:23:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 8,
              "body": "done",
              "createdAt": "2019-12-09T05:24:12Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 18,
              "body": "done",
              "createdAt": "2019-12-09T05:24:43Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 36,
              "body": "done",
              "createdAt": "2019-12-09T05:25:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 75,
              "body": "done",
              "createdAt": "2019-12-09T05:26:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 77,
              "body": "done",
              "createdAt": "2019-12-09T05:26:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 76,
              "body": "done",
              "createdAt": "2019-12-09T05:26:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 81,
              "body": "done",
              "createdAt": "2019-12-09T05:29:57Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 83,
              "body": "done",
              "createdAt": "2019-12-09T05:30:06Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 175,
              "body": "done",
              "createdAt": "2019-12-09T05:37:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 90,
              "body": "Sorry, what topic do you want to discuss?\r\nWeb Bundles have similar content negotiation logic using `variants-value`.\r\n",
              "createdAt": "2019-12-09T05:45:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 149,
              "body": "Added.",
              "createdAt": "2019-12-09T05:47:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 152,
              "body": "Done.",
              "createdAt": "2019-12-09T05:48:37Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 157,
              "body": "done.",
              "createdAt": "2019-12-09T05:49:09Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 167,
              "body": "Changed.",
              "createdAt": "2019-12-09T05:50:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 189,
              "body": "Done.",
              "createdAt": "2019-12-09T05:50:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 23,
              "body": "Done",
              "createdAt": "2019-12-09T06:38:02Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 27,
              "body": "Done",
              "createdAt": "2019-12-09T06:38:27Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 39,
              "body": "I think `allowed-alt-sxg` should work even when the HTML is not a signed exchange.",
              "createdAt": "2019-12-09T06:41:04Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 40,
              "body": "Done.",
              "createdAt": "2019-12-09T06:41:37Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 51,
              "body": "Removed.",
              "createdAt": "2019-12-09T06:44:17Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 109,
              "body": "Done",
              "createdAt": "2019-12-09T06:47:16Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 115,
              "body": "Done.",
              "createdAt": "2019-12-09T06:48:20Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 126,
              "body": "Done.",
              "createdAt": "2019-12-09T06:50:01Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "Done.",
              "createdAt": "2019-12-09T06:54:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 36,
              "body": "That's computable. Removed \"along with...\".",
              "createdAt": "2019-12-09T06:55:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 137,
              "body": "Done.",
              "createdAt": "2019-12-09T07:01:38Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 73,
              "body": "Done",
              "createdAt": "2019-12-09T07:12:55Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 25,
              "body": "Done",
              "createdAt": "2019-12-09T07:55:55Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 69,
              "body": "I think it is easy to understand the logic if we have name of  the two cache mechanism.",
              "createdAt": "2019-12-09T08:02:56Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2019-12-09T09:30:48Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 1,
              "body": "Merged.",
              "createdAt": "2019-12-09T09:31:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 88,
              "body": "Merged",
              "createdAt": "2019-12-09T09:31:20Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 132,
              "body": "Merged",
              "createdAt": "2019-12-09T09:31:34Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 188,
              "body": "Merged.",
              "createdAt": "2019-12-09T09:31:48Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5MzE3MzEz",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-09T22:10:54Z",
          "updatedAt": "2019-12-10T00:51:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This should start by describing the user-facing problem we want to solve, as described in https://github.com/w3ctag/w3ctag.github.io/blob/master/explainers.md.\r\n\r\nHere, that might be the following, but please double-check that it actually captures what you mean, and that it's reasonable readable:\r\n\r\n> Users want to see the result of their clicks as fast as possible. This goal benefits from letting a site tell the UA to `prenavigate` to the particular outbound link(s) it thinks the user is most likely to click on. However, naively prenavigating to a cross-origin link [leaks that user visited](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-privacy-preserving-prefetch) the referring page, which the referrer shouldn't do before the user has clicked. The referrer can safely prenavigate to a referrer-origin signed exchange for the top-level HTML of that link, but the UA still can't prefetch that link's subresources without leaking the same information about the user.\r\n>\r\n> We want the referrer to be able to identify that a particular subresource of a prenavigated link is available as a signed exchange served by their own organization. The [`Link: <subresource.sxg>; rel=\"alternate\", type=\"application/signed-exchange\"; anchor=\"subresource\"` header](https://html.spec.whatwg.org/multipage/links.html#rel-alternate) is already defined to identify such alternate forms, where the [`anchor` parameter](https://tools.ietf.org/html/rfc8288#section-3.2) states that the alternate form is for a resource other than the one the `Link` header is attached to.\r\n>\r\n> Arbitrarily replacing a target link's subresources is unsafe for several reasons, so we propose that the target link opt into particular replacements by including a link with `rel=allowed-alt-sxg`.\r\n>\r\n> We think the `<link rel=\"alternate\" type=\"application/signed-exchange\"> formulation is also useful for two other purposes:\r\n> 1. Identifying to a UA or web crawler that the page they're visiting is available as a signed exchange that the user or crawler could download and then send to other users peer-to-peer. This doesn't need either `rel=allowed-alt-sxg` or the `anchor` parameter.\r\n> 2. Identifying that some cross-origin subresources are available as same-origin signed exchanges. This needs the `anchor` parameter, but as long as the instruction to replace subresources is embedded in the document whose subresources are being replaced, it doesn't need `rel=allowed-alt-sxg`.",
              "createdAt": "2019-12-09T22:10:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "I think you can omit the discussion of why double-keyed caching is proposed.",
              "createdAt": "2019-12-09T22:26:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\ncross-origin navigation prefetch work with double-keyed caching which is proposed\r\n```",
              "createdAt": "2019-12-09T22:26:21Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n[still leaks information before the user has clicked on a link](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#private-prefetch).\r\n```",
              "createdAt": "2019-12-09T22:27:15Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nSigned Exchanges solve this privacy-preserving prefetching problem for main\r\n```",
              "createdAt": "2019-12-09T22:27:49Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 53,
              "body": "If you take my suggestion for the introduction, I think this paragraph is redundant with it. This section should go into more detail about how the aggregator and publisher solve the use case, but not restate the overall problem.",
              "createdAt": "2019-12-09T23:39:58Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 65,
              "body": "We've teased the `rel=allowed-alt-sxg` link in the introduction. I think it'll read better if we put its definition before we use it again. So ... maybe put at least some part of the \"Proposal\" and \"Header integrity of signed exchange\" sections before this section of how to solve the use cases?",
              "createdAt": "2019-12-09T23:43:32Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 75,
              "body": "This section looks like the same use case as the \"Privacy-preserving prefetching subresources\" section. Either make them more clearly distinct or remove one.",
              "createdAt": "2019-12-09T23:45:02Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 127,
              "body": "This reads like these are Chrome internals. Folks reading an explainer don't want to see Chrome internals, and most of them don't even want to see the internal variables that'll eventually be used to specify the behavior. If this is important, you might be able to say that, while a document is open, it collects the resources that it prefetches, and then transfers a subset of them across the next navigation.",
              "createdAt": "2019-12-09T23:52:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 140,
              "body": "`ref-for` fragments aren't generally stable. Do you mean https://wicg.github.io/webpackage/loading.html#parsing-a-signed-exchange?",
              "createdAt": "2019-12-09T23:53:29Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 147,
              "body": "This is going to alarm people. Could you include a link to a description of how this doesn't allow servers to pass a user ID from one top-level context to another?",
              "createdAt": "2019-12-09T23:55:43Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 135,
              "body": "Are these still expected to be `prefetch`es or are they now `prenavigate`s?",
              "createdAt": "2019-12-09T23:56:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\n1. While processing a\r\n```",
              "createdAt": "2019-12-09T23:56:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 138,
              "body": "```suggestion\r\n   - If the UA successfully prefetches the signed exchange (including the merkle integrity\r\n```",
              "createdAt": "2019-12-09T23:57:31Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\r\n   check of the body), it stores the parsedExchange which is the result of\r\n```",
              "createdAt": "2019-12-09T23:57:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 144,
              "body": "Presumably except for the one that serves the navigation itself?",
              "createdAt": "2019-12-10T00:03:57Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 148,
              "body": "This step should set up what it's trying to do. I think that's something like\r\n\r\n> The navigated-to document has a set of preloads for which it uses the `allowed-alt-sxg` link relation to declare that they can be served by signed exchanges. The UA either serves all of them from SXGs prefetched by the previous page, or none of them.",
              "createdAt": "2019-12-10T00:06:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 161,
              "body": "\"request\" hasn't been introduced yet.",
              "createdAt": "2019-12-10T00:07:28Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 167,
              "body": "This also looks like the same scenario as the previous section.",
              "createdAt": "2019-12-10T00:08:59Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 190,
              "body": "There should probably be a section that starts with a definition of the `allowed-alt-sxg` link relation, including an example header expressing it.",
              "createdAt": "2019-12-10T00:15:04Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 219,
              "body": "I don't follow \"defined in the header\". ",
              "createdAt": "2019-12-10T00:16:31Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 217,
              "body": "Maybe\r\n\r\n```suggestion\r\nany of the signed exchanges (eg: sig matching, URL matching, Merkle Integrity\r\n```\r\n\r\n?",
              "createdAt": "2019-12-10T00:16:43Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 215,
              "body": "It's not clear what \"matching\" means here. I think you're referring to subresource preloads that are provided by prefetches on the previous page?",
              "createdAt": "2019-12-10T00:18:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 240,
              "body": "This might be easier to read as something like, \"However, the imagesrcset attribute allows a single preload link to declare multiple different target URLs, and it's difficult to embed a `header-integrity` value for each of those URLs into the existing syntax. Instead, we use a separate link that gives a hash of the expected content for each of the possible URLs, while the preload tag continues to select which of the URLs is actually used.\"\r\n\r\n(I do want to double-check that you can defend that claim that it's difficult to embed. Why couldn't it just come after the XXXw field?)",
              "createdAt": "2019-12-10T00:23:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 334,
              "body": "```suggestion\r\nIf a UA supports WebP, the UA must prefetch **image_webp.sxg** holding a WebP image.\r\n```\r\n\r\nThis isn't \"should\", since it's defined by the variants algorithm.",
              "createdAt": "2019-12-10T00:25:10Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 344,
              "body": "```suggestion\r\nwere prefetched in the immediate referrer page. This is intended to avoid leaking the\r\n```\r\n\r\nIt's not clear to me exactly what information gets leaked if we do allow a series of navigations, especially same-origin navigations, to continue using the same set of prefetches. Maye the benefit isn't there, since the first page can just re-prefetch the same-origin content, but then we should say that instead of being vague about the leak.",
              "createdAt": "2019-12-10T00:33:46Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 351,
              "body": "\"The UA needs to check that the signed request URL matches the preload link and not just that the header-integrity value matches, since the header-integrity hash doesn't cover the request URL.\"",
              "createdAt": "2019-12-10T00:36:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 359,
              "body": "```suggestion\r\neven if the HTTP cache already contains the original subresource (http://cdn.publisher.example/lib.js)\r\n```\r\n\r\nAlthough it's not clear to me in this system how the UA would even know what the original subresource URL is before fetching the SXG.",
              "createdAt": "2019-12-10T00:36:29Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 362,
              "body": "This is a duplicate of the previous bullet point.",
              "createdAt": "2019-12-10T00:37:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 365,
              "body": "This is very similar to the first bullet in this list. Put them next to each other.",
              "createdAt": "2019-12-10T00:38:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 369,
              "body": "This one should probably start, \"If a replaced subresource prefetch hasn't completed by the time the UA would start fetching it in the course of loading the next page, the UA must cancel that prefetch and fetch the resource from its original URL. This prevents the distributor from ...\"",
              "createdAt": "2019-12-10T00:40:31Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 377,
              "body": "Isn't this the same as the \"To prevent tracking (user ID transfer)\" item?",
              "createdAt": "2019-12-10T00:41:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 383,
              "body": "Is this true? Who is it exposed to and under what circumstances? When is the alternative SXG even in the HTTP cache? Which partition?",
              "createdAt": "2019-12-10T00:44:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 386,
              "body": "Say what the limitations accomplish here, not just that some phrases exist in other parts of this document.",
              "createdAt": "2019-12-10T00:45:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 391,
              "body": "Also, any personal information that was incorrectly included in a signed exchange would be the information of the aggregator that fetched the SXG, and not the end user.\r\n\r\nThe use of `<link rel=alternate>` to identify the SXG for the current page could inform the UA to omit credentials in fetching that SXG, which would prevent any personal information from being accidentally included.",
              "createdAt": "2019-12-10T00:49:18Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTYyNjA5",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T02:52:54Z",
          "updatedAt": "2019-12-10T02:52:55Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "I have one question.\r\n\r\nI think \"allowed-alt-sxg\" is useful even when the HTML is not served via signed exchange.\r\n\r\n1. An aggregator site prefetches \"https://aggregator.example/publisher.example/lib.js.sxg\".\r\n2. The user clicks a link to \"https://publisher.example/article.html\".\r\n3. The HTTP response header has `Link: <https://publisher.example/lib.js>; rel=\"allowed-alt-sxg\"; header-integrity=\"sha256-...\"` header.\r\n4. When the UA detects <script src=\"./lib.js\">, the UA checks the header-integrity attribute value of the link rel=\"allowed-alt-sxg\" header and the header-integrity value of \"lib.js.sxg\" in cache:\r\n   - If they match, the UA will use \"lib.js.sxg\" in the cache.\r\n   - Otherwise, the UA will fetch \"https://publisher.example/lib.js\".\r\n\r\nDo you think this use case is not useful?\r\nIf so, I will remove this use case and make \"allowed-alt-sxg\" work only when the HTML is served via signed exchange.",
              "createdAt": "2019-12-10T02:52:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTgyODEy",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T04:25:10Z",
          "updatedAt": "2019-12-10T04:25:10Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "I feel like that's unlikely to be helpful: the referrer has to guess that a page with a particular set of preloaded and replaceable subresources will be the next link clicked, without being able to predict exactly which link it is? I do agree that it's technically possible.",
              "createdAt": "2019-12-10T04:25:10Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTkxMzY1",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T05:06:58Z",
          "updatedAt": "2019-12-10T05:06:58Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "OK. I agree with you.\r\nI will remove this use case, and merge \"Privacy-preserving prefetching subresources\" and \"Recursive subresource signed exchange prefetch\".",
              "createdAt": "2019-12-10T05:06:58Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NjM1Mjc4",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you very much for reviewing.",
          "createdAt": "2019-12-10T07:39:50Z",
          "updatedAt": "2019-12-10T09:27:24Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Done.\r\nIf we change the syntax of imagesrcset, existing browsers may not understand the new syntax. I think we should avoid it.",
              "createdAt": "2019-12-10T07:39:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 219,
              "body": "Removed",
              "createdAt": "2019-12-10T07:40:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 334,
              "body": "done.",
              "createdAt": "2019-12-10T07:41:20Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 344,
              "body": "Done.\r\nAh, yes. We may be able to allow same-origin navigations.\r\nBut I prefer stricter restrictions for privacy and security.",
              "createdAt": "2019-12-10T07:44:17Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 351,
              "body": "Done",
              "createdAt": "2019-12-10T08:05:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 362,
              "body": "Removed",
              "createdAt": "2019-12-10T08:06:42Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 365,
              "body": "Moved.",
              "createdAt": "2019-12-10T08:08:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 369,
              "body": "Done.",
              "createdAt": "2019-12-10T08:10:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 377,
              "body": "Removed",
              "createdAt": "2019-12-10T08:10:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 383,
              "body": "Changed to\r\n> This feature exposes the 1 bit information \"the referrer page has prefetched the signed exchange subresources or not\" to the publisher.",
              "createdAt": "2019-12-10T08:20:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 386,
              "body": "Added\r\n> Thanks to these limitations, this feature exposes only 1 bit information to the publisher.",
              "createdAt": "2019-12-10T08:26:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 391,
              "body": "Added.",
              "createdAt": "2019-12-10T08:30:56Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 5,
              "body": "I think we don't need \"We think ...\" in this explainer.\r\nThey are out of scope of this explainer.",
              "createdAt": "2019-12-10T08:54:02Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "Removed.",
              "createdAt": "2019-12-10T08:54:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "Removed.",
              "createdAt": "2019-12-10T08:56:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 50,
              "body": "Removed",
              "createdAt": "2019-12-10T08:56:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 53,
              "body": "Removed.",
              "createdAt": "2019-12-10T08:57:25Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 53,
              "body": "Removed.",
              "createdAt": "2019-12-10T08:57:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 135,
              "body": "Done.",
              "createdAt": "2019-12-10T09:00:35Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 138,
              "body": "Done.",
              "createdAt": "2019-12-10T09:00:49Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 139,
              "body": "Done.",
              "createdAt": "2019-12-10T09:01:04Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 140,
              "body": "Done.",
              "createdAt": "2019-12-10T09:01:12Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 144,
              "body": "Yes.\r\nAdded.",
              "createdAt": "2019-12-10T09:01:21Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 147,
              "body": "Added\r\n> (Note that [header integrity check](#header-integrity-of-signed-exchange) prohibits the distributor from passing a tracking ID to the publisher.)",
              "createdAt": "2019-12-10T09:01:49Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 161,
              "body": "Changed to refer \"linked resource fetch setup steps\".",
              "createdAt": "2019-12-10T09:02:09Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 167,
              "body": "Removed \"Privacy-preserving prefetching subresources\".",
              "createdAt": "2019-12-10T09:03:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 148,
              "body": "Added.",
              "createdAt": "2019-12-10T09:04:27Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 190,
              "body": "Done.\r\nHow about this?",
              "createdAt": "2019-12-10T09:04:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 215,
              "body": "Changed to\r\n> If there are multiple subresource preloads that are provided by prefetches on\r\nthe previous page in signed exchange format",
              "createdAt": "2019-12-10T09:12:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 217,
              "body": "Done",
              "createdAt": "2019-12-10T09:12:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 359,
              "body": "Done.\r\n\r\nIf we don't need to think about privacy, when the HTTP cache has \"lib.js\", UAs don't need to fetch \"lib.js.sxg\" when the UA see rel=preload and rel=allowed-alt-sxg and rel=alternate for better performance. But we can't do that for the privacy reason.",
              "createdAt": "2019-12-10T09:18:12Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNjA0NTQy",
          "commit": {
            "abbreviatedOid": "82bbcba"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This looks much better! Thank you for bearing with the long review.\r\n\r\nI'm approving now, but feel free to ask for another round if you have more questions about my comments here.",
          "createdAt": "2019-12-13T00:17:00Z",
          "updatedAt": "2019-12-13T01:14:39Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I don't have a feeling for whether we're going to want `prefetch` or `prenavigate` here. I bet the TAG will ask too, so have an answer ready.",
              "createdAt": "2019-12-13T00:17:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nThis means that the inner response of the main resource signed exchange (article.html.sxg)\r\n```",
              "createdAt": "2019-12-13T00:18:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nsubresources to prefetch, the inner resource also has to preload the same\r\n```",
              "createdAt": "2019-12-13T00:18:48Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 81,
              "body": "\"prenavigating\" or \"prefetching\"?",
              "createdAt": "2019-12-13T00:23:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 92,
              "body": "I think we're not doing cross-origin recursive prefetches (if we are, the top of this document says that's a privacy problem), so you can drop \"instead of ...\".",
              "createdAt": "2019-12-13T00:24:52Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 99,
              "body": "Which `Document`? Since they're triggered by the top-level SXG's response, I *think* we could attach them to that response, so they're only used on a navigation to that particular response. They could also be attached as prefetches to the source document and then used for any acceptable navigation, but that seems less obviously safe.",
              "createdAt": "2019-12-13T00:30:36Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 95,
              "body": "This may be more detail than readers want. Would it make sense to just say that if the resulting signed exchange is valid and matches the `allowed-alt-sxg` link, we attach it to the top-level prefetch?",
              "createdAt": "2019-12-13T00:35:31Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nthe UA copies the signed exchanges that were prefetched above to the\r\n```",
              "createdAt": "2019-12-13T00:38:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\n    - Note that as browsers move toward partitioned HTTP caches, the source document's cache will likely be separate from the target's cache, so we can't just pass prefetched content through the cache.\r\n```",
              "createdAt": "2019-12-13T00:40:10Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 106,
              "body": "This has been mentioned a couple times already, so maybe we can skip it here. If not, it deserves a separate bullet point.",
              "createdAt": "2019-12-13T00:47:14Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 115,
              "body": "These steps need to be consistent about whether we're talking about a single preload header or the whole set of them. It'll probably be shorter (==easier to read) if we consistently talk about the whole set, so something like\r\n\r\n> 1. For each preload, use the imagesrcset and imagesizes attributes to pick a single URL to preload.\r\n> 2. Identify the subset _SxgPreloads_ of those preloads with an `allowed-alt-sxg` link for that selected URL.\r\n> 3. If every member of _SxgPreloads_ has a valid signed exchange that was transferred from the referring document, use the signed contents of those resources to satisfy the preloads. Ignore any other prefetched signed exchanges.\r\n> 4. Otherwise, ignore all prefetched signed exchanges and re-fetch the preloads from their original URLs.",
              "createdAt": "2019-12-13T00:56:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\n## Identifying exactly one version of a signed exchange\r\n```",
              "createdAt": "2019-12-13T00:57:18Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 160,
              "body": "```suggestion\r\n[SRI `integrity` attribute](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)\r\n```",
              "createdAt": "2019-12-13T00:59:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 161,
              "body": "```suggestion\r\nfor this purpose, because SRI\u2019s `integrity` attribute only covers the content body and not\r\n```",
              "createdAt": "2019-12-13T00:59:19Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n`allowed-alt-sxg` link header, a tracker can use signed exchanges that differ in headers like their `Content-Type` to transfer a user ID via a pattern of parsing failures.\r\n```",
              "createdAt": "2019-12-13T01:00:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 154,
              "body": "I *think* this paragraph is already explained elsewhere.",
              "createdAt": "2019-12-13T01:00:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 150,
              "body": "```suggestion\r\nagain or changes the signing key, but it does change if any of the headers or body change. (It catches changes to the body because a valid signed exchange's headers have to include a `Digest` value that covers the body.)\r\n```",
              "createdAt": "2019-12-13T01:02:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\n# Algorithm sketch\r\n```",
              "createdAt": "2019-12-13T01:02:51Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 170,
              "body": "This \"must\" is covered above. Is there anything in this section that's not already covered? If there is, try to prune out the repetitive bits by referring to the algorithm. If not, just remove this section.",
              "createdAt": "2019-12-13T01:05:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 219,
              "body": "```suggestion\r\n[signature expiration time](https://wicg.github.io/webpackage/loading.html#exchange-signature-expiration-time)\r\n```",
              "createdAt": "2019-12-13T01:06:21Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 288,
              "body": "```suggestion\r\n# Security and Privacy Considerations\r\n```",
              "createdAt": "2019-12-13T01:08:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 298,
              "body": "```suggestion\r\nwere prefetched in the immediate referrer page. This is intended to avoid\r\n```",
              "createdAt": "2019-12-13T01:10:04Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 307,
              "body": "It's more that the UA's decision of whether to fetch signed exchange subresources MUST NOT depend on whether the HTTP cache already contains the original subresource. The UA is free to avoid fetching them for other reasons.",
              "createdAt": "2019-12-13T01:11:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 317,
              "body": "```suggestion\r\ndistributor from interfering the publisher\u2019s page. (Eg. intentionally blocking or delaying...\r\n```",
              "createdAt": "2019-12-13T01:11:26Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 300,
              "body": "```suggestion\r\n- The UA checks the header integrity value, so the distributor of the subresource\r\n```",
              "createdAt": "2019-12-13T01:11:42Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 302,
              "body": "```suggestion\r\nprevents distributors from sending mismatched versions or tracking IDs to the publisher\u2019s page.\r\n```",
              "createdAt": "2019-12-13T01:11:52Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 381,
              "body": "I think the publisher's site winds up treated as a first-party origin, since it gets to be top-level after the navigation.\r\n\r\nThe behavior doesn't line neatly up under the heading of first- vs third-party, but I think we're trying to treat the distributor as a third-party, and of course cross-origin subresources are third-parties.",
              "createdAt": "2019-12-13T01:13:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Njk3MjM0",
          "commit": {
            "abbreviatedOid": "82bbcba"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you very much!",
          "createdAt": "2019-12-23T03:10:43Z",
          "updatedAt": "2019-12-23T08:23:56Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Added Note.",
              "createdAt": "2019-12-23T03:10:43Z",
              "updatedAt": "2019-12-23T08:23:56Z"
            },
            {
              "originalPosition": 59,
              "body": "Done",
              "createdAt": "2019-12-23T03:11:00Z",
              "updatedAt": "2019-12-23T08:23:56Z"
            },
            {
              "originalPosition": 61,
              "body": "Done",
              "createdAt": "2019-12-23T03:11:30Z",
              "updatedAt": "2019-12-23T08:23:56Z"
            },
            {
              "originalPosition": 79,
              "body": "Done",
              "createdAt": "2019-12-23T03:11:44Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 92,
              "body": "Done.",
              "createdAt": "2019-12-23T03:17:07Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 99,
              "body": "In the current Chromium implementation, the prefetched subresource signed exchanges can be used for any navigation from the source document.\r\nBut I think it is OK to restrict to the particular navigation.\r\n(I need to change the implementation, though.)",
              "createdAt": "2019-12-23T03:25:09Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 104,
              "body": "Done",
              "createdAt": "2019-12-23T03:28:23Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 106,
              "body": "Done.",
              "createdAt": "2019-12-23T03:28:28Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 115,
              "body": "Done",
              "createdAt": "2019-12-23T03:31:07Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 131,
              "body": "Done",
              "createdAt": "2019-12-23T03:31:26Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 150,
              "body": "Done.",
              "createdAt": "2019-12-23T03:32:02Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 154,
              "body": "Removed.",
              "createdAt": "2019-12-23T03:32:57Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 160,
              "body": "Done.",
              "createdAt": "2019-12-23T03:33:13Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 161,
              "body": "Done.",
              "createdAt": "2019-12-23T03:34:20Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 163,
              "body": "done.",
              "createdAt": "2019-12-23T03:34:43Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 170,
              "body": "Removed",
              "createdAt": "2019-12-23T07:49:48Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 219,
              "body": "Done",
              "createdAt": "2019-12-23T07:50:10Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 288,
              "body": "Done",
              "createdAt": "2019-12-23T07:50:21Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 298,
              "body": "Done.",
              "createdAt": "2019-12-23T07:50:37Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 300,
              "body": "Done",
              "createdAt": "2019-12-23T07:56:12Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 302,
              "body": "Done",
              "createdAt": "2019-12-23T07:56:55Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 307,
              "body": "Done.",
              "createdAt": "2019-12-23T07:58:36Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 317,
              "body": "Done.",
              "createdAt": "2019-12-23T07:58:56Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 381,
              "body": "Done.",
              "createdAt": "2019-12-23T08:05:49Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 81,
              "body": "Added a link to the github issue.",
              "createdAt": "2019-12-23T08:13:36Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 102,
              "body": "Done.",
              "createdAt": "2019-12-23T08:15:27Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 543,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUyMzYxNTUw",
      "title": "make certurl.CreateOCSPRequest compliant with rfc5019",
      "url": "https://github.com/WICG/webpackage/pull/543",
      "state": "MERGED",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/rfc5019#section-5 requires a OCSP client to use GET for small enough OCSP requests. Although [this is mainly for enabling HTTP caching](https://tools.ietf.org/html/rfc2560#appendix-A.1.1) and `certurl.FetchOCSPResponse` doesn't cache any response, it's worth supporting as `certurl.CreateOCSPRequest` is also exported.\r\n\r\nIn order to add a test which checks the \"POST\" side of the function, we need data of `len(\"http://<responder>/<encoded OCSP req>\") > 255`. I though like creating a dummy cert whose responder url is super long was the easiest (as I wrote in the test tentatively), I don't know where the existing `test-cert.pem` came from, which has a responder url \"http://ocsp.digicert.com\" and doesn't look like a \"dummy\". Would appreciate some guidance.",
      "createdAt": "2019-12-12T11:17:12Z",
      "updatedAt": "2019-12-16T06:45:22Z",
      "closedAt": "2019-12-16T06:45:22Z",
      "mergedAt": "2019-12-16T06:45:22Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-12-13T07:21:21Z",
          "updatedAt": "2019-12-13T07:21:21Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Would you add `test-cert-long.pem` and unskip the new test?",
          "createdAt": "2019-12-16T02:06:24Z",
          "updatedAt": "2019-12-16T02:06:24Z"
        },
        {
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was going to wait for response from @hajimehoshi , but anyway I added one and started to count that test. I believe this PR is now ready to merge, except for few points I forgot to mention:\r\n\r\n- I only added test-cert-long.pem to align with existing test-cert.pem although there were several intermediate products.\r\n- I made command-line preferGET flag default to false for backwards compatibility and as there's no strong reason to use GET if we don't cache the response.\r\n\r\nDo they look good to you?",
          "createdAt": "2019-12-16T06:24:54Z",
          "updatedAt": "2019-12-16T06:24:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNzAwOTk1",
          "commit": {
            "abbreviatedOid": "23ecc92"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Using a dummy cert sgtm.\r\n(The existing `test-cert.pem` was originally added in https://github.com/WICG/webpackage/commit/0d992f8b4db6223e9e343974d230a032de0272b6. @hajimehoshi do you remember where it came from?)\r\n\r\nPlease record the command line used to generate the cert, in a comment.\r\n",
          "createdAt": "2019-12-13T07:27:29Z",
          "updatedAt": "2019-12-13T07:48:01Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Per https://tools.ietf.org/html/rfc2560#appendix-A.1.1, `getUrl` should be constructed as follows:\r\n```\r\n{url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest}\r\n```\r\n`ocspUrl.Parse(...)` may produce different result, for example if `ocspUrl` is `http://example.com/ocsp`.",
              "createdAt": "2019-12-13T07:27:30Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            },
            {
              "originalPosition": 16,
              "body": "Samll -> Small",
              "createdAt": "2019-12-13T07:31:54Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNzYzOTk3",
          "commit": {
            "abbreviatedOid": "be7ca28"
          },
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-13T09:52:54Z",
          "updatedAt": "2019-12-13T09:52:54Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Thanks, fixed it.",
              "createdAt": "2019-12-13T09:52:54Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNzY0MDk3",
          "commit": {
            "abbreviatedOid": "be7ca28"
          },
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-13T09:53:05Z",
          "updatedAt": "2019-12-13T09:53:05Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Done.",
              "createdAt": "2019-12-13T09:53:05Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzEwMTk4",
          "commit": {
            "abbreviatedOid": "be7ca28"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-16T01:57:01Z",
          "updatedAt": "2019-12-16T02:06:38Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm not sure if we should collapse double slashes.\r\n\r\nFYI Chromium uses simple string concatenation:\r\nhttps://cs.chromium.org/chromium/src/net/cert/internal/ocsp.cc?l=1041&rcl=5aabd083f5e0f99abce0a06a8aab4c18e5bb13df\r\n",
              "createdAt": "2019-12-16T01:57:01Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzU2NzAx",
          "commit": {
            "abbreviatedOid": "17055c8"
          },
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-16T06:16:22Z",
          "updatedAt": "2019-12-16T06:16:22Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Then I'd make it align with Chromium, thanks!",
              "createdAt": "2019-12-16T06:16:22Z",
              "updatedAt": "2019-12-16T06:16:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzYzNzc1",
          "commit": {
            "abbreviatedOid": "17055c8"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "All lgtm :)\r\nThank you for your contribution!",
          "createdAt": "2019-12-16T06:44:20Z",
          "updatedAt": "2019-12-16T06:44:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 545,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUyNzEzNjA5",
      "title": "Fix typo",
      "url": "https://github.com/WICG/webpackage/pull/545",
      "state": "MERGED",
      "author": "gaul",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-12-13T04:13:43Z",
      "updatedAt": "2019-12-16T07:52:47Z",
      "closedAt": "2019-12-16T06:32:28Z",
      "mergedAt": "2019-12-16T06:32:28Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-12-16T06:31:35Z",
          "updatedAt": "2019-12-16T06:31:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzYwNjE4",
          "commit": {
            "abbreviatedOid": "3311358"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-12-16T06:32:01Z",
          "updatedAt": "2019-12-16T06:32:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 546,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzNDMwMDUy",
      "title": "go: Fix test names in sct_test.go",
      "url": "https://github.com/WICG/webpackage/pull/546",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks @kumagi for noticing this.",
      "createdAt": "2019-12-16T08:11:15Z",
      "updatedAt": "2019-12-16T09:53:26Z",
      "closedAt": "2019-12-16T09:53:25Z",
      "mergedAt": "2019-12-16T09:53:25Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "nit: I'd suggest `t.Fatalf` rather than `t.Errorf` and then `return`",
          "createdAt": "2019-12-16T08:14:21Z",
          "updatedAt": "2019-12-16T08:14:21Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "> nit: I'd suggest `t.Fatalf` rather than `t.Errorf` and then `return`\r\n\r\nDone.",
          "createdAt": "2019-12-16T08:18:24Z",
          "updatedAt": "2019-12-16T08:18:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyNDI4NzU0",
          "commit": {
            "abbreviatedOid": "c1ca7a1"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-16T09:23:10Z",
          "updatedAt": "2019-12-16T09:23:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 547,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU0NDY2NTg2",
      "title": "js/bundle: Add command line tool",
      "url": "https://github.com/WICG/webpackage/pull/547",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds `gen-webbundle` CLI tool to the `wbn` package, which enables JS developers to build a web bundle from a local directory, without having to install the Go tools.\r\n\r\nInternally it uses `addFilesRecursively`, a new high-level method of `BundleBuilder`.",
      "createdAt": "2019-12-18T07:18:44Z",
      "updatedAt": "2019-12-19T03:40:42Z",
      "closedAt": "2019-12-19T03:40:41Z",
      "mergedAt": "2019-12-19T03:40:41Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@sisidovski Thank you for the review!\r\n@kinu Would you approve this PR?",
          "createdAt": "2019-12-18T10:24:54Z",
          "updatedAt": "2019-12-18T10:24:54Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Tweaked a bit: changed the argument order of `addFiles(Recursively)` to take URL as first argument, for consistency with `addExchange()`.",
          "createdAt": "2019-12-19T03:34:16Z",
          "updatedAt": "2019-12-19T03:34:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzODI5Mzg3",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Put one question, but overall looks good.",
          "createdAt": "2019-12-18T09:22:14Z",
          "updatedAt": "2019-12-18T09:24:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "My understanding might be wrong though, if there is a file located at `/foo/bar/baz/index.html`, this code looks redirecting to `baseURL/index.html`. Is that a correct behavior?",
              "createdAt": "2019-12-18T09:22:14Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzODMzNzIx",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T09:29:23Z",
          "updatedAt": "2019-12-18T09:29:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "IMO: Just using package name (wbn) as a command name does more make sense for me. Why do you make this name?",
              "createdAt": "2019-12-18T09:29:23Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzODM3NjAx",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T09:35:43Z",
          "updatedAt": "2019-12-18T09:43:18Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Note that the recursive call at line 88 updates `baseURL` adding the directory name.\r\n\r\nHere, `baseURL`'s value should be `<user-specified-baseURL>/foo/bar/baz/`, so this exchange would redirect `<user-specified-baseURL>/foo/bar/baz/index.html` to `<user-specified-baseURL>/foo/bar/baz/`.",
              "createdAt": "2019-12-18T09:35:43Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzODUxNjYz",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T09:57:33Z",
          "updatedAt": "2019-12-18T09:58:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yeah, that makes sense to me. Renamed the command.\r\n\r\nWe may add other CLI features in the future (such as `dump-bundle` equivalent), but then we could switch to the subcommand style (e.g. `wbn gen ...` / `wbn dump ...`).\r\n",
              "createdAt": "2019-12-18T09:57:34Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0MDc4MTcy",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T15:59:41Z",
          "updatedAt": "2019-12-18T15:59:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Ah! I was missing it! Thank you for the comment!",
              "createdAt": "2019-12-18T15:59:41Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0Mzg1MDM1",
          "commit": {
            "abbreviatedOid": "bf91878"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-12-19T02:59:59Z",
          "updatedAt": "2019-12-19T02:59:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 548,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU0OTM3OTY3",
      "title": "js/bundle: Allow method chaining in bundle builder",
      "url": "https://github.com/WICG/webpackage/pull/548",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes BundleBuilder methods return the builder itself, so that callers can chain method calls, like this:\r\n```javascript\r\n  const bundle = (new BundleBuilder(primaryURL))\r\n    .setManifestURL(...)\r\n    .addExchange(...)\r\n    .addExchange(...)\r\n    .createBundle();\r\n```\r\nThis is a common idiom of Builder classes.",
      "createdAt": "2019-12-19T04:25:14Z",
      "updatedAt": "2019-12-20T06:18:59Z",
      "closedAt": "2019-12-20T06:18:58Z",
      "mergedAt": "2019-12-20T06:18:58Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu ptl",
          "createdAt": "2019-12-20T05:20:56Z",
          "updatedAt": "2019-12-20T05:20:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0NDA2Njk0",
          "commit": {
            "abbreviatedOid": "a4b6321"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-12-19T04:46:35Z",
          "updatedAt": "2019-12-19T04:46:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1MDgzMjMx",
          "commit": {
            "abbreviatedOid": "a4b6321"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-12-20T06:14:49Z",
          "updatedAt": "2019-12-20T06:14:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 549,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1NTM0OTgz",
      "title": "js/bundle: Bump version to 0.0.4",
      "url": "https://github.com/WICG/webpackage/pull/549",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kinu ptl",
      "createdAt": "2019-12-20T05:21:13Z",
      "updatedAt": "2019-12-20T06:19:46Z",
      "closedAt": "2019-12-20T06:19:45Z",
      "mergedAt": "2019-12-20T06:19:45Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1MDgzMzQw",
          "commit": {
            "abbreviatedOid": "9caadce"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-20T06:15:20Z",
          "updatedAt": "2019-12-20T06:15:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 552,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMDkyODc0",
      "title": "Update the unsigned-bundle explainer",
      "url": "https://github.com/WICG/webpackage/pull/552",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "To prepare for TAG and Mozilla review.",
      "createdAt": "2020-02-04T22:59:11Z",
      "updatedAt": "2020-02-18T08:01:10Z",
      "closedAt": "2020-02-07T21:54:48Z",
      "mergedAt": "2020-02-07T21:54:48Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDc0MzM1",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T05:31:14Z",
          "updatedAt": "2020-02-05T05:31:14Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I'm slightly worried if this may sound like it excludes any types of signatures, e.g. raw-key signed bundles or app-level signatures... while some use cases would need that.  Could \"without origin signatures\" work?\r\n(While, I agree that limiting the focus would be useful/necessary here)",
              "createdAt": "2020-02-05T05:31:14Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg0MTA2",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:08:57Z",
          "updatedAt": "2020-02-05T06:08:58Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Oh so are we considering literally reusing the Service-Worker-Allowed header here?  It feels weird to me as they are different spec for different features (while I agreed that it could work in the similar way to how SW scope works).",
              "createdAt": "2020-02-05T06:08:57Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg1NDUx",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:13:43Z",
          "updatedAt": "2020-02-05T06:13:43Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Here this sounds like it's excluding navigations while the text below mentions navigations too",
              "createdAt": "2020-02-05T06:13:43Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDEzOTY0",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T01:20:46Z",
          "updatedAt": "2020-02-05T06:14:35Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Does this mean the browser must parse manifest (if any) before making redirect to the primary URL?",
              "createdAt": "2020-02-05T01:20:46Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 139,
              "body": "Unfinished sentence",
              "createdAt": "2020-02-05T01:29:08Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg2MDg4",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:15:54Z",
          "updatedAt": "2020-02-05T06:15:55Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "\"It's not clear\" -> \"It'll need more discussion\" ?",
              "createdAt": "2020-02-05T06:15:54Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg3NzUw",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:21:35Z",
          "updatedAt": "2020-02-05T06:21:35Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "So here do we suppose we'll have some flag inside the format to say trusted vs untrusted?  Should we explicitly mention that the resulting 'trusted' flag set inside the browser may be different from the claimed one, e.g. if unsigned bundle says it wants to be trusted but it's served from different origins?  Or, should the flag only be able to say that it should be treated as 'untrusted' (i.e. downgrading only) even if an unsigned bundle is served from the same origin?",
              "createdAt": "2020-02-05T06:21:35Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDkyNjg1",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:38:42Z",
          "updatedAt": "2020-02-05T06:38:43Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "Could we also mention content negotiation, or ability to have multiple resources for single location?\r\nhttps://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-essential-2\r\n\r\nAlso maybe virtue of being a binary format (no need to worry about line ending fixups), being able to satisfy subsetting/reordering needs etc etc?",
              "createdAt": "2020-02-05T06:38:42Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDk0NjU4",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:45:17Z",
          "updatedAt": "2020-02-05T06:45:17Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Could we start with the basic shortcomings stem from the format (e.g. content negotiation etc) before talking about a specific wontfix'ed issue?",
              "createdAt": "2020-02-05T06:45:17Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDk1NzI0",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:48:40Z",
          "updatedAt": "2020-02-05T06:48:41Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "nit: problems -> shortcomings for the usage described in this explainer ...or something?  (For some particular use cases there can be reasons to prefer them to WBN, I suppose)",
              "createdAt": "2020-02-05T06:48:40Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDk2MjUw",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks! Some comments...",
          "createdAt": "2020-02-05T06:50:24Z",
          "updatedAt": "2020-02-05T06:50:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MTI1NzM1",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T00:03:33Z",
          "updatedAt": "2020-02-06T18:14:37Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I think we should consider it: we need a header that says that \"something served under this path can have an effect outside that path\", and that's what `Service-Worker-Allowed` does. The name isn't perfect, so it don't hate the idea of using something else. The TAG might have a preference.",
              "createdAt": "2020-02-06T00:03:33Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 104,
              "body": "It would, although that's probably fast compared to receiving the bytes for either the manifest or the main resource. Do you think we should just drop this part? I can see an argument that the manifest `scope` key in particular is meant to control how an app captures navigations, and it doesn't make sense to have it limit what a bundle that contains the app can also hold.",
              "createdAt": "2020-02-06T00:12:34Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 48,
              "body": "Yep, switched to \"without origin-trusted signatures\", thanks. I've also added a section in open design questions to talk about what we might use such signatures for.",
              "createdAt": "2020-02-06T00:24:28Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 85,
              "body": "I think we should make sure that the browser actually uses the value of the 'trusted' flag in the bundle. So, a 'trusted' bundle downloaded from a different origin would result in a redirect rather than a use of the bundle (maybe with UI to let the user explicitly change the flag in the bundle they downloaded), and an 'untrusted' same-origin bundle would get the `package:` URL scheme and be treated as cross-origin from the origin that served it. That's a way for a site to create a kind of [suborigin](https://w3c.github.io/webappsec-suborigins/). I've added a paragraph mentioning this. (FYI @mikewest @metromoxie @devd)",
              "createdAt": "2020-02-06T00:38:02Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 132,
              "body": "Fixed, thanks.",
              "createdAt": "2020-02-06T00:42:10Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 139,
              "body": "Oops, finished.",
              "createdAt": "2020-02-06T00:42:42Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 143,
              "body": "Done, thanks.",
              "createdAt": "2020-02-06T00:43:05Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 229,
              "body": "Yeah, especially WARC.",
              "createdAt": "2020-02-06T00:52:13Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 245,
              "body": "Mentioned.",
              "createdAt": "2020-02-06T01:00:17Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 252,
              "body": "I've added content negotiation to the list, but the bigger problem is the lack of documentation. It's hard to tell even what capabilities the format has.",
              "createdAt": "2020-02-06T18:07:54Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTIwNzk1",
          "commit": {
            "abbreviatedOid": "42c4add"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T04:04:11Z",
          "updatedAt": "2020-02-07T04:04:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Treating it like a suborigin for same-origin untrusted bundle makes sense to me. I'm not so sure about the redirect for 'trusted' but cross-origin bundle, but no strong opinion on that one for now. (Quick cross-checking appreciated for potential subresource loading cases @horo-t @irori @hayatoito)",
              "createdAt": "2020-02-07T04:04:11Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTQ0MDYw",
          "commit": {
            "abbreviatedOid": "42c4add"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T05:56:39Z",
          "updatedAt": "2020-02-07T05:56:40Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I'm agreeing that we need something. Okay, maybe we can start with this and see what people say...",
              "createdAt": "2020-02-07T05:56:40Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTYyNTAx",
          "commit": {
            "abbreviatedOid": "42c4add"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T07:04:47Z",
          "updatedAt": "2020-02-07T07:04:47Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I'm feeling inclined to drop this. PWAs having subresources out of its manifest's navigation scope is legitimate, but cannot be bundled as-is under this rule.\r\n\r\nProbably the overhead of (waiting for the bytes + parsing) manifest is small, but since the internal redirect to the primary URL is on the critical path of bundle navigation I would like to keep it as fast as possible.",
              "createdAt": "2020-02-07T07:04:47Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1Mzc1MTU1",
          "commit": {
            "abbreviatedOid": "42c4add"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I'm going to merge this, but feel free to keep commenting.",
          "createdAt": "2020-02-07T19:11:07Z",
          "updatedAt": "2020-02-07T21:47:58Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Done, thanks.",
              "createdAt": "2020-02-07T19:11:07Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 85,
              "body": "My thinking about 'trusted'-but-cross-origin comes from using the same flag for signed-but-expired packages. We've talked about a need for non-publishers to be able to pick between having a signed-but-expired package redirect vs act-as-unsigned, and the 'trusted' flag seems appropriate for that, and cross-origin is a similar \"can't verify the trust\" situation.",
              "createdAt": "2020-02-07T21:47:09Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MjAxNTQz",
          "commit": {
            "abbreviatedOid": "93829ff"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-12T05:46:55Z",
          "updatedAt": "2020-02-12T05:46:56Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Re: potential subresource loading cases\r\n\r\nFor subresource loading cases like [this demo](https://docs.google.com/document/d/18fFrURT6xD1GnqJwCx2K3Z81Te9Iv-r2ZsCkOvDH_04/edit#), I don't think we need this 'trusted' flag in the bundle. And also we don\u2019t need primaryUrl/fallbackUrl for subresource web bundle. So we may need to make primaryUrl/fallbackUrl optional.",
              "createdAt": "2020-02-12T05:46:55Z",
              "updatedAt": "2020-02-12T05:46:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTMwMjM1",
          "commit": {
            "abbreviatedOid": "93829ff"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T08:01:09Z",
          "updatedAt": "2020-02-18T08:01:10Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Thanks. It'd be nice if the format can just accommodate both while loading spec part can differ on how to interpret these flags.  While... for navigation case we're probably good to start with this text.",
              "createdAt": "2020-02-18T08:01:09Z",
              "updatedAt": "2020-02-18T08:01:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 553,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMDkyODc1",
      "title": "Update the unsigned-bundle explainer",
      "url": "https://github.com/WICG/webpackage/pull/553",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "To prepare for TAG and Mozilla review.",
      "createdAt": "2020-02-04T22:59:11Z",
      "updatedAt": "2020-02-04T23:04:50Z",
      "closedAt": "2020-02-04T23:04:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Duplicate issue.",
          "createdAt": "2020-02-04T23:04:36Z",
          "updatedAt": "2020-02-04T23:04:36Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 554,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxNjc2OTQw",
      "title": "dump-bundle: Treat JavaScript resources as text",
      "url": "https://github.com/WICG/webpackage/pull/554",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "So that dump-bundle will print response body by default.",
      "createdAt": "2020-02-06T02:26:35Z",
      "updatedAt": "2020-02-06T06:57:12Z",
      "closedAt": "2020-02-06T06:57:04Z",
      "mergedAt": "2020-02-06T06:57:04Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjE1NDcw",
          "commit": {
            "abbreviatedOid": "c147eff"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T05:58:55Z",
          "updatedAt": "2020-02-06T05:59:01Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "`HasPrefix` for `application/javascript` seems a little odd. I think this can be `application/foobar+javascript`.",
              "createdAt": "2020-02-06T05:58:56Z",
              "updatedAt": "2020-02-06T06:49:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjIxODE3",
          "commit": {
            "abbreviatedOid": "c147eff"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T06:21:56Z",
          "updatedAt": "2020-02-06T06:21:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The intention here is that this function should return true for all of the followings:\r\n\r\n- `text/*`\r\n- `application/javascript`\r\n- `application/javascript; charset=utf-8` (this seems not very rare today)\r\n\r\nIt seems there's no registered media type of the form `application/foobar+javascript`.\r\nhttps://www.iana.org/assignments/media-types/media-types.xhtml\r\n\r\n(There're many `*/*+xml` and `*/*+json` types, but this patch is not trying to interpret those.)\r\n",
              "createdAt": "2020-02-06T06:21:56Z",
              "updatedAt": "2020-02-06T06:49:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjI1MTA3",
          "commit": {
            "abbreviatedOid": "c147eff"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T06:33:29Z",
          "updatedAt": "2020-02-06T06:33:30Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Oh I see. How about using `mime` package?\r\n\r\nhttps://play.golang.org/p/gLepcpuj_4a",
              "createdAt": "2020-02-06T06:33:29Z",
              "updatedAt": "2020-02-06T06:49:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjMwMzc1",
          "commit": {
            "abbreviatedOid": "b5cc663"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T06:50:36Z",
          "updatedAt": "2020-02-06T06:50:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Done.",
              "createdAt": "2020-02-06T06:50:36Z",
              "updatedAt": "2020-02-06T06:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjMwNDY5",
          "commit": {
            "abbreviatedOid": "b5cc663"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-02-06T06:50:59Z",
          "updatedAt": "2020-02-06T06:50:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 557,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTQ3NTY3",
      "title": "Add non-browser feedback about unsigned bundles.",
      "url": "https://github.com/WICG/webpackage/pull/557",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@dauwhe, am I representing your position well here? Is there a better description of your opinion on how we make browsers navigate to unsigned books?",
      "createdAt": "2020-02-14T00:01:14Z",
      "updatedAt": "2020-04-08T22:27:54Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Would this be the right section to add use cases such as the ones that Dan York had in mind, e.g. making documentation for internet infra grant available for offline consumption (see https://www.internetsociety.org/grants/chapterthon/2019/)?",
          "createdAt": "2020-04-06T23:59:13Z",
          "updatedAt": "2020-04-06T23:59:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@KenjiBaheux It would, but I would appreciate if you or @danyork could suggest some text.",
          "createdAt": "2020-04-08T22:27:54Z",
          "updatedAt": "2020-04-08T22:27:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 558,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc2OTExNDQ0",
      "title": "Security/privacy questionnaire for unsigned bundles",
      "url": "https://github.com/WICG/webpackage/pull/558",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I haven't double-checked all the answers, and this needs some more links. I'll go over it again tomorrow.",
      "createdAt": "2020-02-19T01:00:38Z",
      "updatedAt": "2020-02-21T21:38:27Z",
      "closedAt": "2020-02-21T06:03:38Z",
      "mergedAt": "2020-02-21T06:03:38Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Still lgtm.",
          "createdAt": "2020-02-21T06:03:29Z",
          "updatedAt": "2020-02-21T06:03:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODEwNDY5",
          "commit": {
            "abbreviatedOid": "e69e5dd"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T02:45:12Z",
          "updatedAt": "2020-02-19T02:45:13Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\n[section](#network-access) in the explainer about how network requests from untrusted bundles\r\n```",
              "createdAt": "2020-02-19T02:45:13Z",
              "updatedAt": "2020-02-20T03:58:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODEwOTgw",
          "commit": {
            "abbreviatedOid": "e69e5dd"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T02:47:04Z",
          "updatedAt": "2020-02-19T02:47:05Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "```suggestion\r\nif `Service-Worker-Allowed` response header is given the default scope can be also extended```\r\n\r\nThe original text was probably a bit garbled.. (feel free to modify further)",
              "createdAt": "2020-02-19T02:47:04Z",
              "updatedAt": "2020-02-20T03:58:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODExMDM2",
          "commit": {
            "abbreviatedOid": "e69e5dd"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-19T02:47:17Z",
          "updatedAt": "2020-02-19T02:47:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwOTQwNDQx",
          "commit": {
            "abbreviatedOid": "e69e5dd"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with nits",
          "createdAt": "2020-02-19T09:07:05Z",
          "updatedAt": "2020-02-19T09:13:29Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nBundle will be loaded within its unique origin with [package: scheme](#urls-for-bundle-components), which is\r\n```",
              "createdAt": "2020-02-19T09:07:06Z",
              "updatedAt": "2020-02-20T03:58:52Z"
            },
            {
              "originalPosition": 129,
              "body": "```suggestion\r\nSee the [security considerations](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#security)\r\nin the format spec, [security and privacy considerations](#security-and-privacy-considerations)\r\nin the explainer, and [open design questions](#open-design-questions) in the\r\nexplainer.\r\n```",
              "createdAt": "2020-02-19T09:12:26Z",
              "updatedAt": "2020-02-20T03:58:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDkxMjA5",
          "commit": {
            "abbreviatedOid": "7a82316"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Sorry for losing a bunch of your links when I copied this to Markdown. I've now rewritten several of the answers in https://github.com/WICG/webpackage/pull/558/commits/7a82316c5d09f32fe774b6ee56161bc4bd6ae04c. PTAL.",
          "createdAt": "2020-02-19T22:38:09Z",
          "updatedAt": "2020-02-19T22:38:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 559,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4NDg2NjU2",
      "title": "Fix #556: describe the origin-computation algorithm better.",
      "url": "https://github.com/WICG/webpackage/pull/559",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I believe that with the encoding suggested here, we can just add \"package\" to the list at https://url.spec.whatwg.org/#concept-url-origin that includes \"https\", and that'll make the origin algorithm work for the new scheme. @annevk pointed out that my explanation was too brief; does this do a better job, or is there some other wording that would express it better?",
      "createdAt": "2020-02-21T21:47:03Z",
      "updatedAt": "2020-04-07T00:12:42Z",
      "closedAt": "2020-04-07T00:12:40Z",
      "mergedAt": "2020-04-07T00:12:40Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Seems fine. Is there a normative description available too somewhere?",
          "createdAt": "2020-02-24T08:47:43Z",
          "updatedAt": "2020-02-24T08:47:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "There's no specification yet.",
          "createdAt": "2020-02-24T22:31:45Z",
          "updatedAt": "2020-02-24T22:31:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Njk4MDg3",
          "commit": {
            "abbreviatedOid": "744e1b2"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\nSorry for the delay.",
          "createdAt": "2020-04-06T23:58:50Z",
          "updatedAt": "2020-04-06T23:58:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 560,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwNTcyNzA2",
      "title": "Sketch how package: URLs should be rendered.",
      "url": "https://github.com/WICG/webpackage/pull/560",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@annevk requested more information on how `package:` URLs should be rendered, so here's a sketch.\r\n\r\nI haven't yet run this by @estark37 and her team. Emily, does this look like a reasonable start? Are you running away in horror? Do y'all have any better ideas?",
      "createdAt": "2020-02-27T00:18:12Z",
      "updatedAt": "2020-04-06T23:48:52Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Doesn't that mean that as far as the user is concerned the authority is with the publisher? (I.e., same as with HTTP URLs today.) And if that's the case, what warrants all the complexity again?",
          "createdAt": "2020-03-02T10:17:11Z",
          "updatedAt": "2020-03-02T10:17:11Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "I'd like to see if we can avoid exposing `package:` URLs in browser UI all together. They look terrifying :) Are there strong use cases for editing them directly? Could we say that either the MVP does not involve editing `package:` URLs _or_ the MVP must involve some sort of custom UI for selecting resources within the package?\r\n\r\nShowing the publisher hostname seems technically correct, but also could potentially lead to a proliferation of \"double address bars\" like we saw with AMP documents; the publisher and/or distributor thinks that it will be confusing to have the distributor hostname showing in the omnibox, so they add a second address bar in the web content showing the publisher hostname -- leading to confusion and sadness. I'm still getting my head around the use cases for unsigned/untrusted bundles so I'm not sure if this seems likely to be a big problem or if I can come up with a better suggestion. Is it likely that the distributor hostname will be meaningless to humans, like a generic CDN domain? Or do you expect distributor hostnames to usually be pretty meaningful, like `offline-ebooks.com` or something?\r\n\r\nA minor note is that the currently proposed v1 solution (show the publisher hostname, reveal the full URL on click) might be a significant implementation investment. Even just eliding `www` subdomain labels was a large implementation effort (as I understand it) because of edge cases with the cursor jumping around when you select, dealing with different ways to focus the omnibox, etc. So it could turn out that implementing custom UI for `package:` URLs is a simpler v1 approach anyway.",
          "createdAt": "2020-03-02T19:21:43Z",
          "updatedAt": "2020-03-02T19:21:43Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, maybe the modified proposal could be: show the distributor's URL in omnibox (ideally  making it non-editable), but internally use package: URL.  @estark37 let us know if you have further comments on this idea. Thanks!",
          "createdAt": "2020-04-06T23:48:52Z",
          "updatedAt": "2020-04-06T23:48:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 561,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNzAxMjI0",
      "title": "go: Simplify SXG cert's validity period check",
      "url": "https://github.com/WICG/webpackage/pull/561",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since it has already passwed 2019-08-01, all SXG certs must\r\nhave <=90 days validity.",
      "createdAt": "2020-03-03T01:51:40Z",
      "updatedAt": "2020-03-03T03:05:47Z",
      "closedAt": "2020-03-03T03:05:31Z",
      "mergedAt": "2020-03-03T03:05:31Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjY4NDUy",
          "commit": {
            "abbreviatedOid": "f946cd8"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-03-03T02:39:32Z",
          "updatedAt": "2020-03-03T02:39:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 563,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3MDMyNDk2",
      "title": "gen-bundle: Skip duplicated URLs in URL list",
      "url": "https://github.com/WICG/webpackage/pull/563",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is similar to #481, but for `gen-bundle -URLList`.",
      "createdAt": "2020-03-12T04:24:09Z",
      "updatedAt": "2020-03-12T05:06:18Z",
      "closedAt": "2020-03-12T05:05:41Z",
      "mergedAt": "2020-03-12T05:05:41Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMjgwMjE5",
          "commit": {
            "abbreviatedOid": "7174e85"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-03-12T05:03:29Z",
          "updatedAt": "2020-03-12T05:03:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 565,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyMzcyNzA0",
      "title": "Add an explainer for subresource loading (#526)",
      "url": "https://github.com/WICG/webpackage/pull/565",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add an explainer for subresource loading (#526).\r\n\r\ncc: @jyasskin, @kinu, @irori, @horo-t",
      "createdAt": "2020-03-23T13:05:04Z",
      "updatedAt": "2020-04-14T12:28:42Z",
      "closedAt": "2020-04-14T12:28:41Z",
      "mergedAt": "2020-04-14T12:28:41Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It looks ipr check said:\r\n\r\n> hayatoito is unknown, they need to link their Github account with a W3C account.\r\n\r\nOkay, I've just linked my GitHub acccount, @hayatoito, with W3C account (hito).  I guess this is sufficient to pass checks, hopefully.\r\n",
          "createdAt": "2020-03-23T13:15:14Z",
          "updatedAt": "2020-03-23T13:15:14Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding https://labs.w3.org/repo-manager/pr/id/WICG/webpackage/565,\r\n\r\n> hayatoito should join the Web Platform Incubator Community Group .\r\n\r\nI've also sent a request to join WICG. \r\n",
          "createdAt": "2020-03-24T00:31:04Z",
          "updatedAt": "2020-03-24T00:31:04Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+cc: @yoavweiss",
          "createdAt": "2020-03-24T03:31:34Z",
          "updatedAt": "2020-03-24T03:31:34Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+cc: @hiroshige-g",
          "createdAt": "2020-03-24T03:41:04Z",
          "updatedAt": "2020-03-24T03:41:04Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess we prefer squash merge in this repository. So I will squash the commits before merging, anyway.",
          "createdAt": "2020-03-25T05:44:07Z",
          "updatedAt": "2020-03-25T05:44:07Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've squashed the commits.",
          "createdAt": "2020-03-26T05:09:06Z",
          "updatedAt": "2020-03-26T05:09:06Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin Could you review this PR? It would be great if you could take a look.\r\n\r\nFor reviewers, please feel free to merge this. I think we can update the explainer with more details anytime later.",
          "createdAt": "2020-04-01T03:20:35Z",
          "updatedAt": "2020-04-01T03:20:35Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've squashed the commits.\r\nReviewers, please feel free to merge the PR if you think it's ready.\r\n",
          "createdAt": "2020-04-09T03:16:32Z",
          "updatedAt": "2020-04-09T03:16:32Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "There are other ongoing discussions but I'm going to merge this (so that more discussion can be built on top of it)",
          "createdAt": "2020-04-14T12:28:32Z",
          "updatedAt": "2020-04-14T12:28:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDU4NzQ1",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-03-24T16:02:18Z",
          "updatedAt": "2020-03-24T16:02:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODA1Mzcy",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T01:30:40Z",
          "updatedAt": "2020-03-25T01:43:40Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I don't think they need to be the same-origin, and actually the example URLs are not the same-origin.\r\nWhen I wrote [this example](https://docs.google.com/document/d/18fFrURT6xD1GnqJwCx2K3Z81Te9Iv-r2ZsCkOvDH_04/edit#heading=h.irqypigubog7), my idea was:\r\n  - If the page is controlled by a service worker, the service worker can intercept any requests from the page and can respond with arbitrary resources.\r\n  - So, it is safe (=no difference from service worker from the security point of view) even if they are not the same origin, when the page can access the web bundle in the CORS manner.\r\n",
              "createdAt": "2020-03-25T01:30:40Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODEyMTMy",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T01:54:44Z",
          "updatedAt": "2020-03-25T02:31:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\na format that allows multiple resources can be bundled, e.g.\r\n```",
              "createdAt": "2020-03-25T01:54:44Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 20,
              "body": "I think this is not true for parsing.\r\n\r\nChrome is already doing streaming parsing / compiling for classic scripts (probably scaling it to more than one processor is hard, though), and for module scripts each module is parsed / compiled as soon as it is downloaded, without waiting for the entire module tree.",
              "createdAt": "2020-03-25T02:09:11Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nresources to a particular bundled resource. Something like [Fetch maps proposal](https://discourse.wicg.io/t/proposal-fetch-maps/4259)\r\n```",
              "createdAt": "2020-03-25T02:24:30Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 97,
              "body": "Could you expand this a bit? I'm not sure how this enables resource subsetting.",
              "createdAt": "2020-03-25T02:30:32Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMxNTE4",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:05:07Z",
          "updatedAt": "2020-03-25T03:05:07Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Thanks.\r\n@kinu, what do you think? I'm afraid that I misunderstood your suggestions.\r\n\r\nI'm wondering what the explainer should mention here. We have 3 URLs:\r\n\r\n1. The main document's URL\r\n2. href\r\n3. scope\r\n\r\nI thought 2 and 3 need to be the same origin, however, it is okay that 1 is in a different origin.\r\nIt's a simple mistake I forgot to update example URLs.\r\n\r\nAny suggestions? If we don't have a clear answer, I think it is okay to mention it as TBD.",
              "createdAt": "2020-03-25T03:05:07Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMyNTQy",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:08:51Z",
          "updatedAt": "2020-03-25T03:08:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ah, thanks! This is typo. \"allows multiple resources *to* be bundled\" might be better, I think.\r\nI'll fix that.",
              "createdAt": "2020-03-25T03:08:52Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMzMTM0",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:10:57Z",
          "updatedAt": "2020-03-25T03:10:58Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Thanks! Let me add a link.",
              "createdAt": "2020-03-25T03:10:58Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMzMjAz",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:11:12Z",
          "updatedAt": "2020-03-25T03:11:13Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Yeah I suggested this but I remember I discussed that cross-origin seems okay too with you. I want to think through all the implications... for example it apparently complicates CSP story. But I agree that maybe we can just drop this for now.",
              "createdAt": "2020-03-25T03:11:12Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMzMzUz",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:11:48Z",
          "updatedAt": "2020-03-25T03:11:49Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "@kinu \r\nDo you have any opinions? I guess we don't have a concrete idea yet.",
              "createdAt": "2020-03-25T03:11:48Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMzNjcw",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:12:55Z",
          "updatedAt": "2020-03-25T03:12:56Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Would just dropping 'parsing and' make sense?",
              "createdAt": "2020-03-25T03:12:55Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODQyMjQ5",
          "commit": {
            "abbreviatedOid": "71d9e93"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:46:24Z",
          "updatedAt": "2020-03-25T03:46:24Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "(^^I commented before I see Hayato's response) @hayatoito I was indeed thinking about 2 and 3 indeed, but thinking about this more it's a little unclear too. (As @horo-t mentioned SW could already override it)  I think I'm fine with just dropping this sentence.",
              "createdAt": "2020-03-25T03:46:24Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODQ3MDk1",
          "commit": {
            "abbreviatedOid": "71d9e93"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T04:07:03Z",
          "updatedAt": "2020-03-25T04:07:03Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Thanks! Okay, let's just drop this for now.\r\nOnce we have a more clear idea, let's add something back.",
              "createdAt": "2020-03-25T04:07:03Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODQ4NjQw",
          "commit": {
            "abbreviatedOid": "649c4c3"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T04:13:43Z",
          "updatedAt": "2020-03-25T04:13:44Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Thanks. Let's drop the \"parsing and\".",
              "createdAt": "2020-03-25T04:13:44Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNjk3MDk0",
          "commit": {
            "abbreviatedOid": "649c4c3"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T04:36:17Z",
          "updatedAt": "2020-03-26T04:36:18Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Can we address this in a follow-up commit? We can adress that later, I think.",
              "createdAt": "2020-03-26T04:36:17Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNzAyMTYz",
          "commit": {
            "abbreviatedOid": "649c4c3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T04:55:33Z",
          "updatedAt": "2020-03-26T04:55:33Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "sgtm.",
              "createdAt": "2020-03-26T04:55:33Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNzYxMTIz",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T07:43:18Z",
          "updatedAt": "2020-03-26T07:43:19Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Yeah... I think I was thinking *something* like: Server can maintain versioned bundles, and client can send a request with some URL parameters that indicates the version of the bundle they already have in cache (so that the server can identify the updated resources and send them back).  This is mostly about updating-fetch for same bundle cases though, and haven't really thought about how to do for similarly looking bundle on different pages cases.",
              "createdAt": "2020-03-26T07:43:18Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MjQwMDA5",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-01T03:17:50Z",
          "updatedAt": "2020-04-01T03:17:51Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "@kinu Thanks! I appreciate that! That's helpful. I think we can update the explainer with the more details once we can explore this area. Let me close this as resolved for now.",
              "createdAt": "2020-04-01T03:17:50Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MzY5MjQx",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Given that we can do more iterations on top of it this LGTM",
          "createdAt": "2020-04-01T08:30:18Z",
          "updatedAt": "2020-04-01T08:30:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1NjQxMzEz",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "jkrems",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-01T14:29:17Z",
          "updatedAt": "2020-04-01T14:29:17Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Both of those option sound like exclusion-based fetching. What we've observed while working on a similar system is that there are scale boundaries where it stops working. When the number of individual items is high, it breaks the length limits for URLs (1) and a digest becomes increasingly unreliable (2).\r\n\r\nThe third solution is to have an official way to batch resources by inclusion instead. It requires an \"inclusion digest\" or \"inclusion list\" instead of an \"cached/exclusion digest\" though.",
              "createdAt": "2020-04-01T14:29:17Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2OTIyOTk5",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T04:01:15Z",
          "updatedAt": "2020-04-03T04:01:16Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "@jkrems\r\nThanks! I agree that especially for dynamic bundling it seems to need some \"inclusion signal\" in requesting phase. I suspect it still could be benefited if it's combined with cache/exclusion approach for better cache efficiency?  A straw-idea could be:\r\n\r\n1. The bundle request should express some hash or list that indicates the set of resources it wants.  Possibly the server and client can share a logic to compute the hash / variations for the session to determine what resources are needed.\r\n2. Platform also attaches some digest that indicates exclusive-fetching information for caching.\r\n\r\nThis explainer didn't tell anything about 1. but probably it'd be better to mention it too. Does it make better sense, or I might be still missing something?",
              "createdAt": "2020-04-03T04:01:15Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MzIyMjQy",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "jkrems",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T14:44:48Z",
          "updatedAt": "2020-04-03T14:44:49Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Makes sense, I think you covered what I had in mind! And this definitely doesn't have to block this initial PR, more a comment towards future iteration.",
              "createdAt": "2020-04-03T14:44:48Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Njc4NjE4",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T23:06:03Z",
          "updatedAt": "2020-04-06T23:26:20Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n  they're also incompatible with new requirements like dynamic bundling (e.g. small edit\r\n```\r\n\r\nAnd please link \"dynamic bundling\" to a description.",
              "createdAt": "2020-04-06T23:06:04Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n- The caching story with JS bundlers (e.g. webpack) is tough. They are pretty good\r\n```\r\n\r\nOr\r\n\r\n```suggestion\r\n- The output of JS bundlers (e.g. webpack) doesn't interact well with the HTTP cache. They are pretty good\r\n```",
              "createdAt": "2020-04-06T23:06:59Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n  parallelization, but that's not possible if all resources are bundled as one\r\n```",
              "createdAt": "2020-04-06T23:07:28Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 48,
              "body": "The primary requirement to avoid fetching the same bytes twice is that \"If a subresource under that scope is needed later in the document, that later fetch should block until at least the index of the bundle has downloaded to see if it's there.\"\r\n\r\nIt seems secondary to then say that if the subresource within that scope isn't in the bundle, its fetch should fail or otherwise notify the developer: that just prevents delays in starting the subresource fetch.",
              "createdAt": "2020-04-06T23:16:06Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 99,
              "body": "A patch format also seems plausible. If the server looks at the If-None-Match request header to learn what version the client already has cached, it can send down a different response type to patch the bundle instead of sending down the whole bundle. I don't know of any existing systems that do that, so we should talk to more people if that direction sounds good. Roberto Peon has argued for patches.",
              "createdAt": "2020-04-06T23:26:12Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE3NTU1",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:43:32Z",
          "updatedAt": "2020-04-08T02:43:32Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks. Done.",
              "createdAt": "2020-04-08T02:43:32Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE4MTk2",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:45:48Z",
          "updatedAt": "2020-04-08T02:45:48Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Ah, I didn't add link \"dynamic bundling\". I think it's still an early idea, and we don't have a good description of that in public yet, AFAIK.",
              "createdAt": "2020-04-08T02:45:48Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE4NjI0",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:47:19Z",
          "updatedAt": "2020-04-08T02:47:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Thanks! The latter sounds good to me.",
              "createdAt": "2020-04-08T02:47:19Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE5MjM0",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:49:40Z",
          "updatedAt": "2020-04-08T02:49:41Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Thanks! Let me add these almost \"as-is\".  I think that would help the reader of this explainer to understand the possible behaviors we are thinking in more details.",
              "createdAt": "2020-04-08T02:49:41Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE5NTAx",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:50:39Z",
          "updatedAt": "2020-04-08T02:50:40Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Thanks! Yes, we are currently discussing this topic actively in other places. I think we'll cover this topic in another explainer!",
              "createdAt": "2020-04-08T02:50:39Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE5NzMw",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:51:32Z",
          "updatedAt": "2020-04-08T02:51:33Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done. Thanks!",
              "createdAt": "2020-04-08T02:51:32Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjM2NTg4",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T03:57:14Z",
          "updatedAt": "2020-04-08T03:57:14Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This one, maybe?\r\n\r\nhttps://github.com/azukaru/progressive-fetching/blob/master/docs/dynamic-bundling/index.md",
              "createdAt": "2020-04-08T03:57:14Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjM4MzAw",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T04:04:20Z",
          "updatedAt": "2020-04-08T04:04:21Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks! Let me add a link to that. I think that is okay for us.",
              "createdAt": "2020-04-08T04:04:21Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 566,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkzOTQ5NjMz",
      "title": "Navigation Explainer: Add a chart illustrating the modes of loading a bundle",
      "url": "https://github.com/WICG/webpackage/pull/566",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Preview: [navigation-to-unsigned-bundles.md](https://github.com/irori/webpackage/blob/chart/explainers/navigation-to-unsigned-bundles.md)\r\nSource code of the chart: https://bit.ly/2UAJ5pX\r\n\r\nLet me know if some terms needs to be changed, and feel free to dismiss this PR if you think it doesn't add much value.",
      "createdAt": "2020-03-26T04:28:54Z",
      "updatedAt": "2020-04-06T23:34:27Z",
      "closedAt": "2020-04-06T23:34:26Z",
      "mergedAt": "2020-04-06T23:34:26Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!\r\n\r\nThe PlantUML image is also compact (in terms of pixels). Let's use this one.",
          "createdAt": "2020-04-06T23:31:34Z",
          "updatedAt": "2020-04-06T23:31:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MzczNzYw",
          "commit": {
            "abbreviatedOid": "ecc45c8"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This lgtm, fwiw",
          "createdAt": "2020-04-01T08:36:24Z",
          "updatedAt": "2020-04-01T08:36:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NjY3ODY3",
          "commit": {
            "abbreviatedOid": "ecc45c8"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks for putting together this diagram! I'd like to rework the \"trusted\" bits of this navigation explainer around whether the response is \"authoritative\" per the HTTP spec (https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#establishing.authority), but we can update the diagram at the same time as we rework the text.",
          "createdAt": "2020-04-06T22:40:19Z",
          "updatedAt": "2020-04-06T22:58:07Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "We should be sure to commit the source for any graphics so they're easy to reproduce. e.g.\r\n\r\n```suggestion\r\n![graph TD\r\n  s([Navigation to an<br/>application/webbundle<br/>resource]) -->\r\n  p[Parse primary URL<br/>and control flags] -->\r\n  Signed{Signed?}\r\n  Signed -->|yes| outofscope([\"Load as a signed bundle<br/>(Out of the scope<br/>of this document)\"])\r\n  Signed -->|no| Trusted{The trusted<br/>flag is set?}\r\n  Trusted -->|yes| InScope{The primary URL is<br/>within the unsigned<br/>bundle scope?}\r\n  Trusted -->|no| untrusted([Load as an<br/>untrusted<br/>bundle])\r\n  InScope -->|yes| trust([Load as a<br/>trusted bundle])\r\n  InScope -->|no| redirect([Redirect to the<br/>primary URL])\r\n](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVERcbiAgcyhbTmF2aWdhdGlvbiB0byBhbjxici8-YXBwbGljYXRpb24vd2ViYnVuZGxlPGJyLz5yZXNvdXJjZV0pIC0tPlxuICBwW1BhcnNlIHByaW1hcnkgVVJMPGJyLz5hbmQgY29udHJvbCBmbGFnc10gLS0-XG4gIFNpZ25lZHtTaWduZWQ_fVxuICBTaWduZWQgLS0-fHllc3wgb3V0b2ZzY29wZShbXCJMb2FkIGFzIGEgc2lnbmVkIGJ1bmRsZTxici8-KE91dCBvZiB0aGUgc2NvcGU8YnIvPm9mIHRoaXMgZG9jdW1lbnQpXCJdKVxuICBTaWduZWQgLS0-fG5vfCBUcnVzdGVke1RoZSB0cnVzdGVkPGJyLz5mbGFnIGlzIHNldD99XG4gIFRydXN0ZWQgLS0-fHllc3wgSW5TY29wZXtUaGUgcHJpbWFyeSBVUkwgaXM8YnIvPndpdGhpbiB0aGUgdW5zaWduZWQ8YnIvPmJ1bmRsZSBzY29wZT99XG4gIFRydXN0ZWQgLS0-fG5vfCB1bnRydXN0ZWQoW0xvYWQgYXMgYW48YnIvPnVudHJ1c3RlZDxici8-YnVuZGxlXSlcbiAgSW5TY29wZSAtLT58eWVzfCB0cnVzdChbTG9hZCBhcyBhPGJyLz50cnVzdGVkIGJ1bmRsZV0pXG4gIEluU2NvcGUgLS0-fG5vfCByZWRpcmVjdChbUmVkaXJlY3QgdG8gdGhlPGJyLz5wcmltYXJ5IFVSTF0pXG4iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)\r\n```\r\n\r\n![graph TD\r\n  s([Navigation to an<br/>application/webbundle<br/>resource]) -->\r\n  p[Parse primary URL<br/>and control flags] -->\r\n  Signed{Signed?}\r\n  Signed -->|yes| outofscope([\"Load as a signed bundle<br/>(Out of the scope<br/>of this document)\"])\r\n  Signed -->|no| Trusted{The trusted<br/>flag is set?}\r\n  Trusted -->|yes| InScope{The primary URL is<br/>within the unsigned<br/>bundle scope?}\r\n  Trusted -->|no| untrusted([Load as an<br/>untrusted<br/>bundle])\r\n  InScope -->|yes| trust([Load as a<br/>trusted bundle])\r\n  InScope -->|no| redirect([Redirect to the<br/>primary URL])\r\n](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVERcbiAgcyhbTmF2aWdhdGlvbiB0byBhbjxici8-YXBwbGljYXRpb24vd2ViYnVuZGxlPGJyLz5yZXNvdXJjZV0pIC0tPlxuICBwW1BhcnNlIHByaW1hcnkgVVJMPGJyLz5hbmQgY29udHJvbCBmbGFnc10gLS0-XG4gIFNpZ25lZHtTaWduZWQ_fVxuICBTaWduZWQgLS0-fHllc3wgb3V0b2ZzY29wZShbXCJMb2FkIGFzIGEgc2lnbmVkIGJ1bmRsZTxici8-KE91dCBvZiB0aGUgc2NvcGU8YnIvPm9mIHRoaXMgZG9jdW1lbnQpXCJdKVxuICBTaWduZWQgLS0-fG5vfCBUcnVzdGVke1RoZSB0cnVzdGVkPGJyLz5mbGFnIGlzIHNldD99XG4gIFRydXN0ZWQgLS0-fHllc3wgSW5TY29wZXtUaGUgcHJpbWFyeSBVUkwgaXM8YnIvPndpdGhpbiB0aGUgdW5zaWduZWQ8YnIvPmJ1bmRsZSBzY29wZT99XG4gIFRydXN0ZWQgLS0-fG5vfCB1bnRydXN0ZWQoW0xvYWQgYXMgYW48YnIvPnVudHJ1c3RlZDxici8-YnVuZGxlXSlcbiAgSW5TY29wZSAtLT58eWVzfCB0cnVzdChbTG9hZCBhcyBhPGJyLz50cnVzdGVkIGJ1bmRsZV0pXG4gIEluU2NvcGUgLS0-fG5vfCByZWRpcmVjdChbUmVkaXJlY3QgdG8gdGhlPGJyLz5wcmltYXJ5IFVSTF0pXG4iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)\r\n\r\n\r\nThe PlantUML output is 1/10 the size...\r\n\r\n```suggestion\r\n![@startuml\r\n:Navigation to an application/webbundle resource;\r\n:Parse primary URL and control flags;\r\nif (Signed?) then (yes)\r\n  :Load as a signed bundle\r\n  (Out of the scope of\r\n  this document);\r\n  stop\r\nelse (no)\r\n  if (The trusted flag is set?) then (yes)\r\n    if (The primary URL is\\nwithin the unsigned\\nbundle scope?) then (yes)\r\n      :Load as a trusted bundle;\r\n      stop\r\n    else (no)\r\n      :Redirect to the primary URL;\r\n      stop\r\n    endif\r\n  else (no)\r\n    :Load as an\r\n    untrusted bundle;\r\n    stop\r\n  endif\r\nendif\r\n@enduml](http://www.plantuml.com/plantuml/svg/POyzRWCX48LxJl7ATPNUMyG7i9B8IJet66OT97POCKCitpuOP2KRDy2Wz_FDJjHcBNCqPljYlyFPQaWCJR0CkomnkFRpTA7JgR2FX4oIIdOqcksRpK9OSfXjlkBpiAyk3vTOSugOeZtBQCA4uJsScVpp1lf5ZE5AiZ70Tf-iXnLOI1EWLnXWU2sADDtq49SMgeD17OF09rTcOjsC1X1DYw4eX87JBVHMzr5Tceie-KQ1wXBI__rtyNg584U-XDh4hRrmPpjoX-iuZr6hTUxbtJ8sGMTjpp-ytNaW7p8vXIReckVHp3vCPXMoAkSs5tvW-0tf4VqqktgNEVu0)\r\n```\r\n\r\n![@startuml\r\n:Navigation to an application/webbundle resource;\r\n:Parse primary URL and control flags;\r\nif (Signed?) then (yes)\r\n  :Load as a signed bundle\r\n  (Out of the scope of\r\n  this document);\r\n  stop\r\nelse (no)\r\n  if (The trusted flag is set?) then (yes)\r\n    if (The primary URL is\\nwithin the unsigned\\nbundle scope?) then (yes)\r\n      :Load as a trusted bundle;\r\n      stop\r\n    else (no)\r\n      :Redirect to the primary URL;\r\n      stop\r\n    endif\r\n  else (no)\r\n    :Load as an\r\n    untrusted bundle;\r\n    stop\r\n  endif\r\nendif\r\n@enduml](http://www.plantuml.com/plantuml/svg/POyzRWCX48LxJl7ATPNUMyG7i9B8IJet66OT97POCKCitpuOP2KRDy2Wz_FDJjHcBNCqPljYlyFPQaWCJR0CkomnkFRpTA7JgR2FX4oIIdOqcksRpK9OSfXjlkBpiAyk3vTOSugOeZtBQCA4uJsScVpp1lf5ZE5AiZ70Tf-iXnLOI1EWLnXWU2sADDtq49SMgeD17OF09rTcOjsC1X1DYw4eX87JBVHMzr5Tceie-KQ1wXBI__rtyNg584U-XDh4hRrmPpjoX-iuZr6hTUxbtJ8sGMTjpp-ytNaW7p8vXIReckVHp3vCPXMoAkSs5tvW-0tf4VqqktgNEVu0)",
              "createdAt": "2020-04-06T22:40:19Z",
              "updatedAt": "2020-04-06T23:29:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 567,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDA5NjYz",
      "title": "Update to Python 3",
      "url": "https://github.com/WICG/webpackage/pull/567",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Now that Bikeshed requires it.\r\n\r\nTesting via PR; no need to review this if it passes TravisCI.",
      "createdAt": "2020-03-27T23:32:01Z",
      "updatedAt": "2020-03-31T16:18:37Z",
      "closedAt": "2020-03-31T16:18:36Z",
      "mergedAt": "2020-03-31T16:18:36Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": []
    },
    {
      "number": 570,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwNTUyODE1",
      "title": "Add explicit use cases to the navigation-to-bundles explainer.",
      "url": "https://github.com/WICG/webpackage/pull/570",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And an initial diagram.\r\n\r\nThis could probably use diagrams for the other two use cases, but let me know what you think of the use case descriptions and the first diagram.",
      "createdAt": "2020-04-07T23:35:49Z",
      "updatedAt": "2020-04-08T18:14:32Z",
      "closedAt": "2020-04-08T18:14:30Z",
      "mergedAt": "2020-04-08T18:14:30Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NzkxNDA0",
          "commit": {
            "abbreviatedOid": "d4a33a5"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T09:11:38Z",
          "updatedAt": "2020-04-08T09:11:38Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Maybe also say \"see also the alternate formats section (link) to see why we are proposing this with a new format\" or something (but up to you)",
              "createdAt": "2020-04-08T09:11:38Z",
              "updatedAt": "2020-04-08T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NzkxNzkz",
          "commit": {
            "abbreviatedOid": "d4a33a5"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, lgtm",
          "createdAt": "2020-04-08T09:12:08Z",
          "updatedAt": "2020-04-08T09:12:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjEzOTk0",
          "commit": {
            "abbreviatedOid": "5c1029f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:11:40Z",
          "updatedAt": "2020-04-08T18:11:41Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Thanks, done.",
              "createdAt": "2020-04-08T18:11:40Z",
              "updatedAt": "2020-04-08T18:11:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 571,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyMDkzNDI1",
      "title": "The IETF WPACK WG is chartered now.",
      "url": "https://github.com/WICG/webpackage/pull/571",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-10T22:39:44Z",
      "updatedAt": "2020-04-15T00:49:03Z",
      "closedAt": "2020-04-15T00:49:03Z",
      "mergedAt": "2020-04-15T00:49:03Z",
      "mergedBy": "kinu",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzg3ODU3",
          "commit": {
            "abbreviatedOid": "45e41df"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-04-15T00:48:08Z",
          "updatedAt": "2020-04-15T00:48:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 572,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyNzUwOTA3",
      "title": "Switch to \"authoritative\" instead of \"trusted\" to match HTTP.",
      "url": "https://github.com/WICG/webpackage/pull/572",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#establishing.authority",
      "createdAt": "2020-04-13T17:31:59Z",
      "updatedAt": "2020-04-14T17:02:27Z",
      "closedAt": "2020-04-14T17:02:25Z",
      "mergedAt": "2020-04-14T17:02:25Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTI1ODk5",
          "commit": {
            "abbreviatedOid": "8ca6fad"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with comments",
          "createdAt": "2020-04-14T00:29:08Z",
          "updatedAt": "2020-04-14T00:50:51Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\n<details>\r\n```",
              "createdAt": "2020-04-14T00:29:08Z",
              "updatedAt": "2020-04-14T02:42:48Z"
            },
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n</details>\r\n```",
              "createdAt": "2020-04-14T00:29:41Z",
              "updatedAt": "2020-04-14T02:42:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTY2Mjgx",
          "commit": {
            "abbreviatedOid": "054fc8c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-14T02:42:59Z",
          "updatedAt": "2020-04-14T02:43:00Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Oops, thanks.",
              "createdAt": "2020-04-14T02:43:00Z",
              "updatedAt": "2020-04-14T02:43:00Z"
            }
          ]
        }
      ]
    }
  ]
}